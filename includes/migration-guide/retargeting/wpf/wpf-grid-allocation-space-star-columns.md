### <a name="wpf-grid-allocation-of-space-to-star-columns"></a>WPF 网格分配到星型列的空间

|   |   |
|---|---|
|详细信息|从.NET Framework 4.7 开始，WPF 将替代该算法的<xref:System.Windows.Controls.Grid>使用分配到的空间 * 的列。 这将更改分配给的实际宽度 * 的事例数中的列：<ul><li>当一个或多个 * 的列还具有一个重写该列的比例分配的最小值或最大宽度。 （最小宽度可以源自的显式 MinWidth 声明，或者从列的内容中获取的隐式的最小值。 最大宽度可以仅定义显式，从 MaxWidth 声明。）</li><li>当一个或多个 *-列声明极大 *-权重，大于 10 ^298。</li><li>当 *-权重是充分不同，会遇到浮点不稳定 （溢出、 下溢、 精度损失）。</li><li>当布局圆化处理已启用且有效显示 DPI 足够高时。</li></ul>在前两个情况下，在新的算法生成的宽度可以是明显不同于旧算法; 生成的那些在最后一种情况，差异将最多一个或两个像素。将新算法修复旧算法中存在的几个 bug:<ol><li>向列分配的总空间可能会超过网格宽度。 当向比例份额小于其大小下限的列分配空间时，可能会出现这种问题。 算法会分配大小下限对应的空间，这将减少其他列的可用空间。 如果有任何 * 的列向左以分配的总分配将太大。</li><li>向列分配的总空间可能会占不满网格宽度。 这是 #1，因大于其最大大小，没有将其成比例共享分配给某一列时的双重问题 *-有待占用 slack 的列。</li><li>两个 * 的列可以接收不成正比的分配其 * 的权重。 这是第 1 个/第 2 个问题造成的较为温和的影响，当依序向 *-列 A、B 和 C 分配空间，但 B 列的比例份额与约束下限（或上限）冲突时，可能会出现这种问题。 同样，这会更改 C 列的可用空间，它将比 A 列获得更少（或更多）的按比例分配空间。</li><li>使用极大的权重列 (&gt; 10 ^298) 所有看做就好像它们具有权重 10 ^298。 这些列（以及权重略小的列）之间的比例差异将不会生效。</li><li>未正确处理使用 inifinte 权重列。 [实际上，不能设置无穷大的权重，但这是一项人为限制。 空间分配代码是在努力处理这样的列，但处理得并不好。]</li><li>在避免溢出、下溢、精度损失和类似浮点问题时，存在一些小问题。</li><li>在 DPI 足够高的情况下，无法正确调整布局的圆化处理。</li></ol>新的算法将生成满足以下条件： A 的结果。 分配给的实际宽度 * 的列不小于其最小宽度也不大于其最大宽度。B。 每个<em>-不是列分配其最小或最大宽度分配宽度成正比其<em>的权重。要精确，如果两个列声明宽度 x</em>和 y</em>分别，并且如果既不该列未接收到其最小值或最大宽度，实际宽度 v 和 w 分配给列位于相同的比例： v / w = = x / y.C. 总宽度分配给&quot;成比例&quot;*-列后的可用空间等于分配给受约束的列 (固定的自动和 *-分配其最小值或最大宽度的列)。 例如，这可能是零，如果最小宽度的总和超过了网格的 availbable 宽度。D。 所有这些语句是相对于解释&quot;理想&quot;布局。 布局舍入在生效时，实际的宽度可能与不同的理想宽度多达一个像素。旧算法遵循 (A)，但无法接受在上述情况下的其他条件。有关列和宽度这篇文章中的所说的一切也适用于行和高度。|
|建议|默认情况下，应用从.NET Framework 4.7 的.NET framework 目标版本，将看到新算法，应用面向.NET Framework 4.6.2 或更早版本，将看到旧算法时。若要重写默认值，请使用以下配置设置：<pre><code class="language-xml">&lt;runtime&gt;&#13;&#10;&lt;AppContextSwitchOverrides value=&quot;Switch.System.Windows.Controls.Grid.StarDefinitionsCanExceedAvailableSpace=true&quot; /&gt;&#13;&#10;&lt;/runtime&gt;&#13;&#10;</code></pre>值 'true' 选择旧算法，'false' 选择新的算法。|
|范围|次要|
|版本|4.7|
|类型|重定目标|

