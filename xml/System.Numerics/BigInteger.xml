<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7d0dcda34bb31112c320daec112f3dd4b818dc43" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30471131" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>表示任意大的带符号整数。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger>类型是不可变类型，表示任意大整数的值在理论上没有上限或下限的边界。 成员<xref:System.Numerics.BigInteger>类型几乎其他整数类型 ( <xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.Int64>， <xref:System.SByte>， <xref:System.UInt16>， <xref:System.UInt32>，和<xref:System.UInt64>类型)。 此类型不同于其他整数类型在[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]，其中包含所指示的范围其`MinValue`和`MaxValue`属性。  
  
> [!NOTE]
>  因为<xref:System.Numerics.BigInteger>类型是不可变 (请参阅[可变性和 BigInteger 结构](#mutability))，因为它有没有上限或下限的边界，<xref:System.OutOfMemoryException>可能会导致任何操作引发<xref:System.Numerics.BigInteger>值太增长大。  
  
## <a name="instantiating-a-biginteger-object"></a>实例化 BigInteger 对象  
 可以实例化<xref:System.Numerics.BigInteger>对象有几个方面：  
  
-   你可以使用`new`关键字并提供任何整型或浮点值作为参数传递给<xref:System.Numerics.BigInteger>构造函数。 (浮点值被截断之前分配给<xref:System.Numerics.BigInteger>。)下面的示例演示如何使用`new`关键字来实例化<xref:System.Numerics.BigInteger>值。  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   你可以声明<xref:System.Numerics.BigInteger>变量，并将分配一个值，就像你那样任何数值类型，只要该值是整数类型。 下面的示例使用分配创建<xref:System.Numerics.BigInteger>值从<xref:System.Int64>。  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   你可以分配到一个十进制或浮点值<xref:System.Numerics.BigInteger>对象，如果将值强制转换的虚拟机或模板，首先将其转换。 下面的示例显式强制转换 （在 C# 中) 或 （在 Visual Basic 中) 将转换<xref:System.Double>和<xref:System.Decimal>值赋给<xref:System.Numerics.BigInteger>。  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 这些方法使你能够实例化<xref:System.Numerics.BigInteger>其值处于与一个现有的数值范围的对象类型仅。 可以实例化<xref:System.Numerics.BigInteger>其值可以超过该范围的三种方式之一中的现有数值类型的对象：  
  
-   你可以使用`new`关键字并提供到任何大小的字节数组<xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType>构造函数。 例如:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   你可以调用<xref:System.Numerics.BigInteger.Parse%2A>或<xref:System.Numerics.BigInteger.TryParse%2A>方法要转换的字符串表示形式到数值<xref:System.Numerics.BigInteger>。 例如:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   你可以调用`static`(`Shared`在 Visual Basic 中)<xref:System.Numerics.BigInteger>对数值表达式执行某种操作并返回计算方法<xref:System.Numerics.BigInteger>结果。 下面的示例执行此通过立方<xref:System.UInt64.MaxValue?displayProperty=nameWithType>并分配到结果<xref:System.Numerics.BigInteger>。  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 未初始化的值<xref:System.Numerics.BigInteger>是<xref:System.Numerics.BigInteger.Zero%2A>。  
  
## <a name="performing-operations-on-biginteger-values"></a>对 BigInteger 值执行操作  
 你可以使用<xref:System.Numerics.BigInteger>实例像使用任何其他整数类型。 <xref:System.Numerics.BigInteger> 重载标准数值的运算符，以使您能够执行基本的数学运算，例如加法、 减法、 除法、 乘法、 减法、 求反和一元求反。 你还可以使用标准数值运算符比较两个<xref:System.Numerics.BigInteger>与每个其他的值。 与其他整数类型，类似<xref:System.Numerics.BigInteger>还支持的按位`And`， `Or`， `XOr`，左移位和右移位运算符。 不支持自定义运算符的语言<xref:System.Numerics.BigInteger>结构还提供了用于执行数学运算的等效方法。 其中包括<xref:System.Numerics.BigInteger.Add%2A>， <xref:System.Numerics.BigInteger.Divide%2A>， <xref:System.Numerics.BigInteger.Multiply%2A>， <xref:System.Numerics.BigInteger.Negate%2A>， <xref:System.Numerics.BigInteger.Subtract%2A>，以及其他几个人。  
  
 许多成员<xref:System.Numerics.BigInteger>结构直接对应于其他整数类型的成员。 此外，<xref:System.Numerics.BigInteger>添加成员，如下所示：  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>它返回一个值，指示的符号<xref:System.Numerics.BigInteger>值。  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>它返回数值的绝对值<xref:System.Numerics.BigInteger>值。  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>它返回商和余数的除法运算。  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>它返回最大公约数的两个<xref:System.Numerics.BigInteger>值。  
  
 很多这些其他成员对应于的成员<xref:System.Math>类，该类提供的功能，可以使用基元数值类型。  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>可变性和 BigInteger 结构  
 下面的示例实例化<xref:System.Numerics.BigInteger>对象，然后逐个增加其值。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 尽管此示例看起来可以修改现有对象的值，这不是这种情况。 <xref:System.Numerics.BigInteger> 对象是不可变的这意味着内部，公共语言运行时实际创建一个新<xref:System.Numerics.BigInteger>对象并将其分配一个大于其以前的值的值。 此新对象然后返回到调用方。  
  
> [!NOTE]
>  .NET Framework 中的其他数值类型也是不可变的。 但是，因为<xref:System.Numerics.BigInteger>类型已没有上限或下限的边界，其值可以变得非常大并对性能产生显著影响。  
  
 尽管此过程是透明的调用方，但它确实会引致性能下降。 在某些情况下，尤其是当重复执行操作在循环中非常大<xref:System.Numerics.BigInteger>值，该性能损失可能很重要。 例如，在下面的示例中，执行操作重复达数百万次，和一个<xref:System.Numerics.BigInteger>值就会递增 1 每次该操作成功。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 在这种情况下，可以提高性能，通过执行到的所有中间分配<xref:System.Int32>变量。 然后，该变量的最终值可以分配给<xref:System.Numerics.BigInteger>对象循环退出时。 下面的示例进行了这方面的演示。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>使用字节数组和十六进制字符串  
 如果你转换<xref:System.Numerics.BigInteger>到字节数组的值或如果你转换到的字节数组<xref:System.Numerics.BigInteger>值，你必须考虑的字节顺序。 <xref:System.Numerics.BigInteger>结构要求的各个字节中的字节数组才会显示在 little-endian 的顺序 （即值较低序位字节先于更高序位字节）。 你可以往返<xref:System.Numerics.BigInteger>值通过调用<xref:System.Numerics.BigInteger.ToByteArray%2A>方法，然后将生成的字节数组到<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>构造函数，如以下示例所示。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 若要实例化<xref:System.Numerics.BigInteger>值可以将整数值与传递一个表示某些其他整数类型的值的字节数组，从<xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>方法，并生成的字节数组到然后传入<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>构造函数。 下面的示例实例化<xref:System.Numerics.BigInteger>值从一个字节数组，表示<xref:System.Int16>值。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 <xref:System.Numerics.BigInteger>结构假定，使用 2 的补数表示存储负值。 因为<xref:System.Numerics.BigInteger>结构表示具有无固定长度的数字值<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>构造函数始终解释为符号位数组中的最后一个字节的最高有效位。 若要防止<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>从令人费解 2 的补数表示形式的负值正是正数值的符号和量值表示的构造函数在其中最大值的字节数组中的最后一个字节的有效位通常为集应包含额外的字节，其值为 0。 例如，0xC0 0xBD 0xF0 0xFF 是小 endian 十六进制表示形式 1000000 或 4293967296。 因为此数组中的最后一个字节的最高有效位是打开的字节数组的值将被<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>为-1000000 的构造函数。 若要实例化<xref:System.Numerics.BigInteger>其值为正，字节数组，其元素为 0xC0 0xBD 0xF0 0xFF 0x00 必须传递给构造函数。 下面的示例阐释了这一点。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 字节数组创建<xref:System.Numerics.BigInteger.ToByteArray%2A>从正值的方法包括此额外的零值字节。 因此，<xref:System.Numerics.BigInteger>结构可以成功往返行程值通过分配给，然后将它们还原从字节数组，如以下示例所示。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 但是，你可能需要将此额外的零值字节添加到动态创建的开发人员或通过将无符号的整数转换为字节数组的方法返回的字节数组 (如<xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>， <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>，和<xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>)。  
  
 在分析十六进制字符串时<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType>和<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法假定，如果设置字符串中的第一个字节的最高有效位，或如果字符串的第一个十六进制数字表示较低的四位的字节值，则值为通过使用 2 的补数表示形式表示。 例如，"FF01"和"F01"表示的十进制值-255。 若要区分正负值，正值应包括前导零。 相关重载<xref:System.Numerics.BigInteger.ToString%2A>方法，在传递"X"格式字符串时, 添加到正值返回的十六进制字符串前导零。 这样便能保存/还原<xref:System.Numerics.BigInteger>值使用<xref:System.Numerics.BigInteger.ToString%2A>和<xref:System.Numerics.BigInteger.Parse%2A>方法，如以下示例所示。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 但是，通过调用创建的十六进制字符串`ToString`其他整数类型或的重载的方法<xref:System.Convert.ToString%2A>方法包括`toBase`参数不会指示的值或从其源数据类型的符号派生的十六进制字符串。 已成功实例化<xref:System.Numerics.BigInteger>从这样的字符串值需要一些其他的逻辑。 下面的示例提供了一种可能实现。  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">顺序为 little-endian 的字节值的数组。</param>
        <summary>使用字节数组中的值初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的单个字节`value`数组应采用 little-endian 的顺序，从最低位字节到高序位字节。 例如，数值 1000000000000 由下表中所示：  
  
|||  
|-|-|  
|十六进制字符串|E8D4A51000|  
|字节数组 （首先最低索引）|00 10 A5 D4 E8 00|  
  
 将数值转换为字节数组，如的大多数方法<xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType>和<xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>，在 little-endian 的顺序返回字节数组。  
  
 构造函数需要在要使用符号数值表示法，并且负值使用 2 的补数表示的字节数组中的正值。 换而言之，如果最高顺序位中的最高序位字节的`value`设置，则结果<xref:System.Numerics.BigInteger>值为负。 具体取决于的字节数组的源，这可能导致被错误解释为一个负值是正数值。 字节数组通常通过以下方式生成：  
  
-   通过调用<xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType>方法。 因为此方法对于正值的零到返回数组集中的具有最高序位字节的最高顺序位的字节数组，则不可能的错误解释为负值是正数值。 修改字节数组创建<xref:System.Numerics.BigInteger.ToByteArray%2A>方法总是能成功往返传递给<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>构造函数。  
  
-   通过调用<xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>方法并将其作为参数传递一个带符号的整数。 有符号的整数处理符号数值表示法和 2 的补数表示，因为没有为负值正值可能。  
  
-   通过调用<xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>方法并将其作为参数传递的无符号的整数。 无符号的整数表示由它们的量仅，因为正值可能被曲解为负值。 若要防止此错误解释，可以向数组的末尾添加一个零字节值。 下一节中的示例所示。  
  
-   通过创建一个字节数组可以动态或静态而不一定调用任何之前的方法，或通过修改现有的字节数组。 若要防止正值被错误解释为负值，可以向数组的末尾添加一个零字节值。  
  
 如果`value`是一个空<xref:System.Byte>数组，则新<xref:System.Numerics.BigInteger>对象初始化为值为<xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>。 如果`value`是`null`，在构造函数引发<xref:System.ArgumentNullException>。  
  
   
  
## Examples  
 下面的示例实例化<xref:System.Numerics.BigInteger>从 5 元素字节数组，其值是 {5，4，3，2，1} 的对象。 然后，它显示<xref:System.Numerics.BigInteger>值，表示为十进制和十六进制数字，到控制台。 文本输出的输入数组的比较可以清楚为什么的此重载<xref:System.Numerics.BigInteger>类构造函数创建<xref:System.Numerics.BigInteger>对象，其值是 4328719365 （或 0x102030405）。 字节数组，其值为 5，第一个元素定义的值的最低序位字节<xref:System.Numerics.BigInteger>对象，它是 0x05。 字节数组，其值为 4，第二个元素定义的第二个字节的值<xref:System.Numerics.BigInteger>对象，它是 0x04，依次类推。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 下面的示例实例化一个正数和负数<xref:System.Numerics.BigInteger>值时，请将它们传递到<xref:System.Numerics.BigInteger.ToByteArray%2A>方法，然后将还原原始<xref:System.Numerics.BigInteger>生成的字节数组中的值。 请注意两个值由相同的字节数组。 它们之间的唯一区别是中的字节数组中的最后一个元素的最高有效位。 此位是设置 （的字节的值为 0xFF），如果数组创建从负<xref:System.Numerics.BigInteger>值。 位未设置 （的字节的值为零），如果数组创建一个正从<xref:System.Numerics.BigInteger>值。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 下面的示例演示如何确保，是正数值不正确实例化为一个负值加上其值为 0 到数组末尾的字节。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">十进制数。</param>
        <summary>使用 <see cref="T:System.Numerics.BigInteger" /> 值初始化 <see cref="T:System.Decimal" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此构造函数的结果等同于显式分配<xref:System.Decimal>值赋给<xref:System.Numerics.BigInteger>变量。  
  
 调用此构造函数可能会导致数据丢失;任何小数部分`value`实例化时截断<xref:System.Numerics.BigInteger>对象。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29>构造函数实例化<xref:System.Numerics.BigInteger>对象。 它定义的数组<xref:System.Decimal>值，并随后将传递到每个值<xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29>构造函数。 请注意，<xref:System.Decimal>值截断而不是舍入时分配给<xref:System.Numerics.BigInteger>对象。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">一个双精度浮点值。</param>
        <summary>使用双精度浮点值初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何小数部分`value`实例化时，参数将被截断<xref:System.Numerics.BigInteger>对象。  
  
 由于缺少的精度<xref:System.Double>调用此构造函数的数据类型可能会导致数据丢失。  
  
 <xref:System.Numerics.BigInteger>通过调用此构造函数生成的值等同于显式分配的值<xref:System.Double>值赋给<xref:System.Numerics.BigInteger>。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Numerics.BigInteger.%23ctor%28System.Double%29>构造函数实例化<xref:System.Numerics.BigInteger>对象。 它还阐释使用时可能发生的精度损失<xref:System.Double>数据类型。 A<xref:System.Double>分配较大的值，然后分配给<xref:System.Numerics.BigInteger>对象。 如输出所示，此分配涉及精度损失。 然后，按一递增这两个值。 该输出显示<xref:System.Numerics.BigInteger>对象会反映更改后的值，而<xref:System.Double>对象则没有。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> 的值为 <see cref="F:System.Double.NaN" />。  
  
 或  
  
 <paramref name="value" /> 的值为 <see cref="F:System.Double.NegativeInfinity" />。  
  
 或  
  
 <paramref name="value" /> 的值为 <see cref="F:System.Double.PositiveInfinity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">32 位带符号整数。</param>
        <summary>使用 32 位带符号整数值初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 没有不会丢失精度实例化时<xref:System.Numerics.BigInteger>通过使用此构造函数的对象。  
  
 <xref:System.Numerics.BigInteger>通过调用此构造函数生成的值等同于分配的值<xref:System.Int32>值赋给<xref:System.Numerics.BigInteger>。  
  
 <xref:System.Numerics.BigInteger>结构不包括其中类型参数的构造函数<xref:System.Byte>， <xref:System.Int16>， <xref:System.SByte>，或<xref:System.UInt16>。 但是，<xref:System.Int32>类型支持的 8 位和 16 位有符号和无符号整数的隐式转换为有符号的 32 位整数。 此构造函数调用，因此，如果`value`是之一，这四个整型。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29>构造函数实例化<xref:System.Numerics.BigInteger>32 位整数的数组中的值。 它还使用隐式转换将每个 32 位整数值赋给<xref:System.Numerics.BigInteger>变量。 然后，它比较的两个值以确定所生成<xref:System.Numerics.BigInteger>值都是相同。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">64 位带符号整数。</param>
        <summary>使用 64 位带符号整数值初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 没有不会丢失精度实例化时<xref:System.Numerics.BigInteger>通过使用此构造函数的对象。  
  
 <xref:System.Numerics.BigInteger>通过调用此构造函数生成的值等同于分配的值<xref:System.Int64>值赋给<xref:System.Numerics.BigInteger>。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29>构造函数实例化<xref:System.Numerics.BigInteger>64 位整数的数组中的值。 它还使用隐式转换将每个 64 位整数值赋给<xref:System.Numerics.BigInteger>变量。 然后，它比较的两个值以确定所生成<xref:System.Numerics.BigInteger>值都是相同。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">单精度浮点值。</param>
        <summary>使用单精度浮点值初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何小数部分`value`实例化时，参数将被截断<xref:System.Numerics.BigInteger>对象。  
  
 由于缺少的精度<xref:System.Single>调用此构造函数的数据类型可能会导致数据丢失。  
  
 <xref:System.Numerics.BigInteger>通过调用此构造函数生成的值等同于显式分配的值<xref:System.Single>值赋给<xref:System.Numerics.BigInteger>。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Numerics.BigInteger.%23ctor%28System.Single%29>构造函数实例化<xref:System.Numerics.BigInteger>对象。 它还阐释使用时可能发生的精度损失<xref:System.Single>数据类型。 A<xref:System.Single>分配较大的负值，然后分配给<xref:System.Numerics.BigInteger>对象。 如输出所示，此分配涉及精度损失。 然后，按一递增这两个值。 该输出显示<xref:System.Numerics.BigInteger>对象会反映更改后的值，而<xref:System.Single>对象则没有。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> 的值为 <see cref="F:System.Single.NaN" />。  
  
 或  
  
 <paramref name="value" /> 的值为 <see cref="F:System.Single.NegativeInfinity" />。  
  
 或  
  
 <paramref name="value" /> 的值为 <see cref="F:System.Single.PositiveInfinity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">32 位无符号整数值。</param>
        <summary>使用 32 位无符号整数值初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 没有不会丢失精度实例化时<xref:System.Numerics.BigInteger>使用此构造函数。  
  
 <xref:System.Numerics.BigInteger>通过调用此构造函数生成的值等同于分配的值<xref:System.UInt32>值赋给<xref:System.Numerics.BigInteger>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29>构造函数和赋值语句初始化<xref:System.Numerics.BigInteger>从无符号 32 位整数数组的值。 然后，它比较两个的值如下所示的初始化的两个方法<xref:System.Numerics.BigInteger>值产生相同的结果。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">64 位无符号整数。</param>
        <summary>使用 64 位无符号整数值初始化 <see cref="T:System.Numerics.BigInteger" /> 结构的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 没有不会丢失精度实例化时<xref:System.Numerics.BigInteger>使用此构造函数。  
  
 <xref:System.Numerics.BigInteger>通过调用此构造函数生成的值等同于分配的值<xref:System.UInt64>值赋给<xref:System.Numerics.BigInteger>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29>构造函数实例化<xref:System.Numerics.BigInteger>对象，其值是等于<xref:System.UInt64.MaxValue>。  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">数字。</param>
        <summary>获取 <see cref="T:System.Numerics.BigInteger" /> 对象的绝对值。</summary>
        <returns>
          <paramref name="value" /> 的绝对值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表中所示，数字的绝对值的数值为不带符号，该数字。  
  
|`value` 参数|返回值|  
|-----------------------|------------------|  
|`value` >= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 <xref:System.Numerics.BigInteger.Abs%2A>方法相当于<xref:System.Math.Abs%2A?displayProperty=nameWithType>基元数值类型的方法。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Numerics.BigInteger.Abs%2A>方法将转换<xref:System.Numerics.BigInteger>之前序列化到文件的符号数值表示法到 2 的补数表示形式之间的值。 文件中的数据然后反序列化和分配给一个新<xref:System.Numerics.BigInteger>对象。  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要相加的第一个值。</param>
        <param name="right">要相加的第二个值。</param>
        <summary>将两个 <see cref="T:System.Numerics.BigInteger" /> 值相加，并返回结果。</summary>
        <returns>
          <paramref name="left" /> 与 <paramref name="right" /> 的和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不支持运算符重载或自定义运算符的语言可以使用<xref:System.Numerics.BigInteger.Add%2A>方法来执行加法使用<xref:System.Numerics.BigInteger>值。  
  
 <xref:System.Numerics.BigInteger.Add%2A>方法实例化时是有用的替代的加法运算符<xref:System.Numerics.BigInteger>变量中将其分配添加后，得到的结果的总和，如下面的示例中所示。  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>比较两个 <see cref="T:System.Numerics.BigInteger" /> 值，并返回一个整数，该整数指示第一个值是小于、等于还是大于第二个值。</summary>
        <returns>一个有符号整数，指示 <paramref name="left" /> 和 <paramref name="right" /> 的相对值，如下表所示。  
  
 <list type="table"><listheader><term> 值  
  
 </term><description> 条件  
  
 </description></listheader><item><term> 小于零  
  
 </term><description><paramref name="left" /> 小于 <paramref name="right" />。  
  
 </description></item><item><term> 零  
  
 </term><description><paramref name="left" /> 等于 <paramref name="right" />。  
  
 </description></item><item><term> 大于零  
  
 </term><description><paramref name="left" /> 大于 <paramref name="right" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管<xref:System.Numerics.BigInteger>类型具有没有固定的范围，比较<xref:System.Numerics.BigInteger>值不是通过在缺乏描述的浮点数进行比较的精度。 下面的示例比较两个<xref:System.Numerics.BigInteger>1 且都是不同的值有 1896 位。 <xref:System.Numerics.BigInteger.Compare%2A>方法将正确报告两个值是否不相等。  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例的值与另一个值进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于另一个值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">要比较的 64 位带符号整数。</param>
        <summary>将此实例与 64 位带符号整数进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于 64 位带符号整数的值。</summary>
        <returns>一个带符号整数值，指示此实例与 <paramref name="other" /> 的关系，如下表所示。  
  
 <list type="table"><listheader><term> 返回值  
  
 </term><description> 描述  
  
 </description></listheader><item><term> 小于零  
  
 </term><description> 当前实例小于 <paramref name="other" />。  
  
 </description></item><item><term> 零  
  
 </term><description> 当前实例等于 <paramref name="other" />。  
  
 </description></item><item><term> 大于零  
  
 </term><description> 当前实例大于 <paramref name="other" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`other`是<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>值，它将隐式转换为<xref:System.Int64>值时<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29>调用方法。  
  
   
  
## Examples  
 下面的示例演示调用<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29>使用整数值的方法。  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">要比较的对象。</param>
        <summary>将此实例与另一个 <see cref="T:System.Numerics.BigInteger" /> 进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于指定对象的值。</summary>
        <returns>一个带符号整数值，指示此实例与 <paramref name="other" /> 的关系，如下表所示。  
  
 <list type="table"><listheader><term> 返回值  
  
 </term><description> 描述  
  
 </description></listheader><item><term> 小于零  
  
 </term><description> 当前实例小于 <paramref name="other" />。  
  
 </description></item><item><term> 零  
  
 </term><description> 当前实例等于 <paramref name="other" />。  
  
 </description></item><item><term> 大于零  
  
 </term><description> 当前实例大于 <paramref name="other" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载<xref:System.Numerics.BigInteger.CompareTo%2A>方法实现<xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType>方法。 它用于通过泛型集合对象在集合中的项进行排序。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>方法进行排序的列表`StarInfo`对象。 每个`StarInfo`对象提供星号的名称和其距离以英里地球有关的信息。 `StarInfo` 实现<xref:System.IComparable%601>接口，它使`StarInfo`要排序的泛型集合类的对象。 其<xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType>实现只需包装对的调用<xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>。  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 下面的代码然后实例化四个`StarInfo`对象并将它们存储在一个泛型<xref:System.Collections.Generic.List%601>对象。 后<xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>调用方法时，`StarInfo`地球距离的顺序显示对象。  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要比较的对象。</param>
        <summary>将此实例与指定对象进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于指定对象的值。</summary>
        <returns>一个带符号整数，指示当前实例与 <paramref name="obj" /> 参数的关系，如下表所示。  
  
 <list type="table"><listheader><term> 返回值  
  
 </term><description> 描述  
  
 </description></listheader><item><term> 小于零  
  
 </term><description> 当前实例小于 <paramref name="obj" />。  
  
 </description></item><item><term> 零  
  
 </term><description> 当前实例等于 <paramref name="obj" />。  
  
 </description></item><item><term> 大于零  
  
 </term><description> 当前实例大于 <paramref name="obj" />，或者 <paramref name="obj" /> 参数为 <see langword="null" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载<xref:System.Numerics.BigInteger.CompareTo%2A>方法实现<xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType>方法。 它用于通过非泛型集合对象在集合中的项进行排序。  
  
 `obj`参数必须是以下项之一：  
  
-   一个对象，其运行时类型是<xref:System.Numerics.BigInteger>。  
  
-   <xref:System.Object>其值变量`null`。 如果值`obj`参数是`null`，该方法返回 1，指示当前实例大于`obj`。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Numerics.BigInteger.CompareTo%28System.Object%29>方法来比较<xref:System.Numerics.BigInteger>与一个对象数组中的每个元素的值  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> 不是 <see cref="T:System.Numerics.BigInteger" />。</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">要比较的 64 位无符号整数。</param>
        <summary>将此实例与 64 位无符号整数进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于 64 位无符号整数的值。</summary>
        <returns>一个带符号整数，指示此实例和 <paramref name="other" /> 的相对值，如下表所示。  
  
 <list type="table"><listheader><term> 返回值  
  
 </term><description> 描述  
  
 </description></listheader><item><term> 小于零  
  
 </term><description> 当前实例小于 <paramref name="other" />。  
  
 </description></item><item><term> 零  
  
 </term><description> 当前实例等于 <paramref name="other" />。  
  
 </description></item><item><term> 大于零  
  
 </term><description> 当前实例大于 <paramref name="other" />。  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">要作为被除数的值。</param>
        <param name="divisor">要作为除数的值。</param>
        <summary>用另一个值除 <see cref="T:System.Numerics.BigInteger" /> 值并返回结果。</summary>
        <returns>相除后的商。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Divide%2A>方法执行整数除法; 相除所得的任何其余部分将被丢弃。 若要执行时保留其余部分的整数除法，调用<xref:System.Numerics.BigInteger.DivRem%2A>方法。 若要仅检索余数，调用<xref:System.Numerics.BigInteger.Remainder%2A>方法。  
  
 <xref:System.Numerics.BigInteger.Divide%2A>方法可以由不支持运算符重载的语言。 其行为等同于使用除法运算符的除法。  
  
   
  
## Examples  
 下面的示例创建的数组<xref:System.Numerics.BigInteger>值。 然后，它使用每个元素中使用的除法运算的商作为<xref:System.Numerics.BigInteger.Divide%2A>方法，除法运算符 （/） 和<xref:System.Numerics.BigInteger.DivRem%2A>方法。  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> 是 0（零）。</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">要作为被除数的值。</param>
        <param name="divisor">要作为除数的值。</param>
        <param name="remainder">当此方法返回时，包含一个表示相除余数的 <see cref="T:System.Numerics.BigInteger" /> 值。 此参数未经初始化即被传递。</param>
        <summary>用另一个值除一个 <see cref="T:System.Numerics.BigInteger" /> 值，返回结果，并在输出参数中返回余数。</summary>
        <returns>相除后的商。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法保留商和余数的整数除法运算的结果。 如果你不感的其余部分中，使用<xref:System.Numerics.BigInteger.Divide%2A>方法或除法运算符; 如果要仅对感兴趣其余部分中，使用<xref:System.Numerics.BigInteger.Remainder%2A>方法。  
  
 返回的符号`remainder`值的符号相同`dividend`参数。  
  
 行为<xref:System.Numerics.BigInteger.DivRem%2A>方法等同于的<xref:System.Math.DivRem%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例创建的数组<xref:System.Numerics.BigInteger>值。 然后，它使用每个元素中使用的除法运算的商作为<xref:System.Numerics.BigInteger.Divide%2A>方法，除法运算符 （/） 和<xref:System.Numerics.BigInteger.DivRem%2A>方法。  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> 是 0（零）。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示两个数值是否相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">要比较的 64 位带符号整数值。</param>
        <summary>返回一个值，该值指示当前实例与 64 位带符号整数是否具有相同的值。</summary>
        <returns>
          如果 64 位带符号整数与当前实例具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`other`是<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>值，它将隐式转换为<xref:System.Int64>时调用该方法的值。  
  
 若要确定两个对象而不是只测试相等性之间的关系，请调用<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例实例化<xref:System.Numerics.BigInteger>从除每个整数类型的对象<xref:System.UInt64>。 然后，它调用<xref:System.Numerics.BigInteger.Equals%28System.Int64%29>方法来比较<xref:System.Numerics.BigInteger>值与传递到的原始整数值<xref:System.Numerics.BigInteger>构造函数。 如输出所示，这些值相等中每个用例。  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">要比较的对象。</param>
        <summary>返回一个值，该值指示当前实例与指定的 <see cref="T:System.Numerics.BigInteger" /> 对象是否具有相同的值。</summary>
        <returns>
          如果此 <see cref="T:System.Numerics.BigInteger" /> 对象与 <paramref name="other" /> 具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法实现<xref:System.IEquatable%601>接口，并且执行效果略好于<xref:System.Numerics.BigInteger.Equals%28System.Object%29>因为它不具有要转换`other`参数<xref:System.Numerics.BigInteger>对象。  
  
 若要确定这两者之间的关系<xref:System.Numerics.BigInteger>对象而不是只测试相等性，调用<xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例比较多个星号从地球距离为 Epsilon 为了指明从地球以确定它们是否相等的近似的距离。 该示例使用的每个重载<xref:System.Numerics.BigInteger.Equals%2A>方法来测试相等性。  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要比较的对象。</param>
        <summary>返回一个值，该值指示当前实例与指定的对象是否具有相同的值。</summary>
        <returns>
          如果 <paramref name="obj" /> 参数是 <see cref="T:System.Numerics.BigInteger" /> 对象，并且其值等于当前 <see cref="T:System.Numerics.BigInteger" /> 实例的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`obj`参数不是<xref:System.Numerics.BigInteger>值，该方法返回`false`。 该方法返回`true`才`obj`是<xref:System.Numerics.BigInteger>其值是否等于当前实例的实例。  
  
 若要确定两个对象而不是只测试相等性之间的关系，请调用<xref:System.Numerics.BigInteger.CompareTo%28System.Object%29>方法。  
  
   
  
## Examples  
 下面的示例定义并行<xref:System.Object>和<xref:System.Numerics.BigInteger>数组。 一个数组的每个元素都有第二个数组的对应元素相同的值。 如示例所示中的实例输出<xref:System.Numerics.BigInteger>数组被视为等于中的实例<xref:System.Object>数组仅当后者为<xref:System.Numerics.BigInteger>和它们的值是否相等。  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">要比较的 64 位无符号整数。</param>
        <summary>返回一个值，该值指示当前实例与 64 位无符号整数是否具有相同的值。</summary>
        <returns>
          如果当前实例与 64 位无符号整数具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定两个对象而不是只测试相等性之间的关系，请调用<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例比较多个星号从地球距离为 Epsilon 为了指明从地球以确定它们是否相等的近似的距离。 该示例使用的每个重载<xref:System.Numerics.BigInteger.Equals%2A>方法来测试相等性。  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前 <see cref="T:System.Numerics.BigInteger" /> 对象的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">第一个值。</param>
        <param name="right">第二个值。</param>
        <summary>查找两个 <see cref="T:System.Numerics.BigInteger" /> 值的最大公约数。</summary>
        <returns>
          <paramref name="left" /> 和 <paramref name="right" /> 的最大公约数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最大公约数是到其中的最大数目两个<xref:System.Numerics.BigInteger>值可以划分而无需返回余数。  
  
 如果`left`和`right`参数均为非零数字，因为所有数字都除 1 后，该方法将始终返回至少值为 1。 如果任一参数为零，该方法将返回非零参数的绝对值的数值。 如果这两个值均为零，则该方法返回零。  
  
> [!NOTE]
>  计算最大公约数非常大的值的`left`和`right`可以是非常耗时的操作。  
  
 返回的值<xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>方法始终为正的符号无论`left`和`right`参数。  
  
   
  
## Examples  
 下面的示例演示调用<xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>方法和异常处理提供了一些有用的信息所需<xref:System.ArgumentOutOfRangeException>。 结果指示最大公约数的这两个数字为 1。  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示当前 <see cref="T:System.Numerics.BigInteger" /> 对象的值是否是偶数。</summary>
        <value>
          如果 <see cref="T:System.Numerics.BigInteger" /> 对象的值是偶数，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是便利功能，该值指示是否<xref:System.Numerics.BigInteger>值是由两个整除。 它等效于以下表达式：  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 如果当前的值<xref:System.Numerics.BigInteger>对象是<xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>，该属性返回`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示当前 <see cref="T:System.Numerics.BigInteger" /> 对象的值是否是 <see cref="P:System.Numerics.BigInteger.One" />。</summary>
        <value>
          如果 <see cref="T:System.Numerics.BigInteger" /> 对象的值是 <see cref="P:System.Numerics.BigInteger.One" />，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性提供性能明显高于其他比较方法，如`thisBigInteger.Equals(BigInteger.One)`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示当前 <see cref="T:System.Numerics.BigInteger" /> 对象的值是否是 2 的幂。</summary>
        <value>
          如果 <see cref="T:System.Numerics.BigInteger" /> 对象的值是 2 的幂，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性确定是否<xref:System.Numerics.BigInteger>值已设置的一个非零位。 这意味着，它返回`true`如果的当前值<xref:System.Numerics.BigInteger>对象为 1 (即，2<sup>0</sup>) 或两个任何更高的能力。 它将返回`false`如果的当前值<xref:System.Numerics.BigInteger>对象为 0。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示当前 <see cref="T:System.Numerics.BigInteger" /> 对象的值是否是 <see cref="P:System.Numerics.BigInteger.Zero" />。</summary>
        <value>
          如果 <see cref="T:System.Numerics.BigInteger" /> 对象的值是 <see cref="P:System.Numerics.BigInteger.Zero" />，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性提供的性能明显优于`BigInteger.Equals(BigInteger.Zero)`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回指定数字的对数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要查找其对数的数字。</param>
        <summary>返回指定数字的自然对数（底为 <see langword="e" />）。</summary>
        <returns>
          <paramref name="value" /> 的自然对数（底为 <see langword="e" />），如“备注”部分中的表所示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`参数指定为底数 10。  
  
 此方法的值取决于的符号的精确返回`value`下, 表所示。  
  
|登录的`value`参数|返回值|  
|-------------------------------|------------------|  
|正|自然对数`value`; 即，ln `value`，或日志 e`value`。|  
|零|<xref:System.Double.NegativeInfinity>。|  
|负数|<xref:System.Double.NaN>。|  
  
 若要计算的 10 为底数<xref:System.Numerics.BigInteger>值时，请调用<xref:System.Numerics.BigInteger.Log10%2A>方法。 若要计算的另一个基数的数字的对数，调用<xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29>方法。  
  
 你可以通过调用找到的数字的平方根<xref:System.Numerics.BigInteger.Log%2A>方法以及<xref:System.Math.Exp%2A?displayProperty=nameWithType>方法。 请注意，结果是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>如果结果大于<xref:System.Double.MaxValue?displayProperty=nameWithType>。 下面的示例计算数组中的每个元素的平方根<xref:System.Numerics.BigInteger>值。  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 此方法对应于<xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType>基元数值类型的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> 的自然对数超出了 <see cref="T:System.Double" /> 数据类型的范围。</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">要查找其对数的数字。</param>
        <param name="baseValue">对数的底。</param>
        <summary>返回指定数字在使用指定底时的对数。</summary>
        <returns>
          <paramref name="baseValue" /> 的以 <paramref name="value" /> 为底的对数，如“备注”部分中的表所示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`和`baseValue`作为基 10 个数字指定了参数。  
  
 值的方法取决于的符号的精确返回`value`和上的登录和值`baseValue`下, 表所示。  
  
|`value` 参数|`baseValue` 参数|返回值|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1) -or-(`baseValue` > 1)|logbaseValue(`value`)|  
|`value` < 0|（任意值）|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|（任意值）|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|（任意值）|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|（任意值）|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 若要计算的 10 为底数<xref:System.Numerics.BigInteger>值时，请调用<xref:System.Numerics.BigInteger.Log10%2A>方法。 若要计算数字的自然对数，调用<xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29>方法。  
  
 此方法对应于<xref:System.Math.Log%2A?displayProperty=nameWithType>基元数值类型的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> 的对数超出了 <see cref="T:System.Double" /> 数据类型的范围。</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要查找其对数的数字。</param>
        <summary>返回指定数字以 10 为底的对数。</summary>
        <returns>
          <paramref name="value" /> 的以 10 为底的对数，如“备注”部分中的表所示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`参数指定为底数 10。  
  
 值的方法取决于的符号的精确返回`value`下, 表所示。  
  
|值参数的符号|返回值|  
|-----------------------------|------------------|  
|正|基 10 日志`value`; 即，log10`value`。|  
|零|<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。|  
|负数|<xref:System.Double.NaN?displayProperty=nameWithType>。|  
  
 若要计算的自然对数<xref:System.Numerics.BigInteger>值时，请调用<xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType>方法。 若要计算的另一个基数的数字的对数，调用<xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType>方法。  
  
 此方法对应于<xref:System.Math.Log10%2A?displayProperty=nameWithType>基元数值类型的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> 的以 10 为底的对数超出了 <see cref="T:System.Double" /> 数据类型的范围。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回两个 <see cref="T:System.Numerics.BigInteger" /> 值中的较大者。</summary>
        <returns>
          <paramref name="left" /> 或 <paramref name="right" /> 参数中较大的一个。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法对应于<xref:System.Math.Max%2A?displayProperty=nameWithType>基元数值类型的方法。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Numerics.BigInteger.Max%2A>方法来在一个数组中选择的最大数<xref:System.Numerics.BigInteger>值。  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回两个 <see cref="T:System.Numerics.BigInteger" /> 值中的较小者。</summary>
        <returns>
          <paramref name="left" /> 或 <paramref name="right" /> 参数中较小的一个。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法对应于<xref:System.Math.Min%2A?displayProperty=nameWithType>基元数值类型的方法。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Numerics.BigInteger.Min%2A>方法来选择最少数量的数组中<xref:System.Numerics.BigInteger>值。  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个表示数字负一 (-1) 的值。</summary>
        <value>其值为负一 (-1) 的整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.MinusOne%2A>属性用于比较<xref:System.Numerics.BigInteger>值为-1 或分配-1 到<xref:System.Numerics.BigInteger>对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要计算 <c>exponent</c> 次幂的数字。</param>
        <param name="exponent">对 <c>value</c> 进行幂运算的指数。</param>
        <param name="modulus">
          <c>value</c> 的 <c>exponent</c> 次幂要除以的数值。</param>
        <summary>对以某个数为底、以另一个数为指数的幂执行模数除法。</summary>
        <returns>将 <paramref name="value" /><sup>exponent</sup> 除以 <paramref name="modulus" /> 后的余数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ModPow%2A>方法计算以下表达式：  
  
 (baseValue ^ 指数)Mod 取模  
  
 若要对执行求幂<xref:System.Numerics.BigInteger>值而无需模数除法使用<xref:System.Numerics.BigInteger.Pow%2A>方法。  
  
   
  
## Examples  
 下面的示例提供了调用的简单说明<xref:System.Numerics.BigInteger.ModPow%2A>方法。  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="modulus" /> 为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="exponent" /> 为负数。</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要相乘的第一个数。</param>
        <param name="right">要相乘的第二个数。</param>
        <summary>返回两个 <see cref="T:System.Numerics.BigInteger" /> 值的乘积。</summary>
        <returns>
          <paramref name="left" /> 与 <paramref name="right" /> 参数的乘积。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Multiply%2A>会为不支持运算符重载的语言实现方法。 其行为等同于使用乘法运算符的乘法。 此外，<xref:System.Numerics.BigInteger.Multiply%2A>方法是乘法运算符的有用替代方案，在实例化时<xref:System.Numerics.BigInteger>变量中将其分配的产品的乘法，得到的结果，如下面的示例中所示。  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 如果有必要，此方法会自动执行到其他整数类型的隐式转换<xref:System.Numerics.BigInteger>对象。 在下一节中的示例阐释了这其中<xref:System.Numerics.BigInteger.Multiply%2A>方法传递两个<xref:System.Int64>值。  
  
   
  
## Examples  
 下面的示例尝试执行乘法的两个长整型。 因为的结果超出了长整数范围<xref:System.OverflowException>引发，与<xref:System.Numerics.BigInteger.Multiply%2A>调用方法来处理乘法。 请注意，C# 需要您使用两个`checked`（如此示例所示） 的关键字或`/checked+`编译器选项，以确保数字溢出引发异常。  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要求反的值。</param>
        <summary>对指定的 <see cref="T:System.Numerics.BigInteger" /> 值求反。</summary>
        <returns>
          <paramref name="value" /> 参数乘以负一 (-1) 的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 求反获取大量的加法逆元。 大量的加法逆元是生成的值为 0 时将其添加到原始数的数字。  
  
 <xref:System.Numerics.BigInteger.Negate%2A>会为不支持自定义运算符的语言实现方法。 其行为等同于使用一元求反运算符的求反。 此外，<xref:System.Numerics.BigInteger.Negate%2A>方法是求反运算符的有用替代方案，在实例化时<xref:System.Numerics.BigInteger>变量，如下面的示例中所示。  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 下面的示例演示三种方式要求反的值<xref:System.Numerics.BigInteger>对象。  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个表示数字一 (1) 的值。</summary>
        <value>其值为一 (1) 的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.One%2A>属性通常用于比较<xref:System.Numerics.BigInteger>值为 1 或分配 1 到<xref:System.Numerics.BigInteger>对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要相加的第一个值。</param>
        <param name="right">要相加的第二个值。</param>
        <summary>将两个指定的 <see cref="T:System.Numerics.BigInteger" /> 对象的值相加。</summary>
        <returns>
          <paramref name="left" /> 与 <paramref name="right" /> 的和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Addition%2A>方法定义的加法运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.Add%2A>方法相反。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">第一个值。</param>
        <param name="right">第二个值。</param>
        <summary>对两个 <see cref="T:System.Numerics.BigInteger" /> 值执行按位 <see langword="And" /> 运算。</summary>
        <returns>按位 <see langword="And" /> 运算的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A>方法定义的按位`And`操作<xref:System.Numerics.BigInteger>值。 按位`And`操作设置结果位仅当相应位`left`和`right`还设置下, 表中所示。  
  
|中的位 `left`|中的位 `right`|Result 中位|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A>方法使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A>方法执行的按位`And`对两个操作<xref:System.Numerics.BigInteger>值就像它们是采用二者带虚拟符号扩展的补数表示形式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">第一个值。</param>
        <param name="right">第二个值。</param>
        <summary>对两个 <see cref="T:System.Numerics.BigInteger" /> 值执行按位 <see langword="Or" /> 运算。</summary>
        <returns>按位 <see langword="Or" /> 运算的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A>方法定义的按位`Or`操作<xref:System.Numerics.BigInteger>值。 按位`Or`操作设置结果位仅当一个或两个中的相应位`left`和`right`设置下, 表中所示。  
  
|中的位 `left`|中的位 `right`|Result 中位|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A>方法使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A>方法执行的按位`Or`对两个操作<xref:System.Numerics.BigInteger>值就像它们是采用二者带虚拟符号扩展的补数表示形式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要递减的值。</param>
        <summary>将 <see cref="T:System.Numerics.BigInteger" /> 值减 1。</summary>
        <returns>
          <paramref name="value" /> 参数减 1 后的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Decrement%2A>方法定义的减法运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.Subtract%2A>方法相反。 例如:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 因为<xref:System.Numerics.BigInteger>对象是不可变，<xref:System.Numerics.BigInteger.op_Decrement%2A>运算符创建一个新<xref:System.Numerics.BigInteger>对象，其值是一个小于<xref:System.Numerics.BigInteger>所表示的对象`value`。 这意味着，重复调用<xref:System.Numerics.BigInteger.op_Decrement%2A>可能成本很高。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">要作为被除数的值。</param>
        <param name="divisor">要作为除数的值。</param>
        <summary>通过使用整除，将指定的 <see cref="T:System.Numerics.BigInteger" /> 值除以另一个指定的 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>相除的整数结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Division%2A>方法定义的除法运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 不支持自定义的运算符和运算符重载的语言可以调用<xref:System.Numerics.BigInteger.Divide%2A>方法相反。  
  
 此运算符的等效方法是 <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 下面的示例创建的数组<xref:System.Numerics.BigInteger>值。 然后，它使用每个元素中使用的除法运算的商作为<xref:System.Numerics.BigInteger.Divide%2A>方法，除法运算符 （/） 和<xref:System.Numerics.BigInteger.DivRem%2A>方法。  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> 是 0（零）。</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示两个值是否相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示带符号长整数值与 <see cref="T:System.Numerics.BigInteger" /> 值是否相等。</summary>
        <returns>
          如果 <paramref name="left" /> 与 <paramref name="right" /> 参数具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29>方法定义的相等性比较运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>改为实例方法。  
  
 如果`left`是<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>值，它将隐式转换为<xref:System.Int64>时执行此操作的值。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值与带符号长整数值是否相等。</summary>
        <returns>
          如果 <paramref name="left" /> 与 <paramref name="right" /> 参数具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29>方法定义的相等性比较运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>改为实例方法。  
  
 如果`right`是<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>值，它将隐式转换为<xref:System.Int64>时执行此操作的值。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示两个 <see cref="T:System.Numerics.BigInteger" /> 对象的值是否相等。</summary>
        <returns>
          如果 <paramref name="left" /> 与 <paramref name="right" /> 参数具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>方法定义的相等运算符的运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>改为实例方法。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值与无符号长整数值是否相等。</summary>
        <returns>
          如果 <paramref name="left" /> 与 <paramref name="right" /> 参数具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29>方法定义的相等性比较运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType>改为实例方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示无符号长整数值与 <see cref="T:System.Numerics.BigInteger" /> 值是否相等。</summary>
        <returns>
          如果 <paramref name="left" /> 与 <paramref name="right" /> 参数具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29>方法定义的相等性比较运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType>改为实例方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">第一个值。</param>
        <param name="right">第二个值。</param>
        <summary>对两个 <see cref="T:System.Numerics.BigInteger" /> 值执行按位异 <see langword="Or" /> (<see langword="XOr" />) 运算。</summary>
        <returns>按位 <see langword="Or" /> 运算的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 按位异的结果`Or`操作`true`如果两位的值不同; 否则为它是`false`。 下表说明了独占`Or`操作。  
  
|中的位 x `left`|中的位 x `right`|返回值|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A>方法使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A>方法执行按位异`Or`对两个操作<xref:System.Numerics.BigInteger>值就像它们是采用二者带虚拟符号扩展的补数表示形式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定义 <see cref="T:System.Numerics.BigInteger" /> 对象与其他类型之间的显式转换。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 <see cref="T:System.Decimal" /> 对象到 <see cref="T:System.Numerics.BigInteger" /> 值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何小数部分`value`参数被截断转换前。

 重载<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定义的类型到其中或从中<xref:System.Numerics.BigInteger>可将对象转换。 因为从转换<xref:System.Decimal>到<xref:System.Numerics.BigInteger>可能涉及截断任何小数部分`value`，语言编译器不会自动执行此转换。 相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`在 Visual Basic 中) 使用。 否则，它们显示编译器错误。   

 对于不支持自定义运算符的语言，替代方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>。


## Examples
 以下示例将转换的数组中的各个元素<xref:System.Decimal>值复制到<xref:System.Numerics.BigInteger>对象，，然后显示每个转换的结果。 请注意对任何小数部分的一部分<xref:System.Decimal>在转换期间截断值。   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 <see cref="T:System.Double" /> 值到 <see cref="T:System.Numerics.BigInteger" /> 值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何小数部分`value`参数被截断转换前。

 重载<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定义的类型到其中或从中<xref:System.Numerics.BigInteger>可将对象转换。 因为从转换<xref:System.Double>到<xref:System.Numerics.BigInteger>可能涉及截断任何小数部分`value`，语言编译器不会自动执行此转换。 相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`在 Visual Basic 中) 使用。 否则，它们显示编译器错误。

 对于不支持自定义运算符的语言，替代方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>。


## Examples
 以下示例将转换的数组中的各个元素<xref:System.Double>值复制到<xref:System.Numerics.BigInteger>对象，，然后显示每个转换的结果。 请注意对任何小数部分的一部分<xref:System.Double>在转换期间截断值。   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> 的值为 <see cref="F:System.Double.NaN" />。  
  
 或  
  
 <paramref name="value" /> 的值为 <see cref="F:System.Double.PositiveInfinity" />。
  
 或  
  
 <paramref name="value" /> 的值为 <see cref="F:System.Double.NegativeInfinity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Byte" /> 的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到无符号字节值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重载<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定义的类型到其中或从中<xref:System.Numerics.BigInteger>可将对象转换。 语言编译器不会自动执行此转换，因为它会导致数据丢失。 相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`或`CByte`在 Visual Basic 中) 使用。 否则，它们显示编译器错误。   

 因为此操作定义收缩转换，它可以引发<xref:System.OverflowException>如果在运行时<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.Byte>数据类型。 不会丢失精度在随后出现的<xref:System.Byte>值转换是否成功。

## Examples
 下面的示例演示的转换<xref:System.Numerics.BigInteger>到<xref:System.Byte>值。 它还可以处理<xref:System.OverflowException>引发因为<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.Byte>数据类型。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> 的值小于 <see cref="F:System.Byte.MinValue" />。  
  
 或  
  
 <paramref name="value" /> 的值大于 <see cref="F:System.Byte.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Decimal" /> 的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 <see cref="T:System.Decimal" /> 值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重载<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定义的类型到其中或从中<xref:System.Numerics.BigInteger>可将对象转换。 语言编译器不会自动执行此转换，因为它会导致数据丢失。 相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`或`CDec`在 Visual Basic 中) 使用。   

 因为此操作定义收缩转换，它可以引发<xref:System.OverflowException>如果在运行时<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.Decimal>数据类型。 

## Examples
 下面的示例演示的转换<xref:System.Numerics.BigInteger>到<xref:System.Decimal>值。 它还可以处理<xref:System.OverflowException>引发因为<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.Decimal>数据类型。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> 的值小于 <see cref="F:System.Decimal.MinValue" />。  
  
 或  
  
 <paramref name="value" /> 的值大于 <see cref="F:System.Decimal.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Double" /> 的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 <see cref="T:System.Double" /> 值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重载<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定义的类型到其中或从中<xref:System.Numerics.BigInteger>可将对象转换。 语言编译器不会自动执行此转换，因为它会导致数据丢失。 相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`或`CDbl`在 Visual Basic 中) 使用。   

 因为<xref:System.Numerics.BigInteger>值可以是外部的范围<xref:System.Double>数据类型，此操作都是收缩转换。 如果转换失败，它不会引发<xref:System.OverflowException>。 相反，如果<xref:System.Numerics.BigInteger>值是小于<xref:System.Double.MinValue?displayProperty=nameWithType>，生成<xref:System.Double>值是<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。 如果<xref:System.Numerics.BigInteger>值是否大于<xref:System.Double.MaxValue?displayProperty=nameWithType>，生成<xref:System.Double>值是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>。
 
 转换<xref:System.Numerics.BigInteger>到<xref:System.Double>可能会丢失精度。 在某些情况下，精度损失可能会导致成功执行该强制转换或转换操作即使<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.Double>数据类型。 下面的示例进行了这方面的演示。 它将分配的最大值<xref:System.Double>到两个<xref:System.Numerics.BigInteger>变量，将一个<xref:System.Numerics.BigInteger>变量通过 9.999 e 291,，并测试两个变量是否相等。 按预期对的调用方式<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>方法演示，它们不相等。 但是，将较大的转换<xref:System.Numerics.BigInteger>该值转换回<xref:System.Double>成功，尽管<xref:System.Numerics.BigInteger>值现在超出<xref:System.Double.MaxValue?displayProperty=nameWithType>。   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 下面的示例演示的转换<xref:System.Numerics.BigInteger>到<xref:System.Double>值。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 16 位带符号整数的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 16 位带符号整数值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重载<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定义的类型到其中或从中<xref:System.Numerics.BigInteger>可将对象转换。 语言编译器不会自动执行此转换，因为它会导致数据丢失。 相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`或`CShort`在 Visual Basic 中) 使用。 否则，它们显示编译器错误。   

 因为此操作定义收缩转换，它可以引发<xref:System.OverflowException>如果在运行时<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.Int16>数据类型。 不会丢失精度在随后出现的<xref:System.Int16>值转换是否成功。

## Examples
 下面的示例演示的转换<xref:System.Numerics.BigInteger>到<xref:System.Int16>值。 它还可以处理<xref:System.OverflowException>引发因为<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.Int16>数据类型。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> 的值小于 <see cref="F:System.Int16.MinValue" />。  
  
 或  
  
 <paramref name="value" /> 的值大于 <see cref="F:System.Int16.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 32 位带符号整数的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 32 位带符号整数值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重载<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定义的类型到其中或从中<xref:System.Numerics.BigInteger>可将对象转换。 语言编译器不会自动执行此转换，因为它会导致数据丢失。 相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`或`CInt`在 Visual Basic 中) 使用。 否则，它们显示编译器错误。   

 因为此操作定义收缩转换，它可以引发<xref:System.OverflowException>如果在运行时<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.Int32>数据类型。 不会丢失精度在随后出现的<xref:System.Int16>值转换是否成功。

## Examples
 下面的示例演示的转换<xref:System.Numerics.BigInteger>到<xref:System.Int32>值。 它还可以处理<xref:System.OverflowException>引发因为<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.Int32>数据类型。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> 的值小于 <see cref="F:System.Int32.MinValue" />。  
  
 或  
  
 <paramref name="value" /> 的值大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 64 位带符号整数的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 64 位带符号整数值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重载<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定义的类型到其中或从中<xref:System.Numerics.BigInteger>可将对象转换。 语言编译器不会自动执行此转换，因为它会导致数据丢失。 相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`或`CLng`在 Visual Basic 中) 使用。 否则，它们显示编译器错误。  

 因为此操作定义收缩转换，它可以引发<xref:System.OverflowException>如果在运行时<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.Int64>数据类型。 

## Examples
 下面的示例演示的转换<xref:System.Numerics.BigInteger>到<xref:System.Int64>值。 它还可以处理<xref:System.OverflowException>引发因为<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.Int64>数据类型。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> 的值小于 <see cref="F:System.Int64.MinValue" />。  
  
 或  
  
 <paramref name="value" /> 的值大于 <see cref="F:System.Int64.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 8 位带符号值的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 8 位带符号值的显式转换。  
  
 此 API 不兼容 CLS。 符合的替代方法是 <see cref="T:System.Int16" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重载<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定义的类型到其中或从中<xref:System.Numerics.BigInteger>可将对象转换。 语言编译器不会自动执行此转换，因为它会导致数据丢失。 相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`或`CSByte`在 Visual Basic 中) 使用。 否则，它们显示编译器错误。  

 因为此操作定义收缩转换，它可以引发<xref:System.OverflowException>如果在运行时<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.SByte>数据类型。 不会丢失精度在随后出现的<xref:System.SByte>值转换是否成功。

## Examples
 下面的示例演示的转换<xref:System.Numerics.BigInteger>到<xref:System.SByte>值。 它还可以处理<xref:System.OverflowException>引发因为<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.SByte>数据类型。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> 的值小于 <see cref="F:System.SByte.MinValue" />。  
  
 或  
  
 <paramref name="value" /> 的值大于 <see cref="F:System.SByte.MaxValue" />。</exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为单精度浮点值的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到单精度浮点值的显式转换。</summary>
        <returns>一个对象，包含 <paramref name="value" /> 参数的尽可能精确的表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重载<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定义的类型到其中或从中<xref:System.Numerics.BigInteger>可将对象转换。 语言编译器不会自动执行此转换，因为它会导致数据丢失或精度损失。 相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`或`CSng`在 Visual Basic 中) 使用。 否则，它们显示编译器错误。    

 因为<xref:System.Numerics.BigInteger>值可以是外部的范围<xref:System.Single>数据类型，此操作都是收缩转换。 如果转换失败，它不会引发<xref:System.OverflowException>。 相反，如果<xref:System.Numerics.BigInteger>值是小于<xref:System.Single.MinValue?displayProperty=nameWithType>，生成<xref:System.Single>值是<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>。 如果<xref:System.Numerics.BigInteger>值是否大于<xref:System.Single.MaxValue?displayProperty=nameWithType>，生成<xref:System.Single>值是<xref:System.Single.PositiveInfinity?displayProperty=nameWithType>。

 转换<xref:System.Numerics.BigInteger>到<xref:System.Single>可能会丢失精度。 在某些情况下，精度损失可能会导致成功执行该强制转换或转换操作即使<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.Single>数据类型。 下面的示例进行了这方面的演示。 它将分配的最大值<xref:System.Single>到两个<xref:System.Numerics.BigInteger>变量，将一个<xref:System.Numerics.BigInteger>变量通过 9.999 e 291,，并测试两个变量是否相等。 按预期对的调用方式<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>方法演示，它们不相等。 但是，将较大的转换<xref:System.Numerics.BigInteger>该值转换回<xref:System.Single>成功，尽管<xref:System.Numerics.BigInteger>值现在超出<xref:System.Single.MaxValue?displayProperty=nameWithType>。   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 下面的示例演示的转换<xref:System.Numerics.BigInteger>到<xref:System.Single>值。   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 16 位无符号整数的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 16 位无符号整数值的显式转换。  
  
 此 API 不兼容 CLS。 符合的替代方法是 <see cref="T:System.Int32" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重载<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定义的类型到其中或从中<xref:System.Numerics.BigInteger>可将对象转换。 语言编译器不会自动执行此转换，因为它会导致数据丢失。 相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`或`CUShort`在 Visual Basic 中) 使用。 否则，它们显示编译器错误。    

 因为此操作定义收缩转换，它可以引发<xref:System.OverflowException>如果在运行时<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.UInt16>数据类型。 不会丢失精度在随后出现的<xref:System.UInt16>值转换是否成功。

## Examples
 下面的示例演示的转换<xref:System.Numerics.BigInteger>到<xref:System.UInt16>值。 它还可以处理<xref:System.OverflowException>引发因为<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.UInt16>数据类型。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> 的值小于 <see cref="F:System.UInt16.MinValue" />。  
  
 或  
  
 <paramref name="value" /> 的值大于 <see cref="F:System.UInt16.MaxValue" />。</exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 32 位无符号整数的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 32 位无符号整数值的显式转换。  
  
 此 API 不兼容 CLS。 符合的替代方法是 <see cref="T:System.Int64" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重载<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定义的类型到其中或从中<xref:System.Numerics.BigInteger>可将对象转换。 语言编译器不会自动执行此转换，因为它会导致数据丢失。 相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`或`CUInt`在 Visual Basic 中) 使用。 否则，它们显示编译器错误。    

 因为此操作定义收缩转换，它可以引发<xref:System.OverflowException>如果在运行时<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.UInt32>数据类型。 不会丢失精度在随后出现的<xref:System.UInt32>值转换是否成功。

## Examples
 下面的示例演示的转换<xref:System.Numerics.BigInteger>到<xref:System.UInt32>值。 它还可以处理<xref:System.OverflowException>引发因为<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.UInt32>数据类型。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> 的值小于 <see cref="F:System.UInt32.MinValue" />。  
  
 或  
  
 <paramref name="value" /> 的值大于 <see cref="F:System.UInt32.MaxValue" />。</exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 64 位无符号整数的值。</param>
        <summary>定义从 <see cref="T:System.Numerics.BigInteger" /> 对象到 64 位无符号整数值的显式转换。  
  
 此 API 不兼容 CLS。 符合的替代方法是 <see cref="T:System.Double" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重载<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定义的类型到其中或从中<xref:System.Numerics.BigInteger>可将对象转换。 语言编译器不会自动执行此转换，因为它会导致数据丢失。 相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`或`CULng`在 Visual Basic 中) 使用。 否则，它们显示编译器错误。    

 因为此操作定义收缩转换，它可以引发<xref:System.OverflowException>如果在运行时<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.UInt64>数据类型。 不会丢失精度在随后出现的<xref:System.UInt64>值转换是否成功。

## Examples
 下面的示例演示的转换<xref:System.Numerics.BigInteger>到<xref:System.UInt64>值。 它还可以处理<xref:System.OverflowException>引发因为<xref:System.Numerics.BigInteger>值的范围超出了<xref:System.UInt64>数据类型。   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> 的值小于 <see cref="F:System.UInt64.MinValue" />。  
  
 或  
  
 <paramref name="value" /> 的值大于 <see cref="F:System.UInt64.MaxValue" />。</exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 <see cref="T:System.Single" /> 值到 <see cref="T:System.Numerics.BigInteger" /> 值的显式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何小数部分`value`参数被截断转换前。
 
 重载<xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>方法定义的类型到其中或从中<xref:System.Numerics.BigInteger>可将对象转换。 因为从转换<xref:System.Single>到<xref:System.Numerics.BigInteger>可能涉及截断任何小数部分`value`，语言编译器不会自动执行此转换。 相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`在 Visual Basic 中) 使用。 否则，它们显示编译器错误。

 对于不支持自定义运算符的语言，替代方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>。


## Examples
 以下示例将转换的数组中的各个元素<xref:System.Single>值复制到<xref:System.Numerics.BigInteger>对象，，然后显示每个转换的结果。 请注意对任何小数部分的一部分<xref:System.Single>在转换期间截断值。
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> 的值为 <see cref="F:System.Single.NaN" />。  
  
 或  
  
 <paramref name="value" /> 的值为 <see cref="F:System.Single.PositiveInfinity" />。
  
 或  
  
 <paramref name="value" /> 的值为 <see cref="F:System.Single.NegativeInfinity" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示指定的值是否大于另一个指定的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位带符号整数是否大于 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>
          如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A>方法定义的操作的大于运算符<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>改为实例方法。 此外可以调用某些语言<xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 如果`left`是<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>值，它将隐式转换为<xref:System.Int64>时执行此操作的值。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 是否大于 64 位带符号整数值。</summary>
        <returns>
          如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A>方法定义的操作的大于运算符<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法相反。 此外可以调用某些语言<xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 如果`right`是<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>值，它将隐式转换为<xref:System.Int64>时执行此操作的值。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否大于另一个 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>
          如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A>方法定义的操作的大于运算符<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>方法相反。 它们还可以调用<xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否大于 64 位无符号整数。</summary>
        <returns>
          如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A>方法定义的操作的大于运算符<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法相反。 此外可以调用某些语言<xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否大于 64 位无符号整数。</summary>
        <returns>
          如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThan%2A>方法定义的操作的大于运算符<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法相反。 此外可以调用某些语言<xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示指定的值是否大于等于另一个指定的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位带符号整数是否大于等于 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>
          如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>方法定义的操作大于或等于运算符<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法相反。 此外可以调用某些语言<xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 如果`left`是<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>值，它将隐式转换为<xref:System.Int64>时执行此操作的值。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否大于等于 64 位带符号整数值。</summary>
        <returns>
          如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>方法定义的操作大于或等于运算符<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法相反。 此外可以调用某些语言<xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 如果`right`是<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>值，它将隐式转换为<xref:System.Int64>时执行此操作的值。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否大于等于另一个 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>
          如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>方法定义的操作大于或等于运算符<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType>方法相反。 此外可以调用某些语言<xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否大于等于 64 位无符号整数值。</summary>
        <returns>
          如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>方法定义的操作大于或等于运算符<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法相反。 此外可以调用某些语言<xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位无符号整数是否大于等于 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>
          如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>方法定义的操作大于或等于运算符<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法相反。 此外可以调用某些语言<xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定义 <see cref="T:System.Numerics.BigInteger" /> 对象与其他类型之间的隐式转换。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从无符号字节到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何小数部分`value`参数被截断转换前。

 对于不支持隐式运算符的语言，替代方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>。   

 重载<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法定义的类型，或从其编译器可自动转换到<xref:System.Numerics.BigInteger>而无需使用显式强制转换运算符 （在 C# 中) 或调用转换函数 （在 Visual Basic 中) 的值。 它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。 此重载使编译器能够处理从转换<xref:System.Byte>值赋给<xref:System.Numerics.BigInteger>值，如以下示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 16 位带符号整数到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不支持隐式运算符的语言，替代方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>。   

 重载<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法定义的类型，或从其编译器可自动转换到<xref:System.Numerics.BigInteger>而无需使用显式强制转换运算符 （在 C# 中) 或调用转换函数 （在 Visual Basic 中) 的值。 它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。 此重载使编译器能够处理从转换<xref:System.Int16>值赋给<xref:System.Numerics.BigInteger>值，如以下示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 32 位带符号整数到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不支持隐式运算符的语言，替代方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>。  

 重载<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法定义的类型，或从其编译器可自动转换到<xref:System.Numerics.BigInteger>而无需使用显式强制转换运算符 （在 C# 中) 或调用转换函数 （在 Visual Basic 中) 的值。 它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。 此重载使编译器能够处理从转换<xref:System.Int32>值赋给<xref:System.Numerics.BigInteger>值，如以下示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 64 位带符号整数到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不支持隐式运算符的语言，替代方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>。   
 
 重载<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法定义的类型，或从其编译器可自动转换到<xref:System.Numerics.BigInteger>而无需使用显式强制转换运算符 （在 C# 中) 或调用转换函数 （在 Visual Basic 中) 的值。 它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。 此重载使编译器能够处理从转换<xref:System.Int64>值赋给<xref:System.Numerics.BigInteger>值，如以下示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 8 位带符号整数到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。  
  
 此 API 不兼容 CLS。 符合的替代方法是 <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不支持隐式运算符的语言，替代方法是<xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>。   

 重载<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法定义的类型，或从其编译器可自动转换到<xref:System.Numerics.BigInteger>而无需使用显式强制转换运算符 （在 C# 中) 或调用转换函数 （在 Visual Basic 中) 的值。 它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。 此重载使编译器能够处理从转换<xref:System.SByte>值赋给<xref:System.Numerics.BigInteger>值，如以下示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 16 位无符号整数到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。  
  
 此 API 不兼容 CLS。 符合的替代方法是 <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不支持隐式运算符的语言，替代方法是<xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>。   

 重载<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法定义的类型，或从其编译器可自动转换到<xref:System.Numerics.BigInteger>而无需使用显式强制转换运算符 （在 C# 中) 或调用转换函数 （在 Visual Basic 中) 的值。 它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。 此重载使编译器能够处理从转换<xref:System.UInt16>值赋给<xref:System.Numerics.BigInteger>值，如以下示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 32 位无符号整数到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。  
  
 此 API 不兼容 CLS。 符合的替代方法是 <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不支持隐式运算符的语言，替代方法是<xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>。   

 重载<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法定义的类型，或从其编译器可自动转换到<xref:System.Numerics.BigInteger>而无需使用显式强制转换运算符 （在 C# 中) 或调用转换函数 （在 Visual Basic 中) 的值。 它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。 此重载使编译器能够处理从转换<xref:System.UInt32>值赋给<xref:System.Numerics.BigInteger>值，如以下示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">要转换为 <see cref="T:System.Numerics.BigInteger" /> 的值。</param>
        <summary>定义从 64 位无符号整数到 <see cref="T:System.Numerics.BigInteger" /> 值的隐式转换。  
  
 此 API 不兼容 CLS。 符合的替代方法是 <see cref="T:System.Double" />。</summary>
        <returns>包含 <paramref name="value" /> 参数值的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不支持隐式运算符的语言，替代方法是<xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>。   

 重载<xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>方法定义的类型，或从其编译器可自动转换到<xref:System.Numerics.BigInteger>而无需使用显式强制转换运算符 （在 C# 中) 或调用转换函数 （在 Visual Basic 中) 的值。 它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。 此重载使编译器能够处理从转换<xref:System.UInt64>值赋给<xref:System.Numerics.BigInteger>值，如以下示例所示。   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要递增的值。</param>
        <summary>将 <see cref="T:System.Numerics.BigInteger" /> 值加 1。</summary>
        <returns>
          <paramref name="value" /> 参数加 1 后的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Increment%2A>方法定义的加法运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 缺少递增运算符或不支持运算符重载的某些语言 （如 Visual Basic 中) 可以调用<xref:System.Numerics.BigInteger.op_Increment%2A>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 因为<xref:System.Numerics.BigInteger>对象是不可变，<xref:System.Numerics.BigInteger.op_Increment%2A>运算符创建一个新<xref:System.Numerics.BigInteger>对象，其值是一个多个<xref:System.Numerics.BigInteger>所表示的对象`value`。 因此，重复调用<xref:System.Numerics.BigInteger.op_Increment%2A>可能成本很高。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示两个数值是否不相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位带符号整数与 <see cref="T:System.Numerics.BigInteger" /> 值是否不相等。</summary>
        <returns>
          如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A>方法定义的不相等运算符的运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 不支持自定义运算符的语言可以测试不相等，通过使用以下方法之一：  
  
-   调用<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>实例方法，指示之间的关系<xref:System.Numerics.BigInteger>和符号长整数值。  
  
-   调用<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>实例方法和反转其值。  
  
 如果`left`是<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>值，它将隐式转换为<xref:System.Int64>时执行此操作的值。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值与 64 位带符号整数是否不相等。</summary>
        <returns>
          如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A>方法定义的不相等运算符的运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 不支持自定义运算符的语言可以测试不相等，通过使用以下方法之一：  
  
-   调用<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法，指示之间的关系<xref:System.Numerics.BigInteger>和符号长整数值。  
  
-   调用<xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>方法并反转其值。  
  
 如果`right`是<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>值，它将隐式转换为<xref:System.Int64>时执行此操作的值。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示两个 <see cref="T:System.Numerics.BigInteger" /> 对象是否具有不同的值。</summary>
        <returns>
          如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A>方法定义的不相等运算符的运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 不支持自定义运算符的语言可以测试不相等，通过使用以下方法之一：  
  
-   调用<xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType>方法，指示两个之间的关系<xref:System.Numerics.BigInteger>对象。  
  
-   调用<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>方法并反转其值。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值与 64 位无符号整数是否不相等。</summary>
        <returns>
          如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A>方法定义的不相等运算符的运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 不支持自定义运算符的语言可以测试不相等，通过使用以下方法之一：  
  
-   调用<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法，指示之间的关系<xref:System.Numerics.BigInteger>和无符号长整数值。  
  
-   调用<xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType>方法并反转其值。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位无符号整数与 <see cref="T:System.Numerics.BigInteger" /> 值是否不相等。</summary>
        <returns>
          如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Inequality%2A>方法定义的不相等运算符的运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 不支持自定义运算符的语言可以测试不相等，通过使用以下方法之一：  
  
-   调用<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法，指示之间的关系<xref:System.Numerics.BigInteger>和无符号长整数值。  
  
-   调用<xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType>方法并反转其值。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要移动其位的值。</param>
        <param name="shift">将 <c>value</c> 向左移动的位数。</param>
        <summary>将 <see cref="T:System.Numerics.BigInteger" /> 值向左移动指定的位数。</summary>
        <returns>一个已向左移动指定位数的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LeftShift%2A>方法定义的按位左移运算符的运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  与整数基元与按位左移运算不同<xref:System.Numerics.BigInteger.op_LeftShift%2A>方法保留原始的符号<xref:System.Numerics.BigInteger>值。  
  
 不支持自定义运算符的语言可以通过将乘以执行按位左移运算`value`通过`BigInteger.Pow(2, shift)`。 下面的示例演示的结果与使用此运算符的结果相同。  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示指定的值是否小于另一个指定的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位带符号整数是否小于 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>
          如果 <paramref name="left" /> 小于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A>方法定义的操作的小于运算符<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法相反。 此外可以调用某些语言<xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 如果`left`是<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>值，它将隐式转换为<xref:System.Int64>时执行此操作的值。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否小于 64 位带符号整数。</summary>
        <returns>
          如果 <paramref name="left" /> 小于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A>方法定义的操作的小于运算符<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法相反。 此外可以调用某些语言<xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 如果`right`是<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>值，它将隐式转换为<xref:System.Int64>时执行此操作的值。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否小于另一个 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>
          如果 <paramref name="left" /> 小于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A>方法定义的操作的小于运算符<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType>方法相反。 此外可以调用某些语言<xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否小于 64 位无符号整数。</summary>
        <returns>
          如果 <paramref name="left" /> 小于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A>方法定义的操作的小于运算符<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法相反。 它们还可以调用<xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位无符号整数是否小于 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>
          如果 <paramref name="left" /> 小于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThan%2A>方法定义的操作的小于运算符<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法相反。 它们还可以调用<xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示指定的值是否小于等于另一个指定的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位带符号整数是否小于等于 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>
          如果 <paramref name="left" /> 小于等于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A>方法定义的操作的运算符的小于或等于<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法相反。 它们还可以调用<xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 如果`left`是<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>值，它将隐式转换为<xref:System.Int64>时执行此操作的值。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否小于等于 64 位带符号整数。</summary>
        <returns>
          如果 <paramref name="left" /> 小于等于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A>方法定义的操作的运算符的小于或等于<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>方法相反。 它们还可以调用<xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 如果`right`是<xref:System.Byte>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.SByte>， <xref:System.UInt16>，或<xref:System.UInt32>值，它将隐式转换为<xref:System.Int64>时执行此操作的值。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否小于等于另一个 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>
          如果 <paramref name="left" /> 小于等于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A>方法定义的操作的运算符的小于或等于<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.Compare%2A>方法相反。 它们还可以调用<xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 <see cref="T:System.Numerics.BigInteger" /> 值是否小于等于 64 位无符号整数。</summary>
        <returns>
          如果 <paramref name="left" /> 小于等于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A>方法定义的操作的运算符的小于或等于<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法相反。 它们还可以调用<xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示 64 位无符号整数是否小于等于 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>
          如果 <paramref name="left" /> 小于等于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A>方法定义的操作的运算符的小于或等于<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>方法相反。 它们还可以调用<xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29>方法直接，如以下示例所示。  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">要作为被除数的值。</param>
        <param name="divisor">要作为除数的值。</param>
        <summary>返回两个指定 <see cref="T:System.Numerics.BigInteger" /> 值相除所得的余数。</summary>
        <returns>相除所得的余数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Modulus%2A>方法定义的取模运算符的运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType>方法相反。  
  
 取模运算返回的值的符号取决于的符号`dividend`： 如果`dividend`为正，取模运算返回正结果; 如果它为负，取模运算返回负数的结果。 该取模操作的行为<xref:System.Numerics.BigInteger>值等同于与其他整数类型取模运算。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> 是 0（零）。</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要相乘的第一个值。</param>
        <param name="right">要相乘的第二个值。</param>
        <summary>两个指定的 <see cref="T:System.Numerics.BigInteger" /> 值相乘。</summary>
        <returns>
          <paramref name="left" /> 与 <paramref name="right" /> 的乘积。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Multiply%2A>方法定义的乘法运算符的运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">一个整数值。</param>
        <summary>返回 <see cref="T:System.Numerics.BigInteger" /> 值的按位二进制反码。</summary>
        <returns>
          <paramref name="value" /> 的按位二进制反码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_OnesComplement%2A>方法定义的操作的按位反码运算符的<xref:System.Numerics.BigInteger>值。 每位中的数字值的按位反码运算符反转。 即，位`value`都 0 将设置为 1 在结果中，并为 1 的位将设置为在结果为 0。 <xref:System.Numerics.BigInteger.op_OnesComplement%2A>方法使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 不支持自定义运算符的语言可以在调用<xref:System.Numerics.BigInteger.op_OnesComplement%2A>方法直接以执行按位二进制反码运算。 例如:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要移动其位的值。</param>
        <param name="shift">将 <c>value</c> 向右移动的位数。</param>
        <summary>将 <see cref="T:System.Numerics.BigInteger" /> 值向右移动指定的位数。</summary>
        <returns>一个已向右移动指定位数的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_RightShift%2A>方法定义的按位右移运算符的运算<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 不支持自定义运算符的语言可以执行按位右移运算除以`value`通过`BigInteger.Pow(2, shift)`和减去 1 次`shift`负值。 下面的示例演示的结果与使用此运算符的结果相同。  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 如果`shift`大于或等于正比特数<xref:System.Numerics.BigInteger>值，右移运算的结果是<xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>。 如果`shift`大于在负的比特数<xref:System.Numerics.BigInteger>值，右移运算的结果是<xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要从中减去的值（被减数）。</param>
        <param name="right">要减去的值（减数）。</param>
        <summary>从另一个 <see cref="T:System.Numerics.BigInteger" /> 值中减去 <see cref="T:System.Numerics.BigInteger" /> 值。</summary>
        <returns>
          <paramref name="right" /> 减 <paramref name="left" /> 所得的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_Subtraction%2A>方法定义的减法运算符，用于操作<xref:System.Numerics.BigInteger>值。 它使代码如下所示：  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType>方法相反。  
  
 此运算符的等效方法是<xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>。]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">要求反的值。</param>
        <summary>对指定的 BigInteger 值求反。</summary>
        <returns>
          <paramref name="value" /> 参数乘以负一 (-1) 的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_UnaryNegation%2A>方法定义的一元求反运算符 （或加法逆元运算符） 操作<xref:System.Numerics.BigInteger>值。 操作会生成一个值，当将其添加到原始编号产生 0 （零）。 不支持自定义运算符的语言可以调用<xref:System.Numerics.BigInteger.Negate%2A>方法相反。  
  
 此运算符的等效方法是 <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 下面的示例演示三种不同的方式进行求反运算的值<xref:System.Numerics.BigInteger>对象。  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">一个整数值。</param>
        <summary>返回 <see cref="T:System.Numerics.BigInteger" /> 操作数的值。 （操作数的符号不变。）</summary>
        <returns>
          <paramref name="value" /> 操作数的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.op_UnaryPlus%2A>方法定义的一元正运算符的运算<xref:System.Numerics.BigInteger>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数字的字符串表示形式转换为它的等效 <see cref="T:System.Numerics.BigInteger" /> 表示形式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">包含要转换的数字的字符串。</param>
        <summary>将数字的字符串表示形式转换为它的等效 <see cref="T:System.Numerics.BigInteger" /> 表示形式。</summary>
        <returns>一个值，等于 <paramref name="value" /> 参数中指定的数字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`参数应为以下形式的数字的字符串表示。  
  
 [*ws*][*sign*]*digits*[*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表描述每个元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|可选的空白区域。|  
|*sign*|一个可选符号后。 有效的符号字符由<xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType>当前区域性的属性。|  
|*digits*|范围从 0 到 9 的数字的序列。 忽略任何前导零。|  
  
> [!NOTE]
>  指定的字符串`value`参数解释使用<xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType>样式。 不能包含任何组分隔符或小数分隔符，并且它不能具有小数部分。  
  
 `value`通过使用中的格式设置信息分析参数<xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType>初始化针对当前系统区域性的对象。 有关详情，请参阅<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>。 若要通过使用特定区域性的格式设置信息中分析字符串，使用<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29>方法。  
  
> [!IMPORTANT]
>  如果你使用<xref:System.Numerics.BigInteger.Parse%2A>保存/还原的字符串表示的方法的<xref:System.Numerics.BigInteger>已输出的值<xref:System.Numerics.BigInteger.ToString%2A>方法，则应使用<xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>使用"R"格式说明符生成的字符串表示形式的方法<xref:System.Numerics.BigInteger>值。 否则为的字符串表示形式<xref:System.Numerics.BigInteger>仅 50，最高有效位的原始值和数据可能会丢失，当你使用保留<xref:System.Numerics.BigInteger.Parse%2A>方法，使还原<xref:System.Numerics.BigInteger>值。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Numerics.BigInteger.Parse%28System.String%29>方法可实例化两个<xref:System.Numerics.BigInteger>对象。 它将乘以每个对象由另一个数，然后调用<xref:System.Numerics.BigInteger.Compare%2A>方法来确定两个值之间的关系。  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> 的格式不正确。</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">包含要转换的数字的字符串。</param>
        <param name="style">枚举值的按位组合，这些枚举值指定 <c>value</c> 所允许的格式。</param>
        <summary>将指定样式的数字的字符串表示形式转换为它的等效 <see cref="T:System.Numerics.BigInteger" />。</summary>
        <returns>一个值，等于 <paramref name="value" /> 参数中指定的数字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style`参数定义中允许的样式元素 （如空格、 正整数或负号符号、 组分隔符符号或小数点符号）`value`分析操作成功的参数。 `styles` 必须是中的位标志的组合<xref:System.Globalization.NumberStyles>枚举。 `style`参数将使得此方法重载有用`value`时数字系统 （十进制或十六进制） 由包含的字符串表示形式的十六进制值，`value`仅在运行时，已知时，或者当你想要禁止的空白区域或正负符号`value`。  
  
 根据值`style`、`value`参数可能包括以下元素：  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 如果`style`包括<xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>、`value`参数可能包含下列元素：  
  
 [*ws*]*hexdigits*[*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表描述每个元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|可选的空白区域。 空格可以出现在开始`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>标志，它可以出现在末尾`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>标志。|  
|*$*|特定于区域性的货币符号。 在字符串中的位置由<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType>当前区域性的属性。 当前区域性的货币符号可以出现在`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>标志。|  
|*sign*|一个可选符号后。 符号可以出现在开始`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>标志，它可以出现在末尾`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>标志。 可以在使用括号`value`以指示负值，如果`style`包括<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>标志。|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|一系列从 0 到 9 的数字。 有关*fractional_digits*，但只数字 0 有效。|  
|*，*|区域性特定的组分隔符符号。 当前区域性的组分隔符可以出现在`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>标志。|  
|*.*|特定于区域性的小数点符号。 当前区域性的小数点符号可以出现在`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>标志。 仅数字 0 可以显示为分析操作才能成功; 一个小数数字如果*fractional_digits*包括任何其他数字<xref:System.FormatException>引发。|  
|E|"E"或者"E"字符，指示该值表示指数 （科学型） 表示法。 `value`参数可以表示指数记数法的数字，如果`style`包括<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>标志。|  
|*hexdigits*|一系列从 0 到 f 或从 0 到 F.的十六进制数字|  
  
 仅为数字的字符串 (它对应于<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>样式) 总是可以分析成功。 其余的大多数<xref:System.Globalization.NumberStyles>成员控件可能会存在，但不是需要为存在于输入字符串中的元素。 下表指示个别<xref:System.Globalization.NumberStyles>成员影响中可能存在的元素`value`。  
  
|`NumberStyles` 值|元素允许在`value`除数字之外|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*数字*仅元素。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小数点 （.） 和*小数位数*元素。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E"或"E"字符，它指示指数记数法，连同*exponential_digits*。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*起始处的元素`value`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*结尾的元素`value`。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*登录*起始处的元素`value`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*登录*结尾的元素`value`。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*登录*在括号内包含的数字值的窗体中的元素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|组分隔符 （，） 元素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|货币 （$） 元素中。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有元素。 但是，`value`不能表示十六进制数或指数记数法的数字。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*开头或末尾的元素`value`，*登录*开头的`value`，和小数点 (*。*) 符号。 `value`参数还可以使用指数记数法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`， `sign`，组分隔符 (*，*)，和小数点 (*。*) 元素。|  
|<xref:System.Globalization.NumberStyles.Any>|所有元素。 但是，`value`无法表示十六进制数字。|  
  
> [!IMPORTANT]
>  如果你使用<xref:System.Numerics.BigInteger.Parse%2A>保存/还原的字符串表示的方法的<xref:System.Numerics.BigInteger>已输出的值<xref:System.Numerics.BigInteger.ToString%2A>方法，则应使用<xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>使用"R"格式说明符生成的字符串表示形式的方法<xref:System.Numerics.BigInteger>值。 否则为的字符串表示形式<xref:System.Numerics.BigInteger>仅 50，最高有效位的原始值和数据可能会丢失，当你使用保留<xref:System.Numerics.BigInteger.Parse%2A>方法，使还原<xref:System.Numerics.BigInteger>值。  
  
 与其他不同<xref:System.Globalization.NumberStyles>值，该值允许，但不是需要，特定样式中的元素是否存在`value`、<xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>样式值意味着中的单个数字字符`value`总是被解释为十六进制字符。 有效的十六进制字符为 0-9、 A-F 和 a-f。 其他标志只有可以与组合`style`参数<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>。 (<xref:System.Globalization.NumberStyles>枚举包含复合数字样式， <xref:System.Globalization.NumberStyles.HexNumber>，其中包含两个空白标志。)  
  
> [!NOTE]
>  如果`value`是的字符串表示的十六进制数，则无法将前面添加的任何修饰符 (如`0x`或`&h`) 用于将其识别为十六进制数。 这将导致转换失败。  
  
 如果`value`是一个十六进制的字符串，<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>方法将解释`value`作为使用 2 的补数表示，其前两个十六进制数字是否大于或等于存储的负数`0x80`。 换而言之，此方法将解释中的第一个字节的最高顺序位`value`用作符号位。 若要确保十六进制字符串正确地解释为正数中的第一个数字`value`必须具有值为零。 例如，此方法将解释`0x80`为负值，但它解释`0x080`或`0x0080`为正值。 下面的示例演示了表示正负值的十六进制字符串之间的差异。  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 `value`通过使用中的格式设置信息分析参数<xref:System.Globalization.NumberFormatInfo>初始化针对当前系统区域性的对象。 若要指定分析操作使用其格式设置信息的区域性，调用<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>重载。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>具有几个可能值的方法`style`参数。 它阐释了如何将字符串解释为十六进制值，以及如何禁止空格和正负符号。  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
 或  
  
 <paramref name="style" /> 包括 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 或 <see cref="F:System.Globalization.NumberStyles.HexNumber" /> 标志以及另一个值。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> 不符合由 <see cref="T:System.Globalization.NumberStyles" /> 指定的输入模式。</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">包含要转换的数字的字符串。</param>
        <param name="provider">一个对象，提供有关 <c>value</c> 的区域性特定格式设置信息。</param>
        <summary>将指定的区域性特定格式的数字字符串表示形式转换为它的等效 <see cref="T:System.Numerics.BigInteger" />。</summary>
        <returns>一个值，等于 <paramref name="value" /> 参数中指定的数字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`参数应为以下形式的数字的字符串表示：  
  
 [*ws*][*sign*]*digits*[*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表描述每个元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|可选的空白区域。|  
|*sign*|一个可选符号后。 有效的符号字符由<xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType>属性<xref:System.Globalization.NumberFormatInfo>返回的对象`provider`对象的<xref:System.IFormatProvider.GetFormat%2A>方法。|  
|*digits*|范围从 0 到 9 的数字的序列。 忽略任何前导零。|  
  
> [!NOTE]
>  指定的字符串`value`参数被解释使用<xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType>样式。 不能包含任何组分隔符或小数分隔符，并且它不能具有小数部分。  
  
> [!IMPORTANT]
>  如果你使用<xref:System.Numerics.BigInteger.Parse%2A>保存/还原的字符串表示的方法的<xref:System.Numerics.BigInteger>已输出的值<xref:System.Numerics.BigInteger.ToString%2A>方法，则应使用<xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>使用"R"格式说明符生成的字符串表示形式的方法<xref:System.Numerics.BigInteger>值。 否则为的字符串表示形式<xref:System.Numerics.BigInteger>仅 50，最高有效位的原始值和数据可能会丢失，当你使用保留<xref:System.Numerics.BigInteger.Parse%2A>方法，使还原<xref:System.Numerics.BigInteger>值。  
  
 `provider`参数是<xref:System.IFormatProvider>实现其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.NumberFormatInfo>提供区域性特定格式设置信息的对象。 当<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29>调用方法时，它调用`provider`参数的<xref:System.IFormatProvider.GetFormat%2A>方法并将其传递<xref:System.Type>对象，表示<xref:System.Globalization.NumberFormatInfo>类型。 <xref:System.IFormatProvider.GetFormat%2A>方法然后返回<xref:System.Globalization.NumberFormatInfo>提供的格式有关的信息的对象`value`参数。 有三种方法使用`provider`参数来提供到分析操作的自定义格式设置信息：  
  
-   你可以将传递<xref:System.Globalization.CultureInfo>表示的区域性的提供格式设置信息的对象。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法返回<xref:System.Globalization.NumberFormatInfo>提供该区域性的数字格式设置信息的对象。  
  
-   你可以将传递的实际<xref:System.Globalization.NumberFormatInfo>提供数字格式设置信息的对象。 (其实现<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>仅返回它自身。)  
  
-   你可以传递的自定义对象，实现<xref:System.IFormatProvider>。 其<xref:System.IFormatProvider.GetFormat%2A>方法实例化，并返回<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`的格式`value`解释基于<xref:System.Globalization.NumberFormatInfo>当前区域性的对象。  
  
   
  
## Examples  
 下面的示例演示两种方法定义波形符 （~） 为负号的格式设置<xref:System.Numerics.BigInteger>值。 请注意，若要显示<xref:System.Numerics.BigInteger>对原始字符串的格式相同的值，你的代码必须调用<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法并将其传递<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。  
  
 第一个示例定义一个类以实现<xref:System.IFormatProvider>并使用<xref:System.IFormatProvider.GetFormat%2A>方法以返回<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 A<xref:System.Numerics.BigInteger>然后可以使用下面的代码实例化对象：  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 第二个示例是更简单。 它将传递<xref:System.Globalization.NumberFormatInfo>提供到的格式设置信息的对象`provider`参数。  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> 的格式不正确。</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">包含要转换的数字的字符串。</param>
        <param name="style">枚举值的按位组合，这些枚举值指定 <c>value</c> 所允许的格式。</param>
        <param name="provider">一个对象，提供有关 <c>value</c> 的区域性特定格式设置信息。</param>
        <summary>将指定样式和区域性特定格式的数字的字符串表示形式转换为它的等效 <see cref="T:System.Numerics.BigInteger" />。</summary>
        <returns>一个值，等于 <paramref name="value" /> 参数中指定的数字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style`参数定义中允许的样式元素 （如空格、 正整数或负号符号、 组分隔符符号或小数点符号）`value`分析操作成功的参数。 `styles` 必须是中的位标志的组合<xref:System.Globalization.NumberStyles>枚举。 `style`参数将使得此方法重载有用`value`时数字系统 （十进制或十六进制） 由包含的字符串表示形式的十六进制值，`value`仅在运行时，已知时，或者当你想要禁止的空白区域或正负符号`value`。  
  
 根据值`style`、`value`参数可能包括以下元素：  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[*.fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 如果`style`包括<xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>、`value`参数可能包括以下元素：  
  
 [*ws*]*hexdigits*[*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表描述每个元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|可选的空白区域。 空格可以出现在开始`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>标志，它可以出现在末尾`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>标志。|  
|*$*|特定于区域性的货币符号。 在字符串中的位置由<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType>区域性属性由`provider`参数。 当前区域性的货币符号可以出现在`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>标志。|  
|*sign*|一个可选符号后。 符号可以出现在开始`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>标志，它可以出现在末尾`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>标志。 可以在使用括号`value`以指示负值，如果`style`包括<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>标志。|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|一系列从 0 到 9 的数字。 有关*fractional_digits*，但只数字 0 有效。|  
|*，*|区域性特定的组分隔符符号。 指定的区域性组分隔符符号`provider`可以出现在`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>标志。|  
|*.*|特定于区域性的小数点符号。 指定的区域性的小数点符号`provider`可以出现在`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>标志。 仅数字 0 可以显示为分析操作才能成功; 一个小数数字如果*fractional_digits*包括任何其他数字<xref:System.FormatException>引发。|  
|E|"E"或者"E"字符，指示该值表示指数 （科学型） 表示法。 `value`参数可以表示指数记数法的数字，如果`style`包括<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>标志。|  
|*hexdigits*|一系列从 0 到 f 或从 0 到 F.的十六进制数字|  
  
 仅为数字的字符串 (它对应于<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>样式) 总是可以分析成功。 其余的大多数<xref:System.Globalization.NumberStyles>成员控件可能会存在，但不是需要为存在于输入字符串中的元素。 下表指示个别<xref:System.Globalization.NumberStyles>成员影响中可能存在的元素`value`。  
  
|NumberStyles 值|除数字之外的值中允许的元素|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*数字*仅元素。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小数点 （.） 和*小数位数*元素。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E"或者"E"字符，它指示指数记数法。 连同*exponential_digits*。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*起始处的元素`value`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*结尾的元素`value`。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*登录*起始处的元素`value`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*登录*结尾的元素`value`。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*登录*在括号内包含的数字值的窗体中的元素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|组分隔符 （，） 元素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|货币 （$） 元素中。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有元素。 但是，`value`不能表示十六进制数或指数记数法的数字。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*开头或末尾的元素`value`，*登录*开头的`value`，和小数点 （.） 符号。 `value`参数还可以使用指数记数法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`， `sign`，组分隔符 （、）、 和小数点 （.） 元素。|  
|<xref:System.Globalization.NumberStyles.Any>|所有元素。 但是，`value`无法表示十六进制数字。|  
  
> [!IMPORTANT]
>  如果你使用<xref:System.Numerics.BigInteger.Parse%2A>保存/还原的字符串表示的方法的<xref:System.Numerics.BigInteger>已输出的值<xref:System.Numerics.BigInteger.ToString%2A>方法，则应使用<xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>使用"R"格式说明符生成的字符串表示形式的方法<xref:System.Numerics.BigInteger>值。 否则为的字符串表示形式<xref:System.Numerics.BigInteger>仅 50，最高有效位的原始值和数据可能会丢失，当你使用保留<xref:System.Numerics.BigInteger.Parse%2A>方法，使还原<xref:System.Numerics.BigInteger>值。  
  
 与其他不同<xref:System.Globalization.NumberStyles>值，从而允许但不是需要特定样式中的元素是否存在`value`、<xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>样式值意味着中的单个数字字符`value`总是被解释为十六进制字符。 有效的十六进制字符为 0-9、 A-F 和 a-f。 其他标志只有可以与组合`style`参数<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>。 (<xref:System.Globalization.NumberStyles>枚举包含复合数字样式， <xref:System.Globalization.NumberStyles.HexNumber>，其中包含两个空白标志。)  
  
> [!NOTE]
>  如果`value`是的字符串表示的十六进制数，则无法将前面添加的任何修饰符 (如`0x`或`&h`) 用于将其识别为十六进制数。 这将导致转换失败。  
  
 如果`value`是一个十六进制的字符串，<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>方法将解释`value`作为使用 2 的补数表示，其前两个十六进制数字是否大于或等于存储的负数`0x80`。 换而言之，此方法将解释中的第一个字节的最高顺序位`value`用作符号位。 若要确保十六进制字符串正确地解释为正数中的第一个数字`value`必须具有值为零。 例如，此方法将解释`0x80`为负值，但它解释`0x080`或`0x0080`为正值。 下面的示例演示了表示正负值的十六进制字符串之间的差异。  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 `provider`参数是<xref:System.IFormatProvider>实现。 其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.NumberFormatInfo>对象，提供区域性特定信息的格式`value`。 通常情况下，`provider`可以是以下任何一个：  
  
-   A<xref:System.Globalization.CultureInfo>表示提供数字格式设置信息的区域性的对象。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法返回<xref:System.Globalization.NumberFormatInfo>提供数字格式设置信息的对象。  
  
-   A<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。 (其实现<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>仅返回它自身。)  
  
-   实现一个自定义对象<xref:System.IFormatProvider>并使用<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>方法实例化并返回<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`、<xref:System.Globalization.NumberFormatInfo>对象使用当前区域性的。  
  
   
  
## Examples  
 下面的示例执行几次调用到<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>方法使用的值的各种组合`style`和`provider`参数。  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 大量的单独调用<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>方法的以下实例传递`BigIntegerFormatProvider`类，该类为负号定义波形符 （~）。  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
 或  
  
 <paramref name="style" /> 包括 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 或 <see cref="F:System.Globalization.NumberStyles.HexNumber" /> 标志以及另一个值。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> 不符合由 <paramref name="style" /> 指定的输入模式。</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要计算 <c>exponent</c> 次幂的数字。</param>
        <param name="exponent">对 <c>value</c> 进行幂运算的指数。</param>
        <summary>求以 <see cref="T:System.Numerics.BigInteger" /> 值为底、以指定的值为指数的幂。</summary>
        <returns>
          <paramref name="value" /> 的 <paramref name="exponent" /> 次幂的计算结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Pow%2A>方法返回 1，如果指数参数的值为 0，或如果两者的值`value`和`exponent`参数均为 0。 如果`exponent`为 1，<xref:System.Numerics.BigInteger.Pow%2A>方法返回`value`。 如果`value`是负数，该方法返回负数的结果。  
  
 此方法对应于<xref:System.Math.Pow%2A?displayProperty=nameWithType>基元数值类型的方法。  
  
   
  
## Examples  
 下面的示例演示如何使用求幂<xref:System.Numerics.BigInteger>值，其值范围从 0 到 10 的指数。  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="exponent" /> 参数的值为负。</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">要作为被除数的值。</param>
        <param name="divisor">要作为除数的值。</param>
        <summary>对两个 <see cref="T:System.Numerics.BigInteger" /> 值执行整除并返回余数。</summary>
        <returns>将 <paramref name="dividend" /> 除以 <paramref name="divisor" /> 后的余数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 余数的符号是的迹象`dividend`参数。  
  
 <xref:System.Numerics.BigInteger.Remainder%2A>会为不支持自定义运算符的语言实现方法。 其行为等同于使用取模运算符的除法。  
  
 如果有必要，该方法会自动执行到其他整数类型的隐式转换<xref:System.Numerics.BigInteger>对象执行取模运算之前。  
  
   
  
## Examples  
 下面的示例比较的余数<xref:System.Numerics.BigInteger.DivRem%2A>方法而返回的其余部分<xref:System.Numerics.BigInteger.Remainder%2A>方法来建立两个方法计算相同的余数。  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> 是 0（零）。</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个数字，该数字指示当前 <see cref="T:System.Numerics.BigInteger" /> 对象的符号（负、正或零）。</summary>
        <value>一个指示 <see cref="T:System.Numerics.BigInteger" /> 对象的符号的数字，如下表所示。  
  
 <list type="table"><listheader><term> 数  
  
 </term><description> 描述  
  
 </description></listheader><item><term> -1  
  
 </term><description> 此对象的值为负。  
  
 </description></item><item><term> 0  
  
 </term><description> 此对象的值为 0 （零）。  
  
 </description></item><item><term> 1  
  
 </term><description> 此对象的值为正。  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Sign%2A>属性等效于<xref:System.Math.Sign%2A?displayProperty=nameWithType>基元数值类型的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">要从中减去的值（被减数）。</param>
        <param name="right">要减去的值（减数）。</param>
        <summary>从另一个值中减去一个 <see cref="T:System.Numerics.BigInteger" /> 值并返回结果。</summary>
        <returns>
          <paramref name="right" /> 减 <paramref name="left" /> 所得的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不支持自定义运算符的语言可以使用<xref:System.Numerics.BigInteger.Subtract%2A>方法来执行减法使用<xref:System.Numerics.BigInteger>值。  
  
 <xref:System.Numerics.BigInteger.Subtract%2A>实例化时，方法是减法运算符有用替代<xref:System.Numerics.BigInteger>变量中将其分配相减、 得到的结果的差异，如下面的示例中所示。  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将 <see cref="T:System.Numerics.BigInteger" /> 值转换为字节数组。</summary>
        <returns>转换为字节数组的当前 <see cref="T:System.Numerics.BigInteger" /> 对象的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的数组中的各个字节出现在 little-endian 的顺序。 也就是说，值较低序位字节先于更高序位字节。 数组的第一个字节反映前八位<xref:System.Numerics.BigInteger>值，第二个字节反映了下一步的八位，依次类推。 例如，值 1024 或 0x0400 存储为以下两个字节的数组：  
  
|元素|字节值|  
|-------------|----------------|  
|0|0x00|  
|1|0x04|  
  
 负值写入到数组中的最精简的窗体可能使用 2 的补数表示。 例如，-1 表示为一个字节，其值是`0xFF`而不是作为数组与多个元素，如`0xFF`，`0xFF`或`0xFF`， `0xFF`， `0xFF`， `0xFF`。  
  
 因为 2 的补数表示形式始终解释数组中的最后一个字节的最高顺序位 (处位置的字节<xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) 用作符号位，该方法返回具有额外的元素，其值为零的字节数组到消除歧义否则无法解释为具有设置其符号位的正值。 例如，值 120 或`0x78`表示为单字节的数组： `0x78`。 但是，128 或`0x80`，表示为两个字节的数组： `0x80`， `0x00`。  
  
 你可以往返<xref:System.Numerics.BigInteger>值将它存储为字节数组，然后将其使用还原<xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>构造函数。  
  
> [!CAUTION]
>  如果你的代码修改它还原的值之前，此方法返回的数组内的单个字节值，则必须确保不要无意中更改符号位。 例如，如果您的修改，以便最高顺序位的字节数组的最后一个元素中增加是正数值成为集，则可以添加其值为 0 到数组末尾的新字节。  
  
   
  
## Examples  
 下面的示例演示如何某些<xref:System.Numerics.BigInteger>值以字节数组表示。  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将当前 <see cref="T:System.Numerics.BigInteger" /> 对象的数值转换为其等效字符串表示形式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.Numerics.BigInteger" /> 对象的数值转换为其等效字符串表示形式。</summary>
        <returns>当前 <see cref="T:System.Numerics.BigInteger" /> 值的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString>方法格式<xref:System.Numerics.BigInteger>"R"或往返，当前区域性的格式中的值。 如果你想要指定其他文件格式或区域性，使用的其他重载<xref:System.Numerics.BigInteger.ToString%2A>方法，如下所示：  
  
|若要使用格式|区域性|使用的重载|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") 格式|特定区域性|<xref:System.Numerics.BigInteger.ToString%2A>|  
|特定的格式|默认值 （当前） 区域性|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|特定的格式|特定区域性|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 字符串表示形式<xref:System.Numerics.BigInteger>值包括一个负号，如果其值为负数，且一系列的范围从 0 到 9，不带前导零的数字。 负号由<xref:System.Globalization.NumberFormatInfo>为当前区域性的对象。  
  
   
  
## Examples  
 下面的示例显示<xref:System.Numerics.BigInteger>通过使用默认值<xref:System.Numerics.BigInteger.ToString>方法。 它还显示的字符串表示形式<xref:System.Numerics.BigInteger>通过使用某些标准格式说明符得到的值。 示例使用 EN-US 区域性的格式设置约定来显示。  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <summary>使用指定的区域性特定格式设置信息将当前 <see cref="T:System.Numerics.BigInteger" /> 对象的数值转换为它的等效字符串表示形式。</summary>
        <returns>当前 <see cref="T:System.Numerics.BigInteger" /> 值的字符串表示形式，该值使用 <paramref name="provider" /> 参数指定的格式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>方法格式<xref:System.Numerics.BigInteger>值中的"R"，或往返中，使用来格式化<xref:System.Globalization.NumberFormatInfo>指定区域性的对象。 如果你想要指定不同的格式或当前区域性，使用的其他重载<xref:System.Numerics.BigInteger.ToString%2A>方法，如下所示：  
  
|若要使用格式|区域性|使用的重载|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") 格式|默认值 （当前） 区域性|<xref:System.Numerics.BigInteger.ToString>|  
|特定的格式|默认值 （当前） 区域性|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|特定的格式|特定区域性|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 `provider`参数是<xref:System.IFormatProvider>实现。 其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.NumberFormatInfo>提供此方法返回的字符串的格式的区域性特定信息的对象。 如果`provider`是`null`、<xref:System.Numerics.BigInteger>值的格式使用<xref:System.Globalization.NumberFormatInfo>当前区域性的对象。 唯一属性<xref:System.Globalization.NumberFormatInfo>控制的字符串表示形式的对象<xref:System.Numerics.BigInteger>使用常规格式说明符的值是<xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>，它定义表示负号的字符。  
  
 `provider`参数可以是以下之一：  
  
-   A<xref:System.Globalization.CultureInfo>表示的区域性的提供格式设置信息的对象。  
  
-   <xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。  
  
-   实现一个自定义对象<xref:System.IFormatProvider>。 其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。  
  
   
  
## Examples  
 下面的示例实例化自定义<xref:System.Globalization.NumberFormatInfo>波形符 （~） 定义为负号的对象。 <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>方法然后使用自定义<xref:System.Globalization.NumberFormatInfo>对象来显示一个负<xref:System.Numerics.BigInteger>值。  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">标准或自定义的数值格式字符串。</param>
        <summary>使用指定的格式将当前 <see cref="T:System.Numerics.BigInteger" /> 对象的数值转换为它的等效字符串表示形式。</summary>
        <returns>当前 <see cref="T:System.Numerics.BigInteger" /> 值的字符串表示形式，该值使用 <paramref name="format" /> 参数指定的格式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.String%29>方法格式<xref:System.Numerics.BigInteger>中通过使用指定的格式值<xref:System.Globalization.NumberFormatInfo>对象，表示当前区域性的约定。 如果你想要使用"R"或往返，格式或指定不同的区域性，请使用其他重载的<xref:System.Numerics.BigInteger.ToString%2A>方法，如下所示：  
  
|若要使用格式|区域性|使用的重载|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") 格式|默认值 （当前） 区域性|<xref:System.Numerics.BigInteger.ToString>|  
|Round-trip ("R") 格式|特定区域性|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|特定的格式|特定区域性|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 `format`参数可以是任何有效[标准数字字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)，或的任意组合[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 如果`format`等同于<xref:System.String.Empty?displayProperty=nameWithType>或`null`，当前的返回值<xref:System.Numerics.BigInteger>对象使用往返过程格式说明符 ("R") 进行格式化。 如果`format`是任何其他值，该方法将引发<xref:System.FormatException>。  
  
 .NET Framework 提供了广泛的格式设置支持，以下的格式设置主题中的更详细地介绍：  
  
-   有关数字格式说明符的详细信息，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   有关.NET Framework 中的格式设置支持的详细信息，请参阅[格式化类型](~/docs/standard/base-types/formatting-types.md)。  
  
 返回字符串的格式由<xref:System.Globalization.NumberFormatInfo>为当前区域性的对象。 具体取决于`format`参数，此对象控制输出字符串中的负号、 组分隔符和小数点符号等符号。 若要提供区域性而非当前区域性的格式设置信息，请调用<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>重载。  
  
   
  
## Examples  
 下面的示例初始化<xref:System.Numerics.BigInteger>值并将其显示通过使用每个标准格式字符串和某些自定义格式字符串。  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 不是有效的格式字符串。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">标准或自定义的数值格式字符串。</param>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <summary>使用指定的格式和区域性特定格式信息将当前 <see cref="T:System.Numerics.BigInteger" /> 对象的数值转换为它的等效字符串表示形式。</summary>
        <returns>由 <paramref name="format" /> 和 <paramref name="provider" /> 参数指定的当前 <see cref="T:System.Numerics.BigInteger" /> 值的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>方法格式<xref:System.Numerics.BigInteger>中通过使用指定的格式值<xref:System.Globalization.NumberFormatInfo>指定区域性的对象。 如果你想要使用的往返格式或默认区域性设置，使用的其他重载<xref:System.Numerics.BigInteger.ToString%2A>方法，如下所示：  
  
|若要使用格式|区域性|使用的重载|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") 格式|默认值 （当前） 区域性|<xref:System.Numerics.BigInteger.ToString>|  
|Round-trip ("R") 格式|特定区域性|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|特定的格式|默认值 （当前） 区域性|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 `format`参数可以是任何有效[标准数字字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)，或的任意组合[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 如果`format`等同于<xref:System.String.Empty?displayProperty=nameWithType>或`null`，当前的返回值<xref:System.Numerics.BigInteger>对象使用往返过程格式说明符 ("R") 进行格式化。 如果`format`是任何其他值，该方法将引发<xref:System.FormatException>。  
  
 .NET Framework 提供了广泛的格式设置支持，以下的格式设置主题中的更详细地介绍：  
  
-   有关数字格式说明符的详细信息，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   有关.NET Framework 中的格式设置支持的详细信息，请参阅[格式化类型](~/docs/standard/base-types/formatting-types.md)。  
  
 `provider`参数是<xref:System.IFormatProvider>实现。 其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.NumberFormatInfo>提供此方法返回的字符串的格式的区域性特定信息的对象。 当<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>调用方法时，它调用`provider`参数的<xref:System.IFormatProvider.GetFormat%2A>方法并将其传递<xref:System.Type>对象，表示<xref:System.Globalization.NumberFormatInfo>类型。 <xref:System.IFormatProvider.GetFormat%2A>方法然后返回<xref:System.Globalization.NumberFormatInfo>提供的格式设置信息的对象`value`参数，如负号符号、 组分隔符符号或小数点符号。 有三种方法使用`provider`参数来提供到的格式设置信息<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>方法：  
  
-   你可以将传递<xref:System.Globalization.CultureInfo>表示的区域性的提供格式设置信息的对象。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法返回<xref:System.Globalization.NumberFormatInfo>提供该区域性的数字格式设置信息的对象。  
  
-   你可以将传递的实际<xref:System.Globalization.NumberFormatInfo>提供数字格式设置信息的对象。 (其实现<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>仅返回它自身。)  
  
-   你可以传递的自定义对象，实现<xref:System.IFormatProvider>。 其<xref:System.IFormatProvider.GetFormat%2A>方法实例化，并返回<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`，返回字符串的格式设置将基于<xref:System.Globalization.NumberFormatInfo>当前区域性的对象。  
  
   
  
## Examples  
 下面的示例初始化<xref:System.Numerics.BigInteger>值，并将其显示到控制台中使用标准格式字符串和<xref:System.Globalization.NumberFormatInfo>波形符 （~） 定义为负号的对象。  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 不是有效的格式字符串。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>尝试将数字的字符串表示形式转换为它的等效 <see cref="T:System.Numerics.BigInteger" />，并返回一个指示转换是否成功的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">数字的字符串表示形式。</param>
        <param name="result">当此方法返回时，包含与 <c>value</c> 中所包含的数字等效的<see cref="T:System.Numerics.BigInteger" />；如果转换失败，则包含零 (0)。 如果 <c>value</c> 参数为 <see langword="null" /> 或格式不正确，则转换失败。 此参数未经初始化即被传递。</param>
        <summary>尝试将数字的字符串表示形式转换为它的等效 <see cref="T:System.Numerics.BigInteger" />，并返回一个指示转换是否成功的值。</summary>
        <returns>
          如果 <see langword="true" /> 成功转换，则为 <paramref name="value" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29>方法就像是<xref:System.Numerics.BigInteger.Parse%28System.String%29>方法，但它不会引发异常，如果转换失败。 此方法无需使用异常处理来测试是否<xref:System.FormatException>如果`value`无效，无法成功分析。  
  
 `value`参数应为以下形式的十进制数字的字符串表示：  
  
 [*ws*][*sign*]*digits*[*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表描述每个元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|可选的空白区域。|  
|*sign*|一个可选符号后。 有效的符号字符由<xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType>当前区域性的属性。|  
|*digits*|范围从 0 到 9 的十进制数字的序列。|  
  
> [!NOTE]
>  指定的字符串`value`参数不能包含任何组分隔符或小数分隔符，并且它不能具有小数部分。  
  
 `value`参数解释使用<xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType>样式。 十进制数字，除了允许仅前导空格和尾随空格带有前导符号。 若要显式定义可出现在的区域性特定格式设置信息的样式元素`value`，调用<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>方法。  
  
 `value`通过使用中的格式设置信息分析参数<xref:System.Globalization.NumberFormatInfo>为当前区域性的对象。 有关详情，请参阅<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>。  
  
 此重载将解释中的所有位`value`为十进制数字的参数。 若要分析的字符串表示形式的十六进制数，请调用<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>重载。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29>方法可实例化两个<xref:System.Numerics.BigInteger>对象。 如果转换成功，它将乘以每个对象由另一个数，然后调用<xref:System.Numerics.BigInteger.Compare%2A>方法来确定两个对象之间的关系。  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">数字的字符串表示形式。 该字符串使用由 <c>style</c> 指定的样式来进行解释。</param>
        <param name="style">枚举值的按位组合，用于指示可出现在 <c>value</c> 中的样式元素。 要指定的一个典型值为 <see cref="F:System.Globalization.NumberStyles.Integer" />。</param>
        <param name="provider">一个对象，提供有关 <c>value</c> 的区域性特定格式设置信息。</param>
        <param name="result">当此方法返回时，包含与 <c>value</c> 中所包含的数字等效的 <see cref="T:System.Numerics.BigInteger" />；如果转换失败，则包含 <see cref="P:System.Numerics.BigInteger.Zero" />。 如果 <c>value</c> 参数为 <see langword="null" /> 或其格式不符合 <c>style</c>，则转换失败。 此参数未经初始化即被传递。</param>
        <summary>尝试将指定样式和区域性特定格式的数字的字符串表示形式转换为其 <see cref="T:System.Numerics.BigInteger" /> 等效项，并返回一个指示转换是否成功的值。</summary>
        <returns>
          如果 <paramref name="value" /> 参数成功转换，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>方法就像是<xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>方法，但它不会引发异常，如果转换失败。 此方法无需使用异常处理来测试是否<xref:System.FormatException>如果`value`无效，无法成功分析。  
  
 `style`参数定义中允许的样式元素 （如空白或正整数或负号）`value`分析操作成功的参数。 它必须是中的位标志的组合<xref:System.Globalization.NumberStyles>枚举。 根据值`style`、`value`参数可能包括以下元素：  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 如果`style`参数包含<xref:System.Globalization.NumberStyles.AllowHexSpecifier>、`value`参数可能包括以下元素：  
  
 [*ws*]*hexdigits*[*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表描述每个元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|可选的空白区域。 空格可以出现在开始`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>标志，或在末尾`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>标志。|  
|*$*|特定于区域性的货币符号。 在字符串中的位置由<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A>属性<xref:System.Globalization.NumberFormatInfo>返回对象<xref:System.IFormatProvider.GetFormat%2A>方法`provider`参数。 货币符号可以出现在`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>标志。|  
|*sign*|一个可选符号后。 符号可以出现在开始`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>标志，它可以出现在末尾`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>标志。 可以在使用括号`value`以指示负值，如果`style`包括<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>标志。|  
|*digits*|一系列从 0 到 9 的数字。|  
|*，*|特定于区域性的组分隔符。 指定的区域性的组分隔符`provider`可以出现在`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>标志。|  
|*.*|特定于区域性的小数点符号。 指定的区域性的小数点符号`provider`可以出现在`value`如果`style`包括<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>标志。|  
|*fractional_digits*|数字 0 的一个或多个匹配项。 小数位数可以出现在`value`才`style`包括<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>标志。|  
|E|"E"或者"E"字符，指示该值表示指数 （科学型） 表示法。 `value`参数可以表示指数记数法的数字，如果`style`包括<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>标志。|  
|*exponential_digits*|一系列从 0 到 9 的数字。 `value`参数可以表示指数记数法的数字，如果`style`包括<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>标志。|  
|*hexdigits*|一系列从 0 到 f 或从 0 到 F.的十六进制数字|  
  
 仅为十进制数字的字符串 (它对应于<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>标志) 总是可以分析成功。 其余的大多数<xref:System.Globalization.NumberStyles>成员控件可能会存在，但不是要求必须存在，此输入字符串中的元素。 下表指示个别<xref:System.Globalization.NumberStyles>成员影响中可能存在的元素`value`。  
  
|非复合`NumberStyles`值|除数字之外的值中允许的元素|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|仅为十进制数字。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小数点 (*。*) 和*fractional_digits*元素。 但是， *fractional_digits*仅一个或多个数字 0 或该方法将返回必须组成`false`。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E"或"E"字符，它指示指数记数法，连同*exponential_digits*。 如果`value`表示的数字在指数记数法，它不能有非零、 小数组件。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*起始处的元素`value`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*结尾的元素`value`。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*登录*元素之前*数字*。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*登录*元素的后面*数字*。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*登录*在括号内包含的数字值的窗体中的元素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|组分隔符 (*，*) 元素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|货币 (*$*) 元素。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有元素。 但是，`value`不能表示十六进制数或指数记数法的数字。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*开头或末尾的元素`value`，*登录*开头的`value`，和小数点 (*。*) 符号。 `value`参数还可以使用指数记数法。|  
|<xref:System.Globalization.NumberStyles.Number>|*Ws*，*登录*，组分隔符 (*，*)，和小数点 (*。*) 元素。|  
|<xref:System.Globalization.NumberStyles.Any>|所有元素。 但是，`value`无法表示十六进制数字。|  
  
> [!IMPORTANT]
>  如果你使用<xref:System.Numerics.BigInteger.TryParse%2A>保存/还原的字符串表示的方法的<xref:System.Numerics.BigInteger>已输出的值<xref:System.Numerics.BigInteger.ToString%2A>方法，则应使用<xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>使用"R"格式说明符生成的字符串表示形式的方法<xref:System.Numerics.BigInteger>值。 否则为的字符串表示形式<xref:System.Numerics.BigInteger>仅 50，最高有效位的原始值和数据可能会丢失，当你使用保留<xref:System.Numerics.BigInteger.TryParse%2A>方法，使还原<xref:System.Numerics.BigInteger>值。  
  
 如果<xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>使用标志，`value`必须是十六进制值。 仅其他标志可出现在`style`是<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>。 (<xref:System.Globalization.NumberStyles>枚举具有复合样式， <xref:System.Globalization.NumberStyles.HexNumber>，其中包含两个空白标志。)  
  
> [!NOTE]
>  如果`value`是的字符串表示的十六进制数，则无法将前面添加的任何修饰符 (如`0x`或`&h`) 用于将其识别为十六进制数。 这将导致转换失败。  
  
 如果`value`是一个十六进制的字符串，<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>方法将解释`value`作为使用 2 的补数表示，其前两个十六进制数字是否大于或等于存储的负数`0x80`。 换而言之，此方法将解释中的第一个字节的最高顺序位`value`用作符号位。 若要确保十六进制字符串正确地解释为正数中的第一个数字`value`必须具有值为零。 例如，此方法将解释`0x80`为负值，但它解释`0x080`或`0x0080`为正值。 下面的示例演示了表示正负值的十六进制字符串之间的差异。  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 `provider`参数是<xref:System.IFormatProvider>实现。 其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.NumberFormatInfo>对象，提供区域性特定信息的格式`value`。 `provider`参数可以是以下任何一个：  
  
-   A<xref:System.Globalization.CultureInfo>表示的区域性的提供格式设置信息的对象。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法返回<xref:System.Globalization.NumberFormatInfo>提供该区域性的数字格式设置信息的对象。  
  
-   A<xref:System.Globalization.NumberFormatInfo>提供数字格式设置信息的对象。 (其实现<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>仅返回它自身。)  
  
-   实现一个自定义对象<xref:System.IFormatProvider>。 其<xref:System.IFormatProvider.GetFormat%2A>方法实例化，并返回<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`、<xref:System.Globalization.NumberFormatInfo>对象使用当前区域性的。  
  
   
  
## Examples  
 下面的示例调用某些<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>方法使用的值的各种组合`style`和`provider`参数。  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 大量的单独调用<xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>方法的以下实例传递`BigIntegerFormatProvider`类，该类为负号定义波形符 （~）。  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
 或  
  
 <paramref name="style" /> 包括 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 或 <see cref="F:System.Globalization.NumberStyles.HexNumber" /> 标志以及另一个值。</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个表示数字 0（零）的值。</summary>
        <value>其值为 0（零）的整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger>此属性返回的对象提供方便的来源的零值在赋值和比较中使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>