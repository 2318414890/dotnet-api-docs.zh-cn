<Type Name="Complex" FullName="System.Numerics.Complex">
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="166d8-101">表示一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-101">Represents a complex number.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-102">一个复数是一个数字就会包含实数部分和虚数部分。</span><span class="sxs-lookup"><span data-stu-id="166d8-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="166d8-103">在窗体 z 通常编写复数 z = x + 彝语，其中*x*和*y*为实数，和*我*是具有属性的虚单元*i*<sup>2</sup> =-1。</span><span class="sxs-lookup"><span data-stu-id="166d8-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="166d8-104">由表示复数的实部*x*，并且由表示复数的虚部*y*。</span><span class="sxs-lookup"><span data-stu-id="166d8-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="166d8-105"><xref:System.Numerics.Complex>类型使用笛卡尔坐标系统 （实数，虚数） 时实例化和操作的复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="166d8-106">复数可以表示为一个二维的坐标系统，这被称为复平面中的点。</span><span class="sxs-lookup"><span data-stu-id="166d8-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="166d8-107">复数的实部位于 x 轴 （水平轴），并在 y 轴 （垂直轴） 上定位的虚部。</span><span class="sxs-lookup"><span data-stu-id="166d8-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="166d8-108">此外可以使用极坐标图坐标系统，在极坐标基于其绝对值的数值，表示复平面中的任何点，两个数字的特征是一个点：</span><span class="sxs-lookup"><span data-stu-id="166d8-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system., In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="166d8-109">其量值，该值是从原点的点的距离 （即，0，0 或从该处 x 轴和 y 轴相交的点）。</span><span class="sxs-lookup"><span data-stu-id="166d8-109">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="166d8-110">其阶段，是指真实的轴和从原点绘制到点行之间的角度。</span><span class="sxs-lookup"><span data-stu-id="166d8-110">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="166d8-111">实例化一个复杂的数字</span><span class="sxs-lookup"><span data-stu-id="166d8-111">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="166d8-112">通过以下方式之一，可以将值分配给一个复杂的数字：</span><span class="sxs-lookup"><span data-stu-id="166d8-112">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="166d8-113">通过将两个传递<xref:System.Double>给其构造函数的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-113">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="166d8-114">第一个值表示复数的实部，第二个值表示的虚数部分。</span><span class="sxs-lookup"><span data-stu-id="166d8-114">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="166d8-115">这些值表示复数的二维笛卡尔坐标系统中的位置。</span><span class="sxs-lookup"><span data-stu-id="166d8-115">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="166d8-116">通过调用静态 (`Shared`在 Visual Basic 中)<xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>方法从其极坐标创建复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-116">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="166d8-117">通过分配<xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>， <xref:System.Single>，或<xref:System.Double>值赋给<xref:System.Numerics.Complex>对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-117">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="166d8-118">值将成为复数的实部，并且其虚数部分等于 0。</span><span class="sxs-lookup"><span data-stu-id="166d8-118">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="166d8-119">通过强制转换 （在 C# 中) 或转换 （在 Visual Basic 中)<xref:System.Decimal>或<xref:System.Numerics.BigInteger>值赋给<xref:System.Numerics.Complex>对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-119">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="166d8-120">值将成为复数的实部，并且其虚数部分等于 0。</span><span class="sxs-lookup"><span data-stu-id="166d8-120">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="166d8-121">通过分配由方法或运算符返回的复数<xref:System.Numerics.Complex>对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-121">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="166d8-122">例如，<xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType>是返回之和的两个复数的复数的静态方法和<xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType>运算符添加两个复数并返回结果。</span><span class="sxs-lookup"><span data-stu-id="166d8-122">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="166d8-123">下面的示例演示每个值分配到复数的这些五种方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-123">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="166d8-124">复数的操作</span><span class="sxs-lookup"><span data-stu-id="166d8-124">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="166d8-125"><xref:System.Numerics.Complex> .NET Framework 中的结构包含提供以下功能的成员：</span><span class="sxs-lookup"><span data-stu-id="166d8-125">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="166d8-126">要比较两个复数相加，以确定它们是否相等的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-126">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="166d8-127">若要执行复杂数字的算术运算的运算符。</span><span class="sxs-lookup"><span data-stu-id="166d8-127">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="166d8-128"><xref:System.Numerics.Complex> 运算符，可执行加法、 减法、 乘法、 除法和复数的一元求反。</span><span class="sxs-lookup"><span data-stu-id="166d8-128"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="166d8-129">若要执行复杂数字的其他数字操作的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-129">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="166d8-130">除了四个基本算术运算，你可以引发的指定幂的复数，一个复数的平方根并获取复数的绝对值的数值。</span><span class="sxs-lookup"><span data-stu-id="166d8-130">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="166d8-131">执行对复数的三角运算的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-131">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="166d8-132">例如，可以计算由一个复杂的数字表示的角度的正切值。</span><span class="sxs-lookup"><span data-stu-id="166d8-132">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="166d8-133">请注意，因为<xref:System.Numerics.Complex.Real%2A>和<xref:System.Numerics.Complex.Imaginary%2A>属性是只读的不能修改的现有值<xref:System.Numerics.Complex>对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-133">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="166d8-134">在执行操作的所有方法<xref:System.Numerics.Complex>其编号为，如果其返回值的类型是<xref:System.Numerics.Complex>，返回一个新<xref:System.Numerics.Complex>数。</span><span class="sxs-lookup"><span data-stu-id="166d8-134">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="166d8-135">精度和复数</span><span class="sxs-lookup"><span data-stu-id="166d8-135">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="166d8-136">由两个双精度浮点值表示复数的实部和虚部组成部分。</span><span class="sxs-lookup"><span data-stu-id="166d8-136">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="166d8-137">这意味着，<xref:System.Numerics.Complex>的值，如双精度浮点值，可能会丢失精度数字操作后的。</span><span class="sxs-lookup"><span data-stu-id="166d8-137">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="166d8-138">这意味着，严格比较是否相等的两个<xref:System.Numerics.Complex>值可能会失败，即使两个值之间的差异是由于精度损失。</span><span class="sxs-lookup"><span data-stu-id="166d8-138">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="166d8-139">有关详情，请参阅<xref:System.Double>。</span><span class="sxs-lookup"><span data-stu-id="166d8-139">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="166d8-140">例如，数字的对数求幂应返回原始的数量。</span><span class="sxs-lookup"><span data-stu-id="166d8-140">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="166d8-141">但是，在某些情况下，浮点值的精度丢失可能导致细微差异的两个值，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="166d8-141">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="166d8-142">同样，下面的示例中计算的平方根<xref:System.Numerics.Complex>编号，在 32 位和 IA64 版本的.NET Framework 上产生略有不同的结果。</span><span class="sxs-lookup"><span data-stu-id="166d8-142">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="166d8-143">复数、 无穷大和 NaN</span><span class="sxs-lookup"><span data-stu-id="166d8-143">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="166d8-144">由表示复数的实部和虚部组成部分<xref:System.Double>值。</span><span class="sxs-lookup"><span data-stu-id="166d8-144">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="166d8-145">除了从<xref:System.Double.MinValue?displayProperty=nameWithType>到<xref:System.Double.MaxValue?displayProperty=nameWithType>，复数的实部或虚部部分可以具有的值<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>， <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>，或<xref:System.Double.NaN?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-145">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="166d8-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType><xref:System.Double.NegativeInfinity?displayProperty=nameWithType>，和<xref:System.Double.NaN?displayProperty=nameWithType>所有传播中任何算术或三角运算。</span><span class="sxs-lookup"><span data-stu-id="166d8-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="166d8-147">在下面的示例中，被除<xref:System.Numerics.Complex.Zero>会生成一个复数，其实部和虚部的复数都<xref:System.Double.NaN?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-147">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="166d8-148">因此，执行乘法的此值还将生成一个复数，其实部和虚部的复数是<xref:System.Double.NaN?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-148">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="166d8-149">同样，执行溢出的范围乘法<xref:System.Double>生成类型的复数的实部<xref:System.Double.NaN?displayProperty=nameWithType>和其虚数部分是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-149">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="166d8-150">随后执行使用此复数的除法将返回复数的实部<xref:System.Double.NaN?displayProperty=nameWithType>和其虚数部分是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-150">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="166d8-151">使用无效或溢出的范围的复数的数学运算<xref:System.Double>数据类型不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="166d8-151">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="166d8-152">相反，它们返回<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>， <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>，或<xref:System.Double.NaN?displayProperty=nameWithType>以下情况下：</span><span class="sxs-lookup"><span data-stu-id="166d8-152">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="166d8-153">相除的正数零返回<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-153">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="166d8-154">溢出的上限的任何操作<xref:System.Double>数据类型返回<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-154">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="166d8-155">相除的零返回负数<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-155">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="166d8-156">溢出零下限的任何操作<xref:System.Double>数据类型返回<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-156">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="166d8-157">零被零的除法运算返回<xref:System.Double.NaN?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-157">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="166d8-158">将对其值是的操作数执行任何操作<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>， <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>，或<xref:System.Double.NaN?displayProperty=nameWithType>返回<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>， <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>，或<xref:System.Double.NaN?displayProperty=nameWithType>，取决于特定操作。</span><span class="sxs-lookup"><span data-stu-id="166d8-158">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="166d8-159">请注意，这适用于执行的方法的任何中间计算。</span><span class="sxs-lookup"><span data-stu-id="166d8-159">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="166d8-160">例如的乘法`new Complex(9e308, 9e308) and new Complex(2.5, 3.5)`使用公式 (ac-bd) + （ad + bc） 我。</span><span class="sxs-lookup"><span data-stu-id="166d8-160">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="166d8-161">乘法运算生成的实分量的计算的计算结果表达式 9e308 * 2.5-9e308 * 3.5。</span><span class="sxs-lookup"><span data-stu-id="166d8-161">The calculation of the real component that results from the multiplication evaluates the expression 9e308 * 2.5 - 9e308 * 3.5.</span></span> <span data-ttu-id="166d8-162">此表达式中的每个中间乘法返回<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>，并尝试减去<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>从<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>返回<xref:System.Double.NaN?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-162">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="166d8-163">格式设置一个复杂的数字</span><span class="sxs-lookup"><span data-stu-id="166d8-163">Formatting a Complex Number</span></span>  
 <span data-ttu-id="166d8-164">默认情况下，一个复杂的数字的字符串表示形式`(`*实际*`,` *虚部*`)`，其中*实际*和*虚部*是字符串表示形式<xref:System.Double>形成复数的实部和虚部组件的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-164">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="166d8-165">某些重载<xref:System.Numerics.Complex.ToString%2A>方法允许自定义的字符串表示形式这些<xref:System.Double>以反映特定区域性的格式设置约定，或显示在定义的标准或自定义数字特定格式的值格式字符串。</span><span class="sxs-lookup"><span data-stu-id="166d8-165">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="166d8-166">(有关详细信息，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。)</span><span class="sxs-lookup"><span data-stu-id="166d8-166">(For more information, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
 <span data-ttu-id="166d8-167">一个更常见的方法来表示一个复杂的数字的字符串表示形式 a + bi，其中是复数的实部，而 b 是复数的虚部。</span><span class="sxs-lookup"><span data-stu-id="166d8-167">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="166d8-168">在电气工程复数通常表示为 + bj。</span><span class="sxs-lookup"><span data-stu-id="166d8-168">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="166d8-169">你可以在这两种形式之一返回一个复杂的数字的字符串表示。</span><span class="sxs-lookup"><span data-stu-id="166d8-169">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="166d8-170">若要执行此操作，定义自定义格式提供程序通过实现<xref:System.ICustomFormatter>和<xref:System.IFormatProvider>接口，然后调用<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-170">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="166d8-171">下面的示例定义`ComplexFormatter`的格式的字符串表示一个复数的类 a + bi 或 + bj。</span><span class="sxs-lookup"><span data-stu-id="166d8-171">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="166d8-172">下面的示例然后使用此自定义格式化程序来显示一个复杂的数字的字符串表示。</span><span class="sxs-lookup"><span data-stu-id="166d8-172">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real"><span data-ttu-id="166d8-173">复数的实部。</span><span class="sxs-lookup"><span data-stu-id="166d8-173">The real part of the complex number.</span></span></param>
        <param name="imaginary"><span data-ttu-id="166d8-174">复数的虚部。</span><span class="sxs-lookup"><span data-stu-id="166d8-174">The imaginary part of the complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-175">使用指定的实数值和虚数值初始化 <see cref="T:System.Numerics.Complex" /> 结构的新实例。</span><span class="sxs-lookup"><span data-stu-id="166d8-175">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-176">`real`或`imaginary`它们是否需要显式转换为数据类型，自变量可能会丢失精度<xref:System.Double>。</span><span class="sxs-lookup"><span data-stu-id="166d8-176">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-177">下面的示例实例化两个复数相加，，，然后在加法、 减法、 乘法和除法操作中使用它们。</span><span class="sxs-lookup"><span data-stu-id="166d8-177">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-178">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-178">A complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-179">获取复数的绝对值（或量值）。</span><span class="sxs-lookup"><span data-stu-id="166d8-179">Gets the absolute value (or magnitude) of a complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-180"><paramref name="value" /> 的绝对值。</span><span class="sxs-lookup"><span data-stu-id="166d8-180">The absolute value of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-181">复数的绝对值是等效于其<xref:System.Numerics.Complex.Magnitude%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="166d8-181">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="166d8-182">实数数值的绝对值的数值 + bi 的计算方式如下：</span><span class="sxs-lookup"><span data-stu-id="166d8-182">The absolute value of a real number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="166d8-183">如果 b = 0，则结果为 0。</span><span class="sxs-lookup"><span data-stu-id="166d8-183">If b = 0, the result is 0.</span></span>  
  
-   <span data-ttu-id="166d8-184">如果 > b，结果是 \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>)。</span><span class="sxs-lookup"><span data-stu-id="166d8-184">If a > b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="166d8-185">如果 b >，则结果是 b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>)。</span><span class="sxs-lookup"><span data-stu-id="166d8-185">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="166d8-186">如果绝对值的数值的计算导致溢出时，该方法返回<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-186">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="166d8-187">如果任一<xref:System.Numerics.Complex.Real%2A>或<xref:System.Numerics.Complex.Imaginary%2A>属性是<xref:System.Double.NaN?displayProperty=nameWithType>和其他属性既不是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>也不<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>，该方法返回<xref:System.Double.NaN?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-187">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-188">下面的示例计算复数的绝对值和演示的值等效<xref:System.Numerics.Complex.Magnitude%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="166d8-188">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-189">表示余弦的复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-189">A complex number that represents a cosine.</span></span></param>
        <summary><span data-ttu-id="166d8-190">返回表示指定复数的反余弦值的角度。</span><span class="sxs-lookup"><span data-stu-id="166d8-190">Returns the angle that is the arc cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-191">以弧度为单位的角度，它表示 <paramref name="value" /> 的反余弦。</span><span class="sxs-lookup"><span data-stu-id="166d8-191">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-192"><xref:System.Numerics.Complex.Acos%2A>复数的方法都对应<xref:System.Math.Acos%2A?displayProperty=nameWithType>实数的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-192">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="166d8-193"><xref:System.Numerics.Complex.Acos%2A>方法使用以下公式：</span><span class="sxs-lookup"><span data-stu-id="166d8-193">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="166d8-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="166d8-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="166d8-195">下面的示例演示<xref:System.Numerics.Complex.Acos%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-195">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="166d8-196">它显示该通过返回的值<xref:System.Numerics.Complex.Acos%2A>方法<xref:System.Numerics.Complex.Cos%2A>方法返回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="166d8-196">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="166d8-197">要相加的第一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-197">The first complex number to add.</span></span></param>
        <param name="right"><span data-ttu-id="166d8-198">要相加的第二个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-198">The second complex number to add.</span></span></param>
        <summary><span data-ttu-id="166d8-199">将两个复数相加，并返回结果。</span><span class="sxs-lookup"><span data-stu-id="166d8-199">Adds two complex numbers and returns the result.</span></span></summary>
        <returns><span data-ttu-id="166d8-200"><paramref name="left" /> 与 <paramref name="right" /> 的和。</span><span class="sxs-lookup"><span data-stu-id="166d8-200">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-201">添加复杂的数字，a + bi，和第二个复数，c + di，采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="166d8-201">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="166d8-202">（a + c） + （b + d） 我。</span><span class="sxs-lookup"><span data-stu-id="166d8-202">(a + c) + (b + d)i.</span></span>  
  
 <span data-ttu-id="166d8-203">如果该方法调用结果实部或虚部溢出，则个分量的值是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-203">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="166d8-204">不支持自定义运算符的语言可以使用<xref:System.Numerics.Complex.Add%2A>方法来执行与复数的加法。</span><span class="sxs-lookup"><span data-stu-id="166d8-204">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-205">下面的示例演示添加复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-205">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-206">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-206">A complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-207">返回表示指定复数的反正弦值的角度。</span><span class="sxs-lookup"><span data-stu-id="166d8-207">Returns the angle that is the arc sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-208">表示 <paramref name="value" /> 的反正弦值的角度。</span><span class="sxs-lookup"><span data-stu-id="166d8-208">The angle which is the arc sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-209"><xref:System.Numerics.Complex.Asin%2A>复数的方法都对应<xref:System.Math.Asin%2A?displayProperty=nameWithType>实数的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-209">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="166d8-210"><xref:System.Numerics.Complex.Asin%2A>方法使用以下公式：</span><span class="sxs-lookup"><span data-stu-id="166d8-210">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="166d8-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* 值 + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -值 \* 值))</span><span class="sxs-lookup"><span data-stu-id="166d8-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="166d8-212">下面的示例演示<xref:System.Numerics.Complex.Asin%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-212">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="166d8-213">它显示该通过返回的值<xref:System.Numerics.Complex.Asin%2A>方法<xref:System.Numerics.Complex.Sin%2A>方法返回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="166d8-213">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-214">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-214">A complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-215">返回表示指定复数的反正切的角度。</span><span class="sxs-lookup"><span data-stu-id="166d8-215">Returns the angle that is the arc tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-216">表示 <paramref name="value" /> 的反正切值的角度。</span><span class="sxs-lookup"><span data-stu-id="166d8-216">The angle that is the arc tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-217"><xref:System.Numerics.Complex.Atan%2A>复数的方法都对应<xref:System.Math.Atan%2A?displayProperty=nameWithType>实数的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-217">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="166d8-218"><xref:System.Numerics.Complex.Atan%2A>方法使用以下公式：</span><span class="sxs-lookup"><span data-stu-id="166d8-218">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="166d8-219"><xref:System.Numerics.Complex.ImaginaryOne> / 新复杂 （2.0，0.0）) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> \* 值)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* 值)</span><span class="sxs-lookup"><span data-stu-id="166d8-219"><xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value)</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="166d8-220">下面的示例演示<xref:System.Numerics.Complex.Atan%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-220">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="166d8-221">它显示该通过返回的值<xref:System.Numerics.Complex.Atan%2A>方法<xref:System.Numerics.Complex.Tan%2A>方法返回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="166d8-221">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-222">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-222">A complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-223">计算复数的共轭，并返回结果。</span><span class="sxs-lookup"><span data-stu-id="166d8-223">Computes the conjugate of a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="166d8-224"><paramref name="value" /> 的共轭。</span><span class="sxs-lookup"><span data-stu-id="166d8-224">The conjugate of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-225">复数的共轭反转的虚分量; 的符号也就是说，它适用于的虚分量一元求反。</span><span class="sxs-lookup"><span data-stu-id="166d8-225">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="166d8-226">如果 a + bi 是一个复杂的数字，其共轭是 a-bi。</span><span class="sxs-lookup"><span data-stu-id="166d8-226">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-227">下面的示例显示两个复数的共轭。</span><span class="sxs-lookup"><span data-stu-id="166d8-227">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-228">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-228">A complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-229">返回指定复数的余弦值。</span><span class="sxs-lookup"><span data-stu-id="166d8-229">Returns the cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-230"><paramref name="value" /> 的余弦值。</span><span class="sxs-lookup"><span data-stu-id="166d8-230">The cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-231"><xref:System.Numerics.Complex.Cos%2A>复数的方法都对应<xref:System.Math.Cos%2A?displayProperty=nameWithType>实数的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-231">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="166d8-232"><xref:System.Numerics.Complex.Cos%2A>方法使用以下公式来计算复数的余弦值 a + bi:</span><span class="sxs-lookup"><span data-stu-id="166d8-232">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="166d8-233">(<xref:System.Math.Cos%2A>(a) * <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))</span><span class="sxs-lookup"><span data-stu-id="166d8-233">(<xref:System.Math.Cos%2A>(a) * <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-234">下面的示例演示<xref:System.Numerics.Complex.Acos%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-234">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="166d8-235">它显示该通过返回的值<xref:System.Numerics.Complex.Acos%2A>方法<xref:System.Numerics.Complex.Cos%2A>方法返回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="166d8-235">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-236">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-236">A complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-237">返回指定复数的双曲余弦值。</span><span class="sxs-lookup"><span data-stu-id="166d8-237">Returns the hyperbolic cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-238"><paramref name="value" /> 的双曲余弦值。</span><span class="sxs-lookup"><span data-stu-id="166d8-238">The hyperbolic cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-239"><xref:System.Numerics.Complex.Cosh%2A>复数的方法都对应<xref:System.Math.Cosh%2A?displayProperty=nameWithType>实数的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-239">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="166d8-240"><xref:System.Numerics.Complex.Cosh%2A>方法使用以下公式来计算复数的双曲余弦值 a + bi:</span><span class="sxs-lookup"><span data-stu-id="166d8-240">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="166d8-241">(<xref:System.Math.Cosh%2A>（a） * <xref:System.Math.Cos%2A>（b)， <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="166d8-241">(<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="166d8-242">要作为被除数的复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-242">The complex number to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="166d8-243">要作为除数的复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-243">The complex number to divide by.</span></span></param>
        <summary><span data-ttu-id="166d8-244">用一个复数除另一个复数并返回结果。</span><span class="sxs-lookup"><span data-stu-id="166d8-244">Divides one complex number by another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="166d8-245">相除后的商。</span><span class="sxs-lookup"><span data-stu-id="166d8-245">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-246">相除的复数，a + bi 中的，通过第二个复数、 数量、 c + di，采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="166d8-246">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="166d8-247">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) 我</span><span class="sxs-lookup"><span data-stu-id="166d8-247">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="166d8-248">如果商的计算导致实部或虚部溢出，则该组件的值是<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-248">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="166d8-249"><xref:System.Numerics.Complex.Divide%2A>方法可以由不支持自定义运算符的语言。</span><span class="sxs-lookup"><span data-stu-id="166d8-249">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="166d8-250">其行为等同于使用除法运算符的除法。</span><span class="sxs-lookup"><span data-stu-id="166d8-250">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-251">下面的示例将一个复杂的数字除以复数的数组中每个元素。</span><span class="sxs-lookup"><span data-stu-id="166d8-251">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="166d8-252">返回一个值，该值指示两个复数是否相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-252">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-253">要比较的复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-253">The complex number to compare.</span></span></param>
        <summary><span data-ttu-id="166d8-254">返回一个值，该值指示当前实例与指定的复数是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-254">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="166d8-255">如果此复数与 <paramref name="value" /> 具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="166d8-255"><see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-256"><xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>方法提供<xref:System.IEquatable%601>实现<xref:System.Numerics.Complex>结构。</span><span class="sxs-lookup"><span data-stu-id="166d8-256">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="166d8-257">它的执行略优于<xref:System.Numerics.Complex.Equals%28System.Object%29>方法因为它没有将其参数转换为一个复杂的数字。</span><span class="sxs-lookup"><span data-stu-id="166d8-257">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="166d8-258">两个复数相等，如果相等的实数部分和虚数部分相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-258">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="166d8-259"><xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>方法等效于以下表达式：</span><span class="sxs-lookup"><span data-stu-id="166d8-259">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="166d8-260">使用<see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />方法时要格外小心，因为显然是等效的两个值是可被视为由于其实部和虚部的组件的不同精度不相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-260">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="166d8-261">下面的示例报告<c>（3.33333，0.142857）</c>和<c>（10/3，1/7）</c>是否不相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-261">The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)]
 [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]  
  
 <span data-ttu-id="166d8-262">一个建议的方法是定义两个值之间的差异可接受范围 (如。 01%的值的实部和虚部组件之一) 而不是比较是否相等的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-262">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="166d8-263">如果两个值之间的差异的绝对值是小于或等于该边距，区别是可能是由于精度，存在差异，并因此，值很可能是相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-263">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="166d8-264">下面的示例使用此方法来比较两个复杂值前面的代码示例发现存在不相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-264">The following example uses this technique to compare the two complex values that the previous code example found to be unequal.</span></span> <span data-ttu-id="166d8-265">它找到两个复数相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-265">It finds the two complex numbers to be equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="166d8-266">要比较的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-266">The object to compare.</span></span></param>
        <summary><span data-ttu-id="166d8-267">返回一个值，该值指示当前实例与指定的对象是否具有相同的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-267">Returns a value that indicates whether the current instance and a specified object have the same value.</span></span></summary>
        <returns>
          <span data-ttu-id="166d8-268">如果 <paramref name="obj" /> 参数是一个 <see cref="T:System.Numerics.Complex" /> 对象或是一个能够隐式转换为 <see cref="T:System.Numerics.Complex" /> 对象的类型，并且其值等于当前 <see cref="T:System.Numerics.Complex" /> 对象，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="166d8-268"><see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-269">两个复数相等，如果相等的实数部分和虚数部分相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-269">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="166d8-270"><xref:System.Numerics.Complex.Equals%28System.Object%29>方法等效于以下表达式：</span><span class="sxs-lookup"><span data-stu-id="166d8-270">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="166d8-271">如果`obj`参数不是<xref:System.Numerics.Complex>对象，但它是数据类型为其定义隐式转换，<xref:System.Numerics.Complex.Equals%28System.Object%29>方法将`obj`到<xref:System.Numerics.Complex>对象，其实部为等于值`obj`之前在执行比较，其虚数部分是等于零。</span><span class="sxs-lookup"><span data-stu-id="166d8-271">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="166d8-272">下面的示例阐释了这一点通过查找一个复杂的数字和一个双精度浮点值相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-272">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="166d8-273">使用<see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />方法时要格外小心，因为显然是等效的两个值是可被视为由于其实部和虚部的组件的不同精度不相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-273">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="166d8-274">可以更突出问题，如果<paramref name="obj" />必须转换为<see cref="T:System.Double" />之前执行比较。</span><span class="sxs-lookup"><span data-stu-id="166d8-274">The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison.</span></span> <span data-ttu-id="166d8-275">下面的示例比较复数的实分量似乎是等于<see cref="T:System.Single" />值与该<see cref="T:System.Single" />值。</span><span class="sxs-lookup"><span data-stu-id="166d8-275">The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value.</span></span> <span data-ttu-id="166d8-276">如输出所示，相等性比较返回<see langword="False" />。</span><span class="sxs-lookup"><span data-stu-id="166d8-276">As the output shows, the comparison for equality returns <see langword="False" />.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)]
 [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]  
  
 <span data-ttu-id="166d8-277">一个建议的方法是定义两个值之间的差异可接受范围 (如。 01%的值的实部和虚部组件之一) 而不是比较是否相等的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-277">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="166d8-278">如果两个值之间的差异的绝对值是小于或等于该边距，区别是可能是由于在精度不同，并因此的值很可能相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-278">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="166d8-279">下面的示例使用此方法来比较两个前面的代码示例找到要不相等的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-279">The following example uses this technique to compare the two values that the previous code example found to be unequal.</span></span> <span data-ttu-id="166d8-280">它现在发现它们相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-280">It now finds them to be equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)]
 [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-281">指定幂的复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-281">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="166d8-282">返回 <see langword="e" /> 的由一个复数指定的次幂。</span><span class="sxs-lookup"><span data-stu-id="166d8-282">Returns <see langword="e" /> raised to the power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-283">数字 <see langword="e" /> 的 <paramref name="value" /> 次幂。</span><span class="sxs-lookup"><span data-stu-id="166d8-283">The number <see langword="e" /> raised to the power <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-284">使用<xref:System.Numerics.Complex.Pow%2A>方法来计算其他底的幂。</span><span class="sxs-lookup"><span data-stu-id="166d8-284">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="166d8-285"><xref:System.Numerics.Complex.Exp%2A>复数的方法都对应<xref:System.Math.Exp%2A?displayProperty=nameWithType>实数的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-285">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="166d8-286"><xref:System.Numerics.Complex.Exp%2A> 是函数的反函数<xref:System.Numerics.Complex.Log%2A>。</span><span class="sxs-lookup"><span data-stu-id="166d8-286"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-287">下面的示例演示<xref:System.Numerics.Complex.Exp%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-287">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="166d8-288">它表明，与某些宽限的精度缺乏<xref:System.Double>数据类型，将返回的值传递<xref:System.Numerics.Complex.Log%2A>方法<xref:System.Numerics.Complex.Exp%2A>方法返回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="166d8-288">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude"><span data-ttu-id="166d8-289">量值，它是从原点（x 轴与 y 轴的交点）到数字的距离。</span><span class="sxs-lookup"><span data-stu-id="166d8-289">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span></span></param>
        <param name="phase"><span data-ttu-id="166d8-290">相位，它是直线相对于水平轴的角度，以弧度为单位。</span><span class="sxs-lookup"><span data-stu-id="166d8-290">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span></span></param>
        <summary><span data-ttu-id="166d8-291">从点的极坐标创建复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-291">Creates a complex number from a point's polar coordinates.</span></span></summary>
        <returns><span data-ttu-id="166d8-292">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-292">A complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-293"><xref:System.Numerics.Complex.FromPolarCoordinates%2A>方法实例化基于其极坐标的复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-293">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="166d8-294">因为有多个表示形式上复平面的返回值的点<xref:System.Numerics.Complex.FromPolarCoordinates%2A>方法进行了规范化。</span><span class="sxs-lookup"><span data-stu-id="166d8-294">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="166d8-295">量值规范化为正数，并且在阶段被规范化-范围中的值为<xref:System.Math.PI>到<xref:System.Math.PI>。</span><span class="sxs-lookup"><span data-stu-id="166d8-295">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="166d8-296">因此的值<xref:System.Numerics.Complex.Phase%2A>和<xref:System.Numerics.Complex.Magnitude%2A>产生的复数的属性可能抵不上的原始值`magnitude`和`phase`参数。</span><span class="sxs-lookup"><span data-stu-id="166d8-296">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="166d8-297">若要将值从度数转换成弧度为`phase`参数，multiply 它 <xref:System.Math.PI?displayProperty=nameWithType> /180。</span><span class="sxs-lookup"><span data-stu-id="166d8-297">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-298">下面的示例使用<xref:System.Numerics.Complex.FromPolarCoordinates%2A>方法可实例化一个复数，基于其极坐标，然后显示的值其<xref:System.Numerics.Complex.Magnitude%2A>和<xref:System.Numerics.Complex.Phase%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="166d8-298">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="166d8-299">返回当前 <see cref="T:System.Numerics.Complex" /> 对象的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="166d8-299">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <returns><span data-ttu-id="166d8-300">32 位有符号整数哈希代码。</span><span class="sxs-lookup"><span data-stu-id="166d8-300">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="166d8-301">获取当前 <see cref="T:System.Numerics.Complex" /> 对象的虚部。</span><span class="sxs-lookup"><span data-stu-id="166d8-301">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="166d8-302">复数的虚部。</span><span class="sxs-lookup"><span data-stu-id="166d8-302">The imaginary component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-303">给定复数 a + bi、<xref:System.Numerics.Complex.Imaginary%2A>属性返回 b 的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-303">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-304">下面的示例实例化的数组<xref:System.Numerics.Complex>对象，并显示每个窗体的实部和虚部组件 a + bi。</span><span class="sxs-lookup"><span data-stu-id="166d8-304">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="166d8-305">返回新的 <see cref="T:System.Numerics.Complex" /> 实例，其实数等于零，虚数等于一。</span><span class="sxs-lookup"><span data-stu-id="166d8-305">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="166d8-306">下面的示例实例化<xref:System.Numerics.Complex>值使用<xref:System.Numerics.Complex.ImaginaryOne>属性。</span><span class="sxs-lookup"><span data-stu-id="166d8-306">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="166d8-307">然后，它比较另一个值，通过调用实例化到此值<xref:System.Numerics.Complex>等于零实部和虚部等于 1 的构造函数。</span><span class="sxs-lookup"><span data-stu-id="166d8-307">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="166d8-308">如示例输出所示，两个值相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-308">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="166d8-309">返回一个复数的对数。</span><span class="sxs-lookup"><span data-stu-id="166d8-309">Returns the logarithm of a complex number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-310">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-310">A complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-311">返回指定复数的自然对数（底为 <see langword="e" />）。</span><span class="sxs-lookup"><span data-stu-id="166d8-311">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-312"><paramref name="value" /> 的自然对数（底为 <see langword="e" />）。</span><span class="sxs-lookup"><span data-stu-id="166d8-312">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-313"><xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29>复数的方法都对应<xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType>实数的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-313">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-314">下面的示例演示<xref:System.Numerics.Complex.Log%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-314">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="166d8-315">它表明，与某些宽限的精度缺乏<xref:System.Double>数据类型，将返回的值传递<xref:System.Numerics.Complex.Log%2A>方法<xref:System.Numerics.Complex.Exp%2A>方法返回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="166d8-315">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-316">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-316">A complex number.</span></span></param>
        <param name="baseValue"><span data-ttu-id="166d8-317">对数的底。</span><span class="sxs-lookup"><span data-stu-id="166d8-317">The base of the logarithm.</span></span></param>
        <summary><span data-ttu-id="166d8-318">返回指定复数在使用指定底时的对数。</span><span class="sxs-lookup"><span data-stu-id="166d8-318">Returns the logarithm of a specified complex number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="166d8-319"><paramref name="value" /> 的对数（底为 <paramref name="baseValue" />）。</span><span class="sxs-lookup"><span data-stu-id="166d8-319">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-320"><xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29>复数的方法都对应<xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType>实数的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-320">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-321">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-321">A complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-322">返回指定复数以 10 为底的对数。</span><span class="sxs-lookup"><span data-stu-id="166d8-322">Returns the base-10 logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-323"><paramref name="value" /> 的以 10 为底的对数。</span><span class="sxs-lookup"><span data-stu-id="166d8-323">The base-10 logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-324"><xref:System.Numerics.Complex.Log10%2A>复数的方法都对应<xref:System.Math.Log10%2A?displayProperty=nameWithType>实数的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-324">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="166d8-325">获取复数的量值（或绝对值）。</span><span class="sxs-lookup"><span data-stu-id="166d8-325">Gets the magnitude (or absolute value) of a complex number.</span></span></summary>
        <value><span data-ttu-id="166d8-326">当前实例的量值。</span><span class="sxs-lookup"><span data-stu-id="166d8-326">The magnitude of the current instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-327"><xref:System.Numerics.Complex.Magnitude%2A>属性等效于绝对值的数值的复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-327">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="166d8-328">它指定从原点 （x 轴和 y 轴笛卡尔坐标系统中的交集） 到表示复数的二维点的距离。</span><span class="sxs-lookup"><span data-stu-id="166d8-328">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="166d8-329">绝对值的数值的计算方式如下：</span><span class="sxs-lookup"><span data-stu-id="166d8-329">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="166d8-330">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a * a + b * b)</span><span class="sxs-lookup"><span data-stu-id="166d8-330">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a * a + b * b)</span></span>  
  
 <span data-ttu-id="166d8-331">如果绝对值的数值的计算导致溢出时，此属性返回<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-331">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="166d8-332"><xref:System.Numerics.Complex.Magnitude%2A>和<xref:System.Numerics.Complex.Phase%2A>属性定义极坐标图坐标系统中表示一个复数的点的位置。</span><span class="sxs-lookup"><span data-stu-id="166d8-332">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="166d8-333">可以实例化一个复数，通过调用基于其极坐标，而不是笛卡尔坐标<xref:System.Numerics.Complex.FromPolarCoordinates%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-333">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-334">下面的示例计算复数的绝对值和演示的值等效<xref:System.Numerics.Complex.Magnitude%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="166d8-334">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="166d8-335">要相乘的第一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-335">The first complex number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="166d8-336">要相乘的第二个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-336">The second complex number to multiply.</span></span></param>
        <summary><span data-ttu-id="166d8-337">返回两个复数的乘积。</span><span class="sxs-lookup"><span data-stu-id="166d8-337">Returns the product of two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="166d8-338"><paramref name="left" /> 与 <paramref name="right" /> 参数的乘积。</span><span class="sxs-lookup"><span data-stu-id="166d8-338">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-339">复杂的乘号，a + bi，并第二个复数，c + di，采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="166d8-339">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="166d8-340">(ac-bd) + （ad + bc） 我</span><span class="sxs-lookup"><span data-stu-id="166d8-340">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="166d8-341">如果乘运算导致溢出实部或虚部组件中，该组件的值为<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-341">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="166d8-342"><xref:System.Numerics.Complex.Multiply%2A>会为不支持自定义运算符的语言实现方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-342">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="166d8-343">其行为等同于使用乘法运算符的乘法。</span><span class="sxs-lookup"><span data-stu-id="166d8-343">Its behavior is identical to multiplication using the multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-344">下面的示例一个复数的数组中每个元素的复杂数字的倍数。</span><span class="sxs-lookup"><span data-stu-id="166d8-344">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-345">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-345">A complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-346">返回指定复数的加法逆元。</span><span class="sxs-lookup"><span data-stu-id="166d8-346">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-347"><paramref name="value" /> 参数的 <see cref="P:System.Numerics.Complex.Real" /> 和 <see cref="P:System.Numerics.Complex.Imaginary" /> 部分乘以 -1 的结果。</span><span class="sxs-lookup"><span data-stu-id="166d8-347">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-348">复数的加法逆元是生成的值的复数<xref:System.Numerics.Complex>何时添加到原始的复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-348">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex> when it is added to the original complex number.</span></span> <span data-ttu-id="166d8-349">此方法返回一个复杂的数字顺序原始复数的实部和虚部组件乘以-1。</span><span class="sxs-lookup"><span data-stu-id="166d8-349">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="166d8-350"><xref:System.Numerics.Complex.Negate%2A>会为不支持自定义运算符的语言实现方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-350">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="166d8-351">其行为等同于使用一元求反运算符的求反<xref:System.Numerics.Complex.op_UnaryNegation%2A>。</span><span class="sxs-lookup"><span data-stu-id="166d8-351">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-352">下面的示例获取复数的数组中每个元素的加法逆元。</span><span class="sxs-lookup"><span data-stu-id="166d8-352">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="166d8-353">返回新的 <see cref="T:System.Numerics.Complex" /> 实例，其实数等于一，虚数等于零。</span><span class="sxs-lookup"><span data-stu-id="166d8-353">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="166d8-354">下面的示例实例化<xref:System.Numerics.Complex>值使用<xref:System.Numerics.Complex.One>属性。</span><span class="sxs-lookup"><span data-stu-id="166d8-354">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="166d8-355">然后，它比较另一个值，通过调用实例化到此值<xref:System.Numerics.Complex>等于个实部和虚部等于零的构造函数。</span><span class="sxs-lookup"><span data-stu-id="166d8-355">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="166d8-356">如示例输出所示，两个值相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-356">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="166d8-357">要相加的第一个值。</span><span class="sxs-lookup"><span data-stu-id="166d8-357">The first value to add.</span></span></param>
        <param name="right"><span data-ttu-id="166d8-358">要相加的第二个值。</span><span class="sxs-lookup"><span data-stu-id="166d8-358">The second value to add.</span></span></param>
        <summary><span data-ttu-id="166d8-359">将两个复数相加。</span><span class="sxs-lookup"><span data-stu-id="166d8-359">Adds two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="166d8-360"><paramref name="left" /> 与 <paramref name="right" /> 的和。</span><span class="sxs-lookup"><span data-stu-id="166d8-360">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-361"><xref:System.Numerics.Complex.op_Addition%2A>方法定义复数的加法运算。</span><span class="sxs-lookup"><span data-stu-id="166d8-361">The <xref:System.Numerics.Complex.op_Addition%2A> method defines the addition operation for complex numbers.</span></span> <span data-ttu-id="166d8-362">它使代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="166d8-362">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 <span data-ttu-id="166d8-363">添加复杂的数字，a + bi，和第二个复数，c + di，采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="166d8-363">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="166d8-364">（a + c） + （b + d） 我</span><span class="sxs-lookup"><span data-stu-id="166d8-364">(a + c) + (b + d)i</span></span>  
  
 <span data-ttu-id="166d8-365">如果该方法调用结果实部或虚部溢出，该组件的值为<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-365">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="166d8-366">不支持自定义运算符的语言可以调用<xref:System.Numerics.Complex.Add%2A>方法相反。</span><span class="sxs-lookup"><span data-stu-id="166d8-366">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="166d8-367">此运算符的等效方法是 <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="166d8-367">The equivalent method for this operator is <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="166d8-368">下面的示例演示添加复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-368">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="166d8-369">要作为被除数的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-369">The value to be divided.</span></span></param>
        <param name="right"><span data-ttu-id="166d8-370">要作为除数的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-370">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="166d8-371">用一个指定复数除另一个指定复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-371">Divides a specified complex number by another specified complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-372"><paramref name="left" /> 除以 <paramref name="right" /> 的结果。</span><span class="sxs-lookup"><span data-stu-id="166d8-372">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-373"><xref:System.Numerics.Complex.op_Division%2A>方法定义为复数的除法运算。</span><span class="sxs-lookup"><span data-stu-id="166d8-373">The <xref:System.Numerics.Complex.op_Division%2A> method defines the division operation for complex numbers.</span></span> <span data-ttu-id="166d8-374">它使代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="166d8-374">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 <span data-ttu-id="166d8-375">一种复杂的划分号，a + bi，并第二个复数，c + di，采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="166d8-375">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="166d8-376">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) 我</span><span class="sxs-lookup"><span data-stu-id="166d8-376">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="166d8-377">如果除法运算导致溢出实部或虚部组件中，该组件的值为<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-377">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="166d8-378">不支持自定义的运算符和运算符重载的语言可以调用<xref:System.Numerics.Complex.Divide%2A>方法相反。</span><span class="sxs-lookup"><span data-stu-id="166d8-378">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="166d8-379">此运算符的等效方法是 <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="166d8-379">The equivalent method for this operator is <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="166d8-380">要比较的第一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-380">The first complex number to compare.</span></span></param>
        <param name="right"><span data-ttu-id="166d8-381">要比较的第二个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-381">The second complex number to compare.</span></span></param>
        <summary><span data-ttu-id="166d8-382">返回一个值，该值指示两个复数是否相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-382">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
        <returns>
          <span data-ttu-id="166d8-383">如果 <paramref name="left" /> 与 <paramref name="right" /> 参数具有相同的值，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="166d8-383"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-384"><xref:System.Numerics.Complex.op_Equality%2A>方法定义的相等运算符的运算<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="166d8-384">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="166d8-385">它使代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="166d8-385">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="166d8-386">不支持自定义运算符的语言可以调用<xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>方法相反。</span><span class="sxs-lookup"><span data-stu-id="166d8-386">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="166d8-387">两个复数相等，如果相等的实数部分和虚数部分相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-387">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="166d8-388"><xref:System.Numerics.Complex.op_Equality%2A>方法等效于以下表达式：</span><span class="sxs-lookup"><span data-stu-id="166d8-388">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="166d8-389">请注意，由于精度的差异，显然是相等的两个复数可被视为不相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-389">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="166d8-390">有关详细信息和可能的解决方法，请参阅<xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-390">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="166d8-391">此运算符的等效方法是 <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="166d8-391">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="166d8-392">定义 <see cref="T:System.Numerics.Complex" /> 对象与其他类型之间的显式转换。</span><span class="sxs-lookup"><span data-stu-id="166d8-392">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-393">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-393">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-394">定义从 <see cref="T:System.Decimal" /> 值到复数的显式转换。</span><span class="sxs-lookup"><span data-stu-id="166d8-394">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-395">一个复数，其实部等于 <paramref name="value" />，虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="166d8-395">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-396">显式转换运算符定义可以转换为的类型<xref:System.Numerics.Complex>对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-396">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="166d8-397">语言编译器不会自动执行此转换，因为它会导致数据丢失。</span><span class="sxs-lookup"><span data-stu-id="166d8-397">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="166d8-398">相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`在 Visual Basic 中) 使用。</span><span class="sxs-lookup"><span data-stu-id="166d8-398">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="166d8-399">否则，它们显示编译器错误。</span><span class="sxs-lookup"><span data-stu-id="166d8-399">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="166d8-400">转换<xref:System.Decimal>复数的实部值可能导致精度损失，因为<xref:System.Double>，后者是复杂的数字的类型<xref:System.Numerics.Complex.Real%2A>属性，具有有效位比<xref:System.Decimal>。</span><span class="sxs-lookup"><span data-stu-id="166d8-400">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="166d8-401">下面的示例演示的显式转换<xref:System.Decimal>值复制到<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="166d8-401">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-402">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-402">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-403">定义从 <see cref="T:System.Numerics.BigInteger" /> 值到复数的显式转换。</span><span class="sxs-lookup"><span data-stu-id="166d8-403">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-404">一个复数，其实部等于 <paramref name="value" />，虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="166d8-404">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-405">显式转换运算符定义可以转换为的类型<xref:System.Numerics.Complex>对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-405">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="166d8-406">语言编译器不会自动执行此转换，因为它会导致数据丢失。</span><span class="sxs-lookup"><span data-stu-id="166d8-406">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="166d8-407">相反，它们执行转换仅当 （在 C# 中) 强制转换运算符或转换函数 (如`CType`在 Visual Basic 中) 使用。</span><span class="sxs-lookup"><span data-stu-id="166d8-407">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="166d8-408">否则，它们显示编译器错误。</span><span class="sxs-lookup"><span data-stu-id="166d8-408">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="166d8-409">转换<xref:System.Numerics.BigInteger>复数的实部值可能导致精度损失，因为<xref:System.Double>，后者是复杂的数字的类型<xref:System.Numerics.Complex.Real%2A>属性，具有有效位比<xref:System.Numerics.BigInteger>。</span><span class="sxs-lookup"><span data-stu-id="166d8-409">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="166d8-410">如果转换失败因为<xref:System.Numerics.BigInteger>值超出了范围的<xref:System.Double>类型，该操作不会引发<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="166d8-410">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="166d8-411">相反，如果`value`是小于<xref:System.Double.MinValue>，结果是具有一个复数<xref:System.Numerics.Complex.Real%2A>属性值等于<xref:System.Double.NegativeInfinity>。</span><span class="sxs-lookup"><span data-stu-id="166d8-411">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="166d8-412">如果`value`大于<xref:System.Double.MaxValue>，结果是具有一个复数<xref:System.Numerics.Complex.Real%2A>属性值等于<xref:System.Double.PositiveInfinity>。</span><span class="sxs-lookup"><span data-stu-id="166d8-412">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="166d8-413">下面的示例演示的显式转换<xref:System.Numerics.BigInteger>值复制到<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="166d8-413">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="166d8-414">定义 <see cref="T:System.Numerics.Complex" /> 对象与其他类型之间的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="166d8-414">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-415">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-415">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-416">定义从无符号字节到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="166d8-416">Defines an implicit conversion of an unsigned byte to a complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-417">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="166d8-417">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-418">重载<xref:System.Numerics.Complex.op_Implicit%2A>运算符定义从中编译器可自动转换的类型<xref:System.Numerics.Complex>而无需使用显式强制转换运算符 （在 C# 中) 或 （在 Visual Basic) 的转换函数的调用的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-418">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="166d8-419">它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="166d8-419">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="166d8-420">此重载使编译器能够处理从转换<xref:System.Byte>到复数，如以下示例所示的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-420">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="166d8-421">请注意，转换的结果是复数的实部等同于<xref:System.Byte>值，并且其虚数部分是等于零。</span><span class="sxs-lookup"><span data-stu-id="166d8-421">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-422">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-422">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-423">定义从双精度浮点数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="166d8-423">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-424">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="166d8-424">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-425">重载<xref:System.Numerics.Complex.op_Implicit%2A>运算符定义从中编译器可自动转换的类型<xref:System.Numerics.Complex>而无需使用显式强制转换运算符 （在 C# 中) 或 （在 Visual Basic) 的转换函数的调用的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-425">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="166d8-426">它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="166d8-426">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="166d8-427">此重载使编译器能够处理从转换<xref:System.Double>到复数，如以下示例所示的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-427">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="166d8-428">请注意，转换的结果是复数的实部等同于<xref:System.Double>值，并且其虚数部分是等于零。</span><span class="sxs-lookup"><span data-stu-id="166d8-428">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-429">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-429">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-430">定义从 16 位带符号整数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="166d8-430">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-431">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="166d8-431">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-432">重载<xref:System.Numerics.Complex.op_Implicit%2A>运算符定义从中编译器可自动转换的类型<xref:System.Numerics.Complex>而无需使用显式强制转换运算符 （在 C# 中) 或 （在 Visual Basic) 的转换函数的调用的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-432">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="166d8-433">它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="166d8-433">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="166d8-434">此重载使编译器能够处理转换从 16 位有符号整数到复数，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="166d8-434">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="166d8-435">请注意，转换的结果是一个复数的实部等于 16 位有符号整数，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="166d8-435">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-436">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-436">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-437">定义从 32 位带符号整数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="166d8-437">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-438">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="166d8-438">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-439">重载<xref:System.Numerics.Complex.op_Implicit%2A>运算符定义从中编译器可自动转换的类型<xref:System.Numerics.Complex>而无需使用显式强制转换运算符 （在 C# 中) 或 （在 Visual Basic) 的转换函数的调用的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-439">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="166d8-440">它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="166d8-440">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="166d8-441">此重载使编译器能够处理转换从有符号的 32 位整数到复数，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="166d8-441">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="166d8-442">请注意，转换的结果是一个复数的实部等同于 32 位有符号整数，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="166d8-442">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-443">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-443">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-444">定义从 64 位带符号整数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="166d8-444">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-445">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="166d8-445">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-446">重载<xref:System.Numerics.Complex.op_Implicit%2A>运算符定义从中编译器可自动转换的类型<xref:System.Numerics.Complex>而无需使用显式强制转换运算符 （在 C# 中) 或 （在 Visual Basic) 的转换函数的调用的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-446">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="166d8-447">它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="166d8-447">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="166d8-448">此重载使编译器能够处理转换从 64 位有符号整数到复数，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="166d8-448">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="166d8-449">请注意，转换的结果是一个复数的实部等于 64 位有符号整数，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="166d8-449">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-450">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-450">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-451">定义从带符号字节到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="166d8-451">Defines an implicit conversion of a signed byte to a complex number.</span></span>   
           
<span data-ttu-id="166d8-452">此 API 不兼容 CLS。</span><span class="sxs-lookup"><span data-stu-id="166d8-452">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="166d8-453">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="166d8-453">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-454">重载<xref:System.Numerics.Complex.op_Implicit%2A>运算符定义从中编译器可自动转换的类型<xref:System.Numerics.Complex>而无需使用显式强制转换运算符 （在 C# 中) 或 （在 Visual Basic) 的转换函数的调用的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-454">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="166d8-455">它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="166d8-455">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="166d8-456">此重载使编译器能够处理转换从有符号字节到复数，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="166d8-456">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="166d8-457">请注意，转换的结果是一个复数的实部等于有符号字节，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="166d8-457">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-458">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-458">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-459">定义从单精度浮点数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="166d8-459">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-460">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="166d8-460">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-461">重载<xref:System.Numerics.Complex.op_Implicit%2A>运算符定义从中编译器可自动转换的类型<xref:System.Numerics.Complex>而无需使用显式强制转换运算符 （在 C# 中) 或 （在 Visual Basic) 的转换函数的调用的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-461">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="166d8-462">它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="166d8-462">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="166d8-463">此重载使编译器能够处理从转换<xref:System.Single>到复数，如以下示例所示的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-463">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="166d8-464">请注意，转换的结果是复数的实部等同于<xref:System.Single>值，并且其虚数部分是等于零。</span><span class="sxs-lookup"><span data-stu-id="166d8-464">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-465">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-465">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-466">定义从 16 位无符号整数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="166d8-466">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="166d8-467">此 API 不兼容 CLS。</span><span class="sxs-lookup"><span data-stu-id="166d8-467">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="166d8-468">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="166d8-468">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-469">重载<xref:System.Numerics.Complex.op_Implicit%2A>运算符定义从中编译器可自动转换的类型<xref:System.Numerics.Complex>而无需使用显式强制转换运算符 （在 C# 中) 或 （在 Visual Basic) 的转换函数的调用的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-469">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="166d8-470">它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="166d8-470">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="166d8-471">此重载使编译器能够处理转换从 16 位无符号整数到复数，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="166d8-471">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="166d8-472">请注意，转换的结果是一个复数的实部等于 16 位无符号整数，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="166d8-472">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-473">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-473">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-474">定义从 32 位无符号整数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="166d8-474">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="166d8-475">此 API 不兼容 CLS。</span><span class="sxs-lookup"><span data-stu-id="166d8-475">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="166d8-476">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="166d8-476">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-477">重载<xref:System.Numerics.Complex.op_Implicit%2A>运算符定义从中编译器可自动转换的类型<xref:System.Numerics.Complex>而无需使用显式强制转换运算符 （在 C# 中) 或 （在 Visual Basic) 的转换函数的调用的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-477">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="166d8-478">它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="166d8-478">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="166d8-479">此重载使编译器能够处理转换从 32 位无符号整数到复数，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="166d8-479">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="166d8-480">请注意，转换的结果是一个复数的实部等同于 32 位无符号整数，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="166d8-480">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-481">要转换为复数的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-481">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-482">定义从 64 位无符号整数到复数的隐式转换。</span><span class="sxs-lookup"><span data-stu-id="166d8-482">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="166d8-483">此 API 不兼容 CLS。</span><span class="sxs-lookup"><span data-stu-id="166d8-483">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="166d8-484">一个对象，其中使用 <paramref name="value" /> 参数的值作为其实部，并使用零作为其虚部。</span><span class="sxs-lookup"><span data-stu-id="166d8-484">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-485">重载<xref:System.Numerics.Complex.op_Implicit%2A>运算符定义从中编译器可自动转换的类型<xref:System.Numerics.Complex>而无需使用显式强制转换运算符 （在 C# 中) 或 （在 Visual Basic) 的转换函数的调用的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-485">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="166d8-486">它们扩大转换，不会丢失数据，不会引发<xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="166d8-486">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="166d8-487">此重载使编译器能够处理转换从 64 位无符号整数到复数，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="166d8-487">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="166d8-488">请注意，转换的结果是一个复数的实部等于 64 位无符号整数，其虚部等于零。</span><span class="sxs-lookup"><span data-stu-id="166d8-488">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="166d8-489">要比较的第一个值。</span><span class="sxs-lookup"><span data-stu-id="166d8-489">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="166d8-490">要比较的第二个值。</span><span class="sxs-lookup"><span data-stu-id="166d8-490">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="166d8-491">返回一个值，该值指示两个复数是否不相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-491">Returns a value that indicates whether two complex numbers are not equal.</span></span></summary>
        <returns>
          <span data-ttu-id="166d8-492">如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="166d8-492"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-493"><xref:System.Numerics.Complex.op_Equality%2A>方法定义为复数是否不相等运算符的操作。</span><span class="sxs-lookup"><span data-stu-id="166d8-493">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="166d8-494">它使代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="166d8-494">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="166d8-495">不支持自定义运算符的语言可以通过调用测试是否不相等<xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>方法并反转其值。</span><span class="sxs-lookup"><span data-stu-id="166d8-495">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="166d8-496">请注意，由于精度的差异，显然是相等的两个复数可被视为不相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-496">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="166d8-497">一种解决方法是实现的比较方法，返回`true`仅复杂数字的两个实部和虚部部分之间的差异超过特定阈值时 (如。 01%的值的实部或虚部组件一个复数的）。</span><span class="sxs-lookup"><span data-stu-id="166d8-497">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="166d8-498">有关更多信息，请参见 <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-498">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="166d8-499">要相乘的第一个值。</span><span class="sxs-lookup"><span data-stu-id="166d8-499">The first value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="166d8-500">要相乘的第二个值。</span><span class="sxs-lookup"><span data-stu-id="166d8-500">The second value to multiply.</span></span></param>
        <summary><span data-ttu-id="166d8-501">将两个指定复数相乘。</span><span class="sxs-lookup"><span data-stu-id="166d8-501">Multiplies two specified complex numbers.</span></span></summary>
        <returns><span data-ttu-id="166d8-502"><paramref name="left" /> 与 <paramref name="right" /> 的乘积。</span><span class="sxs-lookup"><span data-stu-id="166d8-502">The product of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-503"><xref:System.Numerics.Complex.op_Multiply%2A>方法定义复数的乘法运算符的操作。</span><span class="sxs-lookup"><span data-stu-id="166d8-503">The <xref:System.Numerics.Complex.op_Multiply%2A> method defines the operation of the multiplication operator for complex numbers.</span></span> <span data-ttu-id="166d8-504">它使代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="166d8-504">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 <span data-ttu-id="166d8-505">复杂的乘号，a + bi，并第二个复数，c + di，采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="166d8-505">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="166d8-506">(ac-bd) + （ad + bc） 我</span><span class="sxs-lookup"><span data-stu-id="166d8-506">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="166d8-507">如果乘运算导致溢出实部或虚部组件中，该组件的值为<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-507">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="166d8-508">不支持自定义运算符的语言可以调用<xref:System.Numerics.Complex.Multiply%2A>方法相反。</span><span class="sxs-lookup"><span data-stu-id="166d8-508">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> method instead.</span></span>  
  
 <span data-ttu-id="166d8-509">此运算符的等效方法是 <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="166d8-509">The equivalent method for this operator is <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="166d8-510">要从中减去的值（被减数）。</span><span class="sxs-lookup"><span data-stu-id="166d8-510">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="166d8-511">要减去的值（减数）。</span><span class="sxs-lookup"><span data-stu-id="166d8-511">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="166d8-512">从一个复数中减去另一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-512">Subtracts a complex number from another complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-513"><paramref name="right" /> 减 <paramref name="left" /> 所得的结果。</span><span class="sxs-lookup"><span data-stu-id="166d8-513">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-514"><xref:System.Numerics.Complex.op_Subtraction%2A>方法定义的减法运算符为复数的运算。</span><span class="sxs-lookup"><span data-stu-id="166d8-514">The <xref:System.Numerics.Complex.op_Subtraction%2A> method defines the operation of the subtraction operator for complex numbers.</span></span> <span data-ttu-id="166d8-515">它使代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="166d8-515">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 <span data-ttu-id="166d8-516">如果该方法调用结果实部或虚部溢出，该组件的值为<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-516">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="166d8-517">减法的复数，c + di，从另一个复数 + bi，采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="166d8-517">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="166d8-518">(a - c) + (b - d)i</span><span class="sxs-lookup"><span data-stu-id="166d8-518">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="166d8-519">不支持自定义运算符的语言可以调用<xref:System.Numerics.Complex.Subtract%2A>方法相反。</span><span class="sxs-lookup"><span data-stu-id="166d8-519">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="166d8-520">此运算符的等效方法是 <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="166d8-520">The equivalent method for this operator is <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-521">要求反的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-521">The value to negate.</span></span></param>
        <summary><span data-ttu-id="166d8-522">返回指定复数的加法逆元。</span><span class="sxs-lookup"><span data-stu-id="166d8-522">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-523"><paramref name="value" /> 参数的 <see cref="P:System.Numerics.Complex.Real" /> 和 <see cref="P:System.Numerics.Complex.Imaginary" /> 部分乘以 -1 的结果。</span><span class="sxs-lookup"><span data-stu-id="166d8-523">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-524"><xref:System.Numerics.Complex.op_UnaryNegation%2A>方法定义的一元求反 （加法逆元） 运算符为复数的运算。</span><span class="sxs-lookup"><span data-stu-id="166d8-524">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="166d8-525">它使代码如下所示：</span><span class="sxs-lookup"><span data-stu-id="166d8-525">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="166d8-526">产生的复数生成的值<xref:System.Numerics.Complex>0 （零） 时将其添加到原始的复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-526">The resulting complex number produces a value of <xref:System.Numerics.Complex> 0 (zero) when it is added to the original complex number.</span></span> <span data-ttu-id="166d8-527">不支持自定义运算符的语言可以调用<xref:System.Numerics.Complex.Negate%2A>方法相反。</span><span class="sxs-lookup"><span data-stu-id="166d8-527">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="166d8-528">此运算符的等效方法是 <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="166d8-528">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="166d8-529">获取复数的相位。</span><span class="sxs-lookup"><span data-stu-id="166d8-529">Gets the phase of a complex number.</span></span></summary>
        <value><span data-ttu-id="166d8-530">复数的相位（以弧度为单位）。</span><span class="sxs-lookup"><span data-stu-id="166d8-530">The phase of a complex number, in radians.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-531">对于复数 + bi，阶段将计算为<xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b)。</span><span class="sxs-lookup"><span data-stu-id="166d8-531">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="166d8-532">你可以标识一个复数，其实部通过笛卡尔坐标复平面上或通过其极坐标。</span><span class="sxs-lookup"><span data-stu-id="166d8-532">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="166d8-533">复数的相位 （自变量） 是线条的表示复数的位从原点 （x 轴和 y 轴的交叉点） 绘制的实际轴的角度。</span><span class="sxs-lookup"><span data-stu-id="166d8-533">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="166d8-534">量值 (由表示<xref:System.Numerics.Complex.Magnitude%2A>属性) 是由复杂的数字表示的点到原点的距离。</span><span class="sxs-lookup"><span data-stu-id="166d8-534">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="166d8-535">可以实例化一个复数，通过调用基于其极坐标，而不是笛卡尔坐标<xref:System.Numerics.Complex.FromPolarCoordinates%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-535">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="166d8-536">若要从弧度阶段转换度，则将其乘 180 /<xref:System.Math.PI?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-536">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-537">下面的示例使用<xref:System.Numerics.Complex.FromPolarCoordinates%2A>方法可实例化一个复数，基于其极坐标，，然后显示的值其<xref:System.Numerics.Complex.Magnitude%2A>和<xref:System.Numerics.Complex.Phase%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="166d8-537">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="166d8-538">返回指定复数的指定次幂。</span><span class="sxs-lookup"><span data-stu-id="166d8-538">Returns a specified complex number raised to a specified power.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-539">要对其求幂的复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-539">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="166d8-540">指定幂的双精度浮点数。</span><span class="sxs-lookup"><span data-stu-id="166d8-540">A double-precision floating-point number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="166d8-541">返回指定复数的由双精度浮点数指定的次幂。</span><span class="sxs-lookup"><span data-stu-id="166d8-541">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="166d8-542">复数 <paramref name="value" /> 的 <paramref name="power" /> 次幂。</span><span class="sxs-lookup"><span data-stu-id="166d8-542">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-543">如果 `value` 为 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>，则此方法返回 <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-543">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="166d8-544">对于其他值，如果`power`为 0，则此方法返回<xref:System.Numerics.Complex.One?displayProperty=nameWithType>，并且如果`power`为 1，它将返回`value`。</span><span class="sxs-lookup"><span data-stu-id="166d8-544">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="166d8-545">此方法对应于<xref:System.Math.Pow%2A?displayProperty=nameWithType>基元数值类型的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-545">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-546">下面的示例演示使用一个复杂的数字和指数的幂值范围为-1 到 10。</span><span class="sxs-lookup"><span data-stu-id="166d8-546">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-547">要对其求幂的复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-547">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="166d8-548">指定幂的复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-548">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="166d8-549">返回指定复数的由复数指定的次幂。</span><span class="sxs-lookup"><span data-stu-id="166d8-549">Returns a specified complex number raised to a power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-550">复数 <paramref name="value" /> 的 <paramref name="power" /> 次幂。</span><span class="sxs-lookup"><span data-stu-id="166d8-550">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="166d8-551">获取当前 <see cref="T:System.Numerics.Complex" /> 对象的实部。</span><span class="sxs-lookup"><span data-stu-id="166d8-551">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="166d8-552">复数的实部。</span><span class="sxs-lookup"><span data-stu-id="166d8-552">The real component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-553">给定复数 a + bi、<xref:System.Numerics.Complex.Real%2A>属性返回的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-553">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-554">下面的示例实例化的数组<xref:System.Numerics.Complex>对象，并显示每个窗体的实部和虚部组件 a + bi。</span><span class="sxs-lookup"><span data-stu-id="166d8-554">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-555">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-555">A complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-556">返回复数的乘法倒数。</span><span class="sxs-lookup"><span data-stu-id="166d8-556">Returns the multiplicative inverse of a complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-557"><paramref name="value" /> 的倒数。</span><span class="sxs-lookup"><span data-stu-id="166d8-557">The reciprocal of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-558">相互或乘法倒数，大量*x*是一个数字*y*其中*x*乘以*y*将生成 1。</span><span class="sxs-lookup"><span data-stu-id="166d8-558">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="166d8-559">复数的倒数是生成的复数<xref:System.Numerics.Complex.One?displayProperty=nameWithType>两个数相乘时。</span><span class="sxs-lookup"><span data-stu-id="166d8-559">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="166d8-560">如果 a + bi，由表示复数，由表达式表示其相互 / (<sup>2</sup>+ b<sup>2</sup>) +-b / (<sup>2</sup> + b<sup>2</sup>)。</span><span class="sxs-lookup"><span data-stu-id="166d8-560">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="166d8-561">如果值为<xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>，该方法返回<xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-561">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="166d8-562">否则，它将返回该表达式的结果<xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`。</span><span class="sxs-lookup"><span data-stu-id="166d8-562">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-563">下面的示例使用<xref:System.Numerics.Complex.Reciprocal%2A>方法来计算多个复数的相应值。</span><span class="sxs-lookup"><span data-stu-id="166d8-563">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="166d8-564">它还演示了一个复杂的数字乘以其相互的结果是<xref:System.Numerics.Complex.One?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-564">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-565">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-565">A complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-566">返回指定复数的正弦值。</span><span class="sxs-lookup"><span data-stu-id="166d8-566">Returns the sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-567"><paramref name="value" /> 的正弦值。</span><span class="sxs-lookup"><span data-stu-id="166d8-567">The sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-568"><xref:System.Numerics.Complex.Sin%2A>复数的方法都对应<xref:System.Math.Sin%2A?displayProperty=nameWithType>实数的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-568">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="166d8-569"><xref:System.Numerics.Complex.Sin%2A>方法使用以下公式来计算复数的正弦值 a + bi:</span><span class="sxs-lookup"><span data-stu-id="166d8-569">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="166d8-570">(<xref:System.Math.Sin%2A>（a） * <xref:System.Math.Cosh%2A>（b)， <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="166d8-570">(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-571">下面的示例演示<xref:System.Numerics.Complex.Sin%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-571">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="166d8-572">它显示该通过返回的值<xref:System.Numerics.Complex.Asin%2A>方法<xref:System.Numerics.Complex.Sin%2A>方法返回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="166d8-572">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-573">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-573">A complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-574">返回指定复数的双曲正弦值。</span><span class="sxs-lookup"><span data-stu-id="166d8-574">Returns the hyperbolic sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-575"><paramref name="value" /> 的双曲正弦值。</span><span class="sxs-lookup"><span data-stu-id="166d8-575">The hyperbolic sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-576"><xref:System.Numerics.Complex.Sinh%2A>复数的方法都对应<xref:System.Math.Sinh%2A?displayProperty=nameWithType>实数的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-576">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="166d8-577"><xref:System.Numerics.Complex.Sinh%2A>方法使用以下公式来计算复数的双曲正弦值 a + bi:</span><span class="sxs-lookup"><span data-stu-id="166d8-577">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="166d8-578">(<xref:System.Math.Sinh%2A>（a） * <xref:System.Math.Cos%2A>（b)， <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="166d8-578">(<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-579">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-579">A complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-580">返回指定复数的平方根。</span><span class="sxs-lookup"><span data-stu-id="166d8-580">Returns the square root of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-581"><paramref name="value" /> 的平方根。</span><span class="sxs-lookup"><span data-stu-id="166d8-581">The square root of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-582">复数的平方根`value`通过使用以下公式计算：</span><span class="sxs-lookup"><span data-stu-id="166d8-582">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="166d8-583"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span><span class="sxs-lookup"><span data-stu-id="166d8-583"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="166d8-584"><xref:System.Numerics.Complex.Sqrt%2A>复数的方法都对应<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>实数的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-584">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="166d8-585">要从中减去的值（被减数）。</span><span class="sxs-lookup"><span data-stu-id="166d8-585">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="166d8-586">要减去的值（减数）。</span><span class="sxs-lookup"><span data-stu-id="166d8-586">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="166d8-587">从一个复数中减去另一个复数并返回结果。</span><span class="sxs-lookup"><span data-stu-id="166d8-587">Subtracts one complex number from another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="166d8-588"><paramref name="right" /> 减 <paramref name="left" /> 所得的结果。</span><span class="sxs-lookup"><span data-stu-id="166d8-588">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-589">减法的复数，c + di，从另一个复数 + bi，采用以下形式：</span><span class="sxs-lookup"><span data-stu-id="166d8-589">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="166d8-590">(a - c) + (b - d)i</span><span class="sxs-lookup"><span data-stu-id="166d8-590">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="166d8-591">如果该方法调用结果实部或虚部溢出，该组件的值为<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>或<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="166d8-591">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="166d8-592">不支持自定义运算符的语言可以使用<xref:System.Numerics.Complex.Subtract%2A>方法来执行减法使用复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-592">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Subtract%2A> method to perform subtraction using complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-593">下面的示例中减去从复数数组中的每个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-593">The following example subtracts each complex number in an array from a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-594">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-594">A complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-595">返回指定复数的正切值。</span><span class="sxs-lookup"><span data-stu-id="166d8-595">Returns the tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-596"><paramref name="value" /> 的正切值。</span><span class="sxs-lookup"><span data-stu-id="166d8-596">The tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-597"><xref:System.Numerics.Complex.Tan%2A>复数的方法都对应<xref:System.Math.Tan%2A?displayProperty=nameWithType>实数的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-597">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="166d8-598"><xref:System.Numerics.Complex.Tan%2A>方法使用以下公式来计算复数的正切值`value`:</span><span class="sxs-lookup"><span data-stu-id="166d8-598">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="166d8-599"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="166d8-599"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-600">下面的示例演示<xref:System.Numerics.Complex.Tan%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-600">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="166d8-601">它显示该通过返回的值<xref:System.Numerics.Complex.Atan%2A>方法<xref:System.Numerics.Complex.Tan%2A>方法返回原始<xref:System.Numerics.Complex>值。</span><span class="sxs-lookup"><span data-stu-id="166d8-601">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="166d8-602">一个复数。</span><span class="sxs-lookup"><span data-stu-id="166d8-602">A complex number.</span></span></param>
        <summary><span data-ttu-id="166d8-603">返回指定复数的双曲正切值。</span><span class="sxs-lookup"><span data-stu-id="166d8-603">Returns the hyperbolic tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="166d8-604"><paramref name="value" /> 的双曲正切值。</span><span class="sxs-lookup"><span data-stu-id="166d8-604">The hyperbolic tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-605"><xref:System.Numerics.Complex.Tanh%2A>复数的方法都对应<xref:System.Math.Tanh%2A?displayProperty=nameWithType>实数的方法。</span><span class="sxs-lookup"><span data-stu-id="166d8-605">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="166d8-606"><xref:System.Numerics.Complex.Tanh%2A>方法使用以下公式来计算复数的双曲正切值`value`:</span><span class="sxs-lookup"><span data-stu-id="166d8-606">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="166d8-607"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="166d8-607"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="166d8-608">将复数的值转换为其等效的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="166d8-608">Converts the value of a complex number to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="166d8-609">将当前复数的值转换为其采用笛卡尔形式的等效字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="166d8-609">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span></span></summary>
        <returns><span data-ttu-id="166d8-610">当前实例的采用笛卡尔形式的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="166d8-610">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-611">默认字符串表示一个复数形式显示在窗体中使用笛卡尔坐标数`(`  `,` *b*`)`，其中是复数的实数部分和*b*是其虚数部分。</span><span class="sxs-lookup"><span data-stu-id="166d8-611">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="166d8-612">同时和*b*使用常规格式说明符 ("G") 和当前系统区域性的约定进行格式化。</span><span class="sxs-lookup"><span data-stu-id="166d8-612">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-613">下面的示例显示几个复杂数字的字符串表示。</span><span class="sxs-lookup"><span data-stu-id="166d8-613">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="166d8-614">输出使用英语-美国 ("EN-US") 区域性，即，在这种情况下，当前系统区域性的格式设置约定。</span><span class="sxs-lookup"><span data-stu-id="166d8-614">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="166d8-615">一个提供区域性特定的格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-615">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="166d8-616">使用指定的区域性特定格式设置信息，将当前复数的值转换为其采用笛卡尔形式的等效字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="166d8-616">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="166d8-617">由 <paramref name="provider" /> 指定的当前实例的采用笛卡尔形式的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="166d8-617">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-618">字符串表示此方法返回的复数形式显示在窗体中使用笛卡尔坐标数`(`  `,` *b*`)`，其中是复数的实数部分和*b*是其虚数部分。</span><span class="sxs-lookup"><span data-stu-id="166d8-618">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="166d8-619">同时和*b*使用常规格式说明符 ("G") 和由定义区域性的约定进行格式化`provider`。</span><span class="sxs-lookup"><span data-stu-id="166d8-619">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="166d8-620">`provider`参数是<xref:System.IFormatProvider>实现。</span><span class="sxs-lookup"><span data-stu-id="166d8-620">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="166d8-621">其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.NumberFormatInfo>提供的实数和返回字符串中的虚数格式的区域性特定信息的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-621">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="166d8-622">如果`provider`是`null`，则返回的字符串格式都是使用<xref:System.Globalization.NumberFormatInfo>当前区域性的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-622">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="166d8-623">`provider`参数可以是以下之一：</span><span class="sxs-lookup"><span data-stu-id="166d8-623">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="166d8-624">A<xref:System.Globalization.CultureInfo>表示的区域性的提供格式设置信息的对象</span><span class="sxs-lookup"><span data-stu-id="166d8-624">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="166d8-625"><xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-625">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="166d8-626">实现一个自定义对象<xref:System.IFormatProvider>接口。</span><span class="sxs-lookup"><span data-stu-id="166d8-626">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="166d8-627">其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-627">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-628">下面的示例显示几个复杂数字的字符串表示。</span><span class="sxs-lookup"><span data-stu-id="166d8-628">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="166d8-629">结果使用英语-美国 ("EN-US") 和法语-法国 ("FR-FR") 区域性的格式设置约定。</span><span class="sxs-lookup"><span data-stu-id="166d8-629">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="166d8-630">标准或自定义的数值格式字符串。</span><span class="sxs-lookup"><span data-stu-id="166d8-630">A standard or custom numeric format string.</span></span></param>
        <summary><span data-ttu-id="166d8-631">通过对当前复数的实部和虚部使用指定格式，将它的值转换为其采用笛卡尔形式的等效字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="166d8-631">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="166d8-632">当前实例的采用笛卡尔形式的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="166d8-632">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-633">字符串表示此方法返回的复数形式显示在窗体中使用笛卡尔坐标数`(`  `,` *b*`)`，其中是复数的实数部分和*b*是其虚数部分。</span><span class="sxs-lookup"><span data-stu-id="166d8-633">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="166d8-634">同时和*b*都使用指定的格式字符串格式化`format`。</span><span class="sxs-lookup"><span data-stu-id="166d8-634">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="166d8-635">`format`参数可以是任何有效的标准数字格式说明符或自定义数字格式说明符的任意组合。</span><span class="sxs-lookup"><span data-stu-id="166d8-635">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="166d8-636">如果`format`等同于<xref:System.String.Empty?displayProperty=nameWithType>或`null`，使用常规格式说明符 ("G") 格式表示复数的实部和虚部组成部分。</span><span class="sxs-lookup"><span data-stu-id="166d8-636">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="166d8-637">如果`format`是任何其他值，该方法将引发<xref:System.FormatException>。</span><span class="sxs-lookup"><span data-stu-id="166d8-637">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="166d8-638">.NET Framework 提供了广泛的格式设置支持，以下主题中的更详细地介绍：</span><span class="sxs-lookup"><span data-stu-id="166d8-638">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="166d8-639">有关数字格式字符串的详细信息，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="166d8-639">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="166d8-640">有关.NET Framework 中的格式设置的详细信息，请参阅[格式化类型](~/docs/standard/base-types/formatting-types.md)。</span><span class="sxs-lookup"><span data-stu-id="166d8-640">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="166d8-641">返回字符串的格式由<xref:System.Globalization.NumberFormatInfo>为当前区域性的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-641">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="166d8-642">具体取决于`format`参数，此对象控制输出字符串中的负号、 组分隔符和小数点符号等符号。</span><span class="sxs-lookup"><span data-stu-id="166d8-642">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="166d8-643">若要提供区域性而非当前区域性的格式设置信息，请调用<xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29>重载。</span><span class="sxs-lookup"><span data-stu-id="166d8-643">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-644">下面的示例初始化一个复杂的数字，并显示它使用多个标准格式字符串。</span><span class="sxs-lookup"><span data-stu-id="166d8-644">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="166d8-645"><paramref name="format" /> 不是有效的格式字符串。</span><span class="sxs-lookup"><span data-stu-id="166d8-645"><paramref name="format" /> is not a valid format string.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="166d8-646">标准或自定义的数值格式字符串。</span><span class="sxs-lookup"><span data-stu-id="166d8-646">A standard or custom numeric format string.</span></span></param>
        <param name="provider"><span data-ttu-id="166d8-647">一个提供区域性特定的格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-647">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="166d8-648">通过对当前复数的实部和虚部使用指定格式和区域性特定格式信息，将它的值转换为其采用笛卡尔形式的等效字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="166d8-648">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="166d8-649">由 <paramref name="format" /> 和 <paramref name="provider" /> 指定的当前实例的采用笛卡尔形式的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="166d8-649">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-650">字符串表示此方法返回的复数形式显示在窗体中使用笛卡尔坐标数`(`  `,` *b*`)`，其中是复数的实数部分和*b*是其虚数部分。</span><span class="sxs-lookup"><span data-stu-id="166d8-650">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="166d8-651">同时和*b*都使用指定的格式字符串格式化`format`。</span><span class="sxs-lookup"><span data-stu-id="166d8-651">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="166d8-652">`format`参数可以是任何有效的标准数字格式说明符或自定义数字格式说明符的任意组合。</span><span class="sxs-lookup"><span data-stu-id="166d8-652">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="166d8-653">如果`format`等同于<xref:System.String.Empty?displayProperty=nameWithType>或`null`，使用常规格式说明符 ("G") 格式表示复数的实部和虚部组成部分。</span><span class="sxs-lookup"><span data-stu-id="166d8-653">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="166d8-654">如果`format`是任何其他值，该方法将引发<xref:System.FormatException>。</span><span class="sxs-lookup"><span data-stu-id="166d8-654">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="166d8-655">.NET Framework 提供了广泛的格式设置支持，以下主题中的更详细地介绍：</span><span class="sxs-lookup"><span data-stu-id="166d8-655">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="166d8-656">有关数字格式字符串的详细信息，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="166d8-656">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="166d8-657">有关.NET Framework 中的格式设置的详细信息，请参阅[格式化类型](~/docs/standard/base-types/formatting-types.md)。</span><span class="sxs-lookup"><span data-stu-id="166d8-657">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="166d8-658">`provider`参数是<xref:System.IFormatProvider>实现。</span><span class="sxs-lookup"><span data-stu-id="166d8-658">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="166d8-659">其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.NumberFormatInfo>提供的实数和返回字符串中的虚数格式的区域性特定信息的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-659">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="166d8-660">具体取决于`format`参数，此对象控制输出字符串中的负号、 组分隔符和小数点符号等符号。</span><span class="sxs-lookup"><span data-stu-id="166d8-660">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="166d8-661">如果`provider`是`null`，则返回的字符串格式都是使用<xref:System.Globalization.NumberFormatInfo>当前区域性的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-661">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="166d8-662">`provider`参数可以是以下之一：</span><span class="sxs-lookup"><span data-stu-id="166d8-662">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="166d8-663">A<xref:System.Globalization.CultureInfo>表示的区域性的提供格式设置信息的对象</span><span class="sxs-lookup"><span data-stu-id="166d8-663">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="166d8-664"><xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-664">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="166d8-665">实现一个自定义对象<xref:System.IFormatProvider>接口。</span><span class="sxs-lookup"><span data-stu-id="166d8-665">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="166d8-666">其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-666">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-667">下面的示例创建的复数，数组并显示每个使用几个标准格式字符串，以及<xref:System.Globalization.CultureInfo>表示英语-美国 ("EN-US") 和法语-法国 ("FR-FR") 区域性的对象。</span><span class="sxs-lookup"><span data-stu-id="166d8-667">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="166d8-668"><paramref name="format" /> 不是有效的格式字符串。</span><span class="sxs-lookup"><span data-stu-id="166d8-668"><paramref name="format" /> is not a valid format string.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="166d8-669">返回新的 <see cref="T:System.Numerics.Complex" /> 实例，其实数和虚数都等于零。</span><span class="sxs-lookup"><span data-stu-id="166d8-669">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="166d8-670"><xref:System.Numerics.Complex.Zero>属性最常用于比较<xref:System.Numerics.Complex>为零的值。</span><span class="sxs-lookup"><span data-stu-id="166d8-670">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="166d8-671">下面的示例实例化<xref:System.Numerics.Complex>值使用<xref:System.Numerics.Complex.Zero>属性。</span><span class="sxs-lookup"><span data-stu-id="166d8-671">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="166d8-672">然后，它比较另一个值，通过调用实例化到此值<xref:System.Numerics.Complex>等于零实部和虚部等于零的构造函数。</span><span class="sxs-lookup"><span data-stu-id="166d8-672">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="166d8-673">如示例输出所示，两个值相等。</span><span class="sxs-lookup"><span data-stu-id="166d8-673">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>