<Type Name="StackOverflowException" FullName="System.StackOverflowException">
  <TypeSignature Language="C#" Value="public sealed class StackOverflowException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit StackOverflowException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.StackOverflowException" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StackOverflowException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class StackOverflowException sealed : SystemException" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="bd416-101">因包含的嵌套方法调用过多而导致执行堆栈溢出时引发的异常。</span><span class="sxs-lookup"><span data-stu-id="bd416-101">The exception that is thrown when the execution stack overflows because it contains too many nested method calls.</span></span> <span data-ttu-id="bd416-102">此类不能被继承。</span><span class="sxs-lookup"><span data-stu-id="bd416-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd416-103"><xref:System.StackOverflowException> 执行堆栈溢出发生错误时引发，通常发生非常深度或无限递归。</span><span class="sxs-lookup"><span data-stu-id="bd416-103"><xref:System.StackOverflowException> is thrown for execution stack overflow errors, typically in case of a very deep or unbounded recursion.</span></span>  
  
 <span data-ttu-id="bd416-104"><xref:System.StackOverflowException> 使用 HRESULT COR_E_STACKOVERFLOW，其值 0x800703E9。</span><span class="sxs-lookup"><span data-stu-id="bd416-104"><xref:System.StackOverflowException> uses the HRESULT COR_E_STACKOVERFLOW, which has the value 0x800703E9.</span></span> <span data-ttu-id="bd416-105"><xref:System.Reflection.Emit.OpCodes.Localloc>中间语言 (IL) 指令将引发<xref:System.StackOverflowException>。</span><span class="sxs-lookup"><span data-stu-id="bd416-105">The <xref:System.Reflection.Emit.OpCodes.Localloc> intermediate language (IL) instruction throws <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="bd416-106">有关的初始属性值的列表<xref:System.StackOverflowException>对象，请参阅<xref:System.StackOverflowException.%23ctor%2A>构造函数。</span><span class="sxs-lookup"><span data-stu-id="bd416-106">For a list of initial property values for a <xref:System.StackOverflowException> object, see the <xref:System.StackOverflowException.%23ctor%2A> constructors.</span></span>  
  
## <a name="version-considerations"></a><span data-ttu-id="bd416-107">版本注意事项</span><span class="sxs-lookup"><span data-stu-id="bd416-107">Version Considerations</span></span>  
 <span data-ttu-id="bd416-108">在.NET Framework 1.0 和 1.1 中，你无法捕获<xref:System.StackOverflowException>（例如，若要从此不受限制的递归） 的对象。</span><span class="sxs-lookup"><span data-stu-id="bd416-108">In the .NET Framework 1.0 and 1.1, you could catch a <xref:System.StackOverflowException> object (for example, to recover from unbounded recursion).</span></span> <span data-ttu-id="bd416-109">从.NET Framework 2.0 开始，你无法捕捉<xref:System.StackOverflowException>对象`try` / `catch`块，并且相应的进程默认情况下将会终止。</span><span class="sxs-lookup"><span data-stu-id="bd416-109">Starting with the .NET Framework 2.0, you can’t catch a <xref:System.StackOverflowException> object with a `try`/`catch` block, and the corresponding process is terminated by default.</span></span> <span data-ttu-id="bd416-110">因此，应编写代码来检测和防止堆栈溢出。</span><span class="sxs-lookup"><span data-stu-id="bd416-110">Consequently, you should write your code to detect and prevent a stack overflow.</span></span> <span data-ttu-id="bd416-111">例如，如果你的应用程序依赖于递归，用于计数器或状态条件终止递归循环。</span><span class="sxs-lookup"><span data-stu-id="bd416-111">For example, if your app depends on recursion, use a counter or a state condition to terminate the recursive loop.</span></span> <span data-ttu-id="bd416-112">下面的示例使用计数器以确保递归数调用`Execute`方法不能超过最多由 MAX_RECURSIVE_CALLS 常量定义。</span><span class="sxs-lookup"><span data-stu-id="bd416-112">The following example uses a counter to ensure that the number of recursive calls to the `Execute` method do not exceed a maximum defined by the MAX_RECURSIVE_CALLS constant.</span></span>  
  
 [!code-csharp[System.StackOverflowException.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.stackoverflowexception.class/cs/example1a.cs#1)]
 [!code-vb[System.StackOverflowException.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.stackoverflowexception.class/vb/example1a.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="bd416-113">应用<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>属性引发的方法为<xref:System.StackOverflowException>不起作用。</span><span class="sxs-lookup"><span data-stu-id="bd416-113">Applying the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribute to a method that throws a <xref:System.StackOverflowException> has no effect.</span></span> <span data-ttu-id="bd416-114">仍然无法处理从用户代码的异常。</span><span class="sxs-lookup"><span data-stu-id="bd416-114">You still cannot handle the exception from user code.</span></span>  
  
 <span data-ttu-id="bd416-115">如果你的应用程序承载公共语言运行时 (CLR)，它可以指定 CLR 应卸载应用程序域，堆栈溢出异常时发生，并让相应的进程继续。</span><span class="sxs-lookup"><span data-stu-id="bd416-115">If your app hosts the common language runtime (CLR), it can specify that the CLR should unload the application domain where the stack overflow exception occurs and let the corresponding process continue.</span></span> <span data-ttu-id="bd416-116">有关详细信息，请参阅[ICLRPolicyManager 接口](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-interface.md)。</span><span class="sxs-lookup"><span data-stu-id="bd416-116">For more information, see [ICLRPolicyManager Interface](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-interface.md).</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bd416-117">初始化 <see cref="T:System.StackOverflowException" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="bd416-117">Initializes a new instance of the <see cref="T:System.StackOverflowException" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StackOverflowException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StackOverflowException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StackOverflowException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bd416-118">初始化 <see cref="T:System.StackOverflowException" /> 类的新实例，将新实例的 <see cref="P:System.Exception.Message" /> 属性设置为系统提供的描述错误的消息，如“所请求的操作导致堆栈溢出”。</span><span class="sxs-lookup"><span data-stu-id="bd416-118">Initializes a new instance of the <see cref="T:System.StackOverflowException" /> class, setting the <see cref="P:System.Exception.Message" /> property of the new instance to a system-supplied message that describes the error, such as "The requested operation caused a stack overflow."</span></span> <span data-ttu-id="bd416-119">此消息将当前系统区域性考虑在内。</span><span class="sxs-lookup"><span data-stu-id="bd416-119">This message takes into account the current system culture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd416-120">下表显示 <xref:System.StackOverflowException> 的实例的初始属性值。</span><span class="sxs-lookup"><span data-stu-id="bd416-120">The following table shows the initial property values for an instance of <xref:System.StackOverflowException>.</span></span>  
  
|<span data-ttu-id="bd416-121">Property</span><span class="sxs-lookup"><span data-stu-id="bd416-121">Property</span></span>|<span data-ttu-id="bd416-122">“值”</span><span class="sxs-lookup"><span data-stu-id="bd416-122">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="bd416-123">`null`。</span><span class="sxs-lookup"><span data-stu-id="bd416-123">`null`.</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="bd416-124">本地化的错误消息字符串。</span><span class="sxs-lookup"><span data-stu-id="bd416-124">The localized error message string.</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StackOverflowException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StackOverflowException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StackOverflowException(System::String ^ message);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="bd416-125">描述该错误的 <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="bd416-125">A <see cref="T:System.String" /> that describes the error.</span></span> <span data-ttu-id="bd416-126">消息的内容被设计为人可理解的形式。</span><span class="sxs-lookup"><span data-stu-id="bd416-126">The content of message is intended to be understood by humans.</span></span> <span data-ttu-id="bd416-127">此构造函数的调用方需要确保此字符串已针对当前系统区域性进行了本地化。</span><span class="sxs-lookup"><span data-stu-id="bd416-127">The caller of this constructor is required to ensure that this string has been localized for the current system culture.</span></span></param>
        <summary><span data-ttu-id="bd416-128">用指定的错误消息初始化 <see cref="T:System.StackOverflowException" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="bd416-128">Initializes a new instance of the <see cref="T:System.StackOverflowException" /> class with a specified error message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd416-129">下表显示 <xref:System.StackOverflowException> 的实例的初始属性值。</span><span class="sxs-lookup"><span data-stu-id="bd416-129">The following table shows the initial property values for an instance of <xref:System.StackOverflowException>.</span></span>  
  
|<span data-ttu-id="bd416-130">Property</span><span class="sxs-lookup"><span data-stu-id="bd416-130">Property</span></span>|<span data-ttu-id="bd416-131">“值”</span><span class="sxs-lookup"><span data-stu-id="bd416-131">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="bd416-132">空引用（在 Visual Basic 中为 `Nothing`）。</span><span class="sxs-lookup"><span data-stu-id="bd416-132">A null reference (`Nothing` in Visual Basic).</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="bd416-133">错误消息字符串。</span><span class="sxs-lookup"><span data-stu-id="bd416-133">The error message string.</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StackOverflowException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.StackOverflowException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StackOverflowException(System::String ^ message, Exception ^ innerException);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="bd416-134">解释异常原因的错误消息。</span><span class="sxs-lookup"><span data-stu-id="bd416-134">The error message that explains the reason for the exception.</span></span></param>
        <param name="innerException"><span data-ttu-id="bd416-135">导致当前异常的异常。</span><span class="sxs-lookup"><span data-stu-id="bd416-135">The exception that is the cause of the current exception.</span></span> <span data-ttu-id="bd416-136">如果 <c>innerException</c> 参数不是空引用（在 Visual Basic 中为 <see langword="Nothing" />），则在处理内部异常的 <see langword="catch" /> 块中引发当前异常。</span><span class="sxs-lookup"><span data-stu-id="bd416-136">If the <c>innerException</c> parameter is not a null reference (<see langword="Nothing" /> in Visual Basic), the current exception is raised in a <see langword="catch" /> block that handles the inner exception.</span></span></param>
        <summary><span data-ttu-id="bd416-137">使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.StackOverflowException" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="bd416-137">Initializes a new instance of the <see cref="T:System.StackOverflowException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bd416-138">因前一个异常而直接引发的异常可以在 <xref:System.Exception.InnerException%2A> 属性中包含对前一个异常的引用。</span><span class="sxs-lookup"><span data-stu-id="bd416-138">An exception that is thrown as a direct result of a previous exception can include a reference to the previous exception in the <xref:System.Exception.InnerException%2A> property.</span></span> <span data-ttu-id="bd416-139"><xref:System.Exception.InnerException%2A> 属性返回传递到构造函数中的相同值，或者如果 `Nothing` 属性不向构造函数提供内部异常值，则为空引用（在 Visual Basic 中为 <xref:System.Exception.InnerException%2A>）。</span><span class="sxs-lookup"><span data-stu-id="bd416-139">The <xref:System.Exception.InnerException%2A> property returns the same value that is passed into the constructor, or a null reference (`Nothing` in Visual Basic) if the <xref:System.Exception.InnerException%2A> property does not supply the inner exception value to the constructor.</span></span>  
  
 <span data-ttu-id="bd416-140">下表显示 <xref:System.StackOverflowException> 的实例的初始属性值。</span><span class="sxs-lookup"><span data-stu-id="bd416-140">The following table shows the initial property values for an instance of <xref:System.StackOverflowException>.</span></span>  
  
|<span data-ttu-id="bd416-141">Property</span><span class="sxs-lookup"><span data-stu-id="bd416-141">Property</span></span>|<span data-ttu-id="bd416-142">“值”</span><span class="sxs-lookup"><span data-stu-id="bd416-142">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="bd416-143">内部异常引用。</span><span class="sxs-lookup"><span data-stu-id="bd416-143">The inner exception reference.</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="bd416-144">错误消息字符串。</span><span class="sxs-lookup"><span data-stu-id="bd416-144">The error message string.</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
      </Docs>
    </Member>
  </Members>
</Type>