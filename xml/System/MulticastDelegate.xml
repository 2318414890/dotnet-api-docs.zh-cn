<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MulticastDelegate.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac568fe57d35963ff07229ce4e905392ba33a08e1b2.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">68fe57d35963ff07229ce4e905392ba33a08e1b2</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.MulticastDelegate">
          <source>Represents a multicast delegate; that is, a delegate that can have more than one element in its invocation list.</source>
          <target state="translated">表示多路广播委托；即，其调用列表中可以拥有多个元素的委托。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source><ph id="ph1">&lt;xref:System.MulticastDelegate&gt;</ph> is a special class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MulticastDelegate&gt;</ph> 是一个特殊的类。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>Compilers and other tools can derive from this class, but you cannot derive from it explicitly.</source>
          <target state="translated">编译器和其他工具可以派生自此类，但不能从它派生显式。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>The same is true of the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class.</source>
          <target state="translated">这同样适用的<ph id="ph1">&lt;xref:System.Delegate&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>In addition to the methods that delegate types inherit from <ph id="ph1">&lt;xref:System.MulticastDelegate&gt;</ph>, the common language runtime provides two special methods: <ph id="ph2">`BeginInvoke`</ph> and <ph id="ph3">`EndInvoke`</ph>.</source>
          <target state="translated">除了委托类型的方法继承<ph id="ph1">&lt;xref:System.MulticastDelegate&gt;</ph>，公共语言运行时提供两种特殊的方法：<ph id="ph2">`BeginInvoke`</ph>和<ph id="ph3">`EndInvoke`</ph>。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>For more information about these methods, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">有关这些方法的详细信息，请参阅<bpt id="p1">[</bpt>异步调用同步方法<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>A <ph id="ph1">&lt;xref:System.MulticastDelegate&gt;</ph> has a linked list of delegates, called an invocation list, consisting of one or more elements.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.MulticastDelegate&gt;</ph>具有的委托，调用的调用列表，其中包含的一个或多个元素的链接的列表。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>When a multicast delegate is invoked, the delegates in the invocation list are called synchronously in the order in which they appear.</source>
          <target state="translated">调用多路广播的委托时，调用列表中的委托是同步调用它们的出现顺序。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>If an error occurs during execution of the list then an exception is thrown.</source>
          <target state="translated">如果该列表的执行过程中发生错误将引发异常。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>The following example defines a class, <ph id="ph1">`StringContainer`</ph>, which includes a collection of strings.</source>
          <target state="translated">下面的示例定义了一个类<ph id="ph1">`StringContainer`</ph>，其中包括一个字符串集合。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>One of its members is the <ph id="ph1">`CheckAndDisplayDelegate`</ph> delegate, which is used to display strings stored in a <ph id="ph2">`StringContainer`</ph> object that satisfy particular criteria.</source>
          <target state="translated">其成员之一是<ph id="ph1">`CheckAndDisplayDelegate`</ph>委托，用于显示字符串存储在<ph id="ph2">`StringContainer`</ph>满足特定条件的对象。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>The delegate takes a single string as a parameter and returns <ph id="ph1">`void`</ph> (or, in Visual Basic, it's a <ph id="ph2">`Sub`</ph> procedure).</source>
          <target state="translated">委托采用单个字符串作为参数并返回<ph id="ph1">`void`</ph>(或在 Visual Basic 中，它是<ph id="ph2">`Sub`</ph>过程)。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>It also includes a method, <ph id="ph1">`DisplayAllQualified`</ph>, that has a single parameter, a <ph id="ph2">`CheckAndDisplayDelegate`</ph> delegate.</source>
          <target state="translated">它还包括一种方法， <ph id="ph1">`DisplayAllQualified`</ph>，具有单个参数，<ph id="ph2">`CheckAndDisplayDelegate`</ph>委托。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>This allows the method to be called and to display a set of strings that are filtered based on the methods that the delegate contains.</source>
          <target state="translated">这使被调用的方法，并且根据委托中包含的方法来显示一组进行筛选的字符串。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>The example also defines a utility class, <ph id="ph1">`StringExtensions`</ph>, that has two methods:</source>
          <target state="translated">该示例还定义了一个实用工具类<ph id="ph1">`StringExtensions`</ph>，有两种方法：</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source><ph id="ph1">`ConStart`</ph>, which displays strings that begin with a consonant.</source>
          <target state="translated"><ph id="ph1">`ConStart`</ph>它会显示以辅音字母开头的字符串。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source><ph id="ph1">`VowelStart`</ph>, which displays strings that begin with a vowel.</source>
          <target state="translated"><ph id="ph1">`VowelStart`</ph>它会显示开头元音的字符串。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>Note that both methods include a single string parameter and return <ph id="ph1">`void`</ph>.</source>
          <target state="translated">请注意，这两种方法包括单个字符串参数，并且返回<ph id="ph1">`void`</ph>。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>In other words, both methods can be assigned to the  <ph id="ph1">`CheckAndDisplayDelegate`</ph> delegate.</source>
          <target state="translated">换而言之，这两种方法可以分配给<ph id="ph1">`CheckAndDisplayDelegate`</ph>委托。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>The <ph id="ph1">`Test.Main`</ph> method is the application entry point.</source>
          <target state="translated"><ph id="ph1">`Test.Main`</ph>方法是应用程序入口点。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>It instantiates a <ph id="ph1">`StringContainer`</ph> object, populates it with strings, and creates two <ph id="ph2">`CheckAndDisplayDelegate`</ph> delegates, <ph id="ph3">`conStart`</ph> and <ph id="ph4">`vowelStart`</ph>, that invoke a single method.</source>
          <target state="translated">它实例化<ph id="ph1">`StringContainer`</ph>对象，其中填充字符串，并创建两个<ph id="ph2">`CheckAndDisplayDelegate`</ph>委托，<ph id="ph3">`conStart`</ph>和<ph id="ph4">`vowelStart`</ph>，调用单个方法。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Delegate.Combine%2A?displayProperty=nameWithType&gt;</ph> method to create the <ph id="ph2">`multipleDelegates`</ph> delegate, which initially contains the <ph id="ph3">`ConStart`</ph> and  <ph id="ph4">`VowelStart`</ph> delegates.</source>
          <target state="translated">然后，它调用<ph id="ph1">&lt;xref:System.Delegate.Combine%2A?displayProperty=nameWithType&gt;</ph>方法来创建<ph id="ph2">`multipleDelegates`</ph>委托，它最初包含<ph id="ph3">`ConStart`</ph>和<ph id="ph4">`VowelStart`</ph>委托。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>Note that when the <ph id="ph1">`multipleDelegates`</ph> delegate is invoked, it displays all the strings in the collection in their original order.</source>
          <target state="translated">请注意，当<ph id="ph1">`multipleDelegates`</ph>调用委托，它显示在其原始顺序集合中的所有字符串。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>This is because each letter is passed separately to each delegate, and each letter meets the filtering criteria of only one of the two delegates.</source>
          <target state="translated">这是因为每个字母单独传递给每个委托，并且每个字母满足筛选条件的两个委托之一。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>Finally, after calls to <ph id="ph1">&lt;xref:System.Delegate.Remove%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Delegate.Combine%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`multipleDelegates`</ph> contains two <ph id="ph4">`conStart`</ph> delegates.</source>
          <target state="translated">最后，在调用后<ph id="ph1">&lt;xref:System.Delegate.Remove%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Delegate.Combine%2A?displayProperty=nameWithType&gt;</ph>，<ph id="ph3">`multipleDelegates`</ph>包含两个<ph id="ph4">`conStart`</ph>委托。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.MulticastDelegate">
          <source>When it is invoked, each string in the <ph id="ph1">`StringContainer`</ph> object is displayed twice.</source>
          <target state="translated">调用时，在每个字符串<ph id="ph1">`StringContainer`</ph>两次显示对象。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="T:System.MulticastDelegate">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.#ctor(System.Object,System.String)">
          <source>The object on which <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> is defined.</source>
          <target state="translated">在其上定义 <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> 的对象。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.#ctor(System.Object,System.String)">
          <source>The name of the method for which a delegate is created.</source>
          <target state="translated">为其创建委托的方法的名称。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.#ctor(System.Object,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.#ctor(System.Object,System.String)">
          <source>This constructor cannot be used in application code.</source>
          <target state="translated">此构造函数不能在应用程序代码。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.#ctor(System.Object,System.String)">
          <source>To create a delegate by specifying the name of an instance method, use an overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph> method that specifies a method name and a target object.</source>
          <target state="translated">若要通过指定实例方法的名称创建委托，使用的重载<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph>指定方法名称和目标对象的方法。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.#ctor(System.Object,System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method overload creates a delegate for an instance method with a specified name.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29?displayProperty=nameWithType&gt;</ph>方法重载具有指定名称创建的实例方法的委托。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.#ctor(System.Object,System.String)">
          <source>Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</source>
          <target state="translated">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.#ctor(System.Object,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.#ctor(System.Object,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.#ctor(System.Type,System.String)">
          <source>The type of object on which <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> is defined.</source>
          <target state="translated">在其上定义 <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> 的对象的类型。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.#ctor(System.Type,System.String)">
          <source>The name of the static method for which a delegate is created.</source>
          <target state="translated">为其创建委托的静态方法的名称。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.#ctor(System.Type,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.#ctor(System.Type,System.String)">
          <source>This constructor cannot be used in application code.</source>
          <target state="translated">此构造函数不能在应用程序代码。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.#ctor(System.Type,System.String)">
          <source>To create a delegate by specifying the name of a static method, use an overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph> method that specifies a method name but does not specify a target object.</source>
          <target state="translated">若要通过指定静态方法的名称创建委托，使用的重载<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph>指定方法名称，但未指定目标对象的方法。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.#ctor(System.Type,System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method overload creates a static delegate for a method with a specified name.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29?displayProperty=nameWithType&gt;</ph>方法重载具有指定名称创建静态委托方法。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.#ctor(System.Type,System.String)">
          <source>Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</source>
          <target state="translated">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.#ctor(System.Type,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.#ctor(System.Type,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.CombineImpl(System.Delegate)">
          <source>The delegate to combine with this delegate.</source>
          <target state="translated">将与此委托进行合并的委托。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.CombineImpl(System.Delegate)">
          <source>Combines this <ph id="ph1">&lt;see cref="T:System.Delegate" /&gt;</ph> with the specified <ph id="ph2">&lt;see cref="T:System.Delegate" /&gt;</ph> to form a new delegate.</source>
          <target state="translated">将此 <ph id="ph1">&lt;see cref="T:System.Delegate" /&gt;</ph> 与指定的 <ph id="ph2">&lt;see cref="T:System.Delegate" /&gt;</ph> 合并，以形成一个新委托。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.CombineImpl(System.Delegate)">
          <source>A delegate that is the new root of the <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> invocation list.</source>
          <target state="translated">一个委托，它是 <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> 调用列表的新根。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.CombineImpl(System.Delegate)">
          <source><ph id="ph1">&lt;paramref name="follow" /&gt;</ph> does not have the same type as this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="follow" /&gt;</ph> 没有与此实例相同的类型。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.CombineImpl(System.Delegate)">
          <source>Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</source>
          <target state="translated">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.CombineImpl(System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.CombineImpl(System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.Equals(System.Object)">
          <source>The object to compare with this instance.</source>
          <target state="translated">与该实例进行比较的对象。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.Equals(System.Object)">
          <source>Determines whether this multicast delegate and the specified object are equal.</source>
          <target state="translated">确定此多路广播委托和指定的对象是否相等。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> and this instance have the same invocation lists; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> 和此实例具有相同的调用列表，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.Equals(System.Object)">
          <source>Two delegates are equal if they are not <ph id="ph1">`null`</ph> and are of exactly the same type, their invocation lists contain the same number of elements, and every element in the invocation list of the first delegate is equal to the corresponding element in the invocation list of the second delegate.</source>
          <target state="translated">两个委托是否相等，如果它们不<ph id="ph1">`null`</ph>且的完全相同的类型，其调用列表中包含相同数量的元素，且第一个委托的调用列表中每个元素等于在调用中的相应元素第二个委托的列表。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.Equals(System.Object)">
          <source>Two invocation list elements are equal if they invoke the same instance method on the same target instance, or they invoke the same static method.</source>
          <target state="translated">如果它们调用的相同的目标实例上的同一实例方法或它们调用相同的静态方法，两个调用列表的元素相等。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.Equals(System.Object)">
          <source>Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</source>
          <target state="translated">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.Equals(System.Object)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.Equals(System.Object)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">返回此实例的哈希代码。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">32 位有符号整数哈希代码。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.GetHashCode">
          <source>Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</source>
          <target state="translated">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.GetHashCode">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.GetHashCode">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.GetInvocationList">
          <source>Returns the invocation list of this multicast delegate, in invocation order.</source>
          <target state="translated">按照调用顺序返回此多路广播委托的调用列表。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.GetInvocationList">
          <source>An array of delegates whose invocation lists collectively match the invocation list of this instance.</source>
          <target state="translated">一个委托数组，这些委托的调用列表合起来与此实例的调用列表一致。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.GetInvocationList">
          <source>The array contains a set of delegates, each with an invocation list of one entry.</source>
          <target state="translated">该数组包含一组的代理，而每个都有一个条目的调用列表。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.GetInvocationList">
          <source>Invoking these delegates sequentially, in the order they appear in the array, produces the same results as invoking the current instance.</source>
          <target state="translated">按顺序，该数组中显示的顺序调用这些委托生成与调用当前实例相同的结果。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.GetInvocationList">
          <source>Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</source>
          <target state="translated">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.GetInvocationList">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.GetInvocationList">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.GetMethodImpl">
          <source>Returns a static method represented by the current <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated">返回由当前的 <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> 表示的静态方法。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.GetMethodImpl">
          <source>A static method represented by the current <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated">由当前的 <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> 表示的静态方法。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.GetMethodImpl">
          <source>If the <ph id="ph1">&lt;xref:System.MulticastDelegate&gt;</ph> represents multiple methods, only one method is returned.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.MulticastDelegate&gt;</ph>表示多个方法，返回只有一个方法。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>An object that holds all the data needed to serialize or deserialize this instance.</source>
          <target state="translated">一个对象，它保存将此实例序列化或反序列化所需的全部数据。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>(Reserved) The location where serialized data is stored and retrieved.</source>
          <target state="translated">（保留）存储和检索序列化数据的位置。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Populates a <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object with all the data needed to serialize this instance.</source>
          <target state="translated">用序列化该实例所需的所有数据填充 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This method stores all the information in <ph id="ph1">`info`</ph> necessary to serialize this instance.</source>
          <target state="translated">此方法将存储中的所有信息<ph id="ph1">`info`</ph>序列化此实例所需。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">`context`</ph> parameter is reserved and is not currently used in the execution of this method.</source>
          <target state="translated"><ph id="ph1">`context`</ph>参数是保留的当前未使用此方法执行过程中。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</source>
          <target state="translated">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A serialization error occurred.</source>
          <target state="translated">发生了序列化错误。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.op_Equality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>The left operand.</source>
          <target state="translated">左操作数。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.op_Equality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>The right operand.</source>
          <target state="translated">右操作数。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.op_Equality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>Determines whether two <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> objects are equal.</source>
          <target state="translated">确定两个 <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> 对象是否相等。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.op_Equality(System.MulticastDelegate,System.MulticastDelegate)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> and <ph id="ph3">&lt;paramref name="d2" /&gt;</ph> have the same invocation lists; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> 和 <ph id="ph3">&lt;paramref name="d2" /&gt;</ph> 具有相同的调用列表，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.op_Equality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>Two delegates are equal if they are not <ph id="ph1">`null`</ph> and are of exactly the same type, their invocation lists contain the same number of elements, and every element in the invocation list of the first delegate is equal to the corresponding element in the invocation list of the second delegate.</source>
          <target state="translated">两个委托是否相等，如果它们不<ph id="ph1">`null`</ph>且的完全相同的类型，其调用列表中包含相同数量的元素，且第一个委托的调用列表中每个元素等于在调用中的相应元素第二个委托的列表。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.op_Equality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>Two invocation list elements are equal if they invoke the same instance method on the same target instance, or they invoke the same static method.</source>
          <target state="translated">如果它们调用的相同的目标实例上的同一实例方法或它们调用相同的静态方法，两个调用列表的元素相等。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.op_Equality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">此运算符的等效方法是 <ph id="ph1">&lt;xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.op_Equality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</source>
          <target state="translated">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.op_Equality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.op_Equality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.op_Inequality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>The left operand.</source>
          <target state="translated">左操作数。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.op_Inequality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>The right operand.</source>
          <target state="translated">右操作数。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.op_Inequality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>Determines whether two <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> objects are not equal.</source>
          <target state="translated">确定两个 <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> 对象是否相等。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.op_Inequality(System.MulticastDelegate,System.MulticastDelegate)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> and <ph id="ph3">&lt;paramref name="d2" /&gt;</ph> do not have the same invocation lists; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> 和 <ph id="ph3">&lt;paramref name="d2" /&gt;</ph> 没有相同的调用列表，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.op_Inequality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>Two delegates are equal if they are not <ph id="ph1">`null`</ph> and are of exactly the same type, their invocation lists contain the same number of elements, and every element in the invocation list of the first delegate is equal to the corresponding element in the invocation list of the second delegate.</source>
          <target state="translated">两个委托是否相等，如果它们不<ph id="ph1">`null`</ph>且的完全相同的类型，其调用列表中包含相同数量的元素，且第一个委托的调用列表中每个元素等于在调用中的相应元素第二个委托的列表。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.op_Inequality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>Two invocation list elements are equal if they invoke the same instance method on the same target instance, or they invoke the same static method.</source>
          <target state="translated">如果它们调用的相同的目标实例上的同一实例方法或它们调用相同的静态方法，两个调用列表的元素相等。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.op_Inequality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">此运算符的等效方法是 <ph id="ph1">&lt;xref:System.MulticastDelegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.op_Inequality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</source>
          <target state="translated">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.op_Inequality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.op_Inequality(System.MulticastDelegate,System.MulticastDelegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.RemoveImpl(System.Delegate)">
          <source>The delegate to search for in the invocation list.</source>
          <target state="translated">要在调用列表中搜索的委托。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.RemoveImpl(System.Delegate)">
          <source>Removes an element from the invocation list of this <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> that is equal to the specified delegate.</source>
          <target state="translated">从此 <ph id="ph1">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph> 的调用列表中移除与指定委托相等的元素。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.RemoveImpl(System.Delegate)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is found in the invocation list for this instance, then a new <ph id="ph2">&lt;see cref="T:System.Delegate" /&gt;</ph> without <ph id="ph3">&lt;paramref name="value" /&gt;</ph> in its invocation list; otherwise, this instance with its original invocation list.</source>
          <target state="translated">如果在此实例的调用列表中找到 <ph id="ph1">&lt;paramref name="value" /&gt;</ph>，则为其调用列表中没有 <ph id="ph3">&lt;paramref name="value" /&gt;</ph> 的新 <ph id="ph2">&lt;see cref="T:System.Delegate" /&gt;</ph>；否则为此实例（带有其原始调用列表）。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.MulticastDelegate.RemoveImpl(System.Delegate)">
          <source>Cannot create an instance of an abstract class, or this member was invoked with a late-binding mechanism.</source>
          <target state="translated">无法创建抽象类的实例，或者此成员是使用晚期绑定机制调用的。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.RemoveImpl(System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.MulticastDelegate.RemoveImpl(System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>