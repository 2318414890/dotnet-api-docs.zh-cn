<Type Name="FlagsAttribute" FullName="System.FlagsAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4b2417901d3ec970c72a2c6cc0524b2108855ce0" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36431659" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FlagsAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FlagsAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.FlagsAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class FlagsAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FlagsAttribute : Attribute" />
  <TypeSignature Language="F#" Value="type FlagsAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Enum, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>指示可将枚举视为位域（即一组标志）。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 位域一般用于在组合中，可能出现的元素的列表而枚举常量一般用于互相排斥的元素的列表。 因此，位域旨在结合生成未命名的值的按位 OR 操作，而不是枚举的常数。 其使用位域相比枚举常量在不同语言。  
  
## <a name="attributes-of-the-flagsattribute"></a>FlagsAttribute 特性  
 <xref:System.AttributeUsageAttribute> 应用于此类，并将其<xref:System.AttributeUsageAttribute.Inherited%2A>属性指定`false`。 此属性仅可以应用于枚举。  
  
## <a name="guidelines-for-flagsattribute-and-enum"></a>FlagsAttribute 和枚举准则  
  
-   使用<xref:System.FlagsAttribute>枚举才是对数字值执行按位运算 （AND、 OR 独占或） 的自定义属性。  
  
-   在 2 的幂，即 1、 2、 4、 8 等中定义枚举常量。 这意味着不重叠中组合的枚举常量的各个标志。  
  
-   请考虑创建针对常用的标志组合的枚举的常数。 例如，如果你有用于文件 I/O 操作的枚举包含枚举的常数`Read = 1`和`Write = 2`，请考虑创建枚举的常数`ReadWrite = Read OR Write`，它结合`Read`和`Write`标志。 此外，可用于组合标志的按位 OR 操作视为在某些情况下，不应为用于简单任务所需的一个高级的概念。  
  
-   如果为标志枚举常量中定义为负数，因为很多标志位置可能会设置为 1，这可能会使你的代码的混乱，并鼓励编码错误，请务必小心。  
  
-   测试是否在数值中设置一个标志一种简便方式是执行按位与运算，之间的数字值和标志枚举的常数，它将所有位都设置为不对应于标志的零的数字值在然后测试该操作的结果是否等于该标志枚举常量。  
  
-   使用`None`用作枚举其值为零的常量的标志名称。 不能使用`None`按位运算中，来测试一个标志，因为结果始终为零的枚举的常数。 但是，你可以执行的逻辑不之间的数字值的按位、 比较和`None`枚举的常量，以确定是否已设置在数值中的任何位。  
  
     如果你创建而不是标志枚举的值枚举，它是仍必要创建`None`枚举的常数。 原因是，默认情况下用于枚举的内存初始化为零的公共语言运行时。 因此，如果未定义其值为零的常量，枚举将包含在创建时非法值。  
  
     如果你的应用程序需要表示明显默认情况下，请考虑使用其值为零表示默认值的枚举的常数。 如果没有任何默认情况下，请考虑使用其值为零的枚举的常数意味着不由任何其他枚举常量表示这种情况。  
  
-   未定义一个枚举值，只是为了镜像与枚举本身的状态。 例如，不定义仅用于枚举的结束标记的枚举的常数。 如果你需要确定在枚举的最后一个值，请显式检查该值。 此外，你可以执行范围检查第一个和最后一个枚举常量，如果范围内的所有值都是有效。  
  
-   不要指定保留供将来使用的枚举的常数。  
  
-   当你定义的方法或属性，它采用作为值的枚举的常数时，请考虑验证值。 原因是，即使该数值不在枚举中定义，你可以强制转换为枚举类型的数字值。  
  
   
  
## Examples  
 下面的示例演示如何使用`FlagsAttribute`特性，并显示效果上<xref:System.Enum.ToString%2A>的使用方法`FlagsAttribute`上<xref:System.Enum>声明。  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 下面的示例定义两个颜色相关枚举`SingleHue`和`MultiHue`。 后者具有`FlagsAttribute`属性; 前者却没有。 当范围的整数，包括不表示枚举类型的基础值的整数转换为枚举类型和显示其字符串表示形式时，该示例显示行为的差异。   例如，请注意 3 不能表示为`SingleHue`值因为 3 不是基础值的任何`SingleHue`成员，而`FlagsAttribute`特性使可以表示为 3`MultiHue`值`Black, Red`。  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlagsAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FlagsAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlagsAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.FlagsAttribute" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例定义`PhoneService`表示形式的通信提供电话公司的枚举。 它将初始化表示到三个不同的家庭，提供的服务的三个变量，然后指示哪些家庭具有任何服务，哪些家庭具有只移动电话服务，并且哪些家庭具有移动电话和上关于领土行服务。 最后，它隐式调用<xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType>方法以显示提供给每个全体服务的类型。  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 下面的示例演示如何使用`FlagsAttribute`特性，并显示效果上<xref:System.Enum.ToString%2A>的使用方法`FlagsAttribute`上<xref:System.Enum>声明。  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>