<Type Name="FlagsAttribute" FullName="System.FlagsAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="96fd7d37809a311f589d8aebd6325fa8e619f81a" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52240727" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FlagsAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FlagsAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.FlagsAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class FlagsAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FlagsAttribute : Attribute" />
  <TypeSignature Language="F#" Value="type FlagsAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Enum, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="60d88-101">指示可将枚举视为位域（即一组标志）。</span>
      <span class="sxs-lookup">
        <span data-stu-id="60d88-101">Indicates that an enumeration can be treated as a bit field; that is, a set of flags.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60d88-102">位域一般用于结合使用，可能会出现的元素的列表而枚举常量一般用于互相排斥的元素的列表。</span><span class="sxs-lookup"><span data-stu-id="60d88-102">Bit fields are generally used for lists of elements that might occur in combination, whereas enumeration constants are generally used for lists of mutually exclusive elements.</span></span> <span data-ttu-id="60d88-103">因此，位域旨在组合使用位或运算来生成未命名的值，而不是枚举的常量。</span><span class="sxs-lookup"><span data-stu-id="60d88-103">Therefore, bit fields are designed to be combined with a bitwise OR operation to generate unnamed values, whereas enumerated constants are not.</span></span> <span data-ttu-id="60d88-104">语言差异在相比枚举常量的位域的使用。</span><span class="sxs-lookup"><span data-stu-id="60d88-104">Languages vary in their use of bit fields compared to enumeration constants.</span></span>  
  
## <a name="attributes-of-the-flagsattribute"></a><span data-ttu-id="60d88-105">FlagsAttribute 特性</span><span class="sxs-lookup"><span data-stu-id="60d88-105">Attributes of the FlagsAttribute</span></span>  
 <span data-ttu-id="60d88-106"><xref:System.AttributeUsageAttribute> 应用于此类，并将其<xref:System.AttributeUsageAttribute.Inherited%2A>属性指定`false`。</span><span class="sxs-lookup"><span data-stu-id="60d88-106"><xref:System.AttributeUsageAttribute> is applied to this class, and its <xref:System.AttributeUsageAttribute.Inherited%2A> property specifies `false`.</span></span> <span data-ttu-id="60d88-107">此属性只能应用于枚举。</span><span class="sxs-lookup"><span data-stu-id="60d88-107">This attribute can only be applied to enumerations.</span></span>  
  
## <a name="guidelines-for-flagsattribute-and-enum"></a><span data-ttu-id="60d88-108">FlagsAttribute 和枚举的准则</span><span class="sxs-lookup"><span data-stu-id="60d88-108">Guidelines for FlagsAttribute and Enum</span></span>  
  
-   <span data-ttu-id="60d88-109">使用<xref:System.FlagsAttribute>仅当对数字值执行按位运算 （AND、 OR、 异或） 是一个枚举的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="60d88-109">Use the <xref:System.FlagsAttribute> custom attribute for an enumeration only if a bitwise operation (AND, OR, EXCLUSIVE OR) is to be performed on a numeric value.</span></span>  
  
-   <span data-ttu-id="60d88-110">定义中为 2 的幂，即 1、 2、 4、 8 和等等的枚举常量。</span><span class="sxs-lookup"><span data-stu-id="60d88-110">Define enumeration constants in powers of two, that is, 1, 2, 4, 8, and so on.</span></span> <span data-ttu-id="60d88-111">这意味着在组合的枚举常量中的各个标志不会重叠。</span><span class="sxs-lookup"><span data-stu-id="60d88-111">This means the individual flags in combined enumeration constants do not overlap.</span></span>  
  
-   <span data-ttu-id="60d88-112">请考虑创建常用的标志组合一个枚举的常量。</span><span class="sxs-lookup"><span data-stu-id="60d88-112">Consider creating an enumerated constant for commonly used flag combinations.</span></span> <span data-ttu-id="60d88-113">例如，如果有用于文件 I/O 操作的枚举，包含枚举的常量`Read = 1`并`Write = 2`，请考虑创建的枚举的常量`ReadWrite = Read OR Write`，它结合`Read`和`Write`标志。</span><span class="sxs-lookup"><span data-stu-id="60d88-113">For example, if you have an enumeration used for file I/O operations that contains the enumerated constants `Read = 1` and `Write = 2`, consider creating the enumerated constant `ReadWrite = Read OR Write`, which combines the `Read` and `Write` flags.</span></span> <span data-ttu-id="60d88-114">此外，用于组合标志的按位 OR 操作可能被视为一种高级的概念在某些情况下，不应要求对简单的任务。</span><span class="sxs-lookup"><span data-stu-id="60d88-114">In addition, the bitwise OR operation used to combine the flags might be considered an advanced concept in some circumstances that should not be required for simple tasks.</span></span>  
  
-   <span data-ttu-id="60d88-115">如果为标志枚举常量中定义为负数，因为很多标志位置可能会设置为 1，这可能会使您的代码令人困惑并鼓励编码错误，请格外小心。</span><span class="sxs-lookup"><span data-stu-id="60d88-115">Use caution if you define a negative number as a flag enumerated constant because many flag positions might be set to 1, which might make your code confusing and encourage coding errors.</span></span>  
  
-   <span data-ttu-id="60d88-116">测试是否设置了标志中的数字值的简便方法是执行按位 AND 运算之间的数字值和标志枚举的常量，它为不对应于该标志的零的数字值中的所有位都设置然后测试该操作的结果是否等于标志枚举常量。</span><span class="sxs-lookup"><span data-stu-id="60d88-116">A convenient way to test whether a flag is set in a numeric value is to perform a bitwise AND operation between the numeric value and the flag enumerated constant, which sets all bits in the numeric value to zero that do not correspond to the flag, then test whether the result of that operation is equal to the flag enumerated constant.</span></span>  
  
-   <span data-ttu-id="60d88-117">使用`None`用作枚举值为零的常量标志的名称。</span><span class="sxs-lookup"><span data-stu-id="60d88-117">Use `None` as the name of the flag enumerated constant whose value is zero.</span></span> <span data-ttu-id="60d88-118">不能使用`None`按位运算中，若要测试一个标志，因为结果始终为零的枚举的常数。</span><span class="sxs-lookup"><span data-stu-id="60d88-118">You cannot use the `None` enumerated constant in a bitwise AND operation to test for a flag because the result is always zero.</span></span> <span data-ttu-id="60d88-119">但是，你可以执行的逻辑不之间的数字值的按位、 比较和`None`枚举的常数，以确定是否设置在数值中的任何位。</span><span class="sxs-lookup"><span data-stu-id="60d88-119">However, you can perform a logical, not a bitwise, comparison between the numeric value and the `None` enumerated constant to determine whether any bits in the numeric value are set.</span></span>  
  
     <span data-ttu-id="60d88-120">如果您创建的而不是标志枚举值枚举，则仍有必要创建`None`枚举的常数。</span><span class="sxs-lookup"><span data-stu-id="60d88-120">If you create a value enumeration instead of a flags enumeration, it is still worthwhile to create a `None` enumerated constant.</span></span> <span data-ttu-id="60d88-121">原因是，默认情况下为该枚举所使用的内存初始化为零的公共语言运行时。</span><span class="sxs-lookup"><span data-stu-id="60d88-121">The reason is that by default the memory used for the enumeration is initialized to zero by the common language runtime.</span></span> <span data-ttu-id="60d88-122">因此，如果未定义其值为零的常量，枚举将包含非法值时创建它。</span><span class="sxs-lookup"><span data-stu-id="60d88-122">Consequently, if you do not define a constant whose value is zero, the enumeration will contain an illegal value when it is created.</span></span>  
  
     <span data-ttu-id="60d88-123">如果你的应用程序需要表示明显默认情况下，请考虑使用其值为零来表示默认值的枚举的常量。</span><span class="sxs-lookup"><span data-stu-id="60d88-123">If there is an obvious default case your application needs to represent, consider using an enumerated constant whose value is zero to represent the default.</span></span> <span data-ttu-id="60d88-124">如果没有默认情况下，请考虑使用值为零的枚举的常数意味着不由任何其他枚举常量的用例。</span><span class="sxs-lookup"><span data-stu-id="60d88-124">If there is no default case, consider using an enumerated constant whose value is zero that means the case that is not represented by any of the other enumerated constants.</span></span>  
  
-   <span data-ttu-id="60d88-125">未定义的枚举值，只是为了反映该枚举本身的状态。</span><span class="sxs-lookup"><span data-stu-id="60d88-125">Do not define an enumeration value solely to mirror the state of the enumeration itself.</span></span> <span data-ttu-id="60d88-126">例如，未定义的枚举的常量的只是表示枚举的结尾。</span><span class="sxs-lookup"><span data-stu-id="60d88-126">For example, do not define an enumerated constant that merely marks the end of the enumeration.</span></span> <span data-ttu-id="60d88-127">如果您需要确定枚举的最后一个值，请显式检查值。</span><span class="sxs-lookup"><span data-stu-id="60d88-127">If you need to determine the last value of the enumeration, check for that value explicitly.</span></span> <span data-ttu-id="60d88-128">此外，可以为第一个和最后一个枚举常量执行范围检查的范围内的所有值是否为有效。</span><span class="sxs-lookup"><span data-stu-id="60d88-128">In addition, you can perform a range check for the first and last enumerated constant if all values within the range are valid.</span></span>  
  
-   <span data-ttu-id="60d88-129">不要指定保留供将来使用的枚举的常量。</span><span class="sxs-lookup"><span data-stu-id="60d88-129">Do not specify enumerated constants that are reserved for future use.</span></span>  
  
-   <span data-ttu-id="60d88-130">在定义的方法或属性，它采用一个值作为一个枚举的常量时，请考虑验证值。</span><span class="sxs-lookup"><span data-stu-id="60d88-130">When you define a method or property that takes an enumerated constant as a value, consider validating the value.</span></span> <span data-ttu-id="60d88-131">原因是，即使该数字的值未定义的枚举中，您可以强制转换为枚举类型的数字值。</span><span class="sxs-lookup"><span data-stu-id="60d88-131">The reason is that you can cast a numeric value to the enumeration type even if that numeric value is not defined in the enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60d88-132">下面的示例演示如何使用`FlagsAttribute`特性，并在显示效果<xref:System.Enum.ToString%2A>使用的方法`FlagsAttribute`上<xref:System.Enum>声明。</span><span class="sxs-lookup"><span data-stu-id="60d88-132">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 <span data-ttu-id="60d88-133">下面的示例定义两个颜色相关枚举`SingleHue`和`MultiHue`。</span><span class="sxs-lookup"><span data-stu-id="60d88-133">The following example defines two color-related enumerations, `SingleHue` and `MultiHue`.</span></span> <span data-ttu-id="60d88-134">后一种具有`FlagsAttribute`属性; 前者却没有。</span><span class="sxs-lookup"><span data-stu-id="60d88-134">The latter has the `FlagsAttribute` attribute; the former does not.</span></span> <span data-ttu-id="60d88-135">范围的整数，其中包括不表示枚举类型的基础值的整数转换为枚举类型和显示其字符串表示形式时，示例将演示行为的差异。</span><span class="sxs-lookup"><span data-stu-id="60d88-135">The example shows the difference in behavior when a range of integers, including integers that do not represent underlying values of the enumeration type, are cast to the enumeration type and their string representations displayed.</span></span>   <span data-ttu-id="60d88-136">例如，请注意 3 不能表示为`SingleHue`值，因为 3 不是基础值的任何`SingleHue`成员，而`FlagsAttribute`属性使可能表示 3 一样`MultiHue`的值`Black, Red`。</span><span class="sxs-lookup"><span data-stu-id="60d88-136">For example, note that 3 cannot be represented as a `SingleHue` value because 3 is not the underlying value of any `SingleHue` member, whereas the `FlagsAttribute` attribute makes it possible to represent 3 as a `MultiHue` value of `Black, Red`.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlagsAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FlagsAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlagsAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="60d88-137">初始化 <see cref="T:System.FlagsAttribute" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="60d88-137">Initializes a new instance of the <see cref="T:System.FlagsAttribute" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60d88-138">下面的示例定义`PhoneService`枚举，它表示形式的通信提供的电话公司。</span><span class="sxs-lookup"><span data-stu-id="60d88-138">The following example defines a `PhoneService` enumeration that represents forms of communication provided by a telephone company.</span></span> <span data-ttu-id="60d88-139">它初始化表示提供给三个不同家庭的服务的三个变量，然后指示哪些家庭具有任何服务的家庭有只有移动电话服务，而哪些家庭有移动电话和 land 行服务。</span><span class="sxs-lookup"><span data-stu-id="60d88-139">It initializes three variables representing the service provided to three different households, and then indicates which households have no service, which households have only cell phone service, and which households have both cell phone and land line service.</span></span> <span data-ttu-id="60d88-140">最后，它隐式调用<xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType>方法以显示用于每个家庭的服务的类型。</span><span class="sxs-lookup"><span data-stu-id="60d88-140">Finally, it implicitly calls the <xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> method to display the types of service provided to each household.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 <span data-ttu-id="60d88-141">下面的示例演示如何使用`FlagsAttribute`特性，并在显示效果<xref:System.Enum.ToString%2A>使用的方法`FlagsAttribute`上<xref:System.Enum>声明。</span><span class="sxs-lookup"><span data-stu-id="60d88-141">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>