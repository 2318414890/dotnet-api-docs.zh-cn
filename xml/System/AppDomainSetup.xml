<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="de1a8d1ecd07f9f8d0291eb6d18e2d042042a9b2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30730031" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示可以添加到 <see cref="T:System.AppDomain" /> 的实例的程序集绑定信息。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 更改的属性<xref:System.AppDomainSetup>实例不会影响任何现有<xref:System.AppDomain>。 它可能会影响仅创建一个新<xref:System.AppDomain>，当<xref:System.AppDomain.CreateDomain%2A>方法调用与<xref:System.AppDomainSetup>作为参数的实例。  
  
 此类实现 <xref:System.IAppDomainSetup> 接口。  
  
> [!CAUTION]
>  默认值为<xref:System.AppDomainSetup.DisallowCodeDownload%2A>属性为 false。 此设置是不安全的服务。 为了帮助防止服务下载部分受信任的代码，请将此属性设置为 true  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.AppDomainSetup" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.AppDomainSetup" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">要用于应用程序域的激活上下文。</param>
        <summary>使用指定的激活上下文（用于基于清单的应用程序域激活）初始化 <see cref="T:System.AppDomainSetup" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ActivationContext>对象指定的用于`activationContext`用于生成<xref:System.Runtime.Hosting.ActivationArguments>对象，其中包含激活新的应用程序域所需信息。 这<xref:System.Runtime.Hosting.ActivationArguments>对象可以通过使用访问<xref:System.AppDomainSetup.ActivationArguments%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationContext" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" />
      </Parameters>
      <Docs>
        <param name="activationArguments">一个对象，指定以基于清单的方式激活新的应用程序域所需的信息。</param>
        <summary>使用基于清单的应用程序域激活所需的指定激活参数初始化 <see cref="T:System.AppDomainSetup" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为指定的对象`activationArguments`可以通过使用访问<xref:System.AppDomainSetup.ActivationArguments%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="activationArguments" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与应用程序域的激活有关的数据。</summary>
        <value>一个对象，其中包含与应用程序域的激活有关的数据。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此属性设置为引发任何异常`null`。  
  
 提供的信息<xref:System.Runtime.Hosting.ActivationArguments>对象支持基于清单的激活。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">属性设置为 <see cref="T:System.Runtime.Hosting.ActivationArguments" /> 对象，该对象的应用程序标识不匹配 <see cref="P:System.AppDomainSetup.ApplicationTrust" /> 属性返回的 <see cref="T:System.Security.Policy.ApplicationTrust" /> 对象的应用程序标识。 如果 <see cref="P:System.AppDomainSetup.ApplicationTrust" /> 属性为 <see langword="null" />，则不会引发异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.AppDomainInitializer" /> 委托，该委托表示在初始化应用程序域时调用的回调方法。</summary>
        <value>一个委托，表示在初始化应用程序域时调用的回调方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要将信息传递给回调方法，分配的字符串转换为数组<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>属性。 该数组传递给回调方法每次<xref:System.AppDomain>初始化。  
  
 新创建的应用程序域的上下文中执行此回调方法。  
  
   
  
## Examples  
 下面的示例创建名为的子应用程序域`ChildDomain`，使用<xref:System.AppDomainSetup>对象和从默认应用程序域的证据。 <xref:System.AppDomainSetup.AppDomainInitializer%2A>属性设置为回调方法`AppDomainInit`，这初始化子域时调用。 回调方法的参数都将置于一个字符串，该值将赋给数组<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>属性。 创建子域时，回调方法只需将打印字符串。  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置传给 <see cref="T:System.AppDomainInitializer" /> 委托所表示的回调方法的参数。 在初始化应用程序域时将调用该回调方法。</summary>
        <value>一个字符串数组，当在 <see cref="T:System.AppDomainInitializer" /> 初始化过程中调用 <see cref="T:System.AppDomain" /> 委托所表示的回调方法时，该字符串数组将被传给该回调方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.AppDomainSetup.AppDomainInitializer%2A>属性指定一个期间调用的回调方法<xref:System.AppDomain>初始化。 如果<xref:System.AppDomainSetup.AppDomainInitializer%2A>未设置属性，则不使用分配给此属性的数组。  
  
 新创建的应用程序域的上下文中执行此回调方法。  
  
   
  
## Examples  
 下面的代码示例创建名为的子应用程序域`ChildDomain`，使用<xref:System.AppDomainSetup>对象和从默认应用程序域的证据。 <xref:System.AppDomainSetup.AppDomainInitializer%2A>属性设置为回调方法`AppDomainInit`，这初始化子域时调用。 回调方法的参数都将置于一个字符串，该值将赋给数组<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>属性。 创建子域时，回调方法只需将打印字符串。  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置程序集的显示名称，该程序集为使用 <see cref="T:System.AppDomainSetup" /> 对象创建的应用程序域提供应用程序域管理器的类型。</summary>
        <value>程序集的显示名称，该程序集提供应用程序域管理器的 <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要指定应用程序域管理器的类型，设置此属性与<xref:System.AppDomainSetup.AppDomainManagerType%2A>属性。 如果未设置这些属性之一，另一个被忽略。  
  
 如果未不提供任何类型，从与父应用程序域相同的类型创建的应用程序域管理器 (即，从该应用程序域<xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType>调用方法)。  
  
 当加载应用程序域时，<xref:System.TypeLoadException>如果程序集不存在，或者如果程序集不包含由指定的类型将引发<xref:System.AppDomainSetup.AppDomainManagerType%2A>属性。 <xref:System.IO.FileLoadException> 如果找到的程序集但不是匹配的版本信息将引发。  
  
 若要设置默认应用程序域的应用程序域管理器，使用[ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md)和[ \<p e >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md)中的元素[\<运行时 >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)一部分的应用程序配置文件或使用环境变量中所述<xref:System.AppDomainManager>。  
  
 此功能需要应用程序具有完全信任。 （例如，在桌面上运行的应用程序具有完全信任。）如果应用程序不具有完全信任，<xref:System.TypeLoadException>引发。  
  
 通过给定程序集显示名称的格式<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置类型的全名，该类型可为使用此 <see cref="T:System.AppDomainSetup" /> 对象创建的应用程序域提供应用程序域管理器。</summary>
        <value>类型的全名，其中包括命名空间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要指定应用程序域管理器的类型，设置此属性与<xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>属性。 如果未设置这些属性之一，另一个被忽略。  
  
 如果未不提供任何类型，从与父应用程序域相同的类型创建的应用程序域管理器 (即，从该应用程序域<xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType>调用方法)。  
  
 当加载应用程序域时，<xref:System.TypeLoadException>如果通过指定的程序集，将引发<xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>属性不包含此属性指定的类型。  
  
 若要设置默认应用程序域的应用程序域管理器，使用[ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md)和[ \<p e >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md)中的元素[\<运行时 >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)一部分的应用程序配置文件或使用环境变量中所述<xref:System.AppDomainManager>。  
  
 此功能需要应用程序具有完全信任。 （例如，在桌面上运行的应用程序具有完全信任。）如果应用程序不具有完全信任，<xref:System.TypeLoadException>引发。  
  
 一种类型的完整名称的格式由<xref:System.Type.FullName%2A?displayProperty=nameWithType>属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置包含该应用程序的目录的名称。</summary>
        <value>应用程序基目录的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序基目录是程序集管理器开始探测程序集。  
  
 <xref:System.AppDomainSetup.ApplicationBase%2A>属性可以影响到应用程序域授予的权限。 例如，应用程序域通常来自本地计算机接收基于源其位置的完全信任。 但是，如果<xref:System.AppDomainSetup.ApplicationBase%2A>属性，<xref:System.AppDomain>设置 intranet 目录的完整名称为<xref:System.AppDomainSetup.ApplicationBase%2A>设置将限制授予给应用程序域到 LocalIntranet grant 即使应用程序域的权限实际来自本地计算机。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.AppDomainSetup.ApplicationBase%2A>属性来设置程序集加载程序开始探测程序集加载到新的应用程序域的位置。  
  
> [!NOTE]
>  你必须确保你指定的文件夹存在。  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问的路径信息。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用程序的名称。</summary>
        <value>应用程序的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何设置<xref:System.AppDomainSetup.ApplicationName%2A>时创建新的应用程序域的属性。  
  
 该示例创建一个新的应用程序域，并随后调用<xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>方法示例程序集加载到新的应用程序域并创建的实例`Worker`类。 `Worker`类继承<xref:System.MarshalByRefObject>，因此该示例可以使用返回的代理<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>调用`TestLoad`方法。  
  
 `TestLoad`方法加载指定程序集。 你必须指定有效的、 完全限定的程序集名称，或注释掉<xref:System.Reflection.Assembly.Load%28System.String%29>方法。 `TestLoad`方法列出的程序集加载到新的应用程序域，并显示你指定的程序集和示例程序集将加载。  
  
 该示例使用<xref:System.LoaderOptimizationAttribute>属性告知程序集加载程序如何应用程序将跨应用程序域共享代码。  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个包含安全性和信任信息的对象。</summary>
        <value>包含安全和信任信息的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是`null`时<xref:System.AppDomainSetup>创建。 更改后，则无法重置为空引用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">属性设置为 <see cref="T:System.Security.Policy.ApplicationTrust" /> 对象，该对象的应用程序标识不匹配 <see cref="P:System.AppDomainSetup.ActivationArguments" /> 属性返回的 <see cref="T:System.Runtime.Hosting.ActivationArguments" /> 对象的应用程序标识。 如果 <see cref="P:System.AppDomainSetup.ActivationArguments" /> 属性为 <see langword="null" />，则不会引发异常。</exception>
        <exception cref="T:System.ArgumentNullException">属性设置为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置特定于应用程序且从中对文件进行卷影复制的区域的名称。</summary>
        <value>从中对文件进行卷影复制的目录路径和文件名的完全限定名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了使此属性产生任何影响，<xref:System.AppDomainSetup.ApplicationName%2A>还必须设置属性。 如果<xref:System.AppDomainSetup.ApplicationName%2A>未设置属性，<xref:System.AppDomainSetup.CachePath%2A>属性将被忽略，并且卷影副本缓存位置默认为下载缓存。  
  
 卷影复制的详细信息，请参阅[影像复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问的路径信息。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用程序域的配置文件的名称。</summary>
        <value>配置文件的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配置文件描述的搜索规则和应用程序域的配置数据。 创建应用程序域的主机负责提供此数据，因为有意义的值会变化情况。  
  
 例如，ASP.NET 应用程序的配置数据存储为每个应用程序、 站点以及计算机，可执行文件的配置数据存储为每个应用程序、 用户和计算机时。 仅主机知道特定情况的配置数据的详细信息。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问的路径信息。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定在搜索要加载的程序集时是否探测应用程序基路径和专用二进制路径。</summary>
        <value>
          如果不允许探测，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>属性是`true`的值<xref:System.AppDomainSetup.ApplicationBase%2A>忽略属性。 通过指定的目录中的探测没有任何程序集，即<xref:System.AppDomainSetup.ApplicationBase%2A>属性。 此外的值<xref:System.AppDomainSetup.PrivateBinPath%2A>属性和<xref:System.AppDomainSetup.PrivateBinPathProbe%2A>属性将被忽略。 任何程序集指定的目录中探测<xref:System.AppDomainSetup.PrivateBinPath%2A>属性。  
  
 <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>属性提供一层额外的控制加载过程。 在正常的程序集加载序列，应用程序基探测之前<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>引发事件。 但是，某些应用程序可能需要从在文档中，OLE 复合文件中或从既不在全局程序集缓存中上也不由指定的目录中的唯一已知位置加载程序集<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>属性。 此类应用程序可以使用<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>属性以避免导致正常探测的延迟和避免加载可能位于正常的探测路径的必需程序集的副本。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示应用程序域是否允许程序集绑定重定向。</summary>
        <value>
          如果不允许程序集的重定向，则为 <see langword="true" />；如果允许，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowBindingRedirects%2A>属性设计为供服务和服务器应用程序程序集绑定重定向不是应用程序方案的一部分。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示应用程序域是否允许通过 HTTP 下载程序集。</summary>
        <value>
          如果不允许通过 HTTP 下载程序集，则为 <see langword="true" />；如果允许则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowCodeDownload%2A>属性设计为供服务和服务器应用程序从 intranet 或 Internet 下载代码不是应用程序方案的一部分。  
  
> [!CAUTION]
>  默认值为<xref:System.AppDomainSetup.DisallowCodeDownload%2A>属性是`false`。 此设置是不安全的服务。 为了帮助防止服务下载部分受信任的代码，请将此属性设置为`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否将配置文件的 [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) 部分应用于应用程序域。</summary>
        <value>
          如果忽略应用程序域配置文件的 <see langword="&lt;publisherPolicy&gt;" /> 部分，则为 <see langword="true" />；如果接受所声明的发行者策略，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A>属性仅适用于本地加载 Web 应用程序。 使用此属性以帮助防止恶意尝试在安全模式下执行不安全的 Web 应用程序。  
  
 有关跳过发布服务器策略的详细信息，请参阅[重定向程序集版本](~/docs/framework/configure-apps/redirect-assembly-versions.md)主题。 有关安全模式的详细信息，请参阅的"检查配置文件"部分[运行时如何定位程序集](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)主题。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置动态生成的文件所在的目录的基目录。</summary>
        <value>
          <see cref="P:System.AppDomain.DynamicDirectory" /> 所在的目录。  
 <block subset="none" type="note"><para>  
 该属性的返回值不同于分配的值。
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 此属性用于设置新的应用程序域的动态目录将位于的基目录。 新的应用程序域中的代码加载程序集、 程序集解析时看起来正常的探测路径中的第一行。 如果找不到程序集，它会查找在动态目录中，即<xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType>属性。 将加载和执行由新的应用程序域的动态程序集可放置在此处。  
  
 将分配到的路径时<xref:System.AppDomainSetup.DynamicBase%2A>属性，添加了其他子目录; 此子目录的名称是分配给的值的哈希代码<xref:System.AppDomainSetup.ApplicationName%2A>属性。 因此，随后返回此属性的基目录始终是分配的值不同的。  
  
> [!IMPORTANT]
>  将一个值分配给此属性不会创建任何目录。 必须创建或验证使用它们的代码的目录。  
  
 该动态目录是的子目录<xref:System.AppDomainSetup.DynamicBase%2A>。 其简单名称是返回的值<xref:System.AppDomainSetup.ApplicationName%2A>属性，因此其格式是*原始路径*\\*哈希代码*\\*应用程序名称*.  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.AppDomainSetup.DynamicBase%2A>属性来设置应用程序域的路径探测时加载的动态程序集。  
  
 该示例创建<xref:System.AppDomainSetup>对象并设置其<xref:System.AppDomainSetup.ApplicationName%2A>属性设置为"示例"并将其<xref:System.AppDomainSetup.DynamicBase%2A>"C:\DynamicAssemblyDir"的属性。 然后该示例显示<xref:System.AppDomainSetup.DynamicBase%2A>属性，以显示应用程序名称的哈希代码，已追加视为最初分配的路径的子目录。  
  
> [!NOTE]
>  在此示例中的基目录旨在将示例应用程序的探测路径之外。 请务必编译中的不同位置的示例。 每次运行该示例删除基目录和所有子目录。  
  
 该示例创建新的应用程序域使用<xref:System.AppDomainSetup>对象。 然后，示例创建的动态目录，如果不存在。 虽然本示例使用应用程序域的<xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType>属性来获取其名称的动态目录中，它可以轻松地事先创建目录通过串联的原始路径，应用程序名称的哈希代码和应用程序名称。  
  
 本示例具有`GenerateDynamicAssembly`发出名为程序集的方法`DynamicHelloWorld.dll`并将其存储在新应用程序域的动态目录。 动态程序集包含一个类型， `HelloWorld`，具有一个静态方法 (`Shared`在 Visual Basic 中的方法) 名为`HelloFromAD`。 调用此方法显示应用程序域的名称。  
  
 `Example`类派生自<xref:System.MarshalByRefObject>，因此该示例可以创建类的实例中的新应用程序域和调用其`Test`方法。 `Test`方法加载的动态程序集按其显示名称，并调用静态`HelloFromAD`方法。  
  
 你可以显示在正常的探测路径后搜索的动态目录，通过对名为程序集编写代码`DynamicHelloWorld.dll`并将其编译此示例为同一个目录中。 程序集必须具有一个名为类`HelloWorld`与一个名为的静态方法`HelloFromAD`。 此方法不需要具有相同的功能与在这些示例。它只是可以向控制台显示字符串。 程序集必须还具有<xref:System.Reflection.AssemblyVersionAttribute>将其版本设置为 1.0.0.0 的属性。 运行示例时，当前目录中编译的程序集位于之前搜索的动态目录。  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">无法设置此属性，因为应用程序域上的应用程序名称为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问的路径信息。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回由 <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 方法设置的 XML 配置信息，这些信息优先于应用程序的 XML 配置信息。</summary>
        <returns>一个数组，其中包含由 <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 方法设置的 XML 配置信息；如果未调用 <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 方法，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法提供了如何重写创建新的应用程序域的应用程序的配置信息。 中的配置文件信息`value`重写应用程序的配置文件信息。 例如，当 Example.exe 应用程序创建新的应用程序域时，它会重写最初从 Example.exe.config 文件中获取的配置信息。  
  
> [!IMPORTANT]
>  配置文件信息的一些使用者不使用存储的信息<xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法。 运行时不会强制此。 若要确保新的应用程序域中被重写所有配置文件信息，请使用<xref:System.AppDomainSetup.ConfigurationFile%2A>属性来指定配置文件。 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法会影响程序集绑定。  
  
 中的 XML`value`具有与在常规配置文件中，XML 相同，只不过它存储为<xref:System.Byte>数组。  
  
 若要访问应用程序域的配置字节，使用<xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType>属性来获取<xref:System.AppDomainSetup>对象对于应用程序域中，然后使用<xref:System.AppDomainSetup.GetConfigurationBytes%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与此域关联的许可证文件的位置。</summary>
        <value>许可证文件的位置和名称。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问的路径信息。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定用于加载可执行文件的优化策略。</summary>
        <value>与 <see cref="T:System.LoaderOptimizationAttribute" /> 配合使用的枚举常数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建动态程序集，并将其保存到磁盘，然后使用<xref:System.AppDomainSetup.LoaderOptimization%2A>属性来设置用于将程序集加载到应用程序域的优化策略。  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置标以 <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> 标志的程序集的列表，这些程序集对沙箱应用程序域中的部分信任代码可见。</summary>
        <value>部分程序集名称的数组，其中每个部分名称都由简单程序集名称和公钥组成。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 开头[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、 <xref:System.Security.AllowPartiallyTrustedCallersAttribute> (APTCA) 特性可以通过条件设置其<xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A>属性<xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>。 将标有 APTCA 程序集<xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>流量，除非主机应用程序允许它不能由部分受信任的代码。  
  
 沙盒应用程序域的主机允许的应用程序域使用带有条件 APTCA 特性的程序集，通过创建一个数组，包含的简单名称和公钥的每个程序集，并将数组分配给此属性中的代码。 例如，数组的元素可能如下所示:"MyAssembly，PublicKey =0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9"。  
  
> [!IMPORTANT]
>  如果你使用的一个子类<xref:System.AppDomainManager>，并定义它的程序集依赖于用条件 APTCA 特性标记的程序集，则必须将传递给列表中包括这些程序集<xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A>属性<xref:System.AppDomainSetup>使用来创建应用程序域。 否则将禁用用条件 APTCA 特性标记的程序集。  
  
> [!NOTE]
>  当你正调试的应用程序在沙盒应用程序域中，运行某些<xref:System.Security.SecurityException>消息可能会产生误导。 例如，一条消息可能状态，你完全受信任的程序集之一只具有有限权限，当问题的真正原因时超过沙盒应用程序域的授予集的安全要求已传播到的边界沙盒应用程序域和失败。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用程序基目录下的目录列表，这些目录被探测以寻找其中的私有程序集。</summary>
        <value>目录名称的列表，用分号分隔。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 专用程序集部署在与应用程序相同的目录结构中。 如果为指定目录<xref:System.AppDomainSetup.PrivateBinPath%2A>下不是<xref:System.AppDomainSetup.ApplicationBase%2A>，它们将被忽略。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个字符串值，用于在应用程序的搜索路径中包含 <see cref="P:System.AppDomainSetup.ApplicationBase" />，或者从搜索路径中排除该基路径而只在 <see cref="P:System.AppDomainSetup.PrivateBinPath" /> 中进行搜索。</summary>
        <value>空引用（ Visual Basic 中的 <see langword="Nothing" />），包括搜索程序集时的应用程序基路径；要排除该路径的任何非空字符串值。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此属性设置为任何非 null 字符串值，包括<xref:System.String.Empty?displayProperty=nameWithType>("")，以排除应用程序目录路径-即， <xref:System.AppDomainSetup.ApplicationBase%2A> -对于应用程序，并搜索程序集的搜索路径中仅在<xref:System.AppDomainSetup.PrivateBinPath%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否在应用程序域中为互操作调用禁用接口缓存，从而对每个调用执行 <c>QueryInterface</c>。</summary>
        <value>
          如果为使用当前 <see cref="T:System.AppDomainSetup" /> 对象创建的应用程序域中的互操作调用禁用接口缓存，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对性能的互操作调用禁用接口缓存产生重大影响。  
  
 此成员在中引入[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="switches">指定兼容性开关的字符串值的可枚举集或要擦除现有兼容性开关的 <see langword="null" />。</param>
        <summary>设置指定的开关，从而使应用程序域针对指定问题与早期版本的 .NET Framework 兼容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 主要版本的.NET Framework 有时会引入的先前版本中的重大更改。 例如，[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]引入了少量的重大更改从[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。 使用<xref:System.AppDomainSetup.SetCompatibilitySwitches%2A>方法，以指定一个或多个这些重大更改应将其回滚应用程序域，以使此行为与以前版本的.NET framework 兼容。  
  
 每次调用此方法，它将替换现有的交换机设置。 若要清除设置，指定`null`为`switches`参数。  
  
 为提供的字符串值的一套`switches`可以是一个简单的字符串数组，因为数组实现<xref:System.Collections.IEnumerable>接口。  
  
 下表提供兼容性开关，可设置为还原的.NET Framework 的早期版本的行为的示例。  
  
|开关|含义|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|代码访问安全性 (CAS)[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]在此应用程序域中启用。 请参阅[ &lt;NetFx40_LegacySecurityPolicy&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)。|  
|"NetFx40_Legacy20SortingBehavior"|字符串排序的默认值[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]在此应用程序域中启用。 已成功还原旧排序行为还要求 sort00001000.dll 动态链接库，可在本地系统上。 请参阅[ &lt;CompatSortNLSVersion&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)。|  
|"NetFx40_Legacy40SortingBehavior"|字符串排序的默认值[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和在此应用程序域中启用 Unicode 5.0。 已成功还原旧排序行为还要求 sort00060101.dll 动态链接库，可在本地系统上。|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> 格式设置行为[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]在此应用程序域中启用。 请参阅[ &lt;TimeSpan_LegacyFormatMode&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)和"还原旧时间跨度格式设置"部分的<xref:System.TimeSpan>主题。|  
|"UseRandomizedStringHashAlgorithm"|运行时计算字符串的哈希代码上每个应用程序域而不是使用单一的哈希算法跨应用程序域中生成的一致的哈希代码。 请参阅[ &lt;UseRandomizedStringHashAlgorithm&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)。|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">一个数组，其中包含要用于应用程序域的 XML 配置信息。</param>
        <summary>提供应用程序域的 XML 配置信息，并替换应用程序的 XML 配置信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法使您能够将创建新的应用程序域的应用程序的配置信息。 中的配置文件信息`value`替换应用程序的配置文件信息。 例如，当 Example.exe 应用程序创建新的应用程序域时，它可以替换最初从 Example.exe.config 文件中获取的配置信息。  
  
> [!IMPORTANT]
>  配置文件信息的一些使用者不使用存储的信息<xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法。 运行时不会强制此。 若要确保所有的配置文件信息已替换为新的应用程序域中，使用<xref:System.AppDomainSetup.ConfigurationFile%2A>属性来指定配置文件。 <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法会影响程序集绑定。  
  
 中的 XML`value`具有与在常规配置文件中，XML 相同，只不过它存储为<xref:System.Byte>数组。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="functionVersion" Type="System.Int32" />
        <Parameter Name="functionPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="functionName">要重载的字符串比较函数的名称。</param>
        <param name="functionVersion">函数版本。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]，必须为 1 或者 更大的数值。</param>
        <param name="functionPointer">重写 <c>functionName</c> 的函数的指针。</param>
        <summary>向通用语言运行时提供备用字符串比较功能实现。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下面的字符串比较和排序方法可重写<xref:System.AppDomainSetup.SetNativeFunction%2A>方法：  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 有关这些函数的信息，请参阅[国家/地区的语言支持功能](http://go.microsoft.com/fwlink/?LinkId=228134)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="functionName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionVersion" /> 不是 1 或者更大的值。  
  
 或  
  
 <paramref name="functionPointer" /> 为 <see cref="F:System.IntPtr.Zero" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置目录的名称，这些目录包含要进行卷影复制的程序集。</summary>
        <value>目录名称的列表，用分号分隔。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 启用卷影复制后，默认值是向通过探测; 找到的所有程序集的卷影副本即指定的目录的<xref:System.AppDomainSetup.PrivateBinPath%2A>和<xref:System.AppDomainSetup.ApplicationBase%2A>属性。 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>属性将卷影副本限制到指定的目录中的程序集<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>。  
  
 如果未将字符串分配至 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> 属性或者将此属性设置为 `null`，则 <xref:System.AppDomainSetup.ApplicationBase%2A> 和 <xref:System.AppDomainSetup.PrivateBinPath%2A> 属性指定的目录中的所有程序集均进行卷影复制。  
  
> [!IMPORTANT]
>  目录路径不能包含分号，因为分号是分隔符。 分号没有转义符。  
  
 卷影复制生效时，程序集文件复制到其他位置，这些程序集加载之前。 没有锁定原始程序集文件，因此它可以进行更新。 卷影复制的详细信息，请参阅[影像复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问的路径信息。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置指示卷影复制是打开还是关闭的字符串。</summary>
        <value>字符串值“true”指示打开了卷影复制；“false”则指示关闭了卷影复制。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 卷影复制的详细信息，请参阅[影像复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置为应用程序域指定目标版本和 .NET Framework 配置文件的字符串，以可由 <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" /> 构造函数分析的格式。</summary>
        <value>.NET Framework 的目标版本和配置文件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置此属性来告诉当前正在运行.NET Framework 版本，将使用的应用程序域加载并运行目标版本和配置文件已编译的程序集。 如果当前正在运行.NET Framework 版本有影响的兼容性用目标版本编译的代码的可选行为，它可以启用或禁用这些行为，根据需要，为了提高兼容性。 当应用程序支持在单独的应用程序域中运行它们编译使用.NET framework 的多个版本的外接程序时，这很有用。  
  
 对于客户端应用程序，值<xref:System.AppDomainSetup.TargetFrameworkName%2A>属性，则从推断<xref:System.Runtime.Versioning.TargetFrameworkAttribute>属性。 在[!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)]和更高版本，此属性添加到程序集将根据项目的设置自动**目标框架**属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>