<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="AppDomain.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c3ab234edad8a65f7b4b6688da32990c9642f79d.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c3ab234edad8a65f7b4b6688da32990c9642f79d</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Represents an application domain, which is an isolated environment where applications execute.</source>
          <target state="translated">表示应用程序域，它是一个应用程序在其中执行的独立环境。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>This class cannot be inherited.</source>
          <target state="translated">此类不能被继承。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Application domains, which are represented by <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> objects, help provide isolation, unloading, and security boundaries for executing managed code.</source>
          <target state="translated">应用程序域，由表示<ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>对象，帮助提供有关执行托管的代码的隔离、 卸载和安全边界。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Use application domains to isolate tasks that might bring down a process.</source>
          <target state="translated">使用应用程序域隔离可能会终止进程的任务。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>If the state of the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> that's executing a task becomes unstable, the <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph> can be unloaded without affecting the process.</source>
          <target state="translated">如果状态<ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>，正在执行的任务变得不稳定，<ph id="ph2">&lt;xref:System.AppDomain&gt;</ph>可以而不会影响进程中卸载。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>This is important when a process must run for long periods without restarting.</source>
          <target state="translated">进程必须运行很长一段无需重新启动时，这很重要。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>You can also use application domains to isolate tasks that should not share data.</source>
          <target state="translated">你还可以使用应用程序域隔离不应共享数据的任务。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>If an assembly is loaded into the default application domain, it cannot be unloaded from memory while the process is running.</source>
          <target state="translated">如果程序集被加载到默认应用程序域，它无法从内存中卸载过程运行时。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>However, if you open a second application domain to load and execute the assembly, the assembly is unloaded when that application domain is unloaded.</source>
          <target state="translated">但是，如果您打开第二个应用程序域加载和执行程序集，程序集是卸载卸载该应用程序域时。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Use this technique to minimize the working set of long-running processes that occasionally use large DLLs.</source>
          <target state="translated">使用此方法最大程度减少偶尔使用大型 Dll 的长时间运行进程的工作集。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Multiple application domains can run in a single process; however, there is not a one-to-one correlation between application domains and threads.</source>
          <target state="translated">多个应用程序域可以运行在一个进程中;但是，没有应用程序域和线程之间的一对一的相关性。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Several threads can belong to a single application domain, and while a given thread is not confined to a single application domain, at any given time, a thread executes in a single application domain.</source>
          <target state="translated">多个线程可以属于单个应用程序域，并且单个应用程序域中时的给定的线程并不局限于单个应用程序域，在任何给定时间，执行线程。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Application domains are created using the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> method.</source>
          <target state="translated">使用创建应用程序域<ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> instances are used to load and execute assemblies (<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> 实例用于加载和执行程序集 (<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>When an <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> is no longer in use, it can be unloaded.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>是不再在使用中，可以将它卸载。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> class implements a set of events that enable applications to respond when an assembly is loaded, when an application domain will be unloaded, or when an unhandled exception is thrown.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>类实现的一组启用应用程序进行响应时加载的程序集，应用程序域将被卸载，或引发未经处理的异常时的事件。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>For more information on using application domains, see <bpt id="p1">[</bpt>Application Domains<ept id="p1">](~/docs/framework/app-domains/application-domains.md)</ept>.</source>
          <target state="translated">有关使用应用程序域的详细信息，请参阅<bpt id="p1">[</bpt>应用程序域<ept id="p1">](~/docs/framework/app-domains/application-domains.md)</ept>。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>This class implements the <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph>, <ph id="ph2">&lt;xref:System._AppDomain&gt;</ph>, and <ph id="ph3">&lt;xref:System.Security.IEvidenceFactory&gt;</ph> interfaces.</source>
          <target state="translated">此类实现<ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph>， <ph id="ph2">&lt;xref:System._AppDomain&gt;</ph>，和<ph id="ph3">&lt;xref:System.Security.IEvidenceFactory&gt;</ph>接口。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>You should never create a remotable wrapper for an <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> object.</source>
          <target state="translated">决不要创建的远程操作包装<ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Doing so could publish a remote reference to that <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, exposing methods such as <ph id="ph2">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> to remote access and effectively destroying code access security for that <ph id="ph3">&lt;xref:System.AppDomain&gt;</ph>.</source>
          <target state="translated">这样可以将发布到的远程引用<ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>，如公开方法<ph id="ph2">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>与远程访问和有效地销毁该的代码访问安全性<ph id="ph3">&lt;xref:System.AppDomain&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Malicious clients connecting to the remoted <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> could obtain access to any resource the <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph> itself has access to.</source>
          <target state="translated">恶意客户端连接到远程<ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>无法获取任何资源的访问权限<ph id="ph2">&lt;xref:System.AppDomain&gt;</ph>本身具有访问权限。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Do not create remotable wrappers for any type that extends <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph> and that implements methods that could be used by malicious clients to bypass the security system.</source>
          <target state="translated">不创建任何扩展的类型的远程操作包装<ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph>并实现恶意客户端无法用于绕过安全系统的方法。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>The default value for the <ph id="ph1">&lt;xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType&gt;</ph> property is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">默认值为<ph id="ph1">&lt;xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType&gt;</ph>属性是<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>This setting is unsafe for services.</source>
          <target state="translated">此设置是不安全的服务。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>To prevent services from downloading partially trusted code, set this property to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">若要防止服务下载部分受信任的代码，请将此属性设置为<ph id="ph1">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>This example shows how to create a new <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, instantiate a type in that new <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph>, and communicate with that type’s object.</source>
          <target state="translated">此示例演示如何创建一个新<ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>，新实例化中的一个类型<ph id="ph2">&lt;xref:System.AppDomain&gt;</ph>，以及与该类型的对象通信。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>In addition, this example shows how to unload the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> causing the object to be garbage collected.</source>
          <target state="translated">此外，此示例演示如何卸载<ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>导致要进行垃圾回收的对象。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="P:System.AppDomain.ActivationContext">
          <source>Gets the activation context for the current application domain.</source>
          <target state="translated">获取当前应用程序域的激活上下文。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ActivationContext">
          <source>An object that represents the activation context for the current application domain, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the domain has no activation context.</source>
          <target state="translated">一个对象，表示当前应用程序域的激活上下文；或者如果域没有激活上下文，则返回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ActivationContext">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ActivationContext">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>The name of the directory to be appended to the private path.</source>
          <target state="translated">要追加到专用路径的目录名称。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>Appends the specified directory name to the private path list.</source>
          <target state="translated">将指定的目录名追加到专用路径列表。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>The use of this property is not recommended, because it might change the probing path for assemblies after they have already been loaded.</source>
          <target state="translated">不建议使用此属性，因为它可能会更改之后它们都已加载程序集的探测路径。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph> property instead.</source>
          <target state="translated">改用 <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>The private path, or relative search path, is the path relative to the base directory where the assembly resolver probes for private assemblies.</source>
          <target state="translated">专用路径或相对搜索路径是相对于此程序集冲突解决程序从中探测专用程序集的基目录的路径。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="P:System.AppDomain.ApplicationIdentity">
          <source>Gets the identity of the application in the application domain.</source>
          <target state="translated">获得应用程序域中的应用程序标识。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationIdentity">
          <source>An object that identifies the application in the application domain.</source>
          <target state="translated">标识应用程序域中应用程序的对象。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationIdentity">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationIdentity">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="P:System.AppDomain.ApplicationTrust">
          <source>Gets information describing permissions granted to an application and whether the application has a trust level that allows it to run.</source>
          <target state="translated">获取说明授予应用程序的权限以及应用程序是否拥有允许其运行的信任级别的信息。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationTrust">
          <source>An object that encapsulates permission and trust information for the application in the application domain.</source>
          <target state="translated">封装应用程序域中应用程序的权限及信任信息的对象。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationTrust">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationTrust">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ApplyPolicy(System.String)">
          <source>The assembly display name, in the form provided by the <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph> property.</source>
          <target state="translated">程序集显示名称，采用 <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph> 属性提供的格式。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ApplyPolicy(System.String)">
          <source>Returns the assembly display name after policy has been applied.</source>
          <target state="translated">返回应用策略后的程序集显示名称。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ApplyPolicy(System.String)">
          <source>A string containing the assembly display name after policy has been applied.</source>
          <target state="translated">包含应用策略后的程序集显示名称的字符串。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ApplyPolicy(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ApplyPolicy%2A&gt;</ph> method takes an assembly display name and returns the post-policy display name.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.ApplyPolicy%2A&gt;</ph>方法采用一个程序集的显示名称和返回的策略后的显示名称。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ApplyPolicy(System.String)">
          <source>This is useful if you need to load an assembly using policy, because the reflection-only context does not apply policy.</source>
          <target state="translated">这是你需要使用策略，将程序集的加载，因为只反射上下文不适用于策略的情况下很有用。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="E:System.AppDomain.AssemblyLoad">
          <source>Occurs when an assembly is loaded.</source>
          <target state="translated">在加载程序集时发生。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>The <ph id="ph1">&lt;xref:System.AssemblyLoadEventHandler&gt;</ph> delegate for this event indicates what assembly was loaded.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AssemblyLoadEventHandler&gt;</ph>委托此事件指示哪些程序集被加载。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>To register an event handler for this event, you must have the required permissions, or a <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown.</source>
          <target state="translated">若要注册的事件处理程序此事件，你必须具有所需的权限，或<ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">有关处理事件的详细信息，请参阅<bpt id="p1">[</bpt>处理和引发事件<ept id="p1">](~/docs/standard/events/index.md)</ept>。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.AssemblyLoad&gt;</ph> event.</source>
          <target state="translated">下面的示例演示如何<ph id="ph1">&lt;xref:System.AppDomain.AssemblyLoad&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">若要运行此代码示例，你必须提供完全限定程序集名称。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">有关如何获取完全限定程序集名称的信息，请参阅<bpt id="p1">[</bpt>程序集名称<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="E:System.AppDomain.AssemblyResolve">
          <source>Occurs when the resolution of an assembly fails.</source>
          <target state="translated">在对程序集的解析失败时发生。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>It is the responsibility of the <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> for this event to return the assembly that is specified by the <ph id="ph2">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> property, or to return null if the assembly is not recognized.</source>
          <target state="translated">它负责<ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph>此事件返回的程序集指定<ph id="ph2">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph>属性，或者若要返回无法识别程序集的情况下为 null。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>The assembly must be loaded into an execution context; if it is loaded into the reflection-only context, the load that caused this event to be raised fails.</source>
          <target state="translated">该程序集必须加载到执行上下文;如果它加载到只反射上下文，导致引发此事件加载会失败。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For guidance on the use of this event, see <bpt id="p1">[</bpt>Resolving Assembly Loads<ept id="p1">](~/docs/framework/app-domains/resolve-assembly-loads.md)</ept>.</source>
          <target state="translated">有关使用此事件的指南，请参阅<bpt id="p1">[</bpt>解析程序集加载<ept id="p1">](~/docs/framework/app-domains/resolve-assembly-loads.md)</ept>。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> property returns the assembly that requested the assembly load that could not be resolved.</source>
          <target state="translated">开头<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>、<ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>属性返回的请求无法解析的程序集加载的程序集。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For example, the loader might be unable to load a dependency of the requesting assembly because the requesting assembly and its dependency are not in the probing path.</source>
          <target state="translated">例如，加载程序可能无法加载请求的程序集的依赖项，因为请求的程序集和其依赖项不探测路径中。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>Knowing the identity of the requesting assembly might be useful in locating the dependency or in identifying the correct version, if more than one version of the dependency is available.</source>
          <target state="translated">了解请求的程序集的标识可能定位依赖项或者在很有用标识正确的版本，如果多个依赖项的版本可用。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For more information, see <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">有关详情，请参阅<ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.ResolveEventHandler&gt;</ph> event is raised for all assemblies, including resource assemblies.</source>
          <target state="translated">开头<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>、<ph id="ph2">&lt;xref:System.ResolveEventHandler&gt;</ph>事件引发的所有程序集，包括资源程序集。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>In earlier versions, the event was not raised for resource assemblies.</source>
          <target state="translated">在早期版本中的资源程序集不引发事件。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>If the operating system is localized, the handler might be called multiple times: once for each culture in the fallback chain.</source>
          <target state="translated">如果本地化操作系统，则可能会调用处理程序多次： 一次针对回退链中每个区域性。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For this event, the <ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> property returns the assembly name before policy is applied.</source>
          <target state="translated">对于此事件，<ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph>应用策略之前，属性将返回的程序集名称。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>If more than one event handler is registered for this event, the event handlersarecalled in order until an event handler returns a value that isn't <ph id="ph1">`null`</ph>.</source>
          <target state="translated">如果此事件注册多个事件处理程序，不按顺序直到事件处理程序返回一个值事件 handlersarecalled <ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>Subsequent event handlers are ignored.</source>
          <target state="translated">将忽略后续的事件处理程序。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">有关处理事件的详细信息，请参阅<bpt id="p1">[</bpt>处理和引发事件<ept id="p1">](~/docs/standard/events/index.md)</ept>。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">下面的示例演示如何<ph id="ph1">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">若要运行此代码示例，你必须提供完全限定程序集名称。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">有关如何获取完全限定程序集名称的信息，请参阅<bpt id="p1">[</bpt>程序集名称<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="P:System.AppDomain.BaseDirectory">
          <source>Gets the base directory that the assembly resolver uses to probe for assemblies.</source>
          <target state="translated">获取基目录，它由程序集冲突解决程序用来探测程序集。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>The base directory that the assembly resolver uses to probe for assemblies.</source>
          <target state="translated">基目录，由程序集冲突解决程序用来探测程序集。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>This property corresponds to the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">此属性对应于<ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>It can also be retrieved using the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method with the string "APPBASE".</source>
          <target state="translated">它可以还使用检索<ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph>与字符串"APPBASE"的方法。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain.</source>
          <target state="translated">下面的代码示例创建一个新的应用程序域，指定要加载到域中搜索的程序集时要使用的基目录。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>The example then uses the <ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph> property to obtain the base directory path, for display to the console.</source>
          <target state="translated">然后该示例使用<ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph>属性来获取基目录路径，以显示到控制台。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="P:System.AppDomain.BaseDirectory">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>for access to the information in the path itself, including if the path is in the form "file://" or <ph id="ph1">\\</ph>\UNC\dir or "c:<ph id="ph2">\\</ph>".</source>
          <target state="translated">获得路径本身中的信息，如果包括路径采用的是窗体"file://"或<ph id="ph1">\\</ph>\UNC\dir 或"c:<ph id="ph2">\\</ph>"。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ClearPrivatePath">
          <source>Resets the path that specifies the location of private assemblies to the empty string ("").</source>
          <target state="translated">将指定专用程序集位置的路径重置为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>The private path is a path relative to the base directory that the common language runtime searches to locate private assemblies.</source>
          <target state="translated">专用的路径是相对于基目录，公共语言运行时搜索来查找私有程序集的路径。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>For more information, see <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">有关详情，请参阅<ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.AppDomain.ClearPrivatePath%2A&gt;</ph> method to remove all entries from the list of private paths to search when assemblies are loaded.</source>
          <target state="translated">下面的代码示例演示如何使用<ph id="ph1">&lt;xref:System.AppDomain.ClearPrivatePath%2A&gt;</ph>方法从的搜索时程序集都会加载专用路径列表中移除所有项。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>This method is now obsolete, and should not be used for new development.</source>
          <target state="translated">此方法现已过时，并不应使用新的开发。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ClearPrivatePath">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>Resets the list of directories containing shadow copied assemblies to the empty string ("").</source>
          <target state="translated">将包含影像复制的程序集的目录列表重置为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>The shadow copy path is a list of directories where shadow copied assemblies are stored.</source>
          <target state="translated">卷影复制路径是存储的卷影复制的程序集的目录列表。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>For more information, see <ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType&gt;</ph> and <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType&gt;</ph>和<bpt id="p1">[</bpt>影像复制程序集<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new instance of a specified COM type.</source>
          <target state="translated">创建指定 COM 类型的新实例。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The name of a file containing an assembly that defines the requested type.</source>
          <target state="translated">文件的名称，该文件包含定义所请求的类型的程序集。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The name of the requested type.</source>
          <target state="translated">所请求类型的名称。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>Creates a new instance of a specified COM type.</source>
          <target state="translated">创建指定 COM 类型的新实例。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</source>
          <target state="translated">形参指定文件的名称，该文件包含含有类型和类型名称的程序集。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">一个对象，该对象是 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 指定的新实例的包装。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">返回值需要打开包装才能访问真实对象。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>Use this method to create objects remotely without having to load the type locally.</source>
          <target state="translated">使用此方法以远程创建对象，而无需本地加载该类型。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The return value must to be unwrapped to access the real object.</source>
          <target state="translated">返回值需要打开包装才能访问真实对象。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>A <ph id="ph1">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph> attribute with a value of <ph id="ph2">`true`</ph> must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> is thrown.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph>属性值为<ph id="ph2">`true`</ph>必须以显式或默认方式对此方法 COM 类型，来创建该类型; 的实例应用否则为<ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The following sample demonstrates</source>
          <target state="translated">下面的示例演示如何</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The type cannot be loaded.</source>
          <target state="translated">无法加载此类型。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>No public parameterless constructor was found.</source>
          <target state="translated">未找到公共无形参构造函数。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is an abstract class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 是一个抽象类。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>This member was invoked with a late-binding mechanism.</source>
          <target state="translated">使用晚期绑定机制调用了此成员。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">调用方不能为非继承自 <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph> 的对象提供激活属性。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The COM object that is being referred to is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">所引用的 COM 对象为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name of a file containing an assembly that defines the requested type.</source>
          <target state="translated">文件的名称，该文件包含定义所请求的类型的程序集。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name of the requested type.</source>
          <target state="translated">所请求类型的名称。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the value of the computed hash code.</source>
          <target state="translated">表示计算所得的哈希代码的值。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the hash algorithm used by the assembly manifest.</source>
          <target state="translated">表示程序集清单使用的哈希算法。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Creates a new instance of a specified COM type.</source>
          <target state="translated">创建指定 COM 类型的新实例。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</source>
          <target state="translated">形参指定文件的名称，该文件包含含有类型和类型名称的程序集。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">一个对象，该对象是 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 指定的新实例的包装。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">返回值需要打开包装才能访问真实对象。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Use this method to create objects remotely without having to load the type locally.</source>
          <target state="translated">使用此方法以远程创建对象，而无需本地加载该类型。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The return value must to be unwrapped to access the real object.</source>
          <target state="translated">返回值需要打开包装才能访问真实对象。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>A <ph id="ph1">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph> attribute with a value of <ph id="ph2">`true`</ph> must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> is thrown.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph>属性值为<ph id="ph2">`true`</ph>必须以显式或默认方式对此方法 COM 类型，来创建该类型; 的实例应用否则为<ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The type cannot be loaded.</source>
          <target state="translated">无法加载此类型。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>No public parameterless constructor was found.</source>
          <target state="translated">未找到公共无形参构造函数。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is an abstract class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 是一个抽象类。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This member was invoked with a late-binding mechanism.</source>
          <target state="translated">使用晚期绑定机制调用了此成员。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">调用方不能为非继承自 <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph> 的对象提供激活属性。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The COM object that is being referred to is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">所引用的 COM 对象为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new application domain.</source>
          <target state="translated">创建新的应用程序域。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>The friendly name of the domain.</source>
          <target state="translated">域的友好名称。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>Creates a new application domain with the specified name.</source>
          <target state="translated">使用指定的名称新建应用程序域。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>The newly created application domain.</source>
          <target state="translated">新创建的应用程序域。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>The <ph id="ph1">`friendlyName`</ph> parameter is intended to identify the domain in a manner that is meaningful to humans.</source>
          <target state="translated"><ph id="ph1">`friendlyName`</ph>参数用于确定对用户有意义的方式的域。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>This string should be suitable for display in user interfaces.</source>
          <target state="translated">此字符串应适合在用户界面中显示。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>This method overload uses the <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> information from the default application domain.</source>
          <target state="translated">此方法重载使用<ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph>从默认应用程序域的信息。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>The following sample demonstrates, in general, how to create a domain using one of the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overloads.</source>
          <target state="translated">下面的示例演示一般情况下，如何创建使用之一域<ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph>重载。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>to provide evidence.</source>
          <target state="translated">若要提供的证据。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>The friendly name of the domain.</source>
          <target state="translated">域的友好名称。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>This friendly name can be displayed in user interfaces to identify the domain.</source>
          <target state="translated">此友好名称可在用户界面中显示以标识域。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</source>
          <target state="translated">有关详情，请参阅<ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Evidence that establishes the identity of the code that runs in the application domain.</source>
          <target state="translated">确定代码标识的证据，该代码在应用程序域中运行。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Pass <ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the evidence of the current application domain.</source>
          <target state="translated">传递 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 以使用当前应用程序域的证据。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Creates a new application domain with the given name using the supplied evidence.</source>
          <target state="translated">使用所提供的证据创建具有给定名称的新应用程序域。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>The newly created application domain.</source>
          <target state="translated">新创建的应用程序域。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>This method overload uses the <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> information from the default application domain.</source>
          <target state="translated">此方法重载使用<ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph>从默认应用程序域的信息。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>If <ph id="ph1">`securityInfo`</ph> is not supplied, the evidence from the current application domain is used.</source>
          <target state="translated">如果<ph id="ph1">`securityInfo`</ph>是未提供，用于从当前的应用程序域的证据。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Do not use this method overload to create sandboxed application domains.</source>
          <target state="translated">不使用此方法重载来创建沙盒应用程序域。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the evidence that is supplied for <ph id="ph2">`securityInfo`</ph> no longer affects the grant set of the application domain.</source>
          <target state="translated">开头<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>，为提供的证据<ph id="ph2">`securityInfo`</ph>不会再影响应用程序域的授予集。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Use the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> method overload to create sandboxed application domains.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph>方法重载来创建沙盒应用程序域。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>The following sample demonstrates, in general, how to create a domain using one of the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overloads.</source>
          <target state="translated">下面的示例演示一般情况下，如何创建使用之一域<ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph>重载。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>to provide evidence.</source>
          <target state="translated">若要提供的证据。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>The friendly name of the domain.</source>
          <target state="translated">域的友好名称。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>This friendly name can be displayed in user interfaces to identify the domain.</source>
          <target state="translated">此友好名称可在用户界面中显示以标识域。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</source>
          <target state="translated">有关详情，请参阅<ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Evidence that establishes the identity of the code that runs in the application domain.</source>
          <target state="translated">确定代码标识的证据，该代码在应用程序域中运行。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Pass <ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the evidence of the current application domain.</source>
          <target state="translated">传递 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 以使用当前应用程序域的证据。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>An object that contains application domain initialization information.</source>
          <target state="translated">包含应用程序域初始化信息的对象。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Creates a new application domain using the specified name, evidence, and application domain setup information.</source>
          <target state="translated">使用指定的名称、证据和应用程序域设置信息创建新的应用程序域。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>The newly created application domain.</source>
          <target state="translated">新创建的应用程序域。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>If <ph id="ph1">`info`</ph> is not supplied, this method overload uses the <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> information from the default application domain.</source>
          <target state="translated">如果<ph id="ph1">`info`</ph>是未提供，此方法重载使用<ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph>从默认应用程序域的信息。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>If <ph id="ph1">`securityInfo`</ph> is not supplied, the evidence from the current application domain is used.</source>
          <target state="translated">如果<ph id="ph1">`securityInfo`</ph>是未提供，用于从当前的应用程序域的证据。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Do not use this method overload to create sandboxed application domains.</source>
          <target state="translated">不使用此方法重载来创建沙盒应用程序域。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the evidence that is supplied for <ph id="ph2">`securityInfo`</ph> no longer affects the grant set of the application domain.</source>
          <target state="translated">开头<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>，为提供的证据<ph id="ph2">`securityInfo`</ph>不会再影响应用程序域的授予集。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Use the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> method overload to create sandboxed application domains.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph>方法重载来创建沙盒应用程序域。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>The following sample demonstrates, in general, how to create a domain using one of the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overloads.</source>
          <target state="translated">下面的示例演示一般情况下，如何创建使用之一域<ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph>重载。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>to provide evidence.</source>
          <target state="translated">若要提供的证据。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>The friendly name of the domain.</source>
          <target state="translated">域的友好名称。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>This friendly name can be displayed in user interfaces to identify the domain.</source>
          <target state="translated">此友好名称可在用户界面中显示以标识域。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>For more information, see the description of <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</source>
          <target state="translated">有关更多信息，请参见 <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph> 的说明。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Evidence that establishes the identity of the code that runs in the application domain.</source>
          <target state="translated">确定代码标识的证据，该代码在应用程序域中运行。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Pass <ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the evidence of the current application domain.</source>
          <target state="translated">传递 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 以使用当前应用程序域的证据。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>An object that contains application domain initialization information.</source>
          <target state="translated">包含应用程序域初始化信息的对象。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>A default permission set that is granted to all assemblies loaded into the new application domain that do not have specific grants.</source>
          <target state="translated">一个默认权限集，被授予加载到新应用程序域的所有无特定权限的程序集。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>An array of strong names representing assemblies to be considered fully trusted in the new application domain.</source>
          <target state="translated">一组强名称，表示在新应用程序域中被认为完全受信任的程序集。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Creates a new application domain using the specified name, evidence, application domain setup information, default permission set, and array of fully trusted assemblies.</source>
          <target state="translated">使用指定的名称、证据、应用程序域设置信息、默认权限集和一组完全受信任的程序集创建新的应用程序域。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>The newly created application domain.</source>
          <target state="translated">新创建的应用程序域。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>You must set the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> object that you supply for <ph id="ph3">`info`</ph>.</source>
          <target state="translated">必须设置<ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph>属性<ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph>为提供的对象<ph id="ph3">`info`</ph>。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Otherwise, an exception is thrown.</source>
          <target state="translated">否则会引发异常。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>If <ph id="ph1">`securityInfo`</ph> is not supplied, the evidence from the current application domain is used.</source>
          <target state="translated">如果<ph id="ph1">`securityInfo`</ph>是未提供，用于从当前的应用程序域的证据。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>The information provided for <ph id="ph1">`grantSet`</ph> and <ph id="ph2">`fullTrustAssemblies`</ph> is used to create an <ph id="ph3">&lt;xref:System.Security.Policy.ApplicationTrust&gt;</ph> object for the new application domain.</source>
          <target state="translated">为提供的信息<ph id="ph1">`grantSet`</ph>和<ph id="ph2">`fullTrustAssemblies`</ph>用于创建<ph id="ph3">&lt;xref:System.Security.Policy.ApplicationTrust&gt;</ph>新的应用程序域的对象。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>The application domain is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">应用程序域为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.AppDomainSetup.ApplicationBase" /&gt;</ph> property is not set on the <ph id="ph2">&lt;see cref="T:System.AppDomainSetup" /&gt;</ph> object that is supplied for <ph id="ph3">&lt;paramref name="info" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.AppDomainSetup.ApplicationBase" /&gt;</ph> 属性在为 <ph id="ph3">&lt;paramref name="info" /&gt;</ph> 提供的 <ph id="ph2">&lt;see cref="T:System.AppDomainSetup" /&gt;</ph> 对象上没有设置。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>for the ability to create and manipulate an application domain.</source>
          <target state="translated">创建和操作的应用程序域的功能。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">安全操作： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>The friendly name of the domain.</source>
          <target state="translated">域的友好名称。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>This friendly name can be displayed in user interfaces to identify the domain.</source>
          <target state="translated">此友好名称可在用户界面中显示以标识域。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</source>
          <target state="translated">有关详情，请参阅<ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Evidence that establishes the identity of the code that runs in the application domain.</source>
          <target state="translated">确定代码标识的证据，该代码在应用程序域中运行。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Pass <ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the evidence of the current application domain.</source>
          <target state="translated">传递 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 以使用当前应用程序域的证据。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>The base directory that the assembly resolver uses to probe for assemblies.</source>
          <target state="translated">基目录，由程序集冲突解决程序用来探测程序集。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.BaseDirectory" /&gt;</ph>.</source>
          <target state="translated">有关详情，请参阅<ph id="ph1">&lt;see cref="P:System.AppDomain.BaseDirectory" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>The path relative to the base directory where the assembly resolver should probe for private assemblies.</source>
          <target state="translated">相对于基目录的路径，在此程序集冲突解决程序应探测专用程序集。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.RelativeSearchPath" /&gt;</ph>.</source>
          <target state="translated">有关详情，请参阅<ph id="ph1">&lt;see cref="P:System.AppDomain.RelativeSearchPath" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, a shadow copy of an assembly is loaded into this application domain.</source>
          <target state="translated">如果为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，则向此应用程序域中加载程序集的卷影副本。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</source>
          <target state="translated">使用证据、应用程序基路径、相对搜索路径和指定是否向应用程序域中加载程序集的影像副本的形参创建具有给定名称的新应用程序域。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>The newly created application domain.</source>
          <target state="translated">新创建的应用程序域。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>If <ph id="ph1">`securityInfo`</ph> is not supplied, the evidence from the current application domain is used.</source>
          <target state="translated">如果<ph id="ph1">`securityInfo`</ph>是未提供，用于从当前的应用程序域的证据。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>For more information about shadow copying, see <ph id="ph1">&lt;xref:System.AppDomain.ShadowCopyFiles%2A&gt;</ph> and <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">有关卷影复制的详细信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.ShadowCopyFiles%2A&gt;</ph>和<bpt id="p1">[</bpt>影像复制程序集<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Do not use this method overload to create sandboxed application domains.</source>
          <target state="translated">不使用此方法重载来创建沙盒应用程序域。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the evidence that is supplied for <ph id="ph2">`securityInfo`</ph> no longer affects the grant set of the application domain.</source>
          <target state="translated">开头<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>，为提供的证据<ph id="ph2">`securityInfo`</ph>不会再影响应用程序域的授予集。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Use the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> method overload to create sandboxed application domains.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph>方法重载来创建沙盒应用程序域。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>The following sample demonstrates, in general, how to create a domain using one of the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overloads.</source>
          <target state="translated">下面的示例演示一般情况下，如何创建使用之一域<ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph>重载。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>to provide evidence.</source>
          <target state="translated">若要提供的证据。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>The friendly name of the domain.</source>
          <target state="translated">域的友好名称。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>This friendly name can be displayed in user interfaces to identify the domain.</source>
          <target state="translated">此友好名称可在用户界面中显示以标识域。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</source>
          <target state="translated">有关详情，请参阅<ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Evidence that establishes the identity of the code that runs in the application domain.</source>
          <target state="translated">确定代码标识的证据，该代码在应用程序域中运行。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Pass <ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the evidence of the current application domain.</source>
          <target state="translated">传递 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 以使用当前应用程序域的证据。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>The base directory that the assembly resolver uses to probe for assemblies.</source>
          <target state="translated">基目录，由程序集冲突解决程序用来探测程序集。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.BaseDirectory" /&gt;</ph>.</source>
          <target state="translated">有关详情，请参阅<ph id="ph1">&lt;see cref="P:System.AppDomain.BaseDirectory" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>The path relative to the base directory where the assembly resolver should probe for private assemblies.</source>
          <target state="translated">相对于基目录的路径，在此程序集冲突解决程序应探测专用程序集。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.RelativeSearchPath" /&gt;</ph>.</source>
          <target state="translated">有关详情，请参阅<ph id="ph1">&lt;see cref="P:System.AppDomain.RelativeSearchPath" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to load a shadow copy of an assembly into the application domain.</source>
          <target state="translated">如果为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，则将程序集的卷影副本加载到应用程序域中。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.AppDomainInitializer" /&gt;</ph> delegate that represents a callback method to invoke when the new <ph id="ph2">&lt;see cref="T:System.AppDomain" /&gt;</ph> object is initialized.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AppDomainInitializer" /&gt;</ph> 委托，表示初始化新的 <ph id="ph2">&lt;see cref="T:System.AppDomain" /&gt;</ph> 对象时调用的回调方法。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>An array of string arguments to be passed to the callback represented by <bpt id="p1">&lt;c&gt;</bpt>adInit<ept id="p1">&lt;/c&gt;</ept>, when the new <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> object is initialized.</source>
          <target state="translated">字符串实参数组，在初始化新的 <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> 对象时传递给由 <bpt id="p1">&lt;c&gt;</bpt>adInit<ept id="p1">&lt;/c&gt;</ept> 表示的回调。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</source>
          <target state="translated">使用证据、应用程序基路径、相对搜索路径和指定是否向应用程序域中加载程序集的影像副本的形参创建具有给定名称的新应用程序域。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Specifies a callback method that is invoked when the application domain is initialized, and an array of string arguments to pass the callback method.</source>
          <target state="translated">指定在初始化应用程序域时调用的回调方法，以及传递回调方法的字符串实参数组。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>The newly created application domain.</source>
          <target state="translated">新创建的应用程序域。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>The method represented by <ph id="ph1">`adInit`</ph> is executed in the context of the newly created application domain.</source>
          <target state="translated">所表示的方法<ph id="ph1">`adInit`</ph>在新创建的应用程序域的上下文中执行。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>If <ph id="ph1">`securityInfo`</ph> is not supplied, the evidence from the current application domain is used.</source>
          <target state="translated">如果<ph id="ph1">`securityInfo`</ph>是未提供，用于从当前的应用程序域的证据。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>For more information about shadow copying, see <ph id="ph1">&lt;xref:System.AppDomain.ShadowCopyFiles%2A&gt;</ph> and <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">有关卷影复制的详细信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.ShadowCopyFiles%2A&gt;</ph>和<bpt id="p1">[</bpt>影像复制程序集<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Do not use this method overload to create sandboxed application domains.</source>
          <target state="translated">不使用此方法重载来创建沙盒应用程序域。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the evidence that is supplied for <ph id="ph2">`securityInfo`</ph> no longer affects the grant set of the application domain.</source>
          <target state="translated">开头<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>，为提供的证据<ph id="ph2">`securityInfo`</ph>不会再影响应用程序域的授予集。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Use the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> method overload to create sandboxed application domains.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph>方法重载来创建沙盒应用程序域。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>to provide evidence.</source>
          <target state="translated">若要提供的证据。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new instance of a specified type defined in a specified assembly.</source>
          <target state="translated">创建在指定程序集中定义的指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>Creates a new instance of the specified type defined in the specified assembly.</source>
          <target state="translated">创建在指定程序集中定义的指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">一个对象，该对象是 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 指定的新实例的包装。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">返回值需要打开包装才能访问真实对象。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">此方法调用的默认构造函数<ph id="ph1">`typeName`</ph>。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>的格式<ph id="ph2">`assemblyName`</ph>。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</source>
          <target state="translated">尝试调用<ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>在目标上不是当前的应用程序域的应用程序域将导致目标应用程序域中的程序集成功加载。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>Since an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is not <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, when this method attempts to return the <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</source>
          <target state="translated">由于<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>不<ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>，当此方法尝试返回<ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph>到当前的应用程序域加载程序集，公共语言运行时将尝试将程序集加载到当前的应用程序域和负载可能会失败。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</source>
          <target state="translated">可能不同于不同的两个应用程序域的路径设置是否首先加载的程序集加载到当前的应用程序域的程序集。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">调用方没有权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>No matching public constructor was found.</source>
          <target state="translated">未找到匹配的公共构造函数。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typename" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">此示例为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>for the ability to call unmanaged code when creating an instance of a delegate.</source>
          <target state="translated">创建委托的一个实例时调用非托管的代码的功能。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">包含一个或多个可以参与激活的特性的数组。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">通常，为包含单个 <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> 对象的数组，该对象指定激活远程对象所需的 URL。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">此参数与客户端激活的对象相关。客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">应改用 Windows Communication Foundation 来开发分布式应用程序。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly.</source>
          <target state="translated">创建在指定程序集中定义的指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>A parameter specifies an array of activation attributes.</source>
          <target state="translated">形参指定激活特性数组。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">一个对象，该对象是 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 指定的新实例的包装。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">返回值需要打开包装才能访问真实对象。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">此方法调用的默认构造函数<ph id="ph1">`typeName`</ph>。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>的格式<ph id="ph2">`assemblyName`</ph>。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</source>
          <target state="translated">尝试调用<ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>在目标上不是当前的应用程序域的应用程序域将导致目标应用程序域中的程序集成功加载。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Since an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is not <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, when this method attempts to return the <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</source>
          <target state="translated">由于<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>不<ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>，当此方法尝试返回<ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph>到当前的应用程序域加载程序集，公共语言运行时将尝试将程序集加载到当前的应用程序域和负载可能会失败。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</source>
          <target state="translated">可能不同于不同的两个应用程序域的路径设置是否首先加载的程序集加载到当前的应用程序域的程序集。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">调用方没有权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>No matching public constructor was found.</source>
          <target state="translated">未找到匹配的公共构造函数。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">调用方不能为非继承自 <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph> 的对象提供激活属性。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typename" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">此示例为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>for the ability to call unmanaged code when creating an instance of a delegate.</source>
          <target state="translated">创建委托的一个实例时调用非托管的代码的功能。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">表示所有类型的成员上调用操作的能力。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">一个布尔值，指示是否执行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">影响 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 构造函数搜索的零个或多个位标志的组合。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> 为零，则对公共构造函数进行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 对象的检索。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 null，则使用默认联编程序。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">要传递给构造函数的实参。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">如果默认的构造函数是首选构造函数，则 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 必须为空数组或 null。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">区域性特定的信息，这些信息控制将 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 强制转换为 <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> 构造函数所声明的正式类型。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用当前线程的 <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">包含一个或多个可以参与激活的特性的数组。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">通常，为包含单个 <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> 对象的数组，该对象指定激活远程对象所需的 URL。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">此参数与客户端激活的对象相关。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">应改用 Windows Communication Foundation 来开发分布式应用程序。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly.</source>
          <target state="translated">创建在指定程序集中定义的指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, and optional activation attributes.</source>
          <target state="translated">形参指定联编程序、绑定标志、构造函数实参、用于解释实参的特定于区域性的信息，以及可选激活特性。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">一个对象，该对象是 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 指定的新实例的包装。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">返回值需要打开包装才能访问真实对象。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>的格式<ph id="ph2">`assemblyName`</ph>。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</source>
          <target state="translated">尝试调用<ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>在目标上不是当前的应用程序域的应用程序域将导致目标应用程序域中的程序集成功加载。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Since an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is not <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, when this method attempts to return the <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</source>
          <target state="translated">由于<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>不<ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>，当此方法尝试返回<ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph>到当前的应用程序域加载程序集，公共语言运行时将尝试将程序集加载到当前的应用程序域和负载可能会失败。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</source>
          <target state="translated">可能不同于不同的两个应用程序域的路径设置是否首先加载的程序集加载到当前的应用程序域的程序集。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 使用高于当前所加载版本的公共语言运行时版本编译而成。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">调用方没有权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>No matching constructor was found.</source>
          <target state="translated">未找到匹配的构造函数。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">调用方不能为非继承自 <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph> 的对象提供激活属性。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typename" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">此示例为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to call unmanaged code when creating an instance of a delegate.</source>
          <target state="translated">创建委托的一个实例时调用非托管的代码的功能。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">表示所有类型的成员上调用操作的能力。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">一个布尔值，指示是否执行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">影响 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 构造函数搜索的零个或多个位标志的组合。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> 为零，则对公共构造函数进行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 对象的检索。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 null，则使用默认联编程序。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">要传递给构造函数的实参。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">如果默认的构造函数是首选构造函数，则 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 必须为空数组或 null。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">区域性特定的信息，这些信息控制将 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 强制转换为 <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> 构造函数所声明的正式类型。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用当前线程的 <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">包含一个或多个可以参与激活的特性的数组。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">通常，为包含单个 <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> 对象的数组，该对象指定激活远程对象所需的 URL。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">此参数与客户端激活的对象相关。客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">应改用 Windows Communication Foundation 来开发分布式应用程序。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Information used to authorize creation of <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">用于授权创建 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 的信息。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Creates a new instance of the specified type defined in the specified assembly.</source>
          <target state="translated">创建在指定程序集中定义的指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, activation attributes, and authorization to create the type.</source>
          <target state="translated">参数指定联编程序、绑定标志、构造函数自变量、特定于区域性的信息，这些信息用于解释自变量、激活特性和授权，以创建类型。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">一个对象，该对象是 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 指定的新实例的包装。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">返回值需要打开包装才能访问真实对象。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>的格式<ph id="ph2">`assemblyName`</ph>。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</source>
          <target state="translated">尝试调用<ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>在目标上不是当前的应用程序域的应用程序域将导致目标应用程序域中的程序集成功加载。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Since an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is not <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, when this method attempts to return the <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</source>
          <target state="translated">由于<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>不<ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>，当此方法尝试返回<ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph>到当前的应用程序域加载程序集，公共语言运行时将尝试将程序集加载到当前的应用程序域和负载可能会失败。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</source>
          <target state="translated">可能不同于不同的两个应用程序域的路径设置是否首先加载的程序集加载到当前的应用程序域的程序集。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">调用方没有权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>No matching constructor was found.</source>
          <target state="translated">未找到匹配的构造函数。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">调用方不能为非继承自 <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph> 的对象提供激活属性。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null." /&gt;</ph></source>
          <target state="translated">未启用旧版 CAS 策略时，<ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> 应该为 <ph id="ph2">&lt;see langword="null." /&gt;</ph></target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typename" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">此示例为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>to provide evidence.</source>
          <target state="translated">若要提供的证据。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">表示所有类型的成员上调用操作的能力。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new instance of a specified type.</source>
          <target state="translated">创建指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>Creates a new instance of the specified type.</source>
          <target state="translated">创建指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>Parameters specify the assembly where the type is defined, and the name of the type.</source>
          <target state="translated">形参指定定义类型的程序集以及类型的名称。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>An instance of the object specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 所指定对象的实例。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">这是合并的便捷方法<ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">此方法调用的默认构造函数<ph id="ph1">`typeName`</ph>。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>的格式<ph id="ph2">`assemblyName`</ph>。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>See the <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> property for the format of <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph>属性的格式<ph id="ph2">`typeName`</ph>。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>If you make an early-bound call to a method <ph id="ph1">`M`</ph> of an object of type <ph id="ph2">`T1`</ph> that was returned by <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, and that method makes an early-bound call to a method of an object of type <ph id="ph4">`T2`</ph> in an assembly <ph id="ph5">`C`</ph> other than the current assembly or the assembly containing <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> is loaded into the current application domain.</source>
          <target state="translated">如果进行早期绑定调用的方法<ph id="ph1">`M`</ph>类型的对象的<ph id="ph2">`T1`</ph>由返回<ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>，并方法使对类型的对象的方法的早期绑定调用<ph id="ph4">`T2`</ph>的程序集中<ph id="ph5">`C`</ph>以外当前程序集或包含的程序集<ph id="ph6">`T1`</ph>，程序集<ph id="ph7">`C`</ph>会加载到当前的应用程序域。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>This loading occurs even if the early-bound call to <ph id="ph1">`T1.M()`</ph> was made in the body of a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, or in other dynamically generated code.</source>
          <target state="translated">如果即使早期绑定调用，则会发生此加载<ph id="ph1">`T1.M()`</ph>的正文中进行<ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>，或在其他动态生成的代码中。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>If the current domain is the default domain, assembly <ph id="ph1">`C`</ph> cannot be unloaded until the process ends.</source>
          <target state="translated">如果当前域是默认域，程序集<ph id="ph1">`C`</ph>进程结束前不能卸载。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>If the current domain later attempts to load assembly <ph id="ph1">`C`</ph>, the load might fail.</source>
          <target state="translated">如果当前域稍后尝试加载程序集<ph id="ph1">`C`</ph>，则加载可能失败。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The following code example shows the simplest way to execute code in another application domain.</source>
          <target state="translated">下面的代码示例演示在另一个应用程序域中执行代码的最简单方法。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The example defines a class named <ph id="ph1">`Worker`</ph> that inherits from <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>.</source>
          <target state="translated">该示例定义一个名为类<ph id="ph1">`Worker`</ph>继承自<ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The <ph id="ph1">`Worker`</ph> class defines a method that displays the name of the application domain in which it is executing.</source>
          <target state="translated"><ph id="ph1">`Worker`</ph>类定义的方法，显示正在执行的应用程序域的名称。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The example creates instances of <ph id="ph1">`Worker`</ph> in the default application domain and in a new application domain.</source>
          <target state="translated">该示例创建的实例<ph id="ph1">`Worker`</ph>默认应用程序域中和新的应用程序域中。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The assembly that contains <ph id="ph1">`Worker`</ph> must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.</source>
          <target state="translated">包含的程序集<ph id="ph1">`Worker`</ph>必须加载到这两个应用程序域，但是它可以加载仅在新的应用程序域中存在其他程序集。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>No matching public constructor was found.</source>
          <target state="translated">未找到匹配的公共构造函数。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typename" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">调用方没有权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>for the ability to read the file containing the assembly manifest, or if you are creating a type from a module other than the manifest file.</source>
          <target state="translated">它能够读取该文件包含程序集清单，或如果你从不同的清单文件的模块创建一个类型。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">包含一个或多个可以参与激活的特性的数组。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">通常，为包含单个 <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> 对象的数组，该对象指定激活远程对象所需的 URL。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">此参数与客户端激活的对象相关。客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">应改用 Windows Communication Foundation 来开发分布式应用程序。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Creates a new instance of the specified type.</source>
          <target state="translated">创建指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Parameters specify the assembly where the type is defined, the name of the type, and an array of activation attributes.</source>
          <target state="translated">形参指定定义类型的程序集、类型的名称和激活特性的数组。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>An instance of the object specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 所指定对象的实例。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">这是合并的便捷方法<ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">此方法调用的默认构造函数<ph id="ph1">`typeName`</ph>。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>的格式<ph id="ph2">`assemblyName`</ph>。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>See the <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> property for the format of <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph>属性的格式<ph id="ph2">`typeName`</ph>。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>If you make an early-bound call to a method <ph id="ph1">`M`</ph> of an object of type <ph id="ph2">`T1`</ph> that was returned by <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, and that method makes an early-bound call to a method of an object of type <ph id="ph4">`T2`</ph> in an assembly <ph id="ph5">`C`</ph> other than the current assembly or the assembly containing <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> is loaded into the current application domain.</source>
          <target state="translated">如果进行早期绑定调用的方法<ph id="ph1">`M`</ph>类型的对象的<ph id="ph2">`T1`</ph>由返回<ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>，并方法使对类型的对象的方法的早期绑定调用<ph id="ph4">`T2`</ph>的程序集中<ph id="ph5">`C`</ph>以外当前程序集或包含的程序集<ph id="ph6">`T1`</ph>，程序集<ph id="ph7">`C`</ph>会加载到当前的应用程序域。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>This loading occurs even if the early-bound call to <ph id="ph1">`T1.M()`</ph> was made in the body of a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, or in other dynamically generated code.</source>
          <target state="translated">如果即使早期绑定调用，则会发生此加载<ph id="ph1">`T1.M()`</ph>的正文中进行<ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>，或在其他动态生成的代码中。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>If the current domain is the default domain, assembly <ph id="ph1">`C`</ph> cannot be unloaded until the process ends.</source>
          <target state="translated">如果当前域是默认域，程序集<ph id="ph1">`C`</ph>进程结束前不能卸载。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>If the current domain later attempts to load assembly <ph id="ph1">`C`</ph>, the load might fail.</source>
          <target state="translated">如果当前域稍后尝试加载程序集<ph id="ph1">`C`</ph>，则加载可能失败。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>No matching public constructor was found.</source>
          <target state="translated">未找到匹配的公共构造函数。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typename" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">调用方没有权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">调用方不能为非继承自 <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph> 的对象提供激活属性。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to call unmanaged code when creating an instance of a delegate.</source>
          <target state="translated">创建委托的一个实例时调用非托管的代码的功能。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">表示所有类型的成员上调用操作的能力。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">一个布尔值，指示是否执行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">影响 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 构造函数搜索的零个或多个位标志的组合。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> 为零，则对公共构造函数进行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 对象的检索。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 null，则使用默认联编程序。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">要传递给构造函数的实参。</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">如果默认的构造函数是首选构造函数，则 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 必须为空数组或 null。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A culture-specific object used to govern the coercion of types.</source>
          <target state="translated">用于控制类型强制的特定于区域性的对象。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用当前线程的 <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">包含一个或多个可以参与激活的特性的数组。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object.</source>
          <target state="translated">通常是包含单个 <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> 对象的数组。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">指定激活远程对象所需的 URL。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">此参数与客户端激活的对象相关。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">应改用 Windows Communication Foundation 来开发分布式应用程序。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</source>
          <target state="translated">创建在指定的程序集中定义的指定类型的新实例，指定是否忽略类型名称的大小写，并指定绑定特性和用于选择要创建的类型的联编程序、构造函数的自变量、区域性以及激活特性。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An instance of the object specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 所指定对象的实例。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">这是合并的便捷方法<ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>的格式<ph id="ph2">`assemblyName`</ph>。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>See the <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> property for the format of <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph>属性的格式<ph id="ph2">`typeName`</ph>。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If you make an early-bound call to a method <ph id="ph1">`M`</ph> of an object of type <ph id="ph2">`T1`</ph> that was returned by <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, and that method makes an early-bound call to a method of an object of type <ph id="ph4">`T2`</ph> in an assembly <ph id="ph5">`C`</ph> other than the current assembly or the assembly containing <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> is loaded into the current application domain.</source>
          <target state="translated">如果进行早期绑定调用的方法<ph id="ph1">`M`</ph>类型的对象的<ph id="ph2">`T1`</ph>由返回<ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>，并方法使对类型的对象的方法的早期绑定调用<ph id="ph4">`T2`</ph>的程序集中<ph id="ph5">`C`</ph>以外当前程序集或包含的程序集<ph id="ph6">`T1`</ph>，程序集<ph id="ph7">`C`</ph>会加载到当前的应用程序域。</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This loading occurs even if the early-bound call to <ph id="ph1">`T1.M()`</ph> was made in the body of a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, or in other dynamically generated code.</source>
          <target state="translated">如果即使早期绑定调用，则会发生此加载<ph id="ph1">`T1.M()`</ph>的正文中进行<ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>，或在其他动态生成的代码中。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the current domain is the default domain, assembly <ph id="ph1">`C`</ph> cannot be unloaded until the process ends.</source>
          <target state="translated">如果当前域是默认域，程序集<ph id="ph1">`C`</ph>进程结束前不能卸载。</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the current domain later attempts to load assembly <ph id="ph1">`C`</ph>, the load might fail.</source>
          <target state="translated">如果当前域稍后尝试加载程序集<ph id="ph1">`C`</ph>，则加载可能失败。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The following sample demonstrates the use of the <ph id="ph1">`ignoreCase`</ph> parameter.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">`ignoreCase`</ph>参数。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>No matching constructor was found.</source>
          <target state="translated">未找到匹配的构造函数。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typename" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">调用方没有权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">调用方不能为非继承自 <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph> 的对象提供激活属性。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 使用高于当前所加载版本的公共语言运行时版本编译而成。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to call unmanaged code when creating an instance of a delegate.</source>
          <target state="translated">创建委托的一个实例时调用非托管的代码的功能。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">表示所有类型的成员上调用操作的能力。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">一个布尔值，指示是否执行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">影响 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 构造函数搜索的零个或多个位标志的组合。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> 为零，则对公共构造函数进行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 对象的检索。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 null，则使用默认联编程序。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">要传递给构造函数的实参。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">如果默认的构造函数是首选构造函数，则 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 必须为空数组或 null。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A culture-specific object used to govern the coercion of types.</source>
          <target state="translated">用于控制类型强制的特定于区域性的对象。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用当前线程的 <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">包含一个或多个可以参与激活的特性的数组。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">通常，为包含单个 <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> 对象的数组，该对象指定激活远程对象所需的 URL。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">此参数与客户端激活的对象相关。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">应改用 Windows Communication Foundation 来开发分布式应用程序。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Information used to authorize creation of <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">用于授权创建 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 的信息。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Creates a new instance of the specified type.</source>
          <target state="translated">创建指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Parameters specify the name of the type, and how it is found and created.</source>
          <target state="translated">形参指定类型的名称以及查找和创建该类型的方式。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An instance of the object specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 所指定对象的实例。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">这是合并的便捷方法<ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>的格式<ph id="ph2">`assemblyName`</ph>。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>See the <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> property for the format of <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph>属性的格式<ph id="ph2">`typeName`</ph>。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If you make an early-bound call to a method <ph id="ph1">`M`</ph> of an object of type <ph id="ph2">`T1`</ph> that was returned by <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, and that method makes an early-bound call to a method of an object of type <ph id="ph4">`T2`</ph> in an assembly <ph id="ph5">`C`</ph> other than the current assembly or the assembly containing <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> is loaded into the current application domain.</source>
          <target state="translated">如果进行早期绑定调用的方法<ph id="ph1">`M`</ph>类型的对象的<ph id="ph2">`T1`</ph>由返回<ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>，并方法使对类型的对象的方法的早期绑定调用<ph id="ph4">`T2`</ph>的程序集中<ph id="ph5">`C`</ph>以外当前程序集或包含的程序集<ph id="ph6">`T1`</ph>，程序集<ph id="ph7">`C`</ph>会加载到当前的应用程序域。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This loading occurs even if the early-bound call to <ph id="ph1">`T1.M()`</ph> was made in the body of a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, or in other dynamically generated code.</source>
          <target state="translated">如果即使早期绑定调用，则会发生此加载<ph id="ph1">`T1.M()`</ph>的正文中进行<ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>，或在其他动态生成的代码中。</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the current domain is the default domain, assembly <ph id="ph1">`C`</ph> cannot be unloaded until the process ends.</source>
          <target state="translated">如果当前域是默认域，程序集<ph id="ph1">`C`</ph>进程结束前不能卸载。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the current domain later attempts to load assembly <ph id="ph1">`C`</ph>, the load might fail.</source>
          <target state="translated">如果当前域稍后尝试加载程序集<ph id="ph1">`C`</ph>，则加载可能失败。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The following sample demonstrates the use of the <ph id="ph1">`ignoreCase`</ph> parameter.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">`ignoreCase`</ph>参数。</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>No matching constructor was found.</source>
          <target state="translated">未找到匹配的构造函数。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typename" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">调用方没有权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">调用方不能为非继承自 <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph> 的对象提供激活属性。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">表示所有类型的成员上调用操作的能力。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new instance of a specified type defined in the specified assembly file.</source>
          <target state="translated">创建在指定程序集文件中定义的指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The name, including the path, of a file that contains an assembly that defines the requested type.</source>
          <target state="translated">文件的名称（包括路径），该文件包含定义所请求类型的程序集。</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The assembly is loaded using the <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> method.</source>
          <target state="translated">该程序集是使用 <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> 方法加载的。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">创建在指定程序集文件中定义的指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>An object that is a wrapper for the new instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">一个对象，它是新实例的包装，或者如果找不到 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则为 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">返回值需要打开包装才能访问真实对象。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The default constructor for <ph id="ph1">`typeName`</ph> is invoked.</source>
          <target state="translated">默认构造函数<ph id="ph1">`typeName`</ph>调用。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">有关更多信息，请参见 <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>When the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>方法用于在目标应用程序域中，而不从其进行调用的应用程序域中创建实例时，目标应用程序域中则加载程序集。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</source>
          <target state="translated">但是，如果该实例调用的应用程序域处于解包，则以某些方式使用解包的实例会导致要加载到调用应用程序域的程序集。</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</source>
          <target state="translated">例如，实例解包后，可能会请求其类型信息、 要调用其方法后期绑定。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>When the assembly is loaded into the calling application domain, exceptions can occur.</source>
          <target state="translated">程序集加载到调用应用程序域时，可能会发生异常。</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> can occur.</source>
          <target state="translated">如果以前的同一个程序集的另一个版本加载到调用应用程序域，或如果调用应用程序域的负载路径是不同的目标应用程序域，异常诸如<ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph>可以发生。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>If the calling application domain makes early-bound calls to the instance type, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> can be thrown when an attempt is made to cast the instance.</source>
          <target state="translated">如果调用应用程序域进行早期绑定调用实例类型，<ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph>当尝试强制转换实例可能会引发。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29&gt;</ph> method overload to create an instance of an object in a target application domain and call its methods.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29&gt;</ph>方法重载来创建目标应用程序域中的对象的实例并调用其方法。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The example defines the <ph id="ph1">`MarshallableExample`</ph> class, which can be marshaled across application domain boundaries.</source>
          <target state="translated">该示例定义了<ph id="ph1">`MarshallableExample`</ph>类，该类可以跨应用程序域边界进行封送。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The example builds a path to the currently executing assembly, creates a target application domain, and uses the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29&gt;</ph> method overload to load the example assembly into the target application domain and create an instance of <ph id="ph2">`MarshallableExample`</ph>.</source>
          <target state="translated">该示例生成一个指向当前正在执行的程序集路径、 创建目标应用程序域，并使用<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29&gt;</ph>方法重载，并将检索示例程序集加载到目标应用程序域创建的实例<ph id="ph2">`MarshallableExample`</ph>。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The path is absolute in this example, but a relative path would also work because the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph> method is used to load the assembly.</source>
          <target state="translated">路径是绝对地址在此示例中，但相对路径也将起作用，因为<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph>方法用于加载程序集。</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:</source>
          <target state="translated">在解包该对象句柄之后, 的示例演示三种方法可以使用目标应用程序域中的对象：</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Invoking a method with late binding, using reflection.</source>
          <target state="translated">与使用反射后期绑定调用的方法。</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>This requires type information, which causes the assembly to be loaded into the application domain of the caller.</source>
          <target state="translated">这需要类型信息，这会导致要加载到调用方的应用程序域的程序集。</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>(In this example, it is already loaded.)</source>
          <target state="translated">（在此示例中，它已经加载。）</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Casting the object to an interface known to both the caller and the callee.</source>
          <target state="translated">调用方和被调用方已知的接口的对象强制转换。</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.</source>
          <target state="translated">如果调用程序集中的或第三个调用方和被调用方所引用的程序集中定义接口，则调用的程序集不是加载到调用方的应用程序域。</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Using the object directly when its type is known to the caller.</source>
          <target state="translated">直接调用方已知其类型时，请使用对象。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The assembly must be loaded into the application domain of the caller.</source>
          <target state="translated">该程序集必须加载到调用方的应用程序域。</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph> class and to define a method that can be run in the target application domain.</source>
          <target state="translated">若要避免调用程序集加载到调用方的应用程序域的另一个方法是为派生自使调用方<ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph>类并定义可以在目标应用程序域中运行的方法。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain.</source>
          <target state="translated">该方法可以使用反射来检查目标程序集，因为目标程序集已加载到目标应用程序域。</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>See the example for the <ph id="ph1">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph> property.</source>
          <target state="translated">请参阅示例<ph id="ph1">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>No parameterless public constructor was found.</source>
          <target state="translated">未找到无形参的公共构造函数。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">调用方没有足够的权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">此示例为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The name, including the path, of a file that contains an assembly that defines the requested type.</source>
          <target state="translated">文件的名称（包括路径），该文件包含定义所请求类型的程序集。</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The assembly is loaded using the <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> method.</source>
          <target state="translated">该程序集是使用 <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> 方法加载的。</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">包含一个或多个可以参与激活的特性的数组。</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">通常，为包含单个 <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> 对象的数组，该对象指定激活远程对象所需的 URL。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">此参数与客户端激活的对象相关。客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">应改用 Windows Communication Foundation 来开发分布式应用程序。</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">创建在指定程序集文件中定义的指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>An object that is a wrapper for the new instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">一个对象，它是新实例的包装，或者如果找不到 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则为 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">返回值需要打开包装才能访问真实对象。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The default constructor for <ph id="ph1">`typeName`</ph> is invoked.</source>
          <target state="translated">默认构造函数<ph id="ph1">`typeName`</ph>调用。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>For more information about this method, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">有关此方法的详细信息，请参阅<ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>When the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>方法用于在目标应用程序域中，而不从其进行调用的应用程序域中创建实例时，目标应用程序域中则加载程序集。</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</source>
          <target state="translated">但是，如果该实例调用的应用程序域处于解包，则以某些方式使用解包的实例会导致要加载到调用应用程序域的程序集。</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</source>
          <target state="translated">例如，实例解包后，可能会请求其类型信息、 要调用其方法后期绑定。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>When the assembly is loaded into the calling application domain, exceptions can occur.</source>
          <target state="translated">程序集加载到调用应用程序域时，可能会发生异常。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> can occur.</source>
          <target state="translated">如果以前的同一个程序集的另一个版本加载到调用应用程序域，或如果调用应用程序域的负载路径是不同的目标应用程序域，异常诸如<ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph>可以发生。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>If the calling application domain makes early-bound calls to the instance type, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> can be thrown when an attempt is made to cast the instance.</source>
          <target state="translated">如果调用应用程序域进行早期绑定调用实例类型，<ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph>当尝试强制转换实例可能会引发。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">调用方没有足够的权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>No matching public constructor was found.</source>
          <target state="translated">未找到匹配的公共构造函数。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">调用方不能为非继承自 <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph> 的对象提供激活属性。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">此示例为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The name, including the path, of a file that contains an assembly that defines the requested type.</source>
          <target state="translated">文件的名称（包括路径），该文件包含定义所请求类型的程序集。</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The assembly is loaded using the <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> method.</source>
          <target state="translated">该程序集是使用 <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> 方法加载的。</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">一个布尔值，指示是否执行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">影响 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 构造函数搜索的零个或多个位标志的组合。</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> 为零，则对公共构造函数进行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects through reflection.</source>
          <target state="translated">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 对象的检索。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 null，则使用默认联编程序。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">要传递给构造函数的实参。</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">如果默认的构造函数是首选构造函数，则 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 必须为空数组或 null。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">区域性特定的信息，这些信息控制将 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 强制转换为 <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> 构造函数所声明的正式类型。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用当前线程的 <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">包含一个或多个可以参与激活的特性的数组。</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">通常，为包含单个 <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> 对象的数组，该对象指定激活远程对象所需的 URL。</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">此参数与客户端激活的对象相关。</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">应改用 Windows Communication Foundation 来开发分布式应用程序。</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">创建在指定程序集文件中定义的指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that is a wrapper for the new instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">一个对象，它是新实例的包装，或者如果找不到 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则为 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">返回值需要打开包装才能访问真实对象。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">有关更多信息，请参见 <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>When the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>方法用于在目标应用程序域中，而不从其进行调用的应用程序域中创建实例时，目标应用程序域中则加载程序集。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</source>
          <target state="translated">但是，如果该实例调用的应用程序域处于解包，则以某些方式使用解包的实例会导致要加载到调用应用程序域的程序集。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</source>
          <target state="translated">例如，实例解包后，可能会请求其类型信息、 要调用其方法后期绑定。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>When the assembly is loaded into the calling application domain, exceptions can occur.</source>
          <target state="translated">程序集加载到调用应用程序域时，可能会发生异常。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> can occur.</source>
          <target state="translated">如果以前的同一个程序集的另一个版本加载到调用应用程序域，或如果调用应用程序域的负载路径是不同的目标应用程序域，异常诸如<ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph>可以发生。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the calling application domain makes early-bound calls to the instance type, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> can be thrown when an attempt is made to cast the instance.</source>
          <target state="translated">如果调用应用程序域进行早期绑定调用实例类型，<ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph>当尝试强制转换实例可能会引发。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">调用方不能为非继承自 <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph> 的对象提供激活属性。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>No matching public constructor was found.</source>
          <target state="translated">未找到匹配的公共构造函数。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">调用方没有足够的权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 使用高于当前所加载版本的公共语言运行时版本编译而成。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">此示例为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The name, including the path, of a file that contains an assembly that defines the requested type.</source>
          <target state="translated">文件的名称（包括路径），该文件包含定义所请求类型的程序集。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The assembly is loaded using the <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> method.</source>
          <target state="translated">该程序集是使用 <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> 方法加载的。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">一个布尔值，指示是否执行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">影响 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 构造函数搜索的零个或多个位标志的组合。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> 为零，则对公共构造函数进行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects through reflection.</source>
          <target state="translated">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 对象的检索。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 null，则使用默认联编程序。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">要传递给构造函数的实参。</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">如果默认的构造函数是首选构造函数，则 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 必须为空数组或 null。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">区域性特定的信息，这些信息控制将 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 强制转换为 <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> 构造函数所声明的正式类型。</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用当前线程的 <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">包含一个或多个可以参与激活的特性的数组。</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">通常，为包含单个 <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> 对象的数组，该对象指定激活远程对象所需的 URL。</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">此参数与客户端激活的对象相关。</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">应改用 Windows Communication Foundation 来开发分布式应用程序。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Information used to authorize creation of <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">用于授权创建 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 的信息。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">创建在指定程序集文件中定义的指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that is a wrapper for the new instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">一个对象，它是新实例的包装，或者如果找不到 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则为 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">返回值需要打开包装才能访问真实对象。</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>For more information about this method, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">有关此方法的详细信息，请参阅<ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>When the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>方法用于在目标应用程序域中，而不从其进行调用的应用程序域中创建实例时，目标应用程序域中则加载程序集。</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</source>
          <target state="translated">但是，如果该实例调用的应用程序域处于解包，则以某些方式使用解包的实例会导致要加载到调用应用程序域的程序集。</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</source>
          <target state="translated">例如，实例解包后，可能会请求其类型信息、 要调用其方法后期绑定。</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>When the assembly is loaded into the calling application domain, exceptions can occur.</source>
          <target state="translated">程序集加载到调用应用程序域时，可能会发生异常。</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> can occur.</source>
          <target state="translated">如果以前的同一个程序集的另一个版本加载到调用应用程序域，或如果调用应用程序域的负载路径是不同的目标应用程序域，异常诸如<ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph>可以发生。</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the calling application domain makes early-bound calls to the instance type, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> can be thrown when an attempt is made to cast the instance.</source>
          <target state="translated">如果调用应用程序域进行早期绑定调用实例类型，<ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph>当尝试强制转换实例可能会引发。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">调用方不能为非继承自 <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph> 的对象提供激活属性。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">未启用旧版 CAS 策略时，<ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> 应为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>No matching public constructor was found.</source>
          <target state="translated">未找到匹配的公共构造函数。</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">调用方没有足够的权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">此示例为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>to provide evidence.</source>
          <target state="translated">若要提供的证据。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new instance of a specified type defined in the specified assembly file.</source>
          <target state="translated">创建在指定程序集文件中定义的指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>The file name and path of the assembly that defines the requested type.</source>
          <target state="translated">定义所请求类型的程序集的文件名和路径。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">创建在指定程序集文件中定义的指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>The requested object, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">请求的对象，或者如果找不到 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> 则返回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">这是合并的便捷方法<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">此方法调用的默认构造函数<ph id="ph1">`typeName`</ph>。</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">有关更多信息，请参见 <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>No parameterless public constructor was found.</source>
          <target state="translated">未找到无形参的公共构造函数。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">调用方没有足够的权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The file name and path of the assembly that defines the requested type.</source>
          <target state="translated">定义所请求类型的程序集的文件名和路径。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly (see the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property).</source>
          <target state="translated">所请求类型的完全限定名，包括命名空间而不是程序集（请参见 <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性）。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">包含一个或多个可以参与激活的特性的数组。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">通常，为包含单个 <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> 对象的数组，该对象指定激活远程对象所需的 URL。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">此参数与客户端激活的对象相关。客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">应改用 Windows Communication Foundation 来开发分布式应用程序。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">创建在指定程序集文件中定义的指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The requested object, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">请求的对象，或者如果找不到 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> 则返回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">这是合并的便捷方法<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">此方法调用的默认构造函数<ph id="ph1">`typeName`</ph>。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>For more information about this method, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">有关此方法的详细信息，请参阅<ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">调用方不能为非继承自 <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph> 的对象提供激活属性。</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>No parameterless public constructor was found.</source>
          <target state="translated">未找到无形参的公共构造函数。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">调用方没有足够的权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The file name and path of the assembly that defines the requested type.</source>
          <target state="translated">定义所请求类型的程序集的文件名和路径。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">一个布尔值，指示是否执行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">影响 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 构造函数搜索的零个或多个位标志的组合。</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> 为零，则对公共构造函数进行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects through reflection.</source>
          <target state="translated">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 对象的检索。</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 null，则使用默认联编程序。</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">要传递给构造函数的实参。</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">如果默认的构造函数是首选构造函数，则 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 必须为空数组或 null。</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">区域性特定的信息，这些信息控制将 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 强制转换为 <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> 构造函数所声明的正式类型。</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用当前线程的 <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">包含一个或多个可以参与激活的特性的数组。</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">通常，为包含单个 <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> 对象的数组，该对象指定激活远程对象所需的 URL。</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">此参数与客户端激活的对象相关。</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">应改用 Windows Communication Foundation 来开发分布式应用程序。</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly file, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</source>
          <target state="translated">创建在指定的程序集文件中定义的指定类型的新实例，指定是否忽略类型名称的大小写，并指定绑定特性和用于选择要创建的类型的联编程序、构造函数的自变量、区域性以及激活特性。</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The requested object, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">请求的对象，或者如果找不到 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> 则返回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">这是合并的便捷方法<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>For more information about this method, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">有关此方法的详细信息，请参阅<ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">调用方不能为非继承自 <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph> 的对象提供激活属性。</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>No matching public constructor was found.</source>
          <target state="translated">未找到匹配的公共构造函数。</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">调用方没有足够的权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version of the common language runtime that the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 使用高于当前所加载版本的公共语言运行时版本编译而成。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The file name and path of the assembly that defines the requested type.</source>
          <target state="translated">定义所请求类型的程序集的文件名和路径。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">一个布尔值，指示是否执行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">影响 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 构造函数搜索的零个或多个位标志的组合。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> 为零，则对公共构造函数进行区分大小写的搜索。</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects through reflection.</source>
          <target state="translated">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 对象的检索。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 null，则使用默认联编程序。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">要传递给构造函数的实参。</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">如果默认的构造函数是首选构造函数，则 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 必须为空数组或 null。</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">区域性特定的信息，这些信息控制将 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 强制转换为 <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> 构造函数所声明的正式类型。</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用当前线程的 <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">包含一个或多个可以参与激活的特性的数组。</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">通常，为包含单个 <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> 对象的数组，该对象指定激活远程对象所需的 URL。</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">此参数与客户端激活的对象相关。</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">应改用 Windows Communication Foundation 来开发分布式应用程序。</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Information used to authorize creation of <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">用于授权创建 <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> 的信息。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">创建在指定程序集文件中定义的指定类型的新实例。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The requested object, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">请求的对象，或者如果找不到 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> 则返回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">这是合并的便捷方法<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>For more information about this method, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">有关此方法的详细信息，请参阅<ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">调用方不能为非继承自 <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph> 的对象提供激活属性。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph> 中未找到 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>No matching public constructor was found.</source>
          <target state="translated">未找到匹配的公共构造函数。</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">调用方没有足够的权限调用此构造函数。</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">读取包含程序集清单的文件的功能。</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="P:System.AppDomain.CurrentDomain">
          <source>Gets the current application domain for the current <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>.</source>
          <target state="translated">获取当前 <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> 的当前应用程序域。</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.CurrentDomain">
          <source>The current application domain.</source>
          <target state="translated">当前应用程序域。</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.CurrentDomain">
          <source>The following code example creates a new application domain.</source>
          <target state="translated">下面的代码示例创建一个新的应用程序域。</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.CurrentDomain">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.CurrentDomain%2A&gt;</ph> property is used to obtain an <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph> object that represents the current application domain.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.CurrentDomain%2A&gt;</ph>属性用于获取<ph id="ph2">&lt;xref:System.AppDomain&gt;</ph>对象，表示当前的应用程序域。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.CurrentDomain">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.FriendlyName%2A&gt;</ph> property provides the name of the current application domain, which is then displayed at the command line.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.FriendlyName%2A&gt;</ph>属性提供当前应用程序域，然后在命令行中显示的名称。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Defines a dynamic assembly in the current application domain.</source>
          <target state="translated">在当前应用程序域中定义动态程序集。</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">动态程序集的唯一标识。</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The access mode for the dynamic assembly.</source>
          <target state="translated">动态程序集的访问模式。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>Defines a dynamic assembly with the specified name and access mode.</source>
          <target state="translated">以指定名称和访问模式定义动态程序集。</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>A dynamic assembly with the specified name and access mode.</source>
          <target state="translated">含指定名称和访问模式的动态程序集。</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">此方法仅应使用当前的应用程序域中定义的动态程序集。</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">有关详细信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">在开发期间用于发出动态程序集的代码，建议你使用的重载<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法，它指定证据和权限，提供你想要具有，并且包含的动态程序集的证据<ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph>中<ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">包括<ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph>中<ph id="ph2">`refusedPermissions`</ph>参数可确保验证 MSIL。</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">此技术的局限性是它还使<ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph>要求完全信任的代码一起使用时引发。</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">下面的示例演示如何<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法和<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">若要运行此代码示例，你必须提供完全限定程序集名称。</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">有关如何获取完全限定程序集名称的信息，请参阅<bpt id="p1">[</bpt>程序集名称<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性以空格开头，或包含正斜杠或反斜杠。</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">动态程序集的唯一标识。</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The access mode for the dynamic assembly.</source>
          <target state="translated">动态程序集的访问模式。</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>An enumerable list of attributes to be applied to the assembly, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if there are no attributes.</source>
          <target state="translated">要应用于程序集的可枚举特性列表；如果无特性，则为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Defines a dynamic assembly with the specified name, access mode, and custom attributes.</source>
          <target state="translated">使用指定的名称、访问模式和自定义特性定义动态程序集。</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">具有指定名称和功能的动态程序集。</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</source>
          <target state="translated">使用此方法重载来指定属性，除非在已应用创建的动态程序集时，可能无法正常工作。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>For example, security attributes such as <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> do not work correctly if they are added after a dynamic assembly has been created.</source>
          <target state="translated">例如，安全特性例如<ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph>和<ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>如果它们未添加创建的动态程序集后，可能无法正常工作。</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>This method should be used only to define a dynamic assembly in the current application domain.</source>
          <target state="translated">应使用此方法只能用于当前的应用程序域中定义的动态程序集。</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>For more information about this restriction, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">有关此限制的详细信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>This method overload is introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>.</source>
          <target state="translated">此方法重载在中引入<ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The following code sample shows how to create a dynamic assembly that has the <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph>.</source>
          <target state="translated">下面的代码示例演示如何创建动态程序集具有<ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The attribute must be specified as an element of an array of <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objects.</source>
          <target state="translated">该属性必须指定数组的元素为<ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The first step in creating the <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> is to obtain a constructor for the attribute.</source>
          <target state="translated">创建的第一步<ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph>是获取属性的构造函数。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The constructor has no parameters, so the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method is called with an empty array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects to represent the types of the parameters.</source>
          <target state="translated">构造函数没有任何参数，因此<ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>的空数组调用方法时<ph id="ph2">&lt;xref:System.Type&gt;</ph>对象以表示的参数的类型。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The second step is to pass the resulting <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object to the constructor for the <ph id="ph2">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> class, together with an empty array of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> to represent the arguments.</source>
          <target state="translated">第二步是将生成<ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>为构造函数的对象<ph id="ph2">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph>类，以及类型的空数组<ph id="ph3">&lt;xref:System.Object&gt;</ph>来表示的自变量。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The resulting <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> is then passed to the <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method as the only element of an array.</source>
          <target state="translated">生成<ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph>随后会传递给<ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>作为数组的唯一元素的方法。</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.</source>
          <target state="translated">示例代码中新的动态程序集，定义模块和一个类型，然后显示程序集的特性。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> starts with white space, or contains a forward or backward slash.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性以空白开始，或者包含正斜杠或反斜杠。</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">动态程序集的唯一标识。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">访问动态程序集所采用的模式。</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The evidence supplied for the dynamic assembly.</source>
          <target state="translated">为动态程序集提供的证据。</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">该证据始终作为最后一组用于策略解析的证据来使用。</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>Defines a dynamic assembly using the specified name, access mode, and evidence.</source>
          <target state="translated">使用指定名称、访问模式和证据定义动态程序集。</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">具有指定名称和功能的动态程序集。</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>Only fully trusted callers can supply their <ph id="ph1">`evidence`</ph> when defining a dynamic <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">仅完全受信任的调用方可以提供其<ph id="ph1">`evidence`</ph>定义动态时<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The runtime will map the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">运行时将映射<ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph>通过安全策略以确定授予的权限。</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>Partially trusted callers must supply a null <ph id="ph1">`evidence`</ph>.</source>
          <target state="translated">部分受信任的调用方必须提供一个为 null 的<ph id="ph1">`evidence`</ph>。</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> to the dynamic <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> being defined and marks policy as resolved.</source>
          <target state="translated">如果<ph id="ph1">`evidence`</ph>是<ph id="ph2">`null`</ph>、 运行时将复制的权限集，也就是说，当前授予和拒绝集，从调用方的<ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph>为动态<ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph>正在定义并将策略标记为已解决。</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>If the dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> was saved.</source>
          <target state="translated">如果动态<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>是保存到磁盘，后面的加载将获得授予基于与位置关联的策略其中<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>已保存。</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">此方法仅应使用当前的应用程序域中定义的动态程序集。</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">有关详细信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">在开发期间用于发出动态程序集的代码，建议你使用的重载<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法，它指定证据和权限，提供你想要具有，并且包含的动态程序集的证据<ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph>中<ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">包括<ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph>中<ph id="ph2">`refusedPermissions`</ph>参数可确保验证 MSIL。</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">此技术的局限性是它还使<ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph>要求完全信任的代码一起使用时引发。</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">下面的示例演示如何<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法和<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>First, the code example tries to create an instance of <ph id="ph1">`MyDynamicType`</ph> by calling the <ph id="ph2">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> method with an invalid assembly name, and catches the resulting exception.</source>
          <target state="translated">首先，此代码示例尝试创建的实例<ph id="ph1">`MyDynamicType`</ph>通过调用<ph id="ph2">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>具有无效的程序集名称，方法和捕获产生的异常。</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The code example then adds an event handler for the <ph id="ph1">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event, and again tries to create an instance of<ph id="ph2">`MyDynamicType`</ph>.</source>
          <target state="translated">然后，该代码示例添加的事件处理程序<ph id="ph1">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph>事件，并再次尝试创建的实例<ph id="ph2">`MyDynamicType`</ph>。</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>During the call to <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event is raised for the invalid assembly.</source>
          <target state="translated">在调用期间<ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph>无效的程序集对引发事件。</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The event handler creates a dynamic assembly that contains a type named <ph id="ph1">`MyDynamicType`</ph>, gives the type a parameterless constructor, and returns the new dynamic assembly.</source>
          <target state="translated">事件处理程序创建包含名为的类型的动态程序集<ph id="ph1">`MyDynamicType`</ph>，为该类型提供的无参数构造函数，并返回新的动态程序集。</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The call to <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> then finishes successfully, and the constructor for <ph id="ph2">`MyDynamicType`</ph> displays a message at the console.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>成功，然后完成的构造函数和<ph id="ph2">`MyDynamicType`</ph>在控制台显示一条消息。</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性以空格开头，或包含正斜杠或反斜杠。</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">动态程序集的唯一标识。</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">访问动态程序集所采用的模式。</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The name of the directory where the assembly will be saved.</source>
          <target state="translated">保存程序集的目录的名称。</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the directory defaults to the current directory.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> 是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，目录将默认为当前目录。</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>Defines a dynamic assembly using the specified name, access mode, and storage directory.</source>
          <target state="translated">使用指定名称、访问模式和存储目录定义动态程序集。</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">具有指定名称和功能的动态程序集。</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">此方法仅应使用当前的应用程序域中定义的动态程序集。</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">有关详细信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">在开发期间用于发出动态程序集的代码，建议你使用的重载<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法，它指定证据和权限，提供你想要具有，并且包含的动态程序集的证据<ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph>中<ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">包括<ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph>中<ph id="ph2">`refusedPermissions`</ph>参数可确保验证 MSIL。</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">此技术的局限性是它还使<ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph>要求完全信任的代码一起使用时引发。</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">下面的示例演示如何<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法和<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">若要运行此代码示例，你必须提供完全限定程序集名称。</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">有关如何获取完全限定程序集名称的信息，请参阅<bpt id="p1">[</bpt>程序集名称<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性以空格开头，或包含正斜杠或反斜杠。</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">动态程序集的唯一标识。</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The access mode for the dynamic assembly.</source>
          <target state="translated">动态程序集的访问模式。</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>An enumerable list of attributes to be applied to the assembly, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if there are no attributes.</source>
          <target state="translated">要应用于程序集的可枚举特性列表；如果无特性，则为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The source of the security context.</source>
          <target state="translated">安全上下文的源。</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>Defines a dynamic assembly with the specified name, access mode, and custom attributes, and using the specified source for its security context.</source>
          <target state="translated">定义具有指定名称、访问模式和自定义特性的动态程序集，并将指定源用于动态程序集的安全上下文。</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">具有指定名称和功能的动态程序集。</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</source>
          <target state="translated">使用此方法重载来指定属性，除非在已应用创建的动态程序集时，可能无法正常工作。</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>For example, security attributes such as <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> do not work correctly if they are added after a dynamic assembly has been created.</source>
          <target state="translated">例如，安全特性例如<ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph>和<ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>如果它们未添加创建的动态程序集后，可能无法正常工作。</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>This method should be used only to define a dynamic assembly in the current application domain.</source>
          <target state="translated">应使用此方法只能用于当前的应用程序域中定义的动态程序集。</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>For more information about this restriction, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">有关此限制的详细信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> starts with white space, or contains a forward or backward slash.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性以空白开始，或者包含正斜杠或反斜杠。</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The value of <ph id="ph1">&lt;paramref name="securityContextSource" /&gt;</ph> was not one of the enumeration values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityContextSource" /&gt;</ph> 的值不是枚举值之一。</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">动态程序集的唯一标识。</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">访问动态程序集所采用的模式。</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The name of the directory where the assembly will be saved.</source>
          <target state="translated">保存程序集的目录的名称。</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the directory defaults to the current directory.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> 是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，目录将默认为当前目录。</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The evidence supplied for the dynamic assembly.</source>
          <target state="translated">为动态程序集提供的证据。</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">该证据始终作为最后一组用于策略解析的证据来使用。</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>Defines a dynamic assembly using the specified name, access mode, storage directory, and evidence.</source>
          <target state="translated">使用指定名称、访问模式、存储目录和证据定义动态程序集。</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">具有指定名称和功能的动态程序集。</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>Only fully trusted callers can supply their <ph id="ph1">`evidence`</ph> when defining a dynamic <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">仅完全受信任的调用方可以提供其<ph id="ph1">`evidence`</ph>定义动态时<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The runtime will map the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">运行时将映射<ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph>通过安全策略以确定授予的权限。</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>Partially trusted callers must supply a null <ph id="ph1">`evidence`</ph>.</source>
          <target state="translated">部分受信任的调用方必须提供一个为 null 的<ph id="ph1">`evidence`</ph>。</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> to the dynamic <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> being defined and marks policy as resolved.</source>
          <target state="translated">如果<ph id="ph1">`evidence`</ph>是<ph id="ph2">`null`</ph>、 运行时将复制的权限集，也就是说，当前授予和拒绝集，从调用方的<ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph>为动态<ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph>正在定义并将策略标记为已解决。</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>If the dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> was saved.</source>
          <target state="translated">如果动态<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>是保存到磁盘，后面的加载将获得授予基于与位置关联的策略其中<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>已保存。</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">此方法仅应使用当前的应用程序域中定义的动态程序集。</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">有关详细信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">在开发期间用于发出动态程序集的代码，建议你使用的重载<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法，它指定证据和权限，提供你想要具有，并且包含的动态程序集的证据<ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph>中<ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">包括<ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph>中<ph id="ph2">`refusedPermissions`</ph>参数可确保验证 MSIL。</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">此技术的局限性是它还使<ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph>要求完全信任的代码一起使用时引发。</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">下面的示例演示如何<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法和<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">若要运行此代码示例，你必须提供完全限定程序集名称。</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">有关如何获取完全限定程序集名称的信息，请参阅<bpt id="p1">[</bpt>程序集名称<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性以空格开头，或包含正斜杠或反斜杠。</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">动态程序集的唯一标识。</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">访问动态程序集所采用的模式。</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The required permissions request.</source>
          <target state="translated">必需的权限请求。</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The optional permissions request.</source>
          <target state="translated">可选的权限请求。</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The refused permissions request.</source>
          <target state="translated">被拒绝的权限请求。</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Defines a dynamic assembly using the specified name, access mode, and permission requests.</source>
          <target state="translated">使用指定名称、访问模式和权限请求定义动态程序集。</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">具有指定名称和功能的动态程序集。</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The permission requests specified for <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> are not used unless the dynamic assembly has been saved and reloaded into memory.</source>
          <target state="translated">为指定的权限请求<ph id="ph1">`requiredPermissions`</ph>， <ph id="ph2">`optionalPermissions`</ph>，和<ph id="ph3">`refusedPermissions`</ph>不使用除非保存动态程序集并将其重新加载到内存。</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence as well as requested permissions, and supply an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> object.</source>
          <target state="translated">若要指定从不会保存到磁盘中，使用的重载的瞬态程序集的权限请求<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法，它指定证据和所请求的权限，并提供<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">在开发期间用于发出动态程序集的代码，建议你使用的重载<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法，它指定证据和权限，提供你想要具有，并且包含的动态程序集的证据<ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph>中<ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">包括<ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph>中<ph id="ph2">`refusedPermissions`</ph>参数可确保验证 MSIL。</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">此技术的局限性是它还使<ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph>要求完全信任的代码一起使用时引发。</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">此方法仅应使用当前的应用程序域中定义的动态程序集。</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload .</source>
          <target state="translated">有关详细信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">下面的示例演示如何<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法和<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">若要运行此代码示例，你必须提供完全限定程序集名称。</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">有关如何获取完全限定程序集名称的信息，请参阅<bpt id="p1">[</bpt>程序集名称<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性以空格开头，或包含正斜杠或反斜杠。</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">动态程序集的唯一标识。</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">访问动态程序集所采用的模式。</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The name of the directory where the dynamic assembly will be saved.</source>
          <target state="translated">保存动态程序集的目录的名称。</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the current directory is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用当前目录。</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">若要在动态程序集中同步模块、类型和成员的创建，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>An enumerable list of attributes to be applied to the assembly, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if there are no attributes.</source>
          <target state="translated">要应用于程序集的可枚举特性列表；如果无特性，则为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Defines a dynamic assembly using the specified name, access mode, storage directory, and synchronization option.</source>
          <target state="translated">使用指定名称、访问模式、存储目录和同步选项定义动态程序集。</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">具有指定名称和功能的动态程序集。</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</source>
          <target state="translated">使用此方法重载来指定属性，除非在已应用创建的动态程序集时，可能无法正常工作。</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>For example, security attributes such as <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> do not work correctly if they are added after a dynamic assembly has been created.</source>
          <target state="translated">例如，安全特性例如<ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph>和<ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>如果它们未添加创建的动态程序集后，可能无法正常工作。</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If <ph id="ph1">`isSynchronized`</ph> is <ph id="ph2">`true`</ph>, the following methods of the resulting <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> will be synchronized: <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>, and <ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`isSynchronized`</ph>是<ph id="ph2">`true`</ph>，生成的以下方法<ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>将同步： <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>， <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>， <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>， <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>， <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>，和<ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If two of these methods are called on different threads, one will block until the other is completed.</source>
          <target state="translated">如果其中两种方法在不同的线程调用的一个将其他完成之前一直阻止。</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> starts with white space, or contains a forward or backward slash.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性以空白开始，或者包含正斜杠或反斜杠。</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">动态程序集的唯一标识。</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">访问动态程序集所采用的模式。</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The evidence supplied for the dynamic assembly.</source>
          <target state="translated">为动态程序集提供的证据。</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">该证据始终作为最后一组用于策略解析的证据来使用。</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The required permissions request.</source>
          <target state="translated">必需的权限请求。</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The optional permissions request.</source>
          <target state="translated">可选的权限请求。</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The refused permissions request.</source>
          <target state="translated">被拒绝的权限请求。</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Defines a dynamic assembly using the specified name, access mode, evidence, and permission requests.</source>
          <target state="translated">使用指定名称、访问模式、证据和权限请求定义动态程序集。</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">具有指定名称和功能的动态程序集。</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The permission requests specified for <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> are used only if <ph id="ph4">`evidence`</ph> is also supplied, or if the dynamic assembly is saved and reloaded into memory.</source>
          <target state="translated">为指定的权限请求<ph id="ph1">`requiredPermissions`</ph>， <ph id="ph2">`optionalPermissions`</ph>，和<ph id="ph3">`refusedPermissions`</ph>才会使用<ph id="ph4">`evidence`</ph>还提供，或如果动态程序集保存并重新加载到内存。</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you include <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph2">`refusedPermissions`</ph>.</source>
          <target state="translated">在开发期间用于发出动态程序集的代码，建议你在包含<ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph>中<ph id="ph2">`refusedPermissions`</ph>。</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">包括<ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph>中<ph id="ph2">`refusedPermissions`</ph>参数可确保验证 MSIL。</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">此技术的局限性是它还使<ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph>要求完全信任的代码一起使用时引发。</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Only fully trusted callers can supply their <ph id="ph1">`evidence`</ph> when defining a dynamic <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">仅完全受信任的调用方可以提供其<ph id="ph1">`evidence`</ph>定义动态时<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The runtime will map the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">运行时将映射<ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph>通过安全策略以确定授予的权限。</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Partially trusted callers must supply a null <ph id="ph1">`evidence`</ph>.</source>
          <target state="translated">部分受信任的调用方必须提供一个为 null 的<ph id="ph1">`evidence`</ph>。</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> to the dynamic <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> being defined and marks policy as resolved.</source>
          <target state="translated">如果<ph id="ph1">`evidence`</ph>是<ph id="ph2">`null`</ph>、 运行时将复制的权限集，也就是说，当前授予和拒绝集，从调用方的<ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph>为动态<ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph>正在定义并将策略标记为已解决。</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If the dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> was saved.</source>
          <target state="translated">如果动态<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>是保存到磁盘，后面的加载将获得授予基于与位置关联的策略其中<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>已保存。</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">此方法仅应使用当前的应用程序域中定义的动态程序集。</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">有关详细信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">下面的示例演示如何<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法和<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">若要运行此代码示例，你必须提供完全限定程序集名称。</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">有关如何获取完全限定程序集名称的信息，请参阅<bpt id="p1">[</bpt>程序集名称<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性以空格开头，或包含正斜杠或反斜杠。</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">动态程序集的唯一标识。</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">访问动态程序集所采用的模式。</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The name of the directory where the assembly will be saved.</source>
          <target state="translated">保存程序集的目录的名称。</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the directory defaults to the current directory.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> 是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，目录将默认为当前目录。</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The required permissions request.</source>
          <target state="translated">必需的权限请求。</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The optional permissions request.</source>
          <target state="translated">可选的权限请求。</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The refused permissions request.</source>
          <target state="translated">被拒绝的权限请求。</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Defines a dynamic assembly using the specified name, access mode, storage directory, and permission requests.</source>
          <target state="translated">使用指定名称、访问模式、存储目录和权限请求定义动态程序集。</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">具有指定名称和功能的动态程序集。</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The permission requests specified for <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> are not used unless the dynamic assembly has been saved and reloaded into memory.</source>
          <target state="translated">为指定的权限请求<ph id="ph1">`requiredPermissions`</ph>， <ph id="ph2">`optionalPermissions`</ph>，和<ph id="ph3">`refusedPermissions`</ph>不使用除非保存动态程序集并将其重新加载到内存。</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence as well as requested permissions, and supply an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> object.</source>
          <target state="translated">若要指定从不会保存到磁盘中，使用的重载的瞬态程序集的权限请求<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法，它指定证据和所请求的权限，并提供<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">在开发期间用于发出动态程序集的代码，建议你使用的重载<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法，它指定证据和权限，提供你想要具有，并且包含的动态程序集的证据<ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph>中<ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">包括<ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph>中<ph id="ph2">`refusedPermissions`</ph>参数可确保验证 MSIL。</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">此技术的局限性是它还使<ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph>要求完全信任的代码一起使用时引发。</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">此方法仅应使用当前的应用程序域中定义的动态程序集。</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">有关详细信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">下面的示例演示如何<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法和<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">若要运行此代码示例，你必须提供完全限定程序集名称。</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">有关如何获取完全限定程序集名称的信息，请参阅<bpt id="p1">[</bpt>程序集名称<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性以空格开头，或包含正斜杠或反斜杠。</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">动态程序集的唯一标识。</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">访问动态程序集所采用的模式。</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The name of the directory where the assembly will be saved.</source>
          <target state="translated">保存程序集的目录的名称。</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the directory defaults to the current directory.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> 是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，目录将默认为当前目录。</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The evidence supplied for the dynamic assembly.</source>
          <target state="translated">为动态程序集提供的证据。</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">该证据始终作为最后一组用于策略解析的证据来使用。</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The required permissions request.</source>
          <target state="translated">必需的权限请求。</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The optional permissions request.</source>
          <target state="translated">可选的权限请求。</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The refused permissions request.</source>
          <target state="translated">被拒绝的权限请求。</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, and permission requests.</source>
          <target state="translated">使用指定名称、访问模式、存储目录、证据和权限请求定义动态程序集。</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">具有指定名称和功能的动态程序集。</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The permission requests specified for <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> are used only if <ph id="ph4">`evidence`</ph> is also supplied, or if the dynamic assembly is saved and reloaded into memory.</source>
          <target state="translated">为指定的权限请求<ph id="ph1">`requiredPermissions`</ph>， <ph id="ph2">`optionalPermissions`</ph>，和<ph id="ph3">`refusedPermissions`</ph>才会使用<ph id="ph4">`evidence`</ph>还提供，或如果动态程序集保存并重新加载到内存。</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you include <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph2">`refusedPermissions`</ph>.</source>
          <target state="translated">在开发期间用于发出动态程序集的代码，建议你在包含<ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph>中<ph id="ph2">`refusedPermissions`</ph>。</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">包括<ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph>中<ph id="ph2">`refusedPermissions`</ph>参数可确保验证 MSIL。</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">此技术的局限性是它还使<ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph>要求完全信任的代码一起使用时引发。</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Only fully trusted callers can supply their <ph id="ph1">`evidence`</ph> when defining a dynamic <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">仅完全受信任的调用方可以提供其<ph id="ph1">`evidence`</ph>定义动态时<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The runtime will map the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">运行时将映射<ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph>通过安全策略以确定授予的权限。</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Partially trusted callers must supply a null <ph id="ph1">`evidence`</ph>.</source>
          <target state="translated">部分受信任的调用方必须提供一个为 null 的<ph id="ph1">`evidence`</ph>。</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> to the dynamic <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> being defined and marks policy as resolved.</source>
          <target state="translated">如果<ph id="ph1">`evidence`</ph>是<ph id="ph2">`null`</ph>、 运行时将复制的权限集，也就是说，当前授予和拒绝集，从调用方的<ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph>为动态<ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph>正在定义并将策略标记为已解决。</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If the dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> was saved.</source>
          <target state="translated">如果动态<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>是保存到磁盘，后面的加载将获得授予基于与位置关联的策略其中<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>已保存。</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">此方法仅应使用当前的应用程序域中定义的动态程序集。</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">有关详细信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">下面的示例演示如何<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法和<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">若要运行此代码示例，你必须提供完全限定程序集名称。</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">有关如何获取完全限定程序集名称的信息，请参阅<bpt id="p1">[</bpt>程序集名称<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性以空格开头，或包含正斜杠或反斜杠。</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">动态程序集的唯一标识。</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">访问动态程序集所采用的模式。</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The name of the directory where the dynamic assembly will be saved.</source>
          <target state="translated">保存动态程序集的目录的名称。</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the directory defaults to the current directory.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> 是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，目录将默认为当前目录。</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The evidence supplied for the dynamic assembly.</source>
          <target state="translated">为动态程序集提供的证据。</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">该证据始终作为最后一组用于策略解析的证据来使用。</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The required permissions request.</source>
          <target state="translated">必需的权限请求。</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The optional permissions request.</source>
          <target state="translated">可选的权限请求。</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The refused permissions request.</source>
          <target state="translated">被拒绝的权限请求。</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">若要在动态程序集中同步模块、类型和成员的创建，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, permission requests, and synchronization option.</source>
          <target state="translated">使用指定名称、访问模式、存储目录、证据、权限请求和同步选项定义动态程序集。</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">具有指定名称和功能的动态程序集。</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The permission requests specified for <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> are used only if <ph id="ph4">`evidence`</ph> is also supplied, or if the dynamic assembly is saved and reloaded into memory.</source>
          <target state="translated">为指定的权限请求<ph id="ph1">`requiredPermissions`</ph>， <ph id="ph2">`optionalPermissions`</ph>，和<ph id="ph3">`refusedPermissions`</ph>才会使用<ph id="ph4">`evidence`</ph>还提供，或如果动态程序集保存并重新加载到内存。</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you include <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph2">`refusedPermissions`</ph>.</source>
          <target state="translated">在开发期间用于发出动态程序集的代码，建议你在包含<ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph>中<ph id="ph2">`refusedPermissions`</ph>。</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">包括<ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph>中<ph id="ph2">`refusedPermissions`</ph>参数可确保验证 MSIL。</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">此技术的局限性是它还使<ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph>要求完全信任的代码一起使用时引发。</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>Only fully trusted callers can supply their evidence when defining a dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">仅完全受信任调用方可以提供其证据定义动态时<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The runtime will map the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">运行时将映射<ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph>通过安全策略以确定授予的权限。</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>Partially trusted callers must supply <ph id="ph1">`null`</ph> for the <ph id="ph2">`evidence`</ph> parameter.</source>
          <target state="translated">部分受信任的调用方必须提供<ph id="ph1">`null`</ph>为<ph id="ph2">`evidence`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> to the dynamic <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> being defined and marks policy as resolved.</source>
          <target state="translated">如果<ph id="ph1">`evidence`</ph>是<ph id="ph2">`null`</ph>、 运行时将复制的权限集，也就是说，当前授予和拒绝集，从调用方的<ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph>为动态<ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph>正在定义并将策略标记为已解决。</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>If the dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> was saved.</source>
          <target state="translated">如果动态<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>是保存到磁盘，后面的加载将获得授予基于与位置关联的策略其中<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>已保存。</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>If <ph id="ph1">`isSynchronized`</ph> is <ph id="ph2">`true`</ph>, the following methods of the resulting <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> will be synchronized: <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>, and <ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`isSynchronized`</ph>是<ph id="ph2">`true`</ph>，生成的以下方法<ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>将同步： <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>， <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>， <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>， <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>， <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>，和<ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>If two of these methods are called on different threads, one will block until the other completes.</source>
          <target state="translated">如果其中两种方法在不同的线程调用的一个将其他完成之前一直阻止。</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">下面的示例演示如何<ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph>方法和<ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">若要运行此代码示例，你必须提供完全限定程序集名称。</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">有关如何获取完全限定程序集名称的信息，请参阅<bpt id="p1">[</bpt>程序集名称<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性以空格开头，或包含正斜杠或反斜杠。</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">动态程序集的唯一标识。</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">访问动态程序集所采用的模式。</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The name of the directory where the dynamic assembly will be saved.</source>
          <target state="translated">保存动态程序集的目录的名称。</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the current directory is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用当前目录。</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The evidence that is supplied for the dynamic assembly.</source>
          <target state="translated">为动态程序集提供的证据。</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">该证据始终作为最后一组用于策略解析的证据来使用。</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The required permissions request.</source>
          <target state="translated">必需的权限请求。</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The optional permissions request.</source>
          <target state="translated">可选的权限请求。</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The refused permissions request.</source>
          <target state="translated">被拒绝的权限请求。</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">若要在动态程序集中同步模块、类型和成员的创建，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>An enumerable list of attributes to be applied to the assembly, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if there are no attributes.</source>
          <target state="translated">要应用于程序集的可枚举特性列表；如果无特性，则为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Defines a dynamic assembly with the specified name, access mode, storage directory, evidence, permission requests, synchronization option, and custom attributes.</source>
          <target state="translated">使用指定的名称、访问模式、存储目录、证据、权限请求、同步选项和自定义特性定义动态程序集。</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">具有指定名称和功能的动态程序集。</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</source>
          <target state="translated">使用此方法重载来指定属性，除非在已应用创建的动态程序集时，可能无法正常工作。</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>For example, security attributes such as <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> do not work correctly if they are added after a dynamic assembly has been created.</source>
          <target state="translated">例如，安全特性例如<ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph>和<ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>如果它们未添加创建的动态程序集后，可能无法正常工作。</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The permission requests specified for the <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> parameters are used only if the <ph id="ph4">`evidence`</ph> parameter is also supplied, or if the dynamic assembly is saved and reloaded into memory.</source>
          <target state="translated">为指定的权限请求<ph id="ph1">`requiredPermissions`</ph>， <ph id="ph2">`optionalPermissions`</ph>，和<ph id="ph3">`refusedPermissions`</ph>参数才会使用<ph id="ph4">`evidence`</ph>还提供参数，或如果动态程序集保存并重新加载到内存。</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>When you develop code that emits dynamic assemblies, we recommend that you include the <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> flag in the <ph id="ph2">`refusedPermissions`</ph> parameter.</source>
          <target state="translated">当你开发的代码所发出动态程序集时，我们建议你包括<ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph>中标记出来<ph id="ph2">`refusedPermissions`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The inclusion of this flag ensures that the Microsoft intermediate language (MSIL) will be verified.</source>
          <target state="translated">此标志包含可确保的 Microsoft 中间语言 (MSIL) 将进行验证。</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>This technique will detect the unintentional generation of unverifiable code, which otherwise is very difficult to detect.</source>
          <target state="translated">此方法会检测无意间生成无法验证的代码，否则为它是很难检测到了。</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when it is used with code that demands full trust.</source>
          <target state="translated">此技术的局限性是它还使<ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph>当它用于要求完全信任的代码时引发。</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Only fully trusted callers can supply evidence when defining a dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">仅完全受信任调用方可以提供证据定义动态时<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The runtime maps the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">运行时将映射<ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph>通过安全策略以确定授予的权限。</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Partially trusted callers must supply <ph id="ph1">`null`</ph> for the <ph id="ph2">`evidence`</ph> parameter.</source>
          <target state="translated">部分受信任的调用方必须提供<ph id="ph1">`null`</ph>为<ph id="ph2">`evidence`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets (that is, the current grant and deny sets) from the caller's assembly to the dynamic assembly that is being defined, and marks the policy as resolved.</source>
          <target state="translated">如果<ph id="ph1">`evidence`</ph>是<ph id="ph2">`null`</ph>，运行时将从调用方的程序集的权限集 （即，当前授予和拒绝集） 复制到正在定义中，并将策略标记为已解决的动态程序集。</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If the dynamic assembly is saved to disk, subsequent loads will get grants based on policies that are associated with the location where the dynamic assembly was saved.</source>
          <target state="translated">如果将动态程序集保存到磁盘，后续加载将获得授予基于保存动态程序集的位置与关联的策略。</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If <ph id="ph1">`isSynchronized`</ph> is <ph id="ph2">`true`</ph>, the following methods of the resulting <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> will be synchronized: <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>, and <ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`isSynchronized`</ph>是<ph id="ph2">`true`</ph>，生成的以下方法<ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>将同步： <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>， <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>， <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>， <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>， <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>，和<ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If two of these methods are called on different threads, one will block until the other is completed.</source>
          <target state="translated">如果其中两种方法在不同的线程调用的一个将其他完成之前一直阻止。</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>This method overload is introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>.</source>
          <target state="translated">此方法重载在中引入<ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> starts with white space, or contains a forward or backward slash.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="name" /&gt;</ph> 的 <ph id="ph1">&lt;see langword="Name" /&gt;</ph> 属性以空白开始，或者包含正斜杠或反斜杠。</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source>A delegate that specifies a method to call.</source>
          <target state="translated">指定要调用的方法的委托。</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source>Executes the code in another application domain that is identified by the specified delegate.</source>
          <target state="translated">在另一个应用程序域中执行代码，该应用程序域由指定的委托标识。</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source><ph id="ph1">`callBackDelegate`</ph> can specify a marshal-by-value, <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, or <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`callBackDelegate`</ph> 可以指定封送按值， <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>，或<ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source>The following sample demonstrates using a static <ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例演示如何使用静态<ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source>The following sample demonstrates using the <ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph> method by value.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph>按值的方法。</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source>The following sample demonstrates using the <ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph> method by reference.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph>通过引用的方法。</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source><ph id="ph1">&lt;paramref name="callBackDelegate" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="callBackDelegate" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="P:System.AppDomain.DomainManager">
          <source>Gets the domain manager that was provided by the host when the application domain was initialized.</source>
          <target state="translated">获得初始化应用程序域时主机提供的域管理器。</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DomainManager">
          <source>An object that represents the domain manager provided by the host when the application domain was initialized, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no domain manager was provided.</source>
          <target state="translated">一个对象，表示初始化应用程序域时主机提供的域管理器；或者如果没有提供域管理器，则返回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DomainManager">
          <source>An unmanaged host of the common language runtime (CLR) can provide a domain manager.</source>
          <target state="translated">公共语言运行时 (CLR) 的非托管的主机可以提供域管理器。</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DomainManager">
          <source>The domain manager can participate in initializing the new application domain and supply other managers, such as a <ph id="ph1">&lt;xref:System.Security.HostSecurityManager&gt;</ph>, that participate in the operations of the application domain.</source>
          <target state="translated">域管理器可以参与初始化新的应用程序域，并提供其他管理器，如<ph id="ph1">&lt;xref:System.Security.HostSecurityManager&gt;</ph>，该元素参与应用程序域的操作。</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DomainManager">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DomainManager">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="E:System.AppDomain.DomainUnload">
          <source>Occurs when an <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> is about to be unloaded.</source>
          <target state="translated">在即将卸载 <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> 时发生。</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>The <ph id="ph1">&lt;xref:System.EventHandler&gt;</ph> delegate for this event can perform any termination activities before the application domain is unloaded.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler&gt;</ph>委托中卸载应用程序域之前，此事件可以执行任何终止活动。</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>Each application domain that needs to perform processing when it is unloaded should register an event handler for this event.</source>
          <target state="translated">需要用来执行处理卸载时每个应用程序域应该注册的事件处理程序此事件。</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>A shared event handler should not be used, because the <ph id="ph1">&lt;xref:System.EventHandler&gt;</ph> delegate does not identify the domain that is being unloaded.</source>
          <target state="translated">共享的事件处理程序不应使用，因为<ph id="ph1">&lt;xref:System.EventHandler&gt;</ph>委托不会确定正在卸载的域。</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>This event is never raised in the default application domain.</source>
          <target state="translated">默认应用程序域中永远不会引发此事件。</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>Do not make assumptions about the thread the event is raised on.</source>
          <target state="translated">不进行有关线程引发该事件的假设。</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>The event can be raised on a different thread than the one that called the <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> method.</source>
          <target state="translated">可以在与调用的一个不同的线程上引发该事件<ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">有关处理事件的详细信息，请参阅<bpt id="p1">[</bpt>处理和引发事件<ept id="p1">](~/docs/standard/events/index.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="P:System.AppDomain.DynamicDirectory">
          <source>Gets the directory that the assembly resolver uses to probe for dynamically created assemblies.</source>
          <target state="translated">获取目录，它由程序集冲突解决程序用来探测动态创建的程序集。</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The directory that the assembly resolver uses to probe for dynamically created assemblies.</source>
          <target state="translated">目录，它由程序集冲突解决程序用来探测动态创建的程序集。</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>To set the dynamic directory, assign a base directory path to the <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph> property of the <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> object that will be used to create the new application domain.</source>
          <target state="translated">若要设置的动态目录，分配的基目录路径<ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph>属性<ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph>将用于创建新的应用程序域的对象。</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The base directory path you assign to the property is modified by the addition of a subdirectory whose simple name is the hash code of the string you assign to the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType&gt;</ph> property, so the format of the base directory is <bpt id="p1">*</bpt>original path<ept id="p1">*</ept><ph id="ph2">\\</ph><bpt id="p2">*</bpt>hash code<ept id="p2">*</ept>.</source>
          <target state="translated">分配给属性的基目录路径修改通过其简单的名称是你将分配给字符串的哈希代码的子目录添加<ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType&gt;</ph>属性，因此基目录的格式是<bpt id="p1">*</bpt>原始路径<ept id="p1">*</ept> <ph id="ph2">\\</ph><bpt id="p2">*</bpt>哈希代码<ept id="p2">*</ept>。</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The dynamic directory is a subdirectory of this base directory.</source>
          <target state="translated">动态目录是此基目录的子目录。</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>Its simple name is the value of the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType&gt;</ph> property, so its format is <bpt id="p1">*</bpt>original path<ept id="p1">*</ept><ph id="ph2">\\</ph><bpt id="p2">*</bpt>hash code<ept id="p2">*</ept><ph id="ph3">\\</ph><bpt id="p3">*</bpt>application name<ept id="p3">*</ept>.</source>
          <target state="translated">其简单的名称为的值<ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType&gt;</ph>属性，因此其格式是<bpt id="p1">*</bpt>原始路径<ept id="p1">*</ept><ph id="ph2">\\</ph><bpt id="p2">*</bpt>哈希代码<ept id="p2">*</ept><ph id="ph3">\\</ph><bpt id="p3">*</bpt>应用程序名称<ept id="p3">*</ept>。</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.</source>
          <target state="translated">下面的示例创建一个应用程序域与目录的动态程序集、 发出动态程序集并将其存储在动态目录中，然后集加载到新的应用程序域并使用它。</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The example creates an <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> object and sets its <ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationName%2A&gt;</ph> property to "Example" and its <ph id="ph3">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph> property to "C:\DynamicAssemblyDir".</source>
          <target state="translated">该示例创建<ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph>对象并设置其<ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationName%2A&gt;</ph>属性设置为"示例"并将其<ph id="ph3">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph>"C:\DynamicAssemblyDir"的属性。</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The example then displays the <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.</source>
          <target state="translated">然后该示例显示<ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph>属性，以显示应用程序名称的哈希代码，已追加视为最初分配的路径的子目录。</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The base directory in this example is intended to be outside the probing path for the example application.</source>
          <target state="translated">在此示例中的基目录旨在将示例应用程序的探测路径之外。</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>Be sure to compile the example in a different location.</source>
          <target state="translated">请务必编译中的不同位置的示例。</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>Delete the base directory and all its subdirectories each time you run the example.</source>
          <target state="translated">每次运行该示例删除基目录和所有子目录。</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The example creates a new application domain, using the <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> object.</source>
          <target state="translated">该示例创建一个新的应用程序域，使用<ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The example uses the <ph id="ph1">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph> property to retrieve the name of the directory, so it can create the directory.</source>
          <target state="translated">该示例使用<ph id="ph1">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph>属性来检索目录的名称，因此它可以创建目录。</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>(The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)</source>
          <target state="translated">（该示例可以轻松地事先创建目录通过串联的原始路径、 应用程序名称和应用程序名称的哈希代码。）</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The example has a <ph id="ph1">`GenerateDynamicAssembly`</ph> method that emits an assembly named <ph id="ph2">`DynamicHelloWorld.dll`</ph> and stores it in the new application domain's dynamic directory.</source>
          <target state="translated">本示例具有<ph id="ph1">`GenerateDynamicAssembly`</ph>发出名为程序集的方法<ph id="ph2">`DynamicHelloWorld.dll`</ph>并将其存储在新应用程序域的动态目录。</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The dynamic assembly contains one type, <ph id="ph1">`HelloWorld`</ph>, that has a static method (<ph id="ph2">`Shared`</ph> method in Visual Basic) named <ph id="ph3">`HelloFromAD`</ph>.</source>
          <target state="translated">动态程序集包含一个类型， <ph id="ph1">`HelloWorld`</ph>，具有一个静态方法 (<ph id="ph2">`Shared`</ph>在 Visual Basic 中的方法) 名为<ph id="ph3">`HelloFromAD`</ph>。</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>Calling this method displays the name of the application domain.</source>
          <target state="translated">调用此方法显示应用程序域的名称。</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The <ph id="ph1">`Example`</ph> class derives from <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, so the example can create an instance of the class in the new application domain and call its <ph id="ph3">`Test`</ph> method.</source>
          <target state="translated"><ph id="ph1">`Example`</ph>类派生自<ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>，因此该示例可以创建类的实例中的新应用程序域和调用其<ph id="ph3">`Test`</ph>方法。</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The <ph id="ph1">`Test`</ph> method loads the dynamic assembly by its display name and calls the static <ph id="ph2">`HelloFromAD`</ph> method.</source>
          <target state="translated"><ph id="ph1">`Test`</ph>方法加载的动态程序集按其显示名称，并调用静态<ph id="ph2">`HelloFromAD`</ph>方法。</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named <ph id="ph1">`DynamicHelloWorld.dll`</ph> and compiling it in the same directory as this example.</source>
          <target state="translated">你可以显示在正常的探测路径后搜索的动态目录，通过对名为程序集编写代码<ph id="ph1">`DynamicHelloWorld.dll`</ph>并将其编译此示例为同一个目录中。</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The assembly must have a class named <ph id="ph1">`HelloWorld`</ph> with a static method named <ph id="ph2">`HelloFromAD`</ph>.</source>
          <target state="translated">程序集必须具有一个名为类<ph id="ph1">`HelloWorld`</ph>与一个名为的静态方法<ph id="ph2">`HelloFromAD`</ph>。</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>This method does not have to have the same functionality as the one in the example; it can simply display a string to the console.</source>
          <target state="translated">此方法不需要具有相同的功能与在这些示例。它只是可以向控制台显示字符串。</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The assembly must also have an <ph id="ph1">&lt;xref:System.Reflection.AssemblyVersionAttribute&gt;</ph> attribute that sets its version to 1.0.0.0.</source>
          <target state="translated">程序集必须还具有<ph id="ph1">&lt;xref:System.Reflection.AssemblyVersionAttribute&gt;</ph>将其版本设置为 1.0.0.0 的属性。</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.</source>
          <target state="translated">运行示例时，当前目录中编译的程序集位于之前搜索的动态目录。</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="P:System.AppDomain.DynamicDirectory">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>for access to the path information.</source>
          <target state="translated">用于访问的路径信息。</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="P:System.AppDomain.Evidence">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Security.Policy.Evidence" /&gt;</ph> associated with this application domain.</source>
          <target state="translated">获取与该应用程序域关联的 <ph id="ph1">&lt;see cref="T:System.Security.Policy.Evidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Evidence">
          <source>The evidence associated with this application domain.</source>
          <target state="translated">与该应用程序域关联的证据。</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" uid="P:System.AppDomain.Evidence">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Evidence">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Evidence">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Evidence">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">安全操作： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Executes the assembly contained in the specified file.</source>
          <target state="translated">执行指定文件中包含的程序集。</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">包含要执行程序集的文件的名称。</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>Executes the assembly contained in the specified file.</source>
          <target state="translated">执行指定文件中包含的程序集。</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">程序集的入口点返回的值。</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">程序集开始在.NET Framework 标头中指定的入口点执行。</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">此方法加载程序集使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">你还可以执行程序集使用<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法，后者将加载程序集使用<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>To create the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> to load and execute, use the <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> method.</source>
          <target state="translated">若要创建<ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>加载并执行，请使用<ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The following sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">下面的示例演示如何使用的重载之一<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph>在两个不同的域。</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 是用更高版本编译的。</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">指定的程序集没有入口点。</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">用于读取一个 URI，不以"file://"开头。</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>to execute a console application.</source>
          <target state="translated">若要执行一个控制台应用程序。</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">包含要执行程序集的文件的名称。</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">用于加载程序集的证据。</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Executes the assembly contained in the specified file, using the specified evidence.</source>
          <target state="translated">使用指定的证据执行指定文件中包含的程序集。</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">程序集的入口点返回的值。</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">程序集开始在.NET Framework 标头中指定的入口点执行。</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph>方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">此方法加载程序集使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">你还可以执行程序集使用<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法，后者将加载程序集使用<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The following sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">下面的示例演示如何使用的重载之一<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph>在两个不同的域。</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 是用更高版本编译的。</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">指定的程序集没有入口点。</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">用于读取一个 URI，不以"file://"开头。</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>to execute a console application.</source>
          <target state="translated">若要执行一个控制台应用程序。</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">包含要执行程序集的文件的名称。</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The arguments to the entry point of the assembly.</source>
          <target state="translated">程序集的入口点的自变量。</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>Executes the assembly contained in the specified file, using the specified arguments.</source>
          <target state="translated">使用指定的自变量执行指定文件中包含的程序集。</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The value that is returned by the entry point of the assembly.</source>
          <target state="translated">程序集的入口点返回的值。</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">程序集开始在.NET Framework 标头中指定的入口点执行。</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">此方法加载程序集使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">你还可以执行程序集使用<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法，后者将加载程序集使用<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The following sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">下面的示例演示如何使用的重载之一<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph>在两个不同的域。</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 使用高于当前所加载版本的公共语言运行时版本编译而成。</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">指定的程序集没有入口点。</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">用于读取一个 URI，不以"file://"开头。</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">若要执行一个控制台应用程序。</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">包含要执行程序集的文件的名称。</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The supplied evidence for the assembly.</source>
          <target state="translated">为程序集提供的证据。</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The arguments to the entry point of the assembly.</source>
          <target state="translated">程序集的入口点的自变量。</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Executes the assembly contained in the specified file, using the specified evidence and arguments.</source>
          <target state="translated">使用指定的证据和自变量执行指定文件中包含的程序集。</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">程序集的入口点返回的值。</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">程序集开始在.NET Framework 标头中指定的入口点执行。</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">此方法加载程序集使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">你还可以执行程序集使用<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法，后者将加载程序集使用<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The following sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">下面的示例演示如何使用的重载之一<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph>在两个不同的域。</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 是用更高版本编译的。</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">未启用旧版 CAS 策略时，<ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> 应为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">指定的程序集没有入口点。</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">用于读取一个 URI，不以"file://"开头。</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">若要执行一个控制台应用程序。</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">包含要执行程序集的文件的名称。</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The arguments to the entry point of the assembly.</source>
          <target state="translated">程序集的入口点的自变量。</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the value of the computed hash code.</source>
          <target state="translated">表示计算所得的哈希代码的值。</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the hash algorithm used by the assembly manifest.</source>
          <target state="translated">表示程序集清单使用的哈希算法。</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Executes the assembly contained in the specified file, using the specified arguments, hash value, and hash algorithm.</source>
          <target state="translated">使用指定的自变量、哈希值和哈希算法执行指定文件中包含的程序集。</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The value that is returned by the entry point of the assembly.</source>
          <target state="translated">程序集的入口点返回的值。</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">程序集开始在.NET Framework 标头中指定的入口点执行。</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">此方法加载程序集使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">你还可以执行程序集使用<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法，后者将加载程序集使用<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The following sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">下面的示例演示如何使用的重载之一<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph>在两个不同的域。</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 使用高于当前所加载版本的公共语言运行时版本编译而成。</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">指定的程序集没有入口点。</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">用于读取一个 URI，不以"file://"开头。</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>to execute a console application.</source>
          <target state="translated">若要执行一个控制台应用程序。</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">包含要执行程序集的文件的名称。</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The supplied evidence for the assembly.</source>
          <target state="translated">为程序集提供的证据。</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The arguments to the entry point of the assembly.</source>
          <target state="translated">程序集的入口点的自变量。</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the value of the computed hash code.</source>
          <target state="translated">表示计算所得的哈希代码的值。</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the hash algorithm used by the assembly manifest.</source>
          <target state="translated">表示程序集清单使用的哈希算法。</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Executes the assembly contained in the specified file, using the specified evidence, arguments, hash value, and hash algorithm.</source>
          <target state="translated">使用指定的证据、自变量、哈希值和哈希算法执行指定文件中包含的程序集。</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">程序集的入口点返回的值。</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">程序集开始在.NET Framework 标头中指定的入口点执行。</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">此方法加载程序集使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">你还可以执行程序集使用<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法，后者将加载程序集使用<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Thefollowing sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">以下示例演示如何使用的重载之一<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph>在两个不同的域。</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 是用更高版本编译的。</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">未启用旧版 CAS 策略时，<ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> 应为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">指定的程序集没有入口点。</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">用于读取一个 URI，不以"file://"开头。</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>to execute a console application.</source>
          <target state="translated">若要执行一个控制台应用程序。</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Executes an assembly.</source>
          <target state="translated">执行程序集。</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>Executes an assembly given its display name.</source>
          <target state="translated">在给定其显示名称的情况下执行程序集。</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">程序集的入口点返回的值。</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法提供与类似的功能<ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph>方法，但按显示名称指定的程序集或<ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph>而不是文件位置。</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">因此，<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>加载程序集与<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法而不是与<ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">程序集开始在.NET Framework 标头中指定的入口点执行。</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>To create the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> to load and execute, use the <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> method.</source>
          <target state="translated">若要创建<ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>加载并执行，请使用<ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">找不到由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集。</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 是用更高版本编译的。</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">找到了由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集，但无法加载。</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">指定的程序集没有入口点。</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">用于读取从文件或目录中，对于路径本身中的信息的访问权限，并且将显示名称重定向到的路径的访问。</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">用于访问网站，在显示名称重定向到 URL 时。</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>to execute a console application.</source>
          <target state="translated">若要执行一个控制台应用程序。</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object representing the name of the assembly.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> 对象，表示程序集名称。</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>Command-line arguments to pass when starting the process.</source>
          <target state="translated">启动该进程时传递的命令行参数。</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>Executes the assembly given an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>, using the specified arguments.</source>
          <target state="translated">根据给定的 <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> 使用指定的参数执行程序集。</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The value that is returned by the entry point of the assembly.</source>
          <target state="translated">程序集的入口点返回的值。</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法提供与类似的功能<ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph>方法，但按显示名称指定的程序集或<ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph>而不是文件位置。</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">因此，<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>加载程序集与<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法而不是与<ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">程序集开始在.NET Framework 标头中指定的入口点执行。</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">找不到由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集。</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">找到了由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集，但无法加载。</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 使用高于当前所加载版本的公共语言运行时版本编译而成。</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">指定的程序集没有入口点。</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">用于读取从文件或目录中，对于路径本身中的信息的访问权限，并且将显示名称重定向到的路径的访问。</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">用于访问网站，在显示名称重定向到 URL 时。</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">若要执行一个控制台应用程序。</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">用于加载程序集的证据。</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Executes an assembly given its display name, using the specified evidence.</source>
          <target state="translated">在给定显示名称的情况下，使用指定证据执行程序集。</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">程序集的入口点返回的值。</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法提供与类似的功能<ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph>方法，但按显示名称指定的程序集或<ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph>而不是文件位置。</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">因此，<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>加载程序集与<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法而不是与<ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">程序集开始在.NET Framework 标头中指定的入口点执行。</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>When you use the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法替换<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>合并参数，证据。</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">作为参数提供的证据<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法取代加载程序提供的证据。</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">找不到由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集。</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">找到了由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集，但无法加载。</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 是用更高版本编译的。</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">指定的程序集没有入口点。</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">用于读取从文件或目录中，对于路径本身中的信息的访问权限，并且将显示名称重定向到的路径的访问。</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">用于访问网站，在显示名称重定向到 URL 时。</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>to execute a console application.</source>
          <target state="translated">若要执行一个控制台应用程序。</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>Command-line arguments to pass when starting the process.</source>
          <target state="translated">启动该进程时传递的命令行参数。</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>Executes the assembly given its display name, using the specified arguments.</source>
          <target state="translated">在给定显示名称的情况下，使用指定自变量执行程序集。</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The value that is returned by the entry point of the assembly.</source>
          <target state="translated">程序集的入口点返回的值。</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法提供与类似的功能<ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph>方法，但按显示名称指定的程序集或<ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph>而不是文件位置。</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">因此，<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>加载程序集与<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法而不是与<ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">程序集开始在.NET Framework 标头中指定的入口点执行。</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">找不到由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集。</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">找到了由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集，但无法加载。</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 使用高于当前所加载版本的公共语言运行时版本编译而成。</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">指定的程序集没有入口点。</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">用于读取从文件或目录中，对于路径本身中的信息的访问权限，并且将显示名称重定向到的路径的访问。</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">用于访问网站，在显示名称重定向到 URL 时。</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">若要执行一个控制台应用程序。</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object representing the name of the assembly.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> 对象，表示程序集名称。</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">用于加载程序集的证据。</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Command-line arguments to pass when starting the process.</source>
          <target state="translated">启动该进程时传递的命令行参数。</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Executes the assembly given an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>, using the specified evidence and arguments.</source>
          <target state="translated">根据给定的 <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> 使用指定的证据和实参执行程序集。</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">程序集的入口点返回的值。</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法提供与类似的功能<ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph>方法，但按显示名称指定的程序集或<ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph>而不是文件位置。</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">因此，<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>加载程序集与<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法而不是与<ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">程序集开始在.NET Framework 标头中指定的入口点执行。</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>When you use the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法替换<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>合并参数，证据。</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">作为参数提供的证据<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法取代加载程序提供的证据。</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">找不到由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集。</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">找到了由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集，但无法加载。</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 是用更高版本编译的。</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">未启用旧版 CAS 策略时，<ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> 应为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">指定的程序集没有入口点。</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">用于读取从文件或目录中，对于路径本身中的信息的访问权限，并且将显示名称重定向到的路径的访问。</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">用于访问网站，在显示名称重定向到 URL 时。</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">若要执行一个控制台应用程序。</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">用于加载程序集的证据。</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Command-line arguments to pass when starting the process.</source>
          <target state="translated">启动该进程时传递的命令行参数。</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Executes the assembly given its display name, using the specified evidence and arguments.</source>
          <target state="translated">在给定其显示名称的情况下，使用指定证据和自变量执行程序集。</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">程序集的入口点返回的值。</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法提供与类似的功能<ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph>方法，但按显示名称指定的程序集或<ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph>而不是文件位置。</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">因此，<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>加载程序集与<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法而不是与<ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">程序集开始在.NET Framework 标头中指定的入口点执行。</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">此方法不会创建新的进程或应用程序域，并且不会在新线程上执行入口点方法。</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>When you use the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法替换<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>合并参数，证据。</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">作为参数提供的证据<ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph>方法取代加载程序提供的证据。</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">找不到由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集。</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">找到了由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集，但无法加载。</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">由 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 指定的程序集不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> 是用更高版本编译的。</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">未启用旧版 CAS 策略时，<ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> 应为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">指定的程序集没有入口点。</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">用于读取从文件或目录中，对于路径本身中的信息的访问权限，并且将显示名称重定向到的路径的访问。</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">用于访问网站，在显示名称重定向到 URL 时。</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">若要执行一个控制台应用程序。</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" uid="E:System.AppDomain.FirstChanceException">
          <source>Occurs when an exception is thrown in managed code, before the runtime searches the call stack for an exception handler in the application domain.</source>
          <target state="translated">当托管代码抛出异常时发生，在运行时在调用堆栈中搜索应用程序域中的异常处理程序之前。</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>This event is only a notification.</source>
          <target state="translated">此事件是仅一个通知。</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Handling this event does not handle the exception or affect subsequent exception handling in any way.</source>
          <target state="translated">处理此事件不会处理的异常或会影响后续以任何方式处理的异常。</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>After the event has been raised and event handlers have been invoked, the common language runtime (CLR) begins to search for a handler for the exception.</source>
          <target state="translated">引发事件并在调用事件处理程序后，公共语言运行时 (CLR) 开始搜索的异常处理程序。</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source><ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> provides the application domain with a first chance to examine any managed exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> 第一个机会检查任何托管的异常中提供的应用程序域。</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>The event can be handled per application domain.</source>
          <target state="translated">每个应用程序域可以处理此事件。</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>If a thread passes through multiple application domains while executing a call, the event is raised in each application domain that has registered an event handler, before the CLR begins searching for a matching exception handler in that application domain.</source>
          <target state="translated">如果一个线程通过多个应用程序域传递执行调用时，CLR 开始搜索该应用程序域中的匹配异常处理程序之前已注册事件处理程序，每个应用程序域中将引发事件。</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>After the event has been handled, a search is made for a matching exception handler in that application domain.</source>
          <target state="translated">处理此事件后，将为该应用程序域中的匹配异常处理程序中进行搜索。</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>If none is found, the event is raised in the next application domain.</source>
          <target state="translated">如果找不到下, 一步的应用程序域中将引发事件。</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>You must handle all exceptions that occur in the event handler for the <ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> event.</source>
          <target state="translated">你必须处理发生在事件处理程序的所有异常<ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Otherwise, <ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> is raised recursively.</source>
          <target state="translated">否则为<ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph>递归地引发。</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>This could result in a stack overflow and termination of the application.</source>
          <target state="translated">这可能导致堆栈上溢和终止应用程序。</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>We recommend that you implement event handlers for this event as constrained execution regions (CERs), to keep infrastructure-related exceptions such as out-of-memory or stack overflow from affecting the virtual machine while the exception notification is being processed.</source>
          <target state="translated">我们建议你实现此事件的事件处理程序作为受约束的执行区域 (Cer)，以防止与基础结构相关的异常，例如内存不足或堆栈溢出异常通知时影响虚拟机正在处理。</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>This event is not raised for exceptions that indicate corruption of process state, such as access violations, unless the event handler is security-critical and has the <ph id="ph1">&lt;xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute&gt;</ph> attribute.</source>
          <target state="translated">此事件不会引发的异常的指示损坏进程的状态，例如访问冲突，除非事件处理程序是安全关键，并且具有<ph id="ph1">&lt;xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>The common language runtime suspends thread aborts while this notification event is being handled.</source>
          <target state="translated">公共语言运行时挂起线程中止时正在处理此通知事件。</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>The following example creates a series of application domains named <ph id="ph1">`AD0`</ph> through <ph id="ph2">`AD3`</ph>, with a <ph id="ph3">`Worker`</ph> object in each application domain.</source>
          <target state="translated">下面的示例创建名为的应用程序域的一系列<ph id="ph1">`AD0`</ph>通过<ph id="ph2">`AD3`</ph>，与<ph id="ph3">`Worker`</ph>每个应用程序域中的对象。</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Each <ph id="ph1">`Worker`</ph> object has a reference to the <ph id="ph2">`Worker`</ph> object in the next application domain, except for the <ph id="ph3">`Worker`</ph> in the last application domain.</source>
          <target state="translated">每个<ph id="ph1">`Worker`</ph>对象具有对引用<ph id="ph2">`Worker`</ph>对象在下一步的应用程序域中，除<ph id="ph3">`Worker`</ph>最后一个应用程序域中。</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> event is handled in all application domains except <ph id="ph2">`AD1`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph>除外的所有应用程序域中处理事件<ph id="ph2">`AD1`</ph>。</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in <bpt id="p1">[</bpt>How to: Receive First-Chance Exception Notifications<ept id="p1">](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)</ept>.</source>
          <target state="translated">除了此示例中，其演示了多个应用程序域中的首次异常通知，你可以找到在简单的用例<bpt id="p1">[</bpt>如何： 接收首次异常通知<ept id="p1">](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>When the application domains have been created, the default application domain calls the <ph id="ph1">`TestException`</ph> method for the first application domain.</source>
          <target state="translated">默认应用程序域创建的应用程序域后，调用<ph id="ph1">`TestException`</ph>第一个应用程序域的方法。</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Each <ph id="ph1">`Worker`</ph> object calls the <ph id="ph2">`TestException`</ph> method for the next application domain, until the last <ph id="ph3">`Worker`</ph> throws an exception that is either handled or unhandled.</source>
          <target state="translated">每个<ph id="ph1">`Worker`</ph>对象调用<ph id="ph2">`TestException`</ph>方法下一步的应用程序域，直到最后一个<ph id="ph3">`Worker`</ph>引发已处理，或者未经处理的异常。</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Thus, the current thread passes through all the application domains, and <ph id="ph1">`TestException`</ph> is added to the stack in each application domain.</source>
          <target state="translated">因此，当前线程通过所有应用程序域和<ph id="ph1">`TestException`</ph>添加到每个应用程序域中的堆栈。</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>When the last <ph id="ph1">`Worker`</ph> object handles the exception, the <ph id="ph2">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> event is raised only in the last application domain.</source>
          <target state="translated">当最后一个<ph id="ph1">`Worker`</ph>对象处理异常，<ph id="ph2">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph>仅在最后一个应用程序域中引发事件。</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>The other application domains never get a chance to handle the exception, so the event is not raised.</source>
          <target state="translated">其他应用程序域永远不会获得一个机会处理异常，因此不引发该事件。</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>When the last <ph id="ph1">`Worker`</ph> object does not handle the exception, the <ph id="ph2">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> event is raised in each application domain that has an event handler.</source>
          <target state="translated">当最后一个<ph id="ph1">`Worker`</ph>对象并不处理异常，<ph id="ph2">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph>每个应用程序域中具有事件处理程序引发事件。</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.</source>
          <target state="translated">每个事件处理程序完成后，堆栈将继续展开，直到默认应用程序域中捕获该异常。</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>To see how the stack display grows as the event is raised closer and closer to the default application domain, change <ph id="ph1">`e.Exception.Message`</ph> to <ph id="ph2">`e.Exception`</ph> in the <ph id="ph3">`FirstChanceHandler`</ph> event handlers.</source>
          <target state="translated">若要查看堆栈显示为更接近引发该事件的增长和接近默认应用程序域，请更改<ph id="ph1">`e.Exception.Message`</ph>到<ph id="ph2">`e.Exception`</ph>中<ph id="ph3">`FirstChanceHandler`</ph>事件处理程序。</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Notice that when <ph id="ph1">`TestException`</ph> is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.</source>
          <target state="translated">请注意，当<ph id="ph1">`TestException`</ph>调用跨应用程序域边界进行，则它会出现两次： 一次针对该代理，一次存根 （stub）。</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" uid="P:System.AppDomain.FriendlyName">
          <source>Gets the friendly name of this application domain.</source>
          <target state="translated">获取此应用程序域的友好名称。</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>The friendly name of this application domain.</source>
          <target state="translated">此应用程序域的友好名称。</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>The friendly name of the default application domain is the file name of the process executable.</source>
          <target state="translated">默认应用程序域的友好名称是进程可执行文件的文件名。</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>For example, if the executable used to start the process is <ph id="ph1">`"c:\MyAppDirectory\MyAssembly.exe"`</ph>, the friendly name of the default application domain is <ph id="ph2">`"MyAssembly.exe"`</ph>.</source>
          <target state="translated">例如，如果使用可执行文件以启动该过程是<ph id="ph1">`"c:\MyAppDirectory\MyAssembly.exe"`</ph>，默认应用程序域的友好名称是<ph id="ph2">`"MyAssembly.exe"`</ph>。</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.AppDomain.FriendlyName%2A&gt;</ph> property to get the friendly name of the current application domain.</source>
          <target state="translated">下面的代码示例使用<ph id="ph1">&lt;xref:System.AppDomain.FriendlyName%2A&gt;</ph>属性来获取当前应用程序域的友好名称。</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>For the default application domain, the friendly name is the name of the application's executable file.</source>
          <target state="translated">对于默认应用程序域的友好名称是应用程序的可执行文件的名称。</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>The code example also displays additional information about the application domain.</source>
          <target state="translated">下面的代码示例还显示有关应用程序域的其他信息。</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" uid="P:System.AppDomain.FriendlyName">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetAssemblies">
          <source>Gets the assemblies that have been loaded into the execution context of this application domain.</source>
          <target state="translated">获取已加载到此应用程序域的执行上下文中的程序集。</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetAssemblies">
          <source>An array of assemblies in this application domain.</source>
          <target state="translated">此应用程序域中的程序集的数组。</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetAssemblies">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> method to get a list of all assemblies that have been loaded into the application domain.</source>
          <target state="translated">下面的代码示例使用<ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph>方法以获取已加载到应用程序域的所有程序集的列表。</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetAssemblies">
          <source>The assemblies are then displayed to the console.</source>
          <target state="translated">程序集将显示到控制台。</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetAssemblies">
          <source>To run this code example, you need to create an assembly named <ph id="ph1">`CustomLibrary.dll`</ph>, or change the assembly name that is passed to the <ph id="ph2">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> method.</source>
          <target state="translated">若要运行此代码示例，你需要创建一个名为的程序集<ph id="ph1">`CustomLibrary.dll`</ph>，或更改程序集名称传递给<ph id="ph2">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetAssemblies">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>Gets the current thread identifier.</source>
          <target state="translated">获取当前线程标识符。</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>A 32-bit signed integer that is the identifier of the current thread.</source>
          <target state="translated">一个 32 位带符号整数，它是当前线程的标识符。</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> property, which is stable even when the .NET Framework is hosted by an environment that supports fibers (that is, lightweight threads).</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph>属性，它是稳定甚至.NET Framework 承载环境支持纤程 （即，轻量级线程）。</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>to call this method.</source>
          <target state="translated">若要调用此方法。</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">安全操作： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetData(System.String)">
          <source>The name of a predefined application domain property, or the name of an application domain property you have defined.</source>
          <target state="translated">预定义应用程序域属性的名称，或已定义的应用程序域属性的名称。</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetData(System.String)">
          <source>Gets the value stored in the current application domain for the specified name.</source>
          <target state="translated">为指定名称获取存储在当前应用程序域中的值。</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetData(System.String)">
          <source>The value of the <ph id="ph1">&lt;paramref name="name" /&gt;</ph> property, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the property does not exist.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 属性的值，或 <ph id="ph2">&lt;see langword="null" /&gt;</ph>（如果属性不存在）。</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Use this method to retrieve the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>.</source>
          <target state="translated">使用此方法来检索中描述的此实例的属性的名称数据对内部缓存条目的值<ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Note that the comparison of <ph id="ph1">`name`</ph> with the name of key-value pairs is case-sensitive.</source>
          <target state="translated">请注意，比较<ph id="ph1">`name`</ph>同名的键 / 值对是区分大小写。</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>The cache automatically contains predefined system entries that are inserted when the application domain is created.</source>
          <target state="translated">该缓存自动包含在创建应用程序域后插入的预定义的系统项。</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>You can inspect their values with the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method, or the equivalent <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> properties.</source>
          <target state="translated">你可以检查它们的值与<ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph>方法或等效<ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>You can insert or modify your own user defined name-data pairs with the <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A&gt;</ph> method and inspect their values with the <ph id="ph2">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method.</source>
          <target state="translated">你可以插入或修改与自己用户定义名称数据对<ph id="ph1">&lt;xref:System.AppDomain.SetData%2A&gt;</ph>方法，并检查其值与<ph id="ph2">&lt;xref:System.AppDomain.GetData%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>The following table describes the <ph id="ph1">`name`</ph> of each predefined system entry and its corresponding <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> property.</source>
          <target state="translated">下表描述了<ph id="ph1">`name`</ph>每个预定义系统条目和其对应<ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Value of 'name'</source>
          <target state="translated">Name 的值</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Property</source>
          <target state="translated">Property</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"APPBASE"</source>
          <target state="translated">"APPBASE"</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"APP_CONFIG_FILE"</source>
          <target state="translated">"APP_CONFIG_FILE"</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"APP_LAUNCH_URL"</source>
          <target state="translated">"APP_LAUNCH_URL"</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>(no property)</source>
          <target state="translated">（没有属性）</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"APP_LAUNCH_URL" represents the URL originally requested by the user, before any redirection.</source>
          <target state="translated">"APP_LAUNCH_URL"表示最初由用户之前任何重定向请求的 URL。</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>It is available only when the application has been launched with a browser such as Internet Explorer.</source>
          <target state="translated">仅当使用如 Internet Explorer 浏览器中启动应用程序时，才，它才可用。</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Not all browsers provide this value.</source>
          <target state="translated">并非所有浏览器提供此值。</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"APP_NAME"</source>
          <target state="translated">"APP_NAME"</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"BINPATH_PROBE_ONLY"</source>
          <target state="translated">"BINPATH_PROBE_ONLY"</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"CACHE_BASE"</source>
          <target state="translated">"CACHE_BASE"</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"CODE_DOWNLOAD_DISABLED"</source>
          <target state="translated">"CODE_DOWNLOAD_DISABLED"</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"DEV_PATH"</source>
          <target state="translated">"DEV_PATH"</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>(no property)</source>
          <target state="translated">（没有属性）</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"DISALLOW_APP"</source>
          <target state="translated">"DISALLOW_APP"</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"DISALLOW_APP_BASE_PROBING"</source>
          <target state="translated">"DISALLOW_APP_BASE_PROBING"</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"DISALLOW_APP_REDIRECTS"</source>
          <target state="translated">"DISALLOW_APP_REDIRECTS"</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"DYNAMIC_BASE"</source>
          <target state="translated">"DYNAMIC_BASE"</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"FORCE_CACHE_INSTALL"</source>
          <target state="translated">"FORCE_CACHE_INSTALL"</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"LICENSE_FILE", or an application-specific string</source>
          <target state="translated">"LICENSE_FILE"或特定于应用程序字符串</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"LOADER_OPTIMIZATION"</source>
          <target state="translated">"LOADER_OPTIMIZATION"</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"LOCATION_URI"</source>
          <target state="translated">"LOCATION_URI"</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>(no property)</source>
          <target state="translated">（没有属性）</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"PRIVATE_BINPATH"</source>
          <target state="translated">"PRIVATE_BINPATH"</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"REGEX_DEFAULT_MATCH_TIMEOUT"</source>
          <target state="translated">"REGEX_DEFAULT_MATCH_TIMEOUT"</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"REGEX_DEFAULT_MATCH_TIMEOUT" is not a system entry, and its value can be set by calling the <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A&gt;</ph> method.</source>
          <target state="translated">"REGEX_DEFAULT_MATCH_TIMEOUT"不是系统条目，并且其值可以通过调用设置<ph id="ph1">&lt;xref:System.AppDomain.SetData%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"SHADOW_COPY_DIRS"</source>
          <target state="translated">"SHADOW_COPY_DIRS"</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain.</source>
          <target state="translated">下面的示例创建一个新的应用程序域、 设置域，系统提供的值并添加新域值对。</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>The example then demonstrates how to use the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method to retrieve the data from these value pairs and display them to the console.</source>
          <target state="translated">该示例然后演示如何使用<ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph>方法从这些值对检索数据并将它们显示到控制台。</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetData(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetData(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>for access to the information in the path itself, if the property applies to a path.</source>
          <target state="translated">用于访问路径本身，如果要将属性应用到路径中的信息。</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetType">
          <source>Gets the type of the current instance.</source>
          <target state="translated">获取当前实例的类型。</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetType">
          <source>The type of the current instance.</source>
          <target state="translated">当前实例的类型。</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" uid="P:System.AppDomain.Id">
          <source>Gets an integer that uniquely identifies the application domain within the process.</source>
          <target state="translated">获得一个整数，该整数唯一标识进程中的应用程序域。</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Id">
          <source>An integer that identifies the application domain.</source>
          <target state="translated">标识应用程序域的整数。</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Id">
          <source>The following code example creates a second application domain and displays information about the default domain and the new domain.</source>
          <target state="translated">下面的代码示例创建第二个应用程序域，并显示有关的默认域和新的域的信息。</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" uid="M:System.AppDomain.InitializeLifetimeService">
          <source>Gives the <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> an infinite lifetime by preventing a lease from being created.</source>
          <target state="translated">通过防止创建租约来给予 <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> 无限生存期。</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" uid="M:System.AppDomain.InitializeLifetimeService">
          <source>Always <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">总是为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" uid="M:System.AppDomain.InitializeLifetimeService">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.InitializeLifetimeService">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.InitializeLifetimeService">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>The compatibility switch to test.</source>
          <target state="translated">要测试的兼容性开关。</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Gets a nullable Boolean value that indicates whether any compatibility switches are set, and if so, whether the specified compatibility switch is set.</source>
          <target state="translated">获取可以为 null 的布尔值，该值指示是否设置了任何兼容性开关，如果已设置，则指定是否设置了指定的兼容性开关。</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) if no compatibility switches are set; otherwise, a Boolean value that indicates whether the compatibility switch that is specified by <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is set.</source>
          <target state="translated">如果未设置任何兼容性开关，则为 null 引用（Visual Basic 中的 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>）；否则，为布尔值，指示是否设置了由 <ph id="ph2">&lt;paramref name="value" /&gt;</ph> 指定的兼容性开关。</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>This method tests whether the specified compatibility switch has been set for the current application domain.</source>
          <target state="translated">此方法测试是否已为当前的应用程序域中设置了指定的兼容性开关。</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.</source>
          <target state="translated">兼容性开关通常还原行为 （例如，字符串的方式进行排序），.NET Framework 的版本间已改变。</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>They are set by calling the <ph id="ph1">&lt;xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType&gt;</ph> method before creating an application domain.</source>
          <target state="translated">它们设置的调用<ph id="ph1">&lt;xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType&gt;</ph>方法，然后才能创建应用程序域。</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.</source>
          <target state="translated">下表提供兼容性开关，可设置为还原的.NET Framework 的早期版本的行为的示例。</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Switch</source>
          <target state="translated">开关</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Meaning</source>
          <target state="translated">含义</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>"NetFx40_LegacySecurityPolicy"</source>
          <target state="translated">"NetFx40_LegacySecurityPolicy"</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Code access security (CAS) for the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> is enabled in this application domain.</source>
          <target state="translated">代码访问安全性 (CAS)<ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>在此应用程序域中启用。</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>See <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>NetFx40_LegacySecurityPolicy<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)</ept>.</source>
          <target state="translated">请参阅<bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>NetFx40_LegacySecurityPolicy<ph id="ph2">&amp;gt;</ph>元素<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>"NetFx40_Legacy20SortingBehavior"</source>
          <target state="translated">"NetFx40_Legacy20SortingBehavior"</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>String sorting defaults for the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> are enabled in this application domain.</source>
          <target state="translated">字符串排序的默认值<ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>在此应用程序域中启用。</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Its success requires sort00001000.dll to be installed.</source>
          <target state="translated">其成功要求 sort00001000.dll 安装。</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>See <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>CompatSortNLSVersion<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)</ept>.</source>
          <target state="translated">请参阅<bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>CompatSortNLSVersion<ph id="ph2">&amp;gt;</ph>元素<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>"NetFx40_Legacy40SortingBehavior"</source>
          <target state="translated">"NetFx40_Legacy40SortingBehavior"</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>String sorting defaults for the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>and Unicode 5.0 are enabled in this application domain.</source>
          <target state="translated">字符串排序的默认值<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>和在此应用程序域中启用 Unicode 5.0。</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Its success requires sort00060101.dll to be installed.</source>
          <target state="translated">其成功要求 sort00060101.dll 安装。</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>"NetFx40_TimeSpanLegacyFormatMode"</source>
          <target state="translated">"NetFx40_TimeSpanLegacyFormatMode"</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source><ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> formatting behavior for the <ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> is enabled in this application domain.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> 格式设置行为<ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>在此应用程序域中启用。</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>See <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>TimeSpan_LegacyFormatMode<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)</ept> and the "Restoring Legacy TimeSpan Formatting" section of the <ph id="ph3">&lt;xref:System.TimeSpan&gt;</ph> topic.</source>
          <target state="translated">请参阅<bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>TimeSpan_LegacyFormatMode<ph id="ph2">&amp;gt;</ph>元素<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)</ept>和"还原旧时间跨度格式设置"部分的<ph id="ph3">&lt;xref:System.TimeSpan&gt;</ph>主题。</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>"UseRandomizedStringHashAlgorithm"</source>
          <target state="translated">"UseRandomizedStringHashAlgorithm"</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains.</source>
          <target state="translated">运行时计算字符串的哈希代码上每个应用程序域而不是使用单一的哈希算法跨应用程序域中生成的一致的哈希代码。</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>See <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>UseRandomizedStringHashAlgorithm<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>.</source>
          <target state="translated">请参阅<bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>UseRandomizedStringHashAlgorithm<ph id="ph2">&amp;gt;</ph>元素<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsDefaultAppDomain">
          <source>Returns a value that indicates whether the application domain is the default application domain for the process.</source>
          <target state="translated">返回一个值，指示应用程序域是否是进程的默认应用程序域。</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsDefaultAppDomain">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.AppDomain" /&gt;</ph> object represents the default application domain for the process; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果当前 <ph id="ph2">&lt;see cref="T:System.AppDomain" /&gt;</ph> 对象表示进程的默认应用程序域，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsDefaultAppDomain">
          <source>Every managed process has a default application domain.</source>
          <target state="translated">每个托管的进程都有默认应用程序域。</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsDefaultAppDomain">
          <source>Execution begins in the default domain.</source>
          <target state="translated">默认域中开始执行。</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsDefaultAppDomain">
          <source>The following code example creates a second application domain and displays information about the default domain and the new domain.</source>
          <target state="translated">下面的代码示例创建第二个应用程序域，并显示有关的默认域和新的域的信息。</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>Indicates whether this application domain is unloading, and the objects it contains are being finalized by the common language runtime.</source>
          <target state="translated">指示此应用程序域是否正在卸载以及公共语言运行时是否正在终止该域包含的对象。</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this application domain is unloading and the common language runtime has started invoking finalizers; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此应用程序域正在卸载，并且公共语言运行时已开始调用终止程序，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>The finalization method for an object provides you an opportunity to perform any necessary cleanup operations before the object is garbage collected.</source>
          <target state="translated">一个对象的完成方法提供机会在对象垃圾回收之前执行任何必要的清理操作。</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>After finalization, the object is accessible but in an invalid state and therefore unusable.</source>
          <target state="translated">完成后，该对象处于可访问但处于无效状态，因而无法使用。</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>Eventually, garbage collection completes and reclaims the object.</source>
          <target state="translated">最终，垃圾回收完成，并回收对象。</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>An object's finalization method is called in one of the following situations: during garbage collection, when the common language runtime is shutting down, or when the application domain that contains the object is unloaded.</source>
          <target state="translated">在下列情况之一调用对象的完成方法： 垃圾回收期间时公共语言运行时正在关闭，或卸载应用程序域包含的对象时。</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.IsFinalizingForUnload%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> only in the last case; it does not return <ph id="ph3">`true`</ph> if finalization results from routine garbage collection or from CLR shutdown.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.IsFinalizingForUnload%2A&gt;</ph>方法返回<ph id="ph2">`true`</ph>仅在最后一种情况; 它不返回<ph id="ph3">`true`</ph>如果终止结果从例程垃圾回收或 CLR 关闭。</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>To determine whether finalization is due to CLR shutdown, use the <ph id="ph1">&lt;xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">若要确定终止是否由于 CLR 已关闭，请使用<ph id="ph1">&lt;xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>It returns <ph id="ph1">`true`</ph> if finalization is due to an application domain being unloaded or to the CLR shutting down.</source>
          <target state="translated">它将返回<ph id="ph1">`true`</ph>终止是否由于应用程序域正在卸载或者 CLR 正在关闭。</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>While executing in your finalization method during domain unloading, you might want to access another object that is referenced by a static field and has a finalization method.</source>
          <target state="translated">执行时终止方法中在域卸载过程，你可能想要访问另一个对象引用的静态字段，已终止方法。</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>However, you cannot reliably do so because the accessed object might already have been finalized.</source>
          <target state="translated">但是，不能可靠地这样做是因为访问的对象可能已终止。</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>An exception to this rule is the <ph id="ph1">&lt;xref:System.Console&gt;</ph> class, which contains static fields that reference stream objects, but is implemented specially so you can always write to the system console, even during domain unloading or system shutdown.</source>
          <target state="translated">此规则的唯一例外是<ph id="ph1">&lt;xref:System.Console&gt;</ph>类，该类包含引用流对象的静态字段，但比较特殊，以便你可以始终写入系统控制台中，即使在域卸载或系统关闭期间实现。</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>Use this method in an object's finalization method to determine whether the application domain that contains the object is unloading.</source>
          <target state="translated">在对象的完成方法使用此方法，以确定是否包含对象的应用程序域正在卸载。</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>If that is the case, you cannot reliably access any object that has a finalization method and is referenced by a static field.</source>
          <target state="translated">如果是这种情况，你无法可靠地访问任何对象，具有完成方法并由静态字段引用。</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="P:System.AppDomain.IsFullyTrusted">
          <source>Gets a value that indicates whether assemblies that are loaded into the current application domain execute with full trust.</source>
          <target state="translated">获取一个值，该值指示加载到当前应用程序域的程序集是否是以完全信任方式执行的。</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if assemblies that are loaded into the current application domain execute with full trust; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果加载到当前应用程序域的程序集是以完全信任方式执行的，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>This method always returns <ph id="ph1">`true`</ph> for the default application domain of an application that runs on the desktop.</source>
          <target state="translated">此方法始终返回<ph id="ph1">`true`</ph>在桌面上运行的应用程序的默认应用程序域。</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>It returns <ph id="ph1">`false`</ph> for a sandboxed application domain that was created by using the <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> method overload, unless the permissions that are granted to the application domain are equivalent to full trust.</source>
          <target state="translated">它将返回<ph id="ph1">`false`</ph>通过使用创建的沙盒应用程序域<ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph>方法重载，除非授予应用程序域的权限是等效于完全信任。</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.IsFullyTrusted%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> property with fully trusted and partially trusted application domains.</source>
          <target state="translated">下面的示例演示<ph id="ph1">&lt;xref:System.AppDomain.IsFullyTrusted%2A&gt;</ph>属性和<ph id="ph2">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>具有完全受信任和部分受信任的应用程序域属性。</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The fully trusted application domain is the default application domain for the application.</source>
          <target state="translated">完全受信任的应用程序域是应用程序的默认应用程序域。</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The partially trusted application domain is created by using the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">通过创建部分受信任的应用程序域<ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The example uses a <ph id="ph1">`Worker`</ph> class that derives from <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, so it can be marshaled across application domain boundaries.</source>
          <target state="translated">该示例使用<ph id="ph1">`Worker`</ph>派生自的类<ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>，因此它可以跨应用程序域边界进行封送。</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The example creates a <ph id="ph1">`Worker`</ph> object in the default application domain.</source>
          <target state="translated">该示例创建<ph id="ph1">`Worker`</ph>默认应用程序域中的对象。</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>It then calls the <ph id="ph1">`TestIsFullyTrusted`</ph> method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly.</source>
          <target state="translated">然后，它调用<ph id="ph1">`TestIsFullyTrusted`</ph>方法以显示应用程序域和程序加载到应用程序域的两个程序集的属性值： mscorlib 除外，它是.NET Framework 中，并将示例程序集的一部分。</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The application domain is fully trusted, so both assemblies are fully trusted.</source>
          <target state="translated">应用程序域是完全受信任的因此两个程序集是完全受信任。</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The example creates another <ph id="ph1">`Worker`</ph> object in a sandboxed application domain and again calls the <ph id="ph2">`TestIsFullyTrusted`</ph> method.</source>
          <target state="translated">此示例将创建另一个<ph id="ph1">`Worker`</ph>对象在沙盒应用程序域并再次调用<ph id="ph2">`TestIsFullyTrusted`</ph>方法。</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.</source>
          <target state="translated">Mscorlib 始终是受信任的即使在部分受信任的应用程序域中，但示例程序集是部分受信任。</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" uid="P:System.AppDomain.IsHomogenous">
          <source>Gets a value that indicates whether the current application domain has a set of permissions that is granted to all assemblies that are loaded into the application domain.</source>
          <target state="translated">获取一个值，该值指示当前应用程序域是否拥有一个为加载到该应用程序域的所有程序集授予的权限集。</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current application domain has a homogenous set of permissions; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果当前应用程序域具有一组同构权限，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则，为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source>This property returns <ph id="ph1">`true`</ph> for sandboxed application domains that were created by using the <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">此属性返回<ph id="ph1">`true`</ph>使用创建的沙盒应用程序域<ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source>Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</source>
          <target state="translated">沙盒应用程序域具有一组同构权限;也就是说，所有部分受信任的程序集加载到应用程序域授予相同的权限集。</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source>A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</source>
          <target state="translated">沙盒应用程序域 （可选） 有不受此权限集，并改为使用完全信任运行具有强名称程序集的列表。</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source>Fully trusted code can use the <ph id="ph1">&lt;xref:System.AppDomain.PermissionSet%2A&gt;</ph> property to determine the homogenous grant set of a sandboxed application domain.</source>
          <target state="translated">完全受信任的代码可以使用<ph id="ph1">&lt;xref:System.AppDomain.PermissionSet%2A&gt;</ph>属性来确定沙盒应用程序域的同构的授予集。</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source>This property also returns <ph id="ph1">`true`</ph> for the default application domain of a desktop application, because that application domain grants full trust to all assemblies.</source>
          <target state="translated">此属性也会返回<ph id="ph1">`true`</ph>默认应用程序域的桌面应用程序，因为该应用程序域的所有程序集授予完全信任。</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> into this application domain.</source>
          <target state="translated">将 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> 加载到此应用程序域中。</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="byte" /&gt;</ph> 类型的数组，它是包含已发出程序集的基于 COFF 的图像。</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>Loads the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> with a common object file format (COFF) based image containing an emitted <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</source>
          <target state="translated">加载带有基于通用对象文件格式 (COFF) 的图像的 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>，该图像包含已发出的 <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</source>
          <target state="translated">开头<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>，使用此方法加载程序集的信任级别是应用程序域的信任级别相同。</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">应使用此方法只是为了将程序集加载到当前的应用程序域。</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">为方便起见那些不能调用静态的互操作性调用方提供此方法是<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">若要将程序集加载到其他应用程序域中，使用一种方法如<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">普遍适用于此方法的所有重载的信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>The following sample demonstrates the use of loading a raw assembly.</source>
          <target state="translated">下面的示例演示如何使用原始程序集加载。</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">若要运行此代码示例，你必须提供完全限定程序集名称。</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">有关如何获取完全限定程序集名称的信息，请参阅<bpt id="p1">[</bpt>程序集名称<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 是用更高版本编译的。</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>An object that describes the assembly to load.</source>
          <target state="translated">描述要加载的程序集的对象。</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> given its <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</source>
          <target state="translated">在给定 <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> 的情况下加载 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">应使用此方法只是为了将程序集加载到当前的应用程序域。</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">为方便起见那些不能调用静态的互操作性调用方提供此方法是<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">若要将程序集加载到其他应用程序域中，使用一种方法如<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If a version of the requested assembly is already loaded, this method returns the loaded assembly, even if a different version is requested.</source>
          <target state="translated">如果已加载请求的程序集的版本，则此方法返回加载的程序集，即使请求的不同版本。</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>Supplying a partial assembly name for <ph id="ph1">`assemblyRef`</ph> is not recommended.</source>
          <target state="translated">提供的部分程序集名称<ph id="ph1">`assemblyRef`</ph>不建议。</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>(A partial name omits one or more of culture, version, or public key token.</source>
          <target state="translated">（一个或多个区域性、 版本或公钥标记，则会忽略部分名称。</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>For overloads that take a string instead of an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object, "MyAssembly, Version=1.0.0.0" is an example of a partial name and "MyAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=18ab3442da84b47" is an example of a full name.) Using partial names has a negative effect on performance.</source>
          <target state="translated">对于采用字符串而不是重载<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>对象，"MyAssembly，Version = 1.0.0.0"是一个示例部分的名称和"MyAssembly，Version = 1.0.0.0，Culture = neutral，PublicKeyToken = 18ab3442da84b47"举例说明的完整名称。)使用部分名称具有负面性能影响。</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>In addition, a partial assembly name can load an assembly from the global assembly cache only if there is an exact copy of the assembly in the application base directory (<ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">此外，部分程序集名称可以加载程序集从全局程序集缓存只有在应用程序基目录中的程序集的一个精确副本 (<ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If the current <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> object represents application domain <ph id="ph2">`A`</ph>, and the <ph id="ph3">&lt;xref:System.AppDomain.Load%2A&gt;</ph> method is called from application domain <ph id="ph4">`B`</ph>, the assembly is loaded into both application domains.</source>
          <target state="translated">如果当前<ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>对象表示应用程序域<ph id="ph2">`A`</ph>，和<ph id="ph3">&lt;xref:System.AppDomain.Load%2A&gt;</ph>方法从应用程序域调用<ph id="ph4">`B`</ph>，程序集将会加载到这两个应用程序域。</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>For example, the following code loads <ph id="ph1">`MyAssembly`</ph> into the new application domain <ph id="ph2">`ChildDomain`</ph> and also into the application domain where the code executes:</source>
          <target state="translated">例如，下面的代码加载<ph id="ph1">`MyAssembly`</ph>到新的应用程序域<ph id="ph2">`ChildDomain`</ph>和也到的应用程序域中执行的代码：</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>The assembly is loaded into both domains because <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> does not derive from <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, and therefore the return value of the <ph id="ph3">&lt;xref:System.AppDomain.Load%2A&gt;</ph> method cannot be marshaled.</source>
          <target state="translated">程序集加载到这两个域，因为<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>不是派生自<ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>，因此返回的值和<ph id="ph3">&lt;xref:System.AppDomain.Load%2A&gt;</ph>方法不能进行封送处理。</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>Instead, the common language runtime tries to load the assembly into the calling application domain.</source>
          <target state="translated">相反，公共语言运行时尝试加载到调用应用程序域的程序集。</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>The assemblies that are loaded into the two application domains might be different if the path settings for the two application domains are different.</source>
          <target state="translated">如果两个应用程序域的路径设置不同，到两个应用程序域加载的程序集可能有所不同。</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If both the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> property).</source>
          <target state="translated">如果这两个<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph>属性和<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph>属性设置，在首次尝试加载程序集使用的显示名称 (包括版本、 区域性和等等，返回为<ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph>属性)。</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If the file is not found, the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> property is used to search for the assembly.</source>
          <target state="translated">如果未找到该文件，<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>属性用于搜索程序集。</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If the assembly is found using <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>, the display name is matched against the assembly.</source>
          <target state="translated">如果使用找到的程序集<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>，与程序集匹配的显示名称。</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If the match fails, a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown.</source>
          <target state="translated">如果匹配失败，<ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 是用更高版本编译的。</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> given its display name.</source>
          <target state="translated">在给定其显示名称的情况下加载 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">应使用此方法只是为了将程序集加载到当前的应用程序域。</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">为方便起见那些不能调用静态的互操作性调用方提供此方法是<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">若要将程序集加载到其他应用程序域中，使用一种方法如<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">普遍适用于此方法的所有重载的信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 是用更高版本编译的。</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">访问程序集的位置，如果程序集不是本地的功能。</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="byte" /&gt;</ph> 类型的数组，它是包含已发出程序集的基于 COFF 的图像。</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> containing the raw bytes representing the symbols for the assembly.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="byte" /&gt;</ph> 类型的数组，它包含表示程序集符号的原始字节。</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>Loads the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> with a common object file format (COFF) based image containing an emitted <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</source>
          <target state="translated">加载带有基于通用对象文件格式 (COFF) 的图像的 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>，该图像包含已发出的 <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>The raw bytes representing the symbols for the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> are also loaded.</source>
          <target state="translated">还加载表示 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> 的符号的原始字节。</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</source>
          <target state="translated">开头<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>，使用此方法加载程序集的信任级别是应用程序域的信任级别相同。</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">应使用此方法只是为了将程序集加载到当前的应用程序域。</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">为方便起见那些不能调用静态的互操作性调用方提供此方法是<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">若要将程序集加载到其他应用程序域中，使用一种方法如<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">普遍适用于此方法的所有重载的信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>The following sample demonstrates the use of loading a raw assembly.</source>
          <target state="translated">下面的示例演示如何使用原始程序集加载。</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">若要运行此代码示例，你必须提供完全限定程序集名称。</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">有关如何获取完全限定程序集名称的信息，请参阅<bpt id="p1">[</bpt>程序集名称<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 是用更高版本编译的。</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">用于读取一个 URI，不以"file://"开头。</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>An object that describes the assembly to load.</source>
          <target state="translated">描述要加载的程序集的对象。</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">用于加载程序集的证据。</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> given its <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</source>
          <target state="translated">在给定 <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> 的情况下加载 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">应使用此方法只是为了将程序集加载到当前的应用程序域。</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">为方便起见那些不能调用静态的互操作性调用方提供此方法是<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">若要将程序集加载到其他应用程序域中，使用一种方法如<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">普遍适用于此方法的所有重载的信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 是用更高版本编译的。</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>for reading a path that is not in the form "file://" or "<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>" or "c:<ph id="ph3">\\</ph>".</source>
          <target state="translated">用于读取的路径，不在窗体"file://"或"<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>"或"c:<ph id="ph3">\\</ph>"。</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">用于加载程序集的证据。</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> given its display name.</source>
          <target state="translated">在给定其显示名称的情况下加载 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">应使用此方法只是为了将程序集加载到当前的应用程序域。</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">为方便起见那些不能调用静态的互操作性调用方提供此方法是<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">若要将程序集加载到其他应用程序域中，使用一种方法如<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">普遍适用于此方法的所有重载的信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 是用更高版本编译的。</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>for reading a path that is not in the form "file://" or "<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>" or "c:<ph id="ph3">\\</ph>".</source>
          <target state="translated">用于读取的路径，不在窗体"file://"或"<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>"或"c:<ph id="ph3">\\</ph>"。</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>An array of type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="byte" /&gt;</ph> 类型的数组，它是包含已发出程序集的基于 COFF 的图像。</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>An array of type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> containing the raw bytes representing the symbols for the assembly.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="byte" /&gt;</ph> 类型的数组，它包含表示程序集符号的原始字节。</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">用于加载程序集的证据。</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Loads the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> with a common object file format (COFF) based image containing an emitted <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</source>
          <target state="translated">加载带有基于通用对象文件格式 (COFF) 的图像的 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>，该图像包含已发出的 <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The raw bytes representing the symbols for the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> are also loaded.</source>
          <target state="translated">还加载表示 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> 的符号的原始字节。</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</source>
          <target state="translated">开头<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>，使用此方法加载程序集的信任级别是应用程序域的信任级别相同。</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">应使用此方法只是为了将程序集加载到当前的应用程序域。</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">为方便起见那些不能调用静态的互操作性调用方提供此方法是<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">若要将程序集加载到其他应用程序域中，使用一种方法如<ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">普遍适用于此方法的所有重载的信息，请参阅<ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The following sample demonstrates the use of loading a raw assembly.</source>
          <target state="translated">下面的示例演示如何使用原始程序集加载。</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">若要运行此代码示例，你必须提供完全限定程序集名称。</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">有关如何获取完全限定程序集名称的信息，请参阅<bpt id="p1">[</bpt>程序集名称<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 是用更高版本编译的。</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">未启用旧版 CAS 策略时，<ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> 应为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>to provide evidence.</source>
          <target state="translated">若要提供的证据。</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">安全操作： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>for reading a path that is not in the form "file://" or "<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>" or "c:<ph id="ph3">\\</ph>".</source>
          <target state="translated">用于读取的路径，不在窗体"file://"或"<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>"或"c:<ph id="ph3">\\</ph>"。</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>Gets or sets a value that indicates whether CPU and memory monitoring of application domains is enabled for the current process.</source>
          <target state="translated">获取或设置一个值，该值指示是否对当前进程启用应用程序域的 CPU 和内存监视。</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>Once monitoring is enabled for a process, it cannot be disabled.</source>
          <target state="translated">一旦对进程启用了监视，则无法将其禁用。</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if monitoring is enabled; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果启用监视，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>This <ph id="ph1">`static`</ph> property (<ph id="ph2">`Shared`</ph> property in Visual Basic) controls CPU and memory monitoring of all the application domains in the process.</source>
          <target state="translated">这<ph id="ph1">`static`</ph>属性 (<ph id="ph2">`Shared`</ph>属性在 Visual Basic) 控制 CPU 和内存监视的进程中的所有应用程序域。</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>If you attempt to set this property to <ph id="ph1">`false`</ph>, a <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> exception is thrown, even if the current value of the property is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">如果你尝试将此属性设置为<ph id="ph1">`false`</ph>、<ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>引发异常，即使该属性的当前值是<ph id="ph3">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>Once monitoring is enabled, you can use the <ph id="ph1">&lt;xref:System.AppDomain.MonitoringSurvivedMemorySize%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.AppDomain.MonitoringTotalProcessorTime%2A&gt;</ph> instance properties to monitor CPU and memory use of individual application domains.</source>
          <target state="translated">一旦启用了监视，则可以使用<ph id="ph1">&lt;xref:System.AppDomain.MonitoringSurvivedMemorySize%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.AppDomain.MonitoringTotalProcessorTime%2A&gt;</ph>实例监视 CPU 和内存使用情况的各个应用程序域的属性。</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>The current process attempted to assign the value <ph id="ph1">&lt;see langword="false" /&gt;</ph> to this property.</source>
          <target state="translated">当前进程尝试将值 <ph id="ph1">&lt;see langword="false" /&gt;</ph> 分配给该属性。</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>Gets the number of bytes that survived the last collection and that are known to be referenced by the current application domain.</source>
          <target state="translated">获取上次回收后保留下来的，已知由当前应用程序域引用的字节数。</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>The number of surviving bytes.</source>
          <target state="translated">保留下来的字节数。</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>The statistics are updated with each garbage collection.</source>
          <target state="translated">与每个垃圾回收更新统计信息。</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>However, they are guaranteed to be accurate only after a full, blocking collection; that is, a collection that includes all generations and that stops the application while collection occurs.</source>
          <target state="translated">但是，可确保只有在完整、 阻碍性回收; 后才会准确也就是说，的集合包含所有代并停止应用程序时集合时发生。</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>For example, the <ph id="ph1">&lt;xref:System.GC.Collect?displayProperty=nameWithType&gt;</ph> method overload performs a full, blocking collection.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.GC.Collect?displayProperty=nameWithType&gt;</ph>方法重载执行的完整、 阻碍性回收。</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>(Concurrent collection occurs in the background and does not block the application.)</source>
          <target state="translated">（并发回收发生在后台，并且不会阻止应用程序。）</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>The <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> property is set to <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="static" /&gt;</ph>（在 Visual Basic 中为 <ph id="ph2">&lt;see langword="Shared" /&gt;</ph>）<ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> 属性设置为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>Gets the total bytes that survived from the last collection for all application domains in the process.</source>
          <target state="translated">获取进程中所有应用程序域的上次回收后保留下来的总字节数。</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>The total number of surviving bytes for the process.</source>
          <target state="translated">进程的保留下来的总字节数。</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>After a full, blocking collection, this number represents the number of bytes currently held live on managed heaps.</source>
          <target state="translated">完整的阻碍性回收之后，字节数当前实时上保留该数字表示托管堆。</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>It should be close to the number reported by the <ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph> method.</source>
          <target state="translated">它应接近其报告的使用期限<ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>After an ephemeral collection, this number represents the number of bytes currently held live in ephemeral generations.</source>
          <target state="translated">暂时回收之后，该数字表示的字节数当前中实时保留暂时代。</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>The <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> property is set to <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="static" /&gt;</ph>（在 Visual Basic 中为 <ph id="ph2">&lt;see langword="Shared" /&gt;</ph>）<ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> 属性设置为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringTotalAllocatedMemorySize">
          <source>Gets the total size, in bytes, of all memory allocations that have been made by the application domain since it was created, without subtracting memory that has been collected.</source>
          <target state="translated">获取自从创建应用程序域后由应用程序域进行的所有内存分配的总大小（以字节为单位，不扣除已回收的内存）。</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalAllocatedMemorySize">
          <source>The total size of all memory allocations.</source>
          <target state="translated">所有内存分配的总大小。</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringTotalAllocatedMemorySize">
          <source>The <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> property is set to <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="static" /&gt;</ph>（在 Visual Basic 中为 <ph id="ph2">&lt;see langword="Shared" /&gt;</ph>）<ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> 属性设置为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalAllocatedMemorySize">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalAllocatedMemorySize">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>Gets the total processor time that has been used by all threads while executing in the current application domain, since the process started.</source>
          <target state="translated">获取自从进程启动后所有线程在当前应用程序域中执行时所使用的总处理器时间。</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>Total processor time for the current application domain.</source>
          <target state="translated">当前应用程序域的总处理器时间。</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>The total time that is reported for an application domain includes the time each thread in the process spent executing in that application domain.</source>
          <target state="translated">应用程序域报告的总时间包括在该应用程序域中执行的过程中的每个线程所用的时间。</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>A thread that calls into unmanaged code is still associated with an application domain, and the processor time spent executing the unmanaged code is reported for the application domain where the call was made.</source>
          <target state="translated">调入非托管代码的线程仍关联与应用程序域，并且执行非托管的代码报告应用程序域调用已花费的处理器时间。</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>When a thread is blocked or sleeping, it does not consume processor time.</source>
          <target state="translated">当线程被阻止或睡眠，它不占用处理器时间。</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>The <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> property is set to <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="static" /&gt;</ph>（在 Visual Basic 中为 <ph id="ph2">&lt;see langword="Shared" /&gt;</ph>）<ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> 属性设置为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" uid="P:System.AppDomain.PermissionSet">
          <source>Gets the permission set of a sandboxed application domain.</source>
          <target state="translated">获取沙盒应用程序域的权限集。</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.PermissionSet">
          <source>The permission set of the sandboxed application domain.</source>
          <target state="translated">沙盒应用程序域的权限集。</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.PermissionSet">
          <source>Sandboxed application domains that were created by using the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> method overload have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</source>
          <target state="translated">使用创建的沙盒应用程序域<ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph>方法重载具有一组同构权限; 也就是说，对所有部分受信任的程序集加载到应用程序域授予相同的权限集。</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.PermissionSet">
          <source>A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</source>
          <target state="translated">沙盒应用程序域 （可选） 有不受此权限集，并改为使用完全信任运行具有强名称程序集的列表。</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.PermissionSet">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.PermissionSet">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" uid="E:System.AppDomain.ProcessExit">
          <source>Occurs when the default application domain's parent process exits.</source>
          <target state="translated">当默认应用程序域的父进程存在时发生。</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>The <ph id="ph1">&lt;xref:System.EventHandler&gt;</ph> for this event can perform termination activities, such as closing files, releasing storage and so on, before the process ends.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.EventHandler&gt;</ph>此事件可以执行终止活动，如关闭文件，释放存储空间等，进程结束之前。</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>Beginning with the .NET Framework version 2.0, this event is raised in each application domain that registers an event handler.</source>
          <target state="translated">从.NET Framework 2.0 版开始，每个应用程序域中注册事件处理程序中引发此事件。</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>The total execution time of all <ph id="ph1">&lt;xref:System.AppDomain.ProcessExit&gt;</ph> event handlers is limited, just as the total execution time of all finalizers is limited at process shutdown.</source>
          <target state="translated">总执行时间的所有<ph id="ph1">&lt;xref:System.AppDomain.ProcessExit&gt;</ph>事件处理程序是有限的正如所有终结器的总执行时间是有限进程关闭时一样。</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>The default is two seconds.</source>
          <target state="translated">默认值为两秒。</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>An unmanaged host can change this execution time by calling the <bpt id="p1">[</bpt>ICLRPolicyManager::SetTimeout<ept id="p1">](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md)</ept> method with the <bpt id="p2">[</bpt>OPR_ProcessExit<ept id="p2">](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md)</ept> enumeration value.</source>
          <target state="translated">非托管的主机可以通过调用来更改此执行时间<bpt id="p1">[</bpt>iclrpolicymanager:: Settimeout<ept id="p1">](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md)</ept>方法替换<bpt id="p2">[</bpt>OPR_ProcessExit<ept id="p2">](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md)</ept>枚举值。</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>In the .NET Framework versions 1.0 and 1.1, this event is raised only in the default application domain, and only if an event handler is registered in the default application domain.</source>
          <target state="translated">在.NET framework 1.0 和 1.1 版中，此事件是引发仅在默认应用程序域，且仅当在默认应用程序域中注册事件处理程序。</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>To register an event handler for this event, you must have the required permissions, or a <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown.</source>
          <target state="translated">若要注册的事件处理程序此事件，你必须具有所需的权限，或<ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">有关处理事件的详细信息，请参阅<bpt id="p1">[</bpt>处理和引发事件<ept id="p1">](~/docs/standard/events/index.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>Occurs when the resolution of an assembly fails in the reflection-only context.</source>
          <target state="translated">当程序集的解析在仅限反射的上下文中失败时发生。</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>In the reflection-only context, dependencies are not resolved automatically.</source>
          <target state="translated">在仅限反射上下文中，依赖关系将不自动解析。</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>They must be preloaded or returned by the handler for this event.</source>
          <target state="translated">它们必须预加载或返回的此事件的处理程序。</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>This event is raised when an assembly has a dependency that is not already loaded into the reflection-only context.</source>
          <target state="translated">当程序集具有尚未加载到只反射上下文的依赖项时，引发此事件。</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>The missing dependency is specified by the <ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">通过指定缺少的依赖关系<ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>The <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> for this event must return an assembly that satisfies the dependency.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph>此事件必须返回满足此依赖关系的程序集。</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>The assembly that is returned must be loaded into the reflection-only context.</source>
          <target state="translated">返回程序集必须加载到只反射上下文。</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>This event is raised only for missing dependencies of the assembly that you are loading into the reflection-only context (for example, by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType&gt;</ph> method).</source>
          <target state="translated">仅为缺少的依赖关系，若要加载到只反射上下文的程序集将引发此事件 (例如，通过使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType&gt;</ph>方法)。</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>It is not raised if the assembly that you are loading cannot be found.</source>
          <target state="translated">它不被引发如果找不到要加载的程序集。</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> property returns the assembly that requested the assembly load that could not be resolved.</source>
          <target state="translated">开头<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>、<ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>属性返回的请求无法解析的程序集加载的程序集。</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>Knowing the identity of the requesting assembly might be useful in identifying the correct version of the dependency, if more than one version is available.</source>
          <target state="translated">了解请求的程序集的标识可能很有用中标识正确版本的依赖项，如果多个版本可用。</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>For more information, see <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">有关详情，请参阅<ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>For this event, the <ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> property returns the assembly name before policy is applied.</source>
          <target state="translated">对于此事件，<ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph>应用策略之前，属性将返回的程序集名称。</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">有关处理事件的详细信息，请参阅<bpt id="p1">[</bpt>处理和引发事件<ept id="p1">](~/docs/standard/events/index.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>Returns the assemblies that have been loaded into the reflection-only context of the application domain.</source>
          <target state="translated">返回已加载到应用程序域的只反射上下文中的程序集。</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> objects that represent the assemblies loaded into the reflection-only context of the application domain.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> 对象数组，表示加载到应用程序域的只反射上下文中的程序集。</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>This method returns the assemblies that have been loaded into the reflection-only context.</source>
          <target state="translated">此方法返回已加载到只反射上下文的程序集。</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>To get the assemblies that have been loaded for execution, use the <ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> method.</source>
          <target state="translated">若要获取有关执行的已加载的程序集，请使用<ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>The following code example loads the System.dll assembly into the execution context and then into the reflection-only context.</source>
          <target state="translated">下面的代码示例加载 System.dll 程序集插入的执行上下文，然后再到只反射上下文。</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A&gt;</ph> methods are used to display the assemblies loaded into each context.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A&gt;</ph>方法用于显示加载到每个上下文的程序集。</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>An operation is attempted on an unloaded application domain.</source>
          <target state="translated">尝试对已卸载的应用程序域进行操作。</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" uid="P:System.AppDomain.RelativeSearchPath">
          <source>Gets the path under the base directory where the assembly resolver should probe for private assemblies.</source>
          <target state="translated">获取基目录下的路径，在此程序集冲突解决程序应探测专用程序集。</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>The path under the base directory where the assembly resolver should probe for private assemblies.</source>
          <target state="translated">基目录下的路径，在此程序集冲突解决程序应探测专用程序集。</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>Private assemblies are deployed in the same directory structure as the application.</source>
          <target state="translated">专用程序集部署在与应用程序相同的目录结构中。</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>If the path specified by the <ph id="ph1">&lt;xref:System.AppDomain.RelativeSearchPath%2A&gt;</ph> property is not under <ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph>, it is ignored.</source>
          <target state="translated">如果指定了路径<ph id="ph1">&lt;xref:System.AppDomain.RelativeSearchPath%2A&gt;</ph>属性不是下<ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph>，它将被忽略。</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>This property returns the value set using <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">此属性返回的值设置使用<ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" uid="P:System.AppDomain.RelativeSearchPath">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>for access to the path information.</source>
          <target state="translated">用于访问的路径信息。</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" uid="E:System.AppDomain.ResourceResolve">
          <source>Occurs when the resolution of a resource fails because the resource is not a valid linked or embedded resource in the assembly.</source>
          <target state="translated">当资源解析因资源不是程序集中的有效链接资源或嵌入资源而失败时发生。</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>The <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> for this event can attempt to locate the assembly containing the resource and return it.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph>为此事件可以尝试查找包含该资源的程序集并将其返回。</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>This event is not raised if resolution fails because no file can be found for a valid linked resource.</source>
          <target state="translated">如果解析失败，因为没有文件可以找到有效链接资源，不被引发此事件。</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>It is raised if a manifest resource stream cannot be found, but it is not raised if an individual resource key cannot be found.</source>
          <target state="translated">如果找不到的清单资源流，但它不会引发如果找不到单独的资源键，则将引发此事件。</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> property contains the assembly that requested the resource.</source>
          <target state="translated">开头<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>、<ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>属性包含请求资源的程序集。</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>For more information, see <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">有关详情，请参阅<ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>To register an event handler for this event, you must have the required permissions, or a <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown.</source>
          <target state="translated">若要注册的事件处理程序此事件，你必须具有所需的权限，或<ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">有关处理事件的详细信息，请参阅<bpt id="p1">[</bpt>处理和引发事件<ept id="p1">](~/docs/standard/events/index.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>The security policy level.</source>
          <target state="translated">安全策略级别。</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>Establishes the security policy level for this application domain.</source>
          <target state="translated">为此应用程序域确定安全策略级别。</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>Call this method before an assembly is loaded into the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> in order for the security policy to have effect.</source>
          <target state="translated">程序集加载到之前调用此方法<ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>顺序安全策略以产生影响。</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.AppDomain.SetAppDomainPolicy%2A&gt;</ph> method to set the security policy level of an application domain.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.AppDomain.SetAppDomainPolicy%2A&gt;</ph>方法以设置安全策略级别的应用程序域。</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source><ph id="ph1">&lt;paramref name="domainPolicy" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="domainPolicy" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>The security policy level has already been set.</source>
          <target state="translated">已经设置了安全策略级别。</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>The fully qualified path to the shadow copy location.</source>
          <target state="translated">到卷影副本位置的完全限定路径。</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>Establishes the specified directory path as the location where assemblies are shadow copied.</source>
          <target state="translated">确定指定目录路径为对程序集进行影像复制的位置。</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>The cache path is ignored if the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A&gt;</ph> property is not set.</source>
          <target state="translated">如果缓存路径将被忽略<ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A&gt;</ph>未设置属性。</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>See the <ph id="ph1">&lt;xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>For more information on shadow copying see <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">卷影复制的详细信息请参阅<bpt id="p1">[</bpt>影像复制程序集<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Assigns a value to an application domain property.</source>
          <target state="translated">为应用程序域属性分配值。</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The name of a user-defined application domain property to create or change.</source>
          <target state="translated">要创建或更改的用户定义应用程序域属性的名称。</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The value of the property.</source>
          <target state="translated">该属性的值。</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>Assigns the specified value to the specified application domain property.</source>
          <target state="translated">为指定的应用程序域属性分配指定值。</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>Use this method to insert an entry, or modify the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>.</source>
          <target state="translated">使用此方法来插入项时，或者修改描述的此实例的属性的名称数据对内部缓存中的条目的值<ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The cache automatically contains predefined system entries that are inserted when the application domain is created.</source>
          <target state="translated">该缓存自动包含在创建应用程序域后插入的预定义的系统项。</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>You cannot insert or modify system entries with this method.</source>
          <target state="translated">无法插入或修改系统项使用此方法。</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</source>
          <target state="translated">尝试来修改系统条目的方法调用起任何作用;该方法不引发异常。</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>You can inspect the values of system entries with the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method, or the equivalent <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> properties described in <ph id="ph3">&lt;xref:System.AppDomain.GetData%2A&gt;</ph>.</source>
          <target state="translated">你可以检查与系统项的值<ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph>方法或等效<ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph>属性中所述<ph id="ph3">&lt;xref:System.AppDomain.GetData%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>You can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the <ph id="ph1">`name`</ph> argument and a <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> value that represents the timeout interval as the value of the <ph id="ph3">`data`</ph> argument.</source>
          <target state="translated">你可以调用此方法以设置由供电"REGEX_DEFAULT_MATCH_TIMEOUT"评估正则表达式模式的默认超时间隔的值的值作为<ph id="ph1">`name`</ph>自变量和一个<ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph>表示超时值时间间隔数值类型的值<ph id="ph3">`data`</ph>自变量。</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>You can also insert or modify your own user defined name-data pairs with this method and inspect their values with the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method.</source>
          <target state="translated">此外可以插入或修改你自己的用户定义名称数据对使用此方法，并检查它们的值与<ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29&gt;</ph> method to create a new value pair.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29&gt;</ph>方法来创建新的值对。</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The example then uses the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method to retrieve the value, and displays it to the console.</source>
          <target state="translated">然后该示例使用<ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph>方法来检索值，并将其显示到控制台。</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>The name of a user-defined application domain property to create or change.</source>
          <target state="translated">要创建或更改的用户定义应用程序域属性的名称。</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>The value of the property.</source>
          <target state="translated">该属性的值。</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>The permission to demand of the caller when the property is retrieved.</source>
          <target state="translated">检索属性时调用方需要具有的权限。</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>Assigns the specified value to the specified application domain property, with a specified permission to demand of the caller when the property is retrieved.</source>
          <target state="translated">将指定值分配给指定应用程序域属性，检索该属性时要求调用方具有指定权限。</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>Use this method to insert or modify your own user-defined entries in an internal cache of name/data pairs that describe properties of the application domain.</source>
          <target state="translated">此方法用于插入或修改你自己描述应用程序域的属性的名称/数据对的内部缓存中的用户定义条目。</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>When you insert an entry, you can specify a permission demand to enforce when the entry is retrieved.In addition, you can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the <ph id="ph1">`name`</ph> argument and a <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> value that represents the timeout interval as the value of the <ph id="ph3">`data`</ph> argument.</source>
          <target state="translated">当将一个条目时，你可以指定权限请求来强制执行时检索条目。此外，可以调用此方法以设置由供电"REGEX_DEFAULT_MATCH_TIMEOUT"评估正则表达式模式的默认超时间隔的值的值作为<ph id="ph1">`name`</ph>自变量和一个<ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph>值，该值表示超时时间间隔，数值类型的值<ph id="ph3">`data`</ph>自变量。</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>You cannot use this method to assign a security demand to a system-defined property string.</source>
          <target state="translated">此方法不能用于将安全要求分配给系统定义的属性字符串。</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>The cache automatically contains predefined system entries that are inserted when the application domain is created.</source>
          <target state="translated">该缓存自动包含在创建应用程序域后插入的预定义的系统项。</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>You cannot insert or modify system entries with this method.</source>
          <target state="translated">无法插入或修改系统项使用此方法。</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</source>
          <target state="translated">尝试来修改系统条目的方法调用起任何作用;该方法不引发异常。</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>You can inspect the values of system entries with the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method or the equivalent <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> properties described in the Remarks section for the <ph id="ph3">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method.</source>
          <target state="translated">你可以检查与系统项的值<ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph>方法或等效<ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph>属性中的备注部分所述<ph id="ph3">&lt;xref:System.AppDomain.GetData%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> specifies a system-defined property string and <ph id="ph2">&lt;paramref name="permission" /&gt;</ph> is not <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 指定系统定义的属性字符串，并且 <ph id="ph2">&lt;paramref name="permission" /&gt;</ph> 不为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>The fully qualified path that is the base directory for subdirectories where dynamic assemblies are stored.</source>
          <target state="translated">完全限定路径，是存储动态程序集的子目录的基目录。</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>Establishes the specified directory path as the base directory for subdirectories where dynamically generated files are stored and accessed.</source>
          <target state="translated">建立指定的目录路径，作为存储和访问动态生成的文件的子目录的基目录。</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>This method sets the <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph> property of the internal <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> associated with this instance.</source>
          <target state="translated">此方法会设置<ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph>内部属性<ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph>与此实例关联。</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>This method is now obsolete, and should not be used for new development.</source>
          <target state="translated">此方法现已过时，并不应使用新的开发。</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>The following example shows how to use the non-obsolete alternative, the <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">下面的示例演示如何使用非过时的替代项，<ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>For an explanation of this example, see the <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph> property or the <ph id="ph2">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph> property.</source>
          <target state="translated">此示例的说明，请参阅<ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph>属性或<ph id="ph2">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Security.Principal.PrincipalPolicy" /&gt;</ph> values that specifies the type of the principal object to attach to threads.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Principal.PrincipalPolicy" /&gt;</ph> 值之一，指定要附加到线程的主体对象类型。</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>Specifies how principal and identity objects should be attached to a thread if the thread attempts to bind to a principal while executing in this application domain.</source>
          <target state="translated">指定在此应用程序域中执行时如果线程尝试绑定到用户，用户和标识对象应如何附加到该线程。</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>Setting this value will only be effective if you set it before using the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">设置此值才有效，如果你在使用前设置<ph id="ph1">&lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>For example, if you set <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType&gt;</ph> to a given principal (for example, a generic principal) and then use the <ph id="ph2">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph> method to set the <ph id="ph3">&lt;xref:System.Security.Principal.PrincipalPolicy&gt;</ph> to <ph id="ph4">&lt;xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal&gt;</ph>, the current principal will remain the generic principal.</source>
          <target state="translated">例如，如果你设置<ph id="ph1">&lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType&gt;</ph>到给定的主体 （例如，泛型主体），然后使用<ph id="ph2">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph>方法以设置<ph id="ph3">&lt;xref:System.Security.Principal.PrincipalPolicy&gt;</ph>到<ph id="ph4">&lt;xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal&gt;</ph>，当前主体将保持泛型主体。</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>The following example shows the effect on threads of using the <ph id="ph1">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph> method to change the principal policy of the application domain.</source>
          <target state="translated">下面的示例演示使用的线程的影响<ph id="ph1">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph>方法更改应用程序域的主体策略。</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>It also shows the effect of using the <ph id="ph1">&lt;xref:System.AppDomain.SetThreadPrincipal%2A&gt;</ph> method to change the principal that is available for attaching to threads in the application domain.</source>
          <target state="translated">它还显示使用的效果<ph id="ph1">&lt;xref:System.AppDomain.SetThreadPrincipal%2A&gt;</ph>方法可以更改可用于附加到应用程序域中的线程的主体。</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>for ability to manipulate the principal object.</source>
          <target state="translated">有关操作的主体对象的能力。</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">安全操作： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>Turns on shadow copying.</source>
          <target state="translated">打开影像复制功能。</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>For more information on shadow copying, see <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">卷影复制的详细信息，请参阅<bpt id="p1">[</bpt>影像复制程序集<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>This method is now obsolete, and should not be used for new development.</source>
          <target state="translated">此方法现已过时，并不应使用新的开发。</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>A list of directory names, where each name is separated by a semicolon.</source>
          <target state="translated">目录名列表，各名称用分号隔开。</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>Establishes the specified directory path as the location of assemblies to be shadow copied.</source>
          <target state="translated">确定指定目录路径为要进行影像复制的程序集的位置。</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>By default, a shadow copy includes all assemblies found through probing.</source>
          <target state="translated">默认情况下，卷影副本包括通过探测所发现的所有程序集。</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph> method restricts the shadow copy to the assemblies in the directories specified by <ph id="ph2">`path`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph>方法将卷影副本限制到指定的目录中的程序集<ph id="ph2">`path`</ph>。</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph> method does not specify additional directories to be searched for assemblies.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph>方法并不指定要在其中搜索程序集的其他目录。</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>Assemblies to be shadow-copied must already be located in the search path, for example under <ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph>.</source>
          <target state="translated">要进行影像复制程序集必须已位于的搜索路径，例如下<ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph> method specifies which search paths are eligible to be shadow-copied.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph>方法指定的搜索路径有资格卷影复制。</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>This method sets the <ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyDirectories%2A&gt;</ph> property of the internal <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> associated with this instance.</source>
          <target state="translated">此方法会设置<ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyDirectories%2A&gt;</ph>内部属性<ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph>与此实例关联。</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>For more information on shadow copying, see <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">卷影复制的详细信息，请参阅<bpt id="p1">[</bpt>影像复制程序集<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>This method is now obsolete, and should not be used for new development.</source>
          <target state="translated">此方法现已过时，并不应使用新的开发。</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>The principal object to attach to threads.</source>
          <target state="translated">要附加到线程的主体对象。</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>Sets the default principal object to be attached to threads if they attempt to bind to a principal while executing in this application domain.</source>
          <target state="translated">设置在以下情况下要附加到线程的默认主体对象，即当线程在此应用程序域中执行时，如果线程尝试绑定到主体这种情况。</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>The following example shows the effect of using the <ph id="ph1">&lt;xref:System.AppDomain.SetThreadPrincipal%2A&gt;</ph> method to change the principal that is available for attaching to threads that are executing in the application domain.</source>
          <target state="translated">下面的示例演示使用的效果<ph id="ph1">&lt;xref:System.AppDomain.SetThreadPrincipal%2A&gt;</ph>方法可以更改可用于附加到应用程序域中执行的线程的主体。</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>It also shows the effect on threads of using the <ph id="ph1">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph> method to change the principal policy of the application domain.</source>
          <target state="translated">它还演示了使用的线程的影响<ph id="ph1">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph>方法更改应用程序域的主体策略。</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source><ph id="ph1">&lt;paramref name="principal" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="principal" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>The thread principal has already been set.</source>
          <target state="translated">已经设置了线程用户。</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>for ability to manipulate the principal object.</source>
          <target state="translated">有关操作的主体对象的能力。</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">安全操作： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" uid="P:System.AppDomain.SetupInformation">
          <source>Gets the application domain configuration information for this instance.</source>
          <target state="translated">获取此实例的应用程序域配置信息。</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.SetupInformation">
          <source>The application domain initialization information.</source>
          <target state="translated">应用程序域初始化信息。</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" uid="P:System.AppDomain.SetupInformation">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" uid="P:System.AppDomain.ShadowCopyFiles">
          <source>Gets an indication whether the application domain is configured to shadow copy files.</source>
          <target state="translated">获取应用程序域是否配置为影像副本文件的指示。</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ShadowCopyFiles">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the application domain is configured to shadow copy files; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果应用程序域配置为卷影副本文件，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ShadowCopyFiles">
          <source>For more information, see <ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType&gt;</ph> and <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType&gt;</ph>和<bpt id="p1">[</bpt>影像复制程序集<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" uid="P:System.AppDomain.ShadowCopyFiles">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">在卸载的应用程序域上尝试该操作。</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">留待将来使用。</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">必须为 IID_NULL。</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">要映射的名称的传入数组。</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">要映射的名称的计数。</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">要在其中解释名称的区域设置上下文。</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">调用方分配的数组，用于接收与名称对应的 ID。</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">将一组名称映射为对应的一组调度标识符。</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::GetIDsOfNames`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">要返回的类型信息。</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">类型信息的区域设置标识符。</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">接收一个指针，指向请求的类型信息对象。</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::GetTypeInfo`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">指向一个位置，该位置接收对象提供的类型信息接口的数量。</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">检索对象提供的类型信息接口的数量（0 或 1）。</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">标识成员。</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">留待将来使用。</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">必须为 IID_NULL。</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">要在其中解释参数的区域设置上下文。</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">描述调用的上下文的标志。</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">指向一个结构的指针，该结构包含一个自变量数组、一个命名自变量的 DISPID 自变量数组和数组中元素数的计数。</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">指向要存储结果的位置的指针。</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">指向一个包含异常信息的结构的指针。</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">第一个出错自变量的索引。</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">提供对某一对象公开的属性和方法的访问。</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::Invoke`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ToString">
          <source>Obtains a string representation that includes the friendly name of the application domain and any context policies.</source>
          <target state="translated">获取一个字符串表示，包含应用程序域友好名称和任意上下文策略。</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ToString">
          <source>A string formed by concatenating the literal string "Name:", the friendly name of the application domain, and either string representations of the context policies or the string "There are no context policies."</source>
          <target state="translated">一个字符串，通过连接字符串“Name:”、应用程序域的友好名称以及上下文策略的字符串表示或字符串“There are no context policies”而成。</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ToString">
          <source>The following code example displays the return value of the <ph id="ph1">&lt;xref:System.AppDomain.ToString%2A&gt;</ph> method.</source>
          <target state="translated">下面的代码示例显示的返回值<ph id="ph1">&lt;xref:System.AppDomain.ToString%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ToString">
          <source>The application domain represented by the current <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> has been unloaded.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> 表示的应用程序域已卸载。</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" uid="E:System.AppDomain.TypeResolve">
          <source>Occurs when the resolution of a type fails.</source>
          <target state="translated">在对类型的解析失败时发生。</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> event occurs when the common language runtime is unable to determine the assembly that can create the requested type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph>事件发生时公共语言运行时无法确定可以创建请求的类型的程序集。</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>This can occur if the type is defined in a dynamic assembly, or the type is not defined in a dynamic assembly but the runtime does not know which assembly the type is defined in.</source>
          <target state="translated">如果在动态程序集，定义的类型或类型未定义动态程序集中，但运行时不知道程序集类型中定义的类型便会出现此问题。</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>The latter situation can occur when <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> is called with a type name that is not qualified with the assembly name.</source>
          <target state="translated">后一种情况可能发生时<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>调用时使用程序集名称未限定的类型名称。</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>The <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> for this event can attempt to locate and create the type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph>为此事件可以尝试查找并创建类型。</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>However, the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> event does not occur if the runtime knows it is not possible to find a type in certain assemblies.</source>
          <target state="translated">但是，<ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph>事件不会发生如果运行时知道不能以查找特定的程序集中的类型。</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>For example, this event does not occur if the type is not found in a static assembly because the runtime knows types cannot be added dynamically to static assemblies.</source>
          <target state="translated">例如，如果因为运行时知道类型不能动态添加到静态程序集不在静态程序集中找到了类型，也不会发生此事件。</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> property contains the assembly that requested the type.</source>
          <target state="translated">开头<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>、<ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>属性包含请求的类型的程序集。</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>For more information, see <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">有关详情，请参阅<ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>To register an event handler for this event, you must have the required permissions, or a <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown.</source>
          <target state="translated">若要注册的事件处理程序此事件，你必须具有所需的权限，或<ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">有关处理事件的详细信息，请参阅<bpt id="p1">[</bpt>处理和引发事件<ept id="p1">](~/docs/standard/events/index.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> event.</source>
          <target state="translated">下面的示例演示如何<ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">若要运行此代码示例，你必须提供完全限定程序集名称。</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">有关如何获取完全限定程序集名称的信息，请参阅<bpt id="p1">[</bpt>程序集名称<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" uid="E:System.AppDomain.UnhandledException">
          <source>Occurs when an exception is not caught.</source>
          <target state="translated">当某个异常未被捕获时出现。</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This event provides notification of uncaught exceptions.</source>
          <target state="translated">此事件提供通知未捕获的异常。</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>It allows the application to log information about the exception before the system default handler reports the exception to the user and terminates the application.</source>
          <target state="translated">它允许应用程序来记录有关异常的信息，系统默认处理程序将异常报告给用户和终止应用程序之前。</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If sufficient information about the state of the application is available, other actions may be undertaken — such as saving program data for later recovery.</source>
          <target state="translated">如果提供了有关状态的应用程序的足够信息，可以采取其他措施-例如保存更高版本的恢复的程序数据。</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Caution is advised, because program data can become corrupted when exceptions are not handled.</source>
          <target state="translated">建议小心，因为不处理异常时，可能会损坏程序数据。</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In the .NET Framework versions 1.0 and 1.1, application termination and debugging options are reported to the user before this event is raised, rather than after.</source>
          <target state="translated">在.NET framework 1.0 和 1.1 版中，应用程序终止时和调试选项会报告给用户中，将引发此事件之前，而不是之后。</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This event can be handled in any application domain.</source>
          <target state="translated">可以在任何应用程序域中处理此事件。</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>However, the event is not necessarily raised in the application domain where the exception occurred.</source>
          <target state="translated">但是，引发该事件是不一定在何处出现异常的应用程序域中。</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>An exception is unhandled only if the entire stack for the thread has been unwound without finding an applicable exception handler, so the first place the event can be raised is in the application domain where the thread originated.</source>
          <target state="translated">仅当没有找到适用的异常处理程序，因此可以引发该事件的第一个位置是在生成该线程的应用程序域已被线程的整个堆栈展开，会处理异常。</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In the .NET Framework versions 1.0 and 1.1, this event occurs only for the default application domain that is created by the system when an application is started.</source>
          <target state="translated">在.NET framework 1.0 和 1.1 版中，仅为应用程序启动时由系统创建的默认应用程序域发生此事件。</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If an application creates additional application domains, specifying a delegate for this event in those applications domains has no effect.</source>
          <target state="translated">如果应用程序创建其他应用程序域，在这些应用程序域中指定为此事件的委托无效。</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event is handled in the default application domain, it is raised there for any unhandled exception in any thread, no matter what application domain the thread started in.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph>默认应用程序域中处理事件，将引发此事件存在的任何未经处理的异常在任何线程，无论哪个应用程序域启动的线程。</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If the thread started in an application domain that has an event handler for <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph>, the event is raised in that application domain.</source>
          <target state="translated">如果在应用程序域中的事件处理程序中启动线程<ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph>，该应用程序域中引发事件。</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If that application domain is not the default application domain, and there is also an event handler in the default application domain, the event is raised in both application domains.</source>
          <target state="translated">如果该应用程序域不是默认应用程序域，并且还存在一个事件处理程序在默认应用程序域中，将两个应用程序域中引发事件。</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>For example, suppose a thread starts in application domain "AD1", calls a method in application domain "AD2", and from there calls a method in application domain "AD3", where it throws an exception.</source>
          <target state="translated">例如，假设在线程启动应用程序域"AD1"应用程序域"AD2"中调用的方法，并从那里调用的方法在应用程序域"AD3"，它将引发异常。</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The first application domain in which the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event can be raised is "AD1".</source>
          <target state="translated">在其中的第一个应用程序域<ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph>可以引发事件是"AD1"。</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If that application domain is not the default application domain, the event can also be raised in the default application domain.</source>
          <target state="translated">如果该应用程序域不是默认应用程序域，那么还可以在默认应用程序域中引发事件。</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The common language runtime suspends thread aborts while event handlers for the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event are executing.</source>
          <target state="translated">公共语言运行时挂起时事件处理程序的线程中止<ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph>事件一起执行。</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If the event handler has a <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute with the appropriate flags, the event handler is treated as a constrained execution region.</source>
          <target state="translated">如果事件处理程序具有<ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph>属性具有相应的标志，事件处理程序被视为受约束的执行区域。</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, this event is not raised for exceptions that corrupt the state of the process, such as stack overflows or access violations, unless the event handler is security-critical and has the <ph id="ph2">&lt;xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute&gt;</ph> attribute.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>，此事件不会引发的异常的损坏状态的进程，如堆栈溢出或访问冲突，除非事件处理程序是安全关键，并且具有<ph id="ph2">&lt;xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In the .NET Framework versions 1.0 and 1.1, an unhandled exception that occurs in a thread other than the main application thread is caught by the runtime and therefore does not cause the application to terminate.</source>
          <target state="translated">在.NET framework 1.0 和 1.1 版中，在主应用程序线程外的线程中出现未经处理的异常将由运行时捕获，并因此不会导致应用程序终止。</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Thus, it is possible for the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event to be raised without the application terminating.</source>
          <target state="translated">因此，很可能<ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph>不终止的应用程序的情况下引发的事件。</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Starting with the .NET Framework version 2.0, this backstop for unhandled exceptions in child threads was removed, because the cumulative effect of such silent failures included performance degradation, corrupted data, and lockups, all of which were difficult to debug.</source>
          <target state="translated">从.NET Framework 2.0 版开始，此对子子线程中未经处理的异常已被移除，因为这种无提示故障的累积效应包括性能下降，损坏的数据和锁定，它们都非常难以调试。</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>For more information, including a list of cases in which the runtime does not terminate, see <bpt id="p1">[</bpt>Exceptions in Managed Threads<ept id="p1">](~/docs/standard/threading/exceptions-in-managed-threads.md)</ept>.</source>
          <target state="translated">有关详细信息，包括列表的情况下在其中运行时不会终止，请参阅<bpt id="p1">[</bpt>托管线程中的异常<ept id="p1">](~/docs/standard/threading/exceptions-in-managed-threads.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>To register an event handler for this event, you must have the required permissions, or a <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown.</source>
          <target state="translated">若要注册的事件处理程序此事件，你必须具有所需的权限，或<ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">有关处理事件的详细信息，请参阅<bpt id="p1">[</bpt>处理和引发事件<ept id="p1">](~/docs/standard/events/index.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Other Events for Unhandled Exceptions</source>
          <target state="translated">未经处理的异常的其他事件</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>For certain application models, the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event can be preempted by other events if the unhandled exception occurs in the main application thread.</source>
          <target state="translated">对于某些应用程序模型，<ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph>事件可以由其他事件抢先，如果在主应用程序线程中出现未经处理的异常。</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In applications that use Windows Forms, unhandled exceptions in the main application thread cause the <ph id="ph1">&lt;xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType&gt;</ph> event to be raised.</source>
          <target state="translated">使用 Windows 窗体的应用程序中未经处理的异常中的主应用程序线程原因<ph id="ph1">&lt;xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType&gt;</ph>引发事件。</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If this event is handled, the default behavior is that the unhandled exception does not terminate the application, although the application is left in an unknown state.</source>
          <target state="translated">如果处理此事件，默认行为是未处理的异常不会终止该应用程序，尽管应用程序处于未知状态。</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In that case, the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event is not raised.</source>
          <target state="translated">在这种情况下，<ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph>不会引发事件。</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This behavior can be changed by using the application configuration file, or by using the <ph id="ph1">&lt;xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType&gt;</ph> method to change the mode to <ph id="ph2">&lt;xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType&gt;</ph> before the <ph id="ph3">&lt;xref:System.Windows.Forms.Application.ThreadException&gt;</ph> event handler is hooked up.</source>
          <target state="translated">可以更改此行为，通过使用应用程序配置文件，或通过使用<ph id="ph1">&lt;xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType&gt;</ph>方法以将模式更改为<ph id="ph2">&lt;xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType&gt;</ph>之前<ph id="ph3">&lt;xref:System.Windows.Forms.Application.ThreadException&gt;</ph>事件处理程序挂钩。</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This applies only to the main application thread.</source>
          <target state="translated">这仅适用于主应用程序线程。</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event is raised for unhandled exceptions thrown in other threads.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph>事件引发的其他线程中引发的未经处理异常。</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Starting with Microsoft Visual Studio 2005, the Visual Basic application framework provides another event for unhandled exceptions in the main application thread.</source>
          <target state="translated">Visual Basic 应用程序框架从 Microsoft Visual Studio 2005 开始，提供有关在主应用程序线程中未经处理的异常的另一个事件。</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>See the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This event has an event arguments object with the same name as the event arguments object used by <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph>, but with different properties.</source>
          <target state="translated">此事件具有与使用的事件自变量对象同名的事件自变量对象<ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph>，但具有不同的属性。</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In particular, this event arguments object has an <ph id="ph1">&lt;xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A&gt;</ph> property that allows the application to continue running, ignoring the unhandled exception (and leaving the application in an unknown state).</source>
          <target state="translated">具体而言，此事件自变量对象具有<ph id="ph1">&lt;xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A&gt;</ph>属性，它允许应用程序能够继续运行，忽略未经处理的异常 （并会使应用程序处于未知状态）。</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In that case, the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph> event is not raised.</source>
          <target state="translated">在这种情况下，<ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph>不会引发事件。</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The followingexample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event.</source>
          <target state="translated">以下示例演示<ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>It defines an event handler, <ph id="ph1">`MyHandler`</ph>, that is invoked whenever an unhandled exception is thrown in the default application domain.</source>
          <target state="translated">它定义事件处理程序， <ph id="ph1">`MyHandler`</ph>，每当在默认应用程序域中引发未处理的异常时调用。</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>It then throws two exceptions.</source>
          <target state="translated">然后，它将引发两个例外。</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The first is handled by a <bpt id="p1">**</bpt>try/catch<ept id="p1">**</ept> block.</source>
          <target state="translated">第一个由<bpt id="p1">**</bpt>try/catch<ept id="p1">**</ept>块。</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The second is unhandled and invokes the <ph id="ph1">`MyHandle`</ph> routine before the application terminates.</source>
          <target state="translated">第二个未经处理，并调用<ph id="ph1">`MyHandle`</ph>例程之前在应用程序终止。</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>An application domain to unload.</source>
          <target state="translated">要卸载的应用程序域。</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Unloads the specified application domain.</source>
          <target state="translated">卸载指定的应用程序域。</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>In the .NET Framework version 2.0 there is a thread dedicated to unloading application domains.</source>
          <target state="translated">.NET Framework 2.0 版中没有一个线程专用于卸载应用程序域。</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>This improves reliability, especially when the .NET Framework is hosted.</source>
          <target state="translated">这将提高可靠性，尤其是在.NET Framework 承载。</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>When a thread calls <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>, the target domain is marked for unloading.</source>
          <target state="translated">当线程调用<ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>，目标域标记为要卸载。</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>The dedicated thread attempts to unload the domain, and all threads in the domain are aborted.</source>
          <target state="translated">专用的线程尝试卸载的域和域中的所有线程都将立即都中止。</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>If a thread does not abort, for example because it is executing unmanaged code, or because it is executing a <ph id="ph1">`finally`</ph> block, then after a period of time a <ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph> is thrown in the thread that originally called <ph id="ph3">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>.</source>
          <target state="translated">如果一个线程不会中止，例如因为它执行非托管的代码，或是因为正在执行<ph id="ph1">`finally`</ph>块，然后在一段时间后的<ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph>在最初调用的线程中引发<ph id="ph3">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>If the thread that could not be aborted eventually ends, the target domain is not unloaded.</source>
          <target state="translated">如果不可能最终会中止的线程结束，则目标域不卸载。</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Thus, in the .NET Framework version 2.0 <ph id="ph1">`domain`</ph> is not guaranteed to unload, because it might not be possible to terminate executing threads.</source>
          <target state="translated">因此，在.NET Framework 2.0 版<ph id="ph1">`domain`</ph>不能保证卸载，因为它可能不能终止正在执行的线程。</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>In some cases, calling <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> causes an immediate <ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph>, for example if it is called in a finalizer.</source>
          <target state="translated">在某些情况下，调用<ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>导致即时<ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph>，例如如果就是在终结器。</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>The threads in <ph id="ph1">`domain`</ph> are terminated using the <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> method, which throws a <ph id="ph3">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> in the thread.</source>
          <target state="translated">中的线程<ph id="ph1">`domain`</ph>被终止使用<ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph>方法，将引发<ph id="ph3">&lt;xref:System.Threading.ThreadAbortException&gt;</ph>线程中。</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Although the thread should terminate promptly, it can continue executing for an unpredictable amount of time in a <ph id="ph1">`finally`</ph> clause.</source>
          <target state="translated">尽管线程应立即终止，它可以继续执行可不可预测的时间量中<ph id="ph1">`finally`</ph>子句。</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Version Compatibility</source>
          <target state="translated">版本兼容性</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>In the .NET Framework version 1.0 and 1.1 if the thread that calls <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> is running in <ph id="ph2">`domain`</ph>, another thread is started to perform the unload operation.</source>
          <target state="translated">.NET framework 版本 1.0 和 1.1 中，如果调用线程<ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>正在以<ph id="ph2">`domain`</ph>，另一个线程开始执行卸载操作。</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>If <ph id="ph1">`domain`</ph> cannot be unloaded, a <ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph> is thrown in that thread, not in the original thread that called <ph id="ph3">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">`domain`</ph>无法卸载，<ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph>该线程，不在原始调用的线程中引发<ph id="ph3">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>However, if the thread that calls <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> is running outside <ph id="ph2">`domain`</ph>, that thread receives the exception.</source>
          <target state="translated">但是，如果调用线程<ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>外部运行<ph id="ph2">`domain`</ph>，线程将收到异常。</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>The following code example shows how to unload an application domain.</source>
          <target state="translated">下面的代码示例演示如何卸载应用程序域。</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source><ph id="ph1">&lt;paramref name="domain" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="domain" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source><ph id="ph1">&lt;paramref name="domain" /&gt;</ph> could not be unloaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="domain" /&gt;</ph> 未能卸载。</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>An error occurred during the unload process.</source>
          <target state="translated">在卸载进程期间出错。</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>to add an event handler for this event.</source>
          <target state="translated">若要添加的事件处理程序此事件。</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">安全操作： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>