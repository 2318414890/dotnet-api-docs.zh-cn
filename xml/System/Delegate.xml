<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="17dc71087e58ed347b4efbbe71e747eb91676656" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52200581" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="ce7c1-101">表示委托，委托是一种数据结构，它引用静态方法或引用类实例及该类的实例方法。</span>
      <span class="sxs-lookup">
        <span data-stu-id="ce7c1-101">Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-102"><xref:System.Delegate>类是委托类型的基类。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-102">The <xref:System.Delegate> class is the base class for delegate types.</span></span> <span data-ttu-id="ce7c1-103">但是，只有系统和编译器可以派生自显式<xref:System.Delegate>类或从<xref:System.MulticastDelegate>类。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-103">However, only the system and compilers can derive explicitly from the <xref:System.Delegate> class or from the <xref:System.MulticastDelegate> class.</span></span> <span data-ttu-id="ce7c1-104">此外，还不允许从委托类型派生新类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-104">It is also not permissible to derive a new type from a delegate type.</span></span> <span data-ttu-id="ce7c1-105"><xref:System.Delegate>类不被视为是委托类型; 它是用于委托类型派生一个类。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-105">The <xref:System.Delegate> class is not considered a delegate type; it is a class used to derive delegate types.</span></span>  
  
 <span data-ttu-id="ce7c1-106">大多数语言实现`delegate`关键字，并为这些语言的编译器可派生自<xref:System.MulticastDelegate>类; 因此，用户应使用`delegate`语言提供的关键字。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-106">Most languages implement a `delegate` keyword, and compilers for those languages are able to derive from the <xref:System.MulticastDelegate> class; therefore, users should use the `delegate` keyword provided by the language.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-107">公共语言运行时提供`Invoke`对于每个委托类型，具有相同的签名与委托的方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-107">The common language runtime provides an `Invoke` method for each delegate type, with the same signature as the delegate.</span></span> <span data-ttu-id="ce7c1-108">您不需要显式调用此方法，从 C#、 Visual Basic 或 Visual c + +，因为编译器会自动调用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-108">You do not have to call this method explicitly from C#, Visual Basic, or Visual C++, because the compilers call it automatically.</span></span> <span data-ttu-id="ce7c1-109">`Invoke`方法可在[反射](~/docs/framework/reflection-and-codedom/reflection.md)时想要查找的委托类型签名。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-109">The `Invoke` method is useful in [reflection](~/docs/framework/reflection-and-codedom/reflection.md) when you want to find the signature of the delegate type.</span></span>  
  
 <span data-ttu-id="ce7c1-110">公共语言运行时提供每个委托类型与`BeginInvoke`和`EndInvoke`方法，以便能够异步调用的委托。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-110">The common language runtime provides each delegate type with `BeginInvoke` and `EndInvoke` methods, to enable asynchronous invocation of the delegate.</span></span> <span data-ttu-id="ce7c1-111">有关这些方法的详细信息，请参阅[Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-111">For more information about these methods, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
 <span data-ttu-id="ce7c1-112">委托类型的声明建立指定的一个或多个方法签名的协定。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-112">The declaration of a delegate type establishes a contract that specifies the signature of one or more methods.</span></span> <span data-ttu-id="ce7c1-113">委托是所引用的委托类型的实例：</span><span class="sxs-lookup"><span data-stu-id="ce7c1-113">A delegate is an instance of a delegate type that has references to:</span></span>  
  
-   <span data-ttu-id="ce7c1-114">类型和可分配给该类型的目标对象的实例方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-114">An instance method of a type and a target object assignable to that type.</span></span>  
  
-   <span data-ttu-id="ce7c1-115">具有隐藏的类型的实例方法`this`参数在形参表中公开。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-115">An instance method of a type, with the hidden `this` parameter exposed in the formal parameter list.</span></span> <span data-ttu-id="ce7c1-116">委托被称为是一个委托，它打开的实例。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-116">The delegate is said to be an open instance delegate.</span></span>  
  
-   <span data-ttu-id="ce7c1-117">一种静态方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-117">A static method.</span></span>  
  
-   <span data-ttu-id="ce7c1-118">静态方法，并且可分配给该方法的第一个参数的目标对象。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-118">A static method and a target object assignable to the first parameter of the method.</span></span> <span data-ttu-id="ce7c1-119">委托被称为封闭式其第一个参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-119">The delegate is said to be closed over its first argument.</span></span>  
  
 <span data-ttu-id="ce7c1-120">有关绑定的委托的详细信息，请参阅<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-120">For more information on delegate binding, see the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-121">在.NET framework 1.0 和 1.1 中，委托可以表示一种方法，仅当该方法的签名与委托类型指定的签名完全匹配。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-121">In the .NET Framework versions 1.0 and 1.1, a delegate can represent a method only if the signature of the method exactly matches the signature specified by the delegate type.</span></span> <span data-ttu-id="ce7c1-122">因此，仅第一个和第三个项目符号前面的列表中都受支持，并且第一项要求的类型完全匹配项。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-122">Thus, only the first and third bullets in the preceding list are supported, and the first bullet requires an exact type match.</span></span>  
  
 <span data-ttu-id="ce7c1-123">委托时委托表示实例方法通过其第一个参数 （最常见的情况） 关闭时，将对方法的入口点的引用和对一个名为目标，这是赋给定义的类型的类型的对象的引用存储方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-123">When a delegate represents an instance method closed over its first argument (the most common case), the delegate stores a reference to the method's entry point and a reference to an object, called the target, which is of a type assignable to the type that defined the method.</span></span> <span data-ttu-id="ce7c1-124">当委托表示打开的实例方法时，它存储到该方法的入口点的引用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-124">When a delegate represents an open instance method, it stores a reference to the method's entry point.</span></span> <span data-ttu-id="ce7c1-125">委托签名必须包括隐藏`this`参数在其形参表; 在这种情况下，委托不具有对目标对象的引用和调用委托时，必须提供目标对象。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-125">The delegate signature must include the hidden `this` parameter in its formal parameter list; in this case, the delegate does not have a reference to a target object, and a target object must be supplied when the delegate is invoked.</span></span>  
  
 <span data-ttu-id="ce7c1-126">当委托表示静态方法时，该委托存储到该方法的入口点的引用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-126">When a delegate represents a static method, the delegate stores a reference to the method's entry point.</span></span> <span data-ttu-id="ce7c1-127">当委托表示静态方法通过其第一个参数已关闭时，委托将存储对方法的入口点的引用和对可分配给该方法的第一个参数的类型的目标对象的引用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-127">When a delegate represents a static method closed over its first argument, the delegate stores a reference to the method's entry point and a reference to a target object assignable to the type of the method's first argument.</span></span> <span data-ttu-id="ce7c1-128">当调用委托时，静态方法的第一个参数接收目标对象。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-128">When the delegate is invoked, the first argument of the static method receives the target object.</span></span>  
  
 <span data-ttu-id="ce7c1-129">委托的调用列表是列表的一个有序中的每个元素调用一个委托所表示的方法的委托。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-129">The invocation list of a delegate is an ordered set of delegates in which each element of the list invokes exactly one of the methods represented by the delegate.</span></span> <span data-ttu-id="ce7c1-130">调用列表可以包含重复的方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-130">An invocation list can contain duplicate methods.</span></span> <span data-ttu-id="ce7c1-131">在调用过程的调用列表中出现的顺序调用的方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-131">During an invocation, methods are invoked in the order in which they appear in the invocation list.</span></span> <span data-ttu-id="ce7c1-132">尝试调用其调用列表; 中的每个方法的委托对于每个时间它们会显示在调用列表后，会调用重复项。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-132">A delegate attempts to invoke every method in its invocation list; duplicates are invoked once for each time they appear in the invocation list.</span></span> <span data-ttu-id="ce7c1-133">委托是固定不变;创建后，委托的调用列表将不会更改。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-133">Delegates are immutable; once created, the invocation list of a delegate does not change.</span></span>  
  
 <span data-ttu-id="ce7c1-134">委托被引用的多路广播，或可组合，因为委托可以调用一个或多个方法，并且可以用在组合操作。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-134">Delegates are referred to as multicast, or combinable, because a delegate can invoke one or more methods and can be used in combining operations.</span></span>  
  
 <span data-ttu-id="ce7c1-135">合并操作，如<xref:System.Delegate.Combine%2A>和<xref:System.Delegate.Remove%2A>，不会更改现有委托。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-135">Combining operations, such as <xref:System.Delegate.Combine%2A> and <xref:System.Delegate.Remove%2A>, do not alter existing delegates.</span></span> <span data-ttu-id="ce7c1-136">相反，此类操作返回包含结果的操作，一个不变的委托，一个新委托或`null`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-136">Instead, such an operation returns a new delegate that contains the results of the operation, an unchanged delegate, or `null`.</span></span> <span data-ttu-id="ce7c1-137">合并操作将返回`null`时操作的结果是不引用至少一种方法的委托。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-137">A combining operation returns `null` when the result of the operation is a delegate that does not reference at least one method.</span></span> <span data-ttu-id="ce7c1-138">合并操作，返回未更改的委托时请求的操作不起作用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-138">A combining operation returns an unchanged delegate when the requested operation has no effect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-139">托管语言使用<xref:System.Delegate.Combine%2A>和<xref:System.Delegate.Remove%2A>方法来实现委托操作。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-139">Managed languages use the <xref:System.Delegate.Combine%2A> and <xref:System.Delegate.Remove%2A> methods to implement delegate operations.</span></span> <span data-ttu-id="ce7c1-140">示例包括`AddHandler`和`RemoveHandler`在 Visual Basic 中的语句和上的 + = 和-= 运算符委托在 C# 中的类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-140">Examples include the `AddHandler` and `RemoveHandler` statements in Visual Basic and the += and -= operators on delegate types in C#.</span></span>  
  
 <span data-ttu-id="ce7c1-141">从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，泛型委托类型可以具有 variant 类型参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-141">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], generic delegate types can have variant type parameters.</span></span> <span data-ttu-id="ce7c1-142">逆变类型参数可以用作参数类型的委托，协变类型参数可以用作返回类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-142">Contravariant type parameters can be used as parameter types of the delegate, and a covariant type parameter can be used as the return type.</span></span> <span data-ttu-id="ce7c1-143">此功能允许泛型委托类型相同的泛型类型定义，如中所述为赋值兼容其类型参数是引用类型具有继承关系，如果从[协方差和逆变](~/docs/standard/generics/covariance-and-contravariance.md)。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-143">This feature allows generic delegate types that are constructed from the same generic type definition to be assignment-compatible if their type arguments are reference types with an inheritance relationship, as explained in [Covariance and Contravariance](~/docs/standard/generics/covariance-and-contravariance.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-144">赋值兼容的泛型委托的变体由于并不一定是可组合。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-144">Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</span></span> <span data-ttu-id="ce7c1-145">若要可组合，类型必须完全匹配。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-145">To be combinable, the types must match exactly.</span></span> <span data-ttu-id="ce7c1-146">例如，假设一个名为`Derived`派生的类名为`Base`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-146">For example, suppose that a class named `Derived` is derived from a class named `Base`.</span></span> <span data-ttu-id="ce7c1-147">类型的委托`Action<Base>`(`Action(Of Base)`在 Visual Basic 中) 可以分配给类型的变量的`Action<Derived>`，但不能组合两个委托，因为类型不完全匹配。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-147">A delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic) can be assigned to a variable of type `Action<Derived>`, but the two delegates cannot be combined because the types do not match exactly.</span></span>  
  
 <span data-ttu-id="ce7c1-148">如果调用的方法引发异常，该方法停止执行、 异常传递回委托，调用方和剩余方法的调用列表中不会调用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-148">If an invoked method throws an exception, the method stops executing, the exception is passed back to the caller of the delegate, and remaining methods in the invocation list are not invoked.</span></span> <span data-ttu-id="ce7c1-149">在调用方中捕获该异常不会更改此行为。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-149">Catching the exception in the caller does not alter this behavior.</span></span>  
  
 <span data-ttu-id="ce7c1-150">当由委托调用的方法的签名包括返回值时，委托的调用列表中返回的最后一个元素的返回值。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-150">When the signature of the methods invoked by a delegate includes a return value, the delegate returns the return value of the last element in the invocation list.</span></span> <span data-ttu-id="ce7c1-151">如果签名包括按引用传递的参数，参数的最终值将按顺序执行并更新参数的值的调用列表中每个方法的结果。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-151">When the signature includes a parameter that is passed by reference, the final value of the parameter is the result of every method in the invocation list executing sequentially and updating the parameter's value.</span></span>  
  
 <span data-ttu-id="ce7c1-152">最接近的 C 或 c + + 中是委托的函数指针。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-152">The closest equivalent of a delegate in C or C++ is a function pointer.</span></span> <span data-ttu-id="ce7c1-153">委托可以表示的静态方法或实例方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-153">A delegate can represent a static method or an instance method.</span></span> <span data-ttu-id="ce7c1-154">当委托表示实例方法时，该委托存储不仅对方法的入口点，而且还对类实例的引用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-154">When the delegate represents an instance method, the delegate stores not only a reference to the method's entry point, but also a reference to the class instance.</span></span> <span data-ttu-id="ce7c1-155">函数与指针不同，委托是面向对象和类型安全的。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-155">Unlike function pointers, delegates are object oriented and type safe.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce7c1-156">下面的示例演示如何定义一个名为的委托`myMethodDelegate`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-156">The following example shows how to define a delegate named `myMethodDelegate`.</span></span> <span data-ttu-id="ce7c1-157">实例方法和嵌套的静态方法来创建此委托的实例`mySampleClass`类。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-157">Instances of this delegate are created for an instance method and a static method of the nested `mySampleClass` class.</span></span> <span data-ttu-id="ce7c1-158">实例方法的委托需要的实例`mySampleClass`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-158">The delegate for the instance method requires an instance of `mySampleClass`.</span></span> <span data-ttu-id="ce7c1-159">`mySampleClass`实例保存在名为`mySC`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-159">The `mySampleClass` instance is saved in a variable named `mySC`.</span></span>  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="https://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb">
      <span data-ttu-id="ce7c1-160">使用异步方式调用同步方法</span>
      <span class="sxs-lookup">
        <span data-stu-id="ce7c1-160">Calling Synchronous Methods Asynchronously</span>
      </span>
    </related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md">
      <span data-ttu-id="ce7c1-161">委托（C# 编程指南）</span>
      <span class="sxs-lookup">
        <span data-stu-id="ce7c1-161">Delegates (C# Programming Guide)</span>
      </span>
    </related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md">
      <span data-ttu-id="ce7c1-162">委托 (Visual Basic)</span>
      <span class="sxs-lookup">
        <span data-stu-id="ce7c1-162">Delegates (Visual Basic)</span>
      </span>
    </related>
    <related type="Article" href="https://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8">
      <span data-ttu-id="ce7c1-163">如何：定义和使用委托 (C++/CLI)</span>
      <span class="sxs-lookup">
        <span data-stu-id="ce7c1-163">How to: Define and Use Delegates (C++/CLI)</span>
      </span>
    </related>
    <related type="Article" href="https://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f">
      <span data-ttu-id="ce7c1-164">处理和引发事件</span>
      <span class="sxs-lookup">
        <span data-stu-id="ce7c1-164">Handling and Raising Events</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ce7c1-165">初始化一个新委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-165">Initializes a new delegate.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ce7c1-166">类实例，委托对其调用 <paramref name="method" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-166">The class instance on which the delegate invokes <paramref name="method" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ce7c1-167">委托表示的实例方法的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-167">The name of the instance method that the delegate represents.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-168">初始化一个委托，该委托对指定的类实例调用指定的实例方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-168">Initializes a delegate that invokes the specified instance method on the specified class instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-169">不能在应用程序代码中使用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-169">This constructor cannot be used in application code.</span></span> <span data-ttu-id="ce7c1-170">若要通过指定实例方法的名称创建一个委托，使用的重载<xref:System.Delegate.CreateDelegate%2A>指定方法名称和目标对象的方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-170">To create a delegate by specifying the name of an instance method, use an overload of the <xref:System.Delegate.CreateDelegate%2A> method that specifies a method name and a target object.</span></span> <span data-ttu-id="ce7c1-171">例如，<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29>方法重载创建具有指定名称的实例方法的委托。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-171">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> method overload creates a delegate for an instance method with a specified name.</span></span>  
  
 <span data-ttu-id="ce7c1-172">此构造函数实例只方法创建委托。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-172">This constructor creates delegates for instance methods only.</span></span> <span data-ttu-id="ce7c1-173">另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-173">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce7c1-174">
            <paramref name="target" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-174">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-175">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-175">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-176">
            <paramref name="method" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-176">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-177">绑定到目标方法时出错。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-177">There was an error binding to the target method.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-178">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-178">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-179">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-179">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="ce7c1-180">
            <see cref="T:System.Type" /> 表示用于定义 <paramref name="method" /> 的类。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-180">The <see cref="T:System.Type" /> representing the class that defines <paramref name="method" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ce7c1-181">委托表示的静态方法的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-181">The name of the static method that the delegate represents.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-182">初始化一个委托，该委托从指定的类调用指定的静态方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-182">Initializes a delegate that invokes the specified static method from the specified class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-183">不能在应用程序代码中使用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-183">This constructor cannot be used in application code.</span></span> <span data-ttu-id="ce7c1-184">若要指定静态方法的名称创建一个委托，使用的重载<xref:System.Delegate.CreateDelegate%2A>指定方法名称，但未指定目标对象的方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-184">To create a delegate by specifying the name of a static method, use an overload of the <xref:System.Delegate.CreateDelegate%2A> method that specifies a method name but does not specify a target object.</span></span> <span data-ttu-id="ce7c1-185">例如，<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29>方法重载创建具有指定名称的方法的静态委托。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-185">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> method overload creates a static delegate for a method with a specified name.</span></span>  
  
 <span data-ttu-id="ce7c1-186">此构造函数创建只为静态方法的委托。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-186">This constructor creates delegates for static methods only.</span></span> <span data-ttu-id="ce7c1-187">另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-187">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce7c1-188">
            <paramref name="target" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-188">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-189">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-189">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-190">
            <paramref name="method" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-190">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-191">
            <paramref name="target" /> 不是 <see langword="RuntimeType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-191">
              <paramref name="target" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="ce7c1-192">请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-192">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="ce7c1-193">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-193">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-194">
            <paramref name="target" /> 表示开放式泛型类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-194">
              <paramref name="target" /> represents an open generic type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-195">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-195">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-196">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-196">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ce7c1-197">创建委托的浅表副本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-197">Creates a shallow copy of the delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-198">委托的浅表副本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-198">A shallow copy of the delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-199">克隆具有相同<xref:System.Type>，与原始委托的目标、 方法和调用列表。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-199">The clone has the same <xref:System.Type>, target, method, and invocation list as the original delegate.</span></span>  
  
 <span data-ttu-id="ce7c1-200">浅表副本创建与原始对象相同的类型的新实例，然后将复制的原始对象的非静态字段。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-200">A shallow copy creates a new instance of the same type as the original object, and then copies the nonstatic fields of the original object.</span></span> <span data-ttu-id="ce7c1-201">如果此字段为值类型，则执行字段的按位复制。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-201">If the field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="ce7c1-202">如果此字段为引用类型，则复制引用，但被引用的对象;因此，在原始对象的引用和克隆中的引用点对同一对象。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-202">If the field is a reference type, the reference is copied but the referred object is not; therefore, the reference in the original object and the reference in the clone point to the same object.</span></span> <span data-ttu-id="ce7c1-203">与此相反，对象的深层副本会复制所有内容直接或间接引用的对象中的字段。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-203">In contrast, a deep copy of an object duplicates everything directly or indirectly referenced by the fields in the object.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-204">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-204">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-205">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-205">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ce7c1-206">将指定的多路广播（可组合）委托的调用列表连接起来。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-206">Concatenates the invocation lists of the specified multicast (combinable) delegates.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">
          <span data-ttu-id="ce7c1-207">要组合的委托的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-207">The array of delegates to combine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-208">将委托数组的调用列表连接在一起。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-208">Concatenates the invocation lists of an array of delegates.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-209">新的委托，该委托的调用列表将 <paramref name="delegates" /> 数组中的委托的调用列表串联在一起。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-209">A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <paramref name="delegates" /> array.</span>
          </span>
          <span data-ttu-id="ce7c1-210">如果 <paramref name="delegates" /> 为 <see langword="null" />，<paramref name="delegates" /> 包含零个元素，或 <paramref name="delegates" /> 中的每个条目均为 <see langword="null" />，则返回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-210">Returns <see langword="null" /> if <paramref name="delegates" /> is <see langword="null" />, if <paramref name="delegates" /> contains zero elements, or if every entry in <paramref name="delegates" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-211">如果`delegates`数组包含的条目`null`，这些条目将被忽略。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-211">If the `delegates` array contains entries that are `null`, those entries are ignored.</span></span>  
  
 <span data-ttu-id="ce7c1-212">调用列表可以包含重复项;它是指同一对象上的相同方法的条目。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-212">The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-213">赋值兼容的泛型委托的变体由于并不一定是可组合。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-213">Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</span></span> <span data-ttu-id="ce7c1-214">若要可组合，类型必须完全匹配。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-214">To be combinable, the types must match exactly.</span></span> <span data-ttu-id="ce7c1-215">例如，假设一个名为`Derived`派生的类名为`Base`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-215">For example, suppose that a class named `Derived` is derived from a class named `Base`.</span></span> <span data-ttu-id="ce7c1-216">类型的委托`Action<Base>`(`Action(Of Base)`在 Visual Basic 中) 可以分配给类型的变量`Action<Derived>`，如中所述[协变和逆变](~/docs/standard/generics/covariance-and-contravariance.md)，但不能组合两个委托，因为此操作类型不完全匹配。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-216">A delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic) can be assigned to a variable of type `Action<Derived>`, as explained in [Covariance and Contravariance](~/docs/standard/generics/covariance-and-contravariance.md), but the two delegates cannot be combined because the types do not match exactly.</span></span>  
  
 <span data-ttu-id="ce7c1-217"><xref:System.Delegate.Combine%2A> 可用于创建调用多个方法的时间事件发生的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-217"><xref:System.Delegate.Combine%2A> is useful for creating event handlers that call multiple methods each time an event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-218">不是所有 <paramref name="delegates" /> 中的非 null 项都是同一委托类型的实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-218">Not all the non-null entries in <paramref name="delegates" /> are instances of the same delegate type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-219">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-219">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-220">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-220">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="ce7c1-221">最先出现其调用列表的委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-221">The delegate whose invocation list comes first.</span>
          </span>
        </param>
        <param name="b">
          <span data-ttu-id="ce7c1-222">最后出现其调用列表的委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-222">The delegate whose invocation list comes last.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-223">将两个委托的调用列表连接在一起。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-223">Concatenates the invocation lists of two delegates.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-224">新的委托，它的调用列表将 <paramref name="a" /> 和 <paramref name="b" /> 的调用列表按该顺序连接在一起。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-224">A new delegate with an invocation list that concatenates the invocation lists of <paramref name="a" /> and <paramref name="b" /> in that order.</span>
          </span>
          <span data-ttu-id="ce7c1-225">如果 <paramref name="b" /> 为 <see langword="null" />，则返回 <paramref name="a" />；如果 <paramref name="a" /> 为 null 引用，则返回 <paramref name="b" />；如果 <paramref name="a" /> 和 <paramref name="b" /> 均为 null 引用，则返回 null 引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-225">Returns <paramref name="a" /> if <paramref name="b" /> is <see langword="null" />, returns <paramref name="b" /> if <paramref name="a" /> is a null reference, and returns a null reference if both <paramref name="a" /> and <paramref name="b" /> are null references.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-226">调用列表可以包含重复项;它是指同一对象上的相同方法的条目。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-226">The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-227">赋值兼容的泛型委托的变体由于并不一定是可组合。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-227">Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</span></span> <span data-ttu-id="ce7c1-228">若要可组合，类型必须完全匹配。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-228">To be combinable, the types must match exactly.</span></span> <span data-ttu-id="ce7c1-229">例如，假设一个名为`Derived`派生的类名为`Base`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-229">For example, suppose that a class named `Derived` is derived from a class named `Base`.</span></span> <span data-ttu-id="ce7c1-230">类型的委托`Action<Base>`(`Action(Of Base)`在 Visual Basic 中) 可以分配给类型的变量`Action<Derived>`，如中所述[协变和逆变](~/docs/standard/generics/covariance-and-contravariance.md)，但不能组合两个委托，因为此操作类型不完全匹配。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-230">A delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic) can be assigned to a variable of type `Action<Derived>`, as explained in [Covariance and Contravariance](~/docs/standard/generics/covariance-and-contravariance.md), but the two delegates cannot be combined because the types do not match exactly.</span></span>  
  
 <span data-ttu-id="ce7c1-231"><xref:System.Delegate.Combine%2A> 可用于创建调用多个方法的时间事件发生的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-231"><xref:System.Delegate.Combine%2A> is useful for creating event handlers that call multiple methods each time an event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-232">
            <paramref name="a" /> 和 <paramref name="b" /> 均不为 <see langword="null" />，且 <paramref name="a" /> 和 <paramref name="b" /> 不是相同委托类型的实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-232">Both <paramref name="a" /> and <paramref name="b" /> are not <see langword="null" />, and <paramref name="a" /> and <paramref name="b" /> are not instances of the same delegate type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-233">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-233">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-234">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-234">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="ce7c1-235">多路广播（可组合）委托，其调用列表要追加到当前多路广播（可组合）委托的调用列表的结尾。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-235">The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-236">将指定多路广播（可组合）委托和当前多路广播（可组合）委托的调用列表连接起来。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-236">Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-237">新的多路广播（可组合）委托，其调用列表将当前多路广播（可组合）委托的调用列表和 <paramref name="d" /> 的调用列表连接在一起；或者如果 <paramref name="d" /> 为 <see langword="null" />，则返回当前多路广播（可组合）委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-237">A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <paramref name="d" />, or the current multicast (combinable) delegate if <paramref name="d" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-238">此方法仅适用于当前委托是多路广播 （可组合）。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-238">This method applies only if the current delegate is multicast (combinable).</span></span>  
  
 <span data-ttu-id="ce7c1-239">当前实现只需引发<xref:System.MulticastNotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-239">The current implementation simply throws a <xref:System.MulticastNotSupportedException>.</span></span>  
  
 <span data-ttu-id="ce7c1-240">调用列表可以包含重复项;它是指同一对象上的相同方法的条目。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-240">The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">
          <span data-ttu-id="ce7c1-241">始终引发。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-241">Always thrown.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-242">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-242">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-243">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-243">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ce7c1-244">创建指定类型的委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-244">Creates a delegate of the specified type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ce7c1-245">要创建的委托的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-245">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ce7c1-246">描述该委托要表示的静态或实例方法的 <see cref="T:System.Reflection.MethodInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-246">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span>
          </span>
          <span data-ttu-id="ce7c1-247">.NET Framework 1.0 和 1.1 版中仅支持静态方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-247">Only static methods are supported in the .NET Framework version 1.0 and 1.1.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-248">创建指定类型的委托以表示指定的静态方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-248">Creates a delegate of the specified type to represent the specified static method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-249">表示指定静态方法的指定类型的委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-249">A delegate of the specified type to represent the specified static method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-250">在.NET Framework 1.0 和 1.1 版中，此方法的重载创建只为静态方法的委托。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-250">In the .NET Framework version 1.0 and 1.1, this method overload creates delegates for static methods only.</span></span> <span data-ttu-id="ce7c1-251">在.NET Framework 2.0 版中，此方法的重载还可以创建打开实例方法的委托;即，显式提供的隐藏第一个参数的委托实例方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-251">In the .NET Framework version 2.0, this method overload also can create open instance method delegates; that is, delegates that explicitly supply the hidden first argument of instance methods.</span></span> <span data-ttu-id="ce7c1-252">有关的详细说明，请参阅更多常规<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29>方法重载，它允许您创建的打开或关闭实例或静态方法的委托的所有组合并根据需要指定第一个参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-252">For a detailed explanation, see the more general <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods, and optionally to specify a first argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-253">此方法应使用重载时委托未关闭通过其第一个参数，因为它在这种情况下是某种程度上更快。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-253">This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</span></span>  
  
 <span data-ttu-id="ce7c1-254">此方法的重载是等效于调用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法重载并指定`true`为`throwOnBindFailure`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-254">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload and specifying `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-255">从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-255">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="ce7c1-256">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="ce7c1-256">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ce7c1-257">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-257">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="ce7c1-258">兼容的参数类型和返回类型</span><span class="sxs-lookup"><span data-stu-id="ce7c1-258">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="ce7c1-259">在.NET Framework 2.0 版中，参数类型和使用此方法的重载创建委托的返回类型必须是与参数类型和委托表示; 方法的返回类型兼容类型不需要完全匹配。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-259">In the .NET Framework version 2.0, the parameter types and return type of a delegate created using this method overload must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span> <span data-ttu-id="ce7c1-260">这表示在.NET Framework 版本 1.0 和 1.1 中，类型必须完全匹配的绑定行为是放宽了。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-260">This represents a relaxation of the binding behavior in the .NET Framework version 1.0 and 1.1, where the types must match exactly.</span></span>  
  
 <span data-ttu-id="ce7c1-261">如果委托参数的类型的限制性强于方法参数的类型，则该委托的参数与该方法的相应参数兼容，因为这可保证传递给委托的参数可以安全地传递给方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-261">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="ce7c1-262">同样，如果方法的返回类型的限制性强于委托的返回类型，则该委托的返回类型与该方法的返回类型兼容，因为这可保证方法的返回值可以安全地强制转换为委托的返回类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-262">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="ce7c1-263">例如，一个委托，其类型的参数<xref:System.Collections.Hashtable>和返回类型为<xref:System.Object>可以表示具有类型的参数的方法<xref:System.Object>以及一个返回值类型的<xref:System.Collections.Hashtable>。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-263">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce7c1-264">本部分包含两个代码示例。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-264">This section contains two code examples.</span></span> <span data-ttu-id="ce7c1-265">第一个示例演示两种类型的委托可以使用此方法的重载来创建： 打开通过实例方法，并通过静态方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-265">The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</span></span>  
  
 <span data-ttu-id="ce7c1-266">第二个代码示例演示了兼容的参数类型和返回类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-266">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="ce7c1-267">**示例 1**</span><span class="sxs-lookup"><span data-stu-id="ce7c1-267">**Example 1**</span></span>  
  
 <span data-ttu-id="ce7c1-268">下面的代码示例演示了可以使用此重载创建委托的两种方法<xref:System.Delegate.CreateDelegate%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-268">The following code example demonstrates the two ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-269">有两个重载<xref:System.Delegate.CreateDelegate%2A>方法指定<xref:System.Reflection.MethodInfo>，但不是第一个参数; 它们的功能相同，只一个允许您指定是否引发失败时要将绑定，而是其他总是引发。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-269">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify a <xref:System.Reflection.MethodInfo> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="ce7c1-270">此代码示例使用两个重载。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-270">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="ce7c1-271">此示例声明一个类`C`静态方法一起`M2`和实例方法`M1`，和两个委托类型：`D1`的实例`C`和一个字符串，和`D2`采用一个字符串。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-271">The example declares a class `C` with a static method `M2` and an instance method `M1`, and two delegate types: `D1` takes an instance of `C` and a string, and `D2` takes a string.</span></span>  
  
 <span data-ttu-id="ce7c1-272">名为第二个类`Example`包含创建委托的代码。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-272">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="ce7c1-273">类型的委托`D1`，表示打开的实例方法，为实例方法创建`M1`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-273">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="ce7c1-274">当调用委托时，必须传递实例。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-274">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="ce7c1-275">类型的委托`D2`，表示打开的静态方法，为静态方法创建`M2`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-275">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="ce7c1-276">**示例 2**</span><span class="sxs-lookup"><span data-stu-id="ce7c1-276">**Example 2**</span></span>  
  
 <span data-ttu-id="ce7c1-277">下面的代码示例演示了兼容性的参数类型和返回类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-277">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
 <span data-ttu-id="ce7c1-278">代码示例定义名为的基类`Base`和一个名为类`Derived`派生`Base`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-278">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="ce7c1-279">派生的类具有`static`(`Shared`在 Visual Basic 中) 名为方法`MyMethod`类型的一个参数与`Base`和返回类型为`Derived`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-279">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="ce7c1-280">代码示例还定义名为的委托`Example`它具有一个参数的类型`Derived`和返回类型为`Base`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-280">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="ce7c1-281">代码示例演示委托名为`Example`可以用来表示该方法`MyMethod`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-281">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="ce7c1-282">该方法可以绑定到委托，因为：</span><span class="sxs-lookup"><span data-stu-id="ce7c1-282">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="ce7c1-283">委托的参数类型 (`Derived`) 的参数类型比的限制性更强`MyMethod`(`Base`)，以便它始终是安全传递到委托的自变量`MyMethod`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-283">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="ce7c1-284">返回类型`MyMethod`(`Derived`) 是限制性强于委托的参数类型 (`Base`)，以便它始终是安全的委托的返回类型的方法的返回类型转换。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-284">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="ce7c1-285">代码示例会生成任何输出。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-285">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce7c1-286">
            <paramref name="type" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-286">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-287">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-287">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-288">
            <paramref name="method" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-288">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-289">
            <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-289">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="ce7c1-290">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-290">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-291">
            <paramref name="type" /> 不是 <see langword="RuntimeType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-291">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="ce7c1-292">请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-292">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="ce7c1-293">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-293">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-294">
            <paramref name="method" /> 不是一种静态方法，并且 .NET Framework 版本为 1.0 或 1.1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-294">
              <paramref name="method" /> is not a static method, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
          <span data-ttu-id="ce7c1-295">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-295">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-296">无法绑定 <paramref name="method" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-296">
              <paramref name="method" /> cannot be bound.</span>
          </span>
          <span data-ttu-id="ce7c1-297">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-297">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-298">
            <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-298">
              <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span>
          </span>
          <span data-ttu-id="ce7c1-299">请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-299">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="ce7c1-300">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-300">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="ce7c1-301">调用方没有访问 <paramref name="method" /> 所必需的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-301">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-302">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-302">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-303">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-303">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ce7c1-304">要创建的委托的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-304">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="firstArgument">
          <span data-ttu-id="ce7c1-305">委托要绑定到的对象，若要将 <paramref name="method" /> 作为 <see langword="static" />（在 Visual Basic 中为 <see langword="Shared" />），则为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-305">The object to which the delegate is bound, or <see langword="null" /> to treat <paramref name="method" /> as <see langword="static" /> (<see langword="Shared" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ce7c1-306">描述该委托要表示的静态或实例方法的 <see cref="T:System.Reflection.MethodInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-306">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-307">使用指定的第一个参数创建指定类型的委托，该委托表示指定的静态方法或实例方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-307">Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-308">指定类型的委托，表示指定的静态或实例方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-308">A delegate of the specified type that represents the specified static or instance method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-309">调用此方法重载是等效于调用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法重载并指定`true`为`throwOnBindFailure`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-309">Calling this method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload and specifying `true` for `throwOnBindFailure`.</span></span> <span data-ttu-id="ce7c1-310">这两个重载提供最灵活的方式来创建委托。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-310">These two overloads provide the most flexible way to create delegates.</span></span> <span data-ttu-id="ce7c1-311">若要创建委托的静态或实例方法，并可以选择指定的第一个参数，可以使用它们。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-311">You can use them to create delegates for either static or instance methods, and optionally to specify the first argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-312">如果未提供第一个参数，使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法重载，以更好的性能。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-312">If you do not supply a first argument, use the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload for better performance.</span></span>  
  
 <span data-ttu-id="ce7c1-313">委托类型和方法必须具有兼容返回类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-313">The delegate type and the method must have compatible return types.</span></span> <span data-ttu-id="ce7c1-314">返回类型，即`method`必须是可赋值的返回类型为`type`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-314">That is, the return type of `method` must be assignable to the return type of `type`.</span></span>  
  
 <span data-ttu-id="ce7c1-315">如果`firstArgument`是提供，将它传递到`method`每次调用委托时;`firstArgument`称为绑定到委托，委托是说要关闭通过其第一个参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-315">If `firstArgument` is supplied, it is passed to `method` every time the delegate is invoked; `firstArgument` is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</span></span> <span data-ttu-id="ce7c1-316">如果`method`是`static`(`Shared`在 Visual Basic 中)，则参数调用委托时提供的列表包括除第一个; 以外的所有参数，如果`method`然后是实例方法，`firstArgument`传递到隐藏的实例参数 (由`this`在 C# 中，或由`Me`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-316">If `method` is `static` (`Shared` in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if `method` is an instance method, then `firstArgument` is passed to the hidden instance parameter (represented by `this` in C#, or by `Me` in Visual Basic).</span></span>  
  
 <span data-ttu-id="ce7c1-317">如果`firstArgument`提供，则第一个参数`method`必须是引用类型，和`firstArgument`必须与该类型兼容。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-317">If `firstArgument` is supplied, the first parameter of `method` must be a reference type, and `firstArgument` must be compatible with that type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ce7c1-318">如果`method`是`static`(`Shared`在 Visual Basic 中) 且其第一个参数的类型<xref:System.Object>或<xref:System.ValueType>，然后`firstArgument`可以是值类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-318">If `method` is `static` (`Shared` in Visual Basic) and its first parameter is of type <xref:System.Object> or <xref:System.ValueType>, then `firstArgument` can be a value type.</span></span> <span data-ttu-id="ce7c1-319">在这种情况下`firstArgument`自动装箱。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-319">In this case `firstArgument` is automatically boxed.</span></span> <span data-ttu-id="ce7c1-320">自动装箱不会发生的任何其他参数，因为它将在 C# 或 Visual Basic 函数中调用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-320">Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</span></span>  
  
 <span data-ttu-id="ce7c1-321">如果`firstArgument`为 null 引用和`method`是实例方法，结果取决于委托类型的签名`type`和`method`:</span><span class="sxs-lookup"><span data-stu-id="ce7c1-321">If `firstArgument` is a null reference and `method` is an instance method, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="ce7c1-322">如果签名`type`显式包含的隐藏第一个参数`method`，则委托被称为来表示打开的实例方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-322">If the signature of `type` explicitly includes the hidden first parameter of `method`, the delegate is said to represent an open instance method.</span></span> <span data-ttu-id="ce7c1-323">当调用委托时，参数列表中的第一个参数传递到隐藏的实例参数`method`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-323">When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of `method`.</span></span>  
  
-   <span data-ttu-id="ce7c1-324">如果签名的`method`和`type`匹配 （也就是说，所有参数类型都是兼容），则委托称为关闭通过空引用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-324">If the signatures of `method` and `type` match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="ce7c1-325">调用委托就像不是特别有用的办法就的 null 实例上调用实例方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-325">Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</span></span>  
  
 <span data-ttu-id="ce7c1-326">如果`firstArgument`为 null 引用和`method`是静态的结果依赖于委托类型的签名`type`和`method`:</span><span class="sxs-lookup"><span data-stu-id="ce7c1-326">If `firstArgument` is a null reference and `method` is static, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="ce7c1-327">如果签名`method`和`type`匹配 （也就是说，所有参数类型都是兼容），则委托被称为来表示开放的静态方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-327">If the signature of `method` and `type` match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</span></span> <span data-ttu-id="ce7c1-328">这是最常见的情况对静态方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-328">This is the most common case for static methods.</span></span> <span data-ttu-id="ce7c1-329">在这种情况下，通过获取性能稍好<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-329">In this case, you can get slightly better performance by using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span>  
  
-   <span data-ttu-id="ce7c1-330">如果签名`type`开头的第二个参数`method`和参数类型的其余部分是兼容的设备，然后委托被称为封闭式 null 引用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-330">If the signature of `type` begins with the second parameter of `method` and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="ce7c1-331">调用委托时，将为 null 引用传递到的第一个参数`method`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-331">When the delegate is invoked, a null reference is passed to the first parameter of `method`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-332">从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-332">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="ce7c1-333">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="ce7c1-333">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ce7c1-334">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-334">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="ce7c1-335">兼容的参数类型和返回类型</span><span class="sxs-lookup"><span data-stu-id="ce7c1-335">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="ce7c1-336">参数类型和委托的返回类型必须与参数类型和委托表示; 方法的返回类型兼容类型不需要完全匹配。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-336">The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-337">在.NET Framework 1.0 和 1.1 版中，类型必须完全匹配。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-337">In the .NET Framework version 1.0 and 1.1, the types must match exactly.</span></span>  
  
 <span data-ttu-id="ce7c1-338">如果委托参数的类型的限制性强于方法参数的类型，则该委托的参数与该方法的相应参数兼容，因为这可保证传递给委托的参数可以安全地传递给方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-338">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="ce7c1-339">同样，如果方法的返回类型的限制性强于委托的返回类型，则该委托的返回类型与该方法的返回类型兼容，因为这可保证方法的返回值可以安全地强制转换为委托的返回类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-339">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="ce7c1-340">例如，一个委托，其类型的参数<xref:System.Collections.Hashtable>和返回类型为<xref:System.Object>可以表示具有类型的参数的方法<xref:System.Object>以及一个返回值类型的<xref:System.Collections.Hashtable>。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-340">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a><span data-ttu-id="ce7c1-341">确定方法委托可以表示</span><span class="sxs-lookup"><span data-stu-id="ce7c1-341">Determining the Methods a Delegate Can Represent</span></span>  
 <span data-ttu-id="ce7c1-342">另一个有用方法看作的灵活性方面的此重载的<xref:System.Delegate.CreateDelegate%2A>是任何给定的委托可以表示四个不同的方法签名和方法的类型 （静态和实例） 的组合。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-342">Another useful way to think of the flexibility provided by this overload of <xref:System.Delegate.CreateDelegate%2A> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</span></span> <span data-ttu-id="ce7c1-343">委托类型，请考虑`D`带有一个自变量类型的`C`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-343">Consider a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="ce7c1-344">以下介绍的方法`D`可以表示，因为它必须匹配在所有情况下忽略的返回类型：</span><span class="sxs-lookup"><span data-stu-id="ce7c1-344">The following describes the methods `D` can represent, ignoring the return type since it must match in all cases:</span></span>  
  
-   <span data-ttu-id="ce7c1-345">`D` 可以表示有且只有一个参数类型的任何实例方法`C`，无论实例方法属于哪种类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-345">`D` can represent any instance method that has exactly one argument of type `C`, regardless of what type the instance method belongs to.</span></span> <span data-ttu-id="ce7c1-346">当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`是类型的实例`method`属于，和结果委托所说，通过该实例关闭。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-346">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of the type `method` belongs to, and the resulting delegate is said to be closed over that instance.</span></span> <span data-ttu-id="ce7c1-347">(一般而言，`D`如果还可以通过 null 引用封闭`firstArgument`为 null 引用。)</span><span class="sxs-lookup"><span data-stu-id="ce7c1-347">(Trivially, `D` can also be closed over a null reference if `firstArgument` is a null reference.)</span></span>  
  
-   <span data-ttu-id="ce7c1-348">`D` 可以表示的实例方法`C`不带任何参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-348">`D` can represent an instance method of `C` that has no arguments.</span></span> <span data-ttu-id="ce7c1-349">当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`为 null 引用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-349">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="ce7c1-350">结果委托表示打开的实例方法，并且的实例`C`必须提供每次调用它时。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-350">The resulting delegate represents an open instance method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="ce7c1-351">`D` 可以表示采用一种参数类型的静态方法`C`，和方法可以属于任何类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-351">`D` can represent a static method that takes one argument of type `C`, and that method can belong to any type.</span></span> <span data-ttu-id="ce7c1-352">当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`为 null 引用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-352">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="ce7c1-353">结果委托表示开放的静态方法，并且的实例`C`必须提供每次调用它时。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-353">The resulting delegate represents an open static method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="ce7c1-354">`D` 可以表示所属类型的静态方法`F`并且有两个参数，类型为`F`并键入`C`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-354">`D` can represent a static method that belongs to type `F` and has two arguments, of type `F` and type `C`.</span></span> <span data-ttu-id="ce7c1-355">当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`的一个实例`F`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-355">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of `F`.</span></span> <span data-ttu-id="ce7c1-356">生成委托表示静态方法，通过该实例的关闭`F`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-356">The resulting delegate represents a static method that is closed over that instance of `F`.</span></span> <span data-ttu-id="ce7c1-357">请注意，在这种情况其中`F`和`C`属于同一类型、 静态方法有两个参数为该类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-357">Note that in the case where `F` and `C` are the same type, the static method has two arguments of that type.</span></span> <span data-ttu-id="ce7c1-358">(在这种情况下，`D`如果通过 null 引用封闭`firstArgument`为 null 引用。)</span><span class="sxs-lookup"><span data-stu-id="ce7c1-358">(In this case, `D` is closed over a null reference if `firstArgument` is a null reference.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce7c1-359">本部分包含三个代码示例。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-359">This section contains three code examples.</span></span> <span data-ttu-id="ce7c1-360">第一个示例演示了四种类型的可创建的委托： 关闭通过实例方法，通过实例方法，打开的静态方法，通过打开和关闭通过静态方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-360">The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</span></span>  
  
 <span data-ttu-id="ce7c1-361">第二个代码示例演示了兼容的参数类型和返回类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-361">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="ce7c1-362">第三个代码示例定义一个委托类型，并演示可以表示委托类型的所有方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-362">The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</span></span>  
  
 <span data-ttu-id="ce7c1-363">**示例 1**</span><span class="sxs-lookup"><span data-stu-id="ce7c1-363">**Example 1**</span></span>  
  
 <span data-ttu-id="ce7c1-364">下面的代码示例演示了可以使用此重载创建委托的四个方法<xref:System.Delegate.CreateDelegate%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-364">The following code example demonstrates the four ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-365">有两个重载<xref:System.Delegate.CreateDelegate%2A>指定的方法`firstArgument`和一个<xref:System.Reflection.MethodInfo>; 它们的功能相同，只一个允许您指定是否引发失败时要将绑定，而是其他总是引发。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-365">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="ce7c1-366">此代码示例使用两个重载。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-366">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="ce7c1-367">此示例声明一个类`C`使用静态方法`M2`和实例方法`M1`，和三个委托类型：`D1`的实例`C`和一个字符串，`D2`采用一个字符串，并`D3`没有参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-367">The example declares a class `C` with a static method `M2` and an instance method `M1`, and three delegate types: `D1` takes an instance of `C` and a string, `D2` takes a string, and `D3` has no arguments.</span></span>  
  
 <span data-ttu-id="ce7c1-368">名为第二个类`Example`包含创建委托的代码。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-368">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="ce7c1-369">类型的委托`D2`、 已关闭的实例`C`，为实例方法创建`M1`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-369">A delegate of type `D2`, closed over an instance of `C`, is created for the instance method `M1`.</span></span> <span data-ttu-id="ce7c1-370">使用不同的字符串，显示的绑定的实例调用`C`始终使用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-370">It is invoked with different strings, to show that the bound instance of `C` is always used.</span></span>  
  
-   <span data-ttu-id="ce7c1-371">类型的委托`D1`，表示打开的实例方法，为实例方法创建`M1`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-371">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="ce7c1-372">当调用委托时，必须传递实例。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-372">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="ce7c1-373">类型的委托`D2`，表示打开的静态方法，为静态方法创建`M2`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-373">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
-   <span data-ttu-id="ce7c1-374">最后，类型的委托`D3`、 已关闭的字符串上，为静态方法创建`M2`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-374">Finally, a delegate of type `D3`, closed over a string, is created for the static method `M2`.</span></span> <span data-ttu-id="ce7c1-375">调用方法以显示其使用的绑定的字符串。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-375">The method is invoked to show that it uses the bound string.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="ce7c1-376">**示例 2**</span><span class="sxs-lookup"><span data-stu-id="ce7c1-376">**Example 2**</span></span>  
  
 <span data-ttu-id="ce7c1-377">下面的代码示例演示了兼容性的参数类型和返回类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-377">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-378">此代码示例使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-378">This code example uses the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span> <span data-ttu-id="ce7c1-379">使用其他重载采用<xref:System.Reflection.MethodInfo>类似。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-379">The use of other overloads that take <xref:System.Reflection.MethodInfo> is similar.</span></span>  
  
 <span data-ttu-id="ce7c1-380">代码示例定义名为的基类`Base`和一个名为类`Derived`派生`Base`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-380">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="ce7c1-381">派生的类具有`static`(`Shared`在 Visual Basic 中) 名为方法`MyMethod`类型的一个参数与`Base`和返回类型为`Derived`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-381">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="ce7c1-382">代码示例还定义名为的委托`Example`它具有一个参数的类型`Derived`和返回类型为`Base`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-382">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="ce7c1-383">代码示例演示委托名为`Example`可以用来表示该方法`MyMethod`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-383">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="ce7c1-384">该方法可以绑定到委托，因为：</span><span class="sxs-lookup"><span data-stu-id="ce7c1-384">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="ce7c1-385">委托的参数类型 (`Derived`) 的参数类型比的限制性更强`MyMethod`(`Base`)，以便它始终是安全传递到委托的自变量`MyMethod`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-385">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="ce7c1-386">返回类型`MyMethod`(`Derived`) 是限制性强于委托的参数类型 (`Base`)，以便它始终是安全的委托的返回类型的方法的返回类型转换。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-386">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="ce7c1-387">代码示例会生成任何输出。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-387">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 <span data-ttu-id="ce7c1-388">**示例 3**</span><span class="sxs-lookup"><span data-stu-id="ce7c1-388">**Example 3**</span></span>  
  
 <span data-ttu-id="ce7c1-389">下面的代码示例显示了所有方法的单个的委托类型可以表示使用<xref:System.Delegate.CreateDelegate%2A>方法来创建委托。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-389">The following code example shows all the methods a single delegate type can represent, using the <xref:System.Delegate.CreateDelegate%2A> method to create the delegates.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-390">有两个重载<xref:System.Delegate.CreateDelegate%2A>指定的方法`firstArgument`和一个<xref:System.Reflection.MethodInfo>; 它们的功能相同，只一个允许您指定是否引发失败时要将绑定，而是其他总是引发。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-390">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="ce7c1-391">此代码示例使用两个重载。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-391">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="ce7c1-392">代码示例定义两个类：`C`并`F`，和委托类型`D`带有一个自变量类型的`C`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-392">The code example defines two classes, `C` and `F`, and a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="ce7c1-393">类具有匹配的静态和实例方法`M1`， `M3`，并`M4`，和类`C`还具有实例方法`M2`不带任何参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-393">The classes have matching static and instance methods `M1`, `M3`, and `M4`, and class `C` also has an instance method `M2` that has no arguments.</span></span>  
  
 <span data-ttu-id="ce7c1-394">名为第三个类`Example`包含创建委托的代码。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-394">A third class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="ce7c1-395">委托实例创建方法`M1`类型的`C`并键入`F`; 每个已关闭对相应类型的实例。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-395">Delegates are created for instance method `M1` of type `C` and type `F`; each is closed over an instance of the respective type.</span></span> <span data-ttu-id="ce7c1-396">方法`M1`类型的`C`显示`ID`属性的绑定实例和自变量。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-396">Method `M1` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
-   <span data-ttu-id="ce7c1-397">方法创建委托`M2`类型的`C`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-397">A delegate is created for method `M2` of type `C`.</span></span> <span data-ttu-id="ce7c1-398">这是一个开放的实例的委托，委托自变量表示实例方法的隐藏第一个参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-398">This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</span></span> <span data-ttu-id="ce7c1-399">该方法具有任何其他参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-399">The method has no other arguments.</span></span> <span data-ttu-id="ce7c1-400">调用，就好像静态方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-400">It is called as if it were a static method.</span></span>  
  
-   <span data-ttu-id="ce7c1-401">为静态方法创建委托`M3`类型的`C`并键入`F`; 这些是打开的静态委托。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-401">Delegates are created for static method `M3` of type `C` and type `F`; these are open static delegates.</span></span>  
  
-   <span data-ttu-id="ce7c1-402">最后，为静态方法创建委托`M4`类型的`C`并键入`F`; 每个方法具有作为其第一个参数的声明类型和提供的类型的实例，因此委托关闭通过其第一个参数.</span><span class="sxs-lookup"><span data-stu-id="ce7c1-402">Finally, delegates are created for static method `M4` of type `C` and type `F`; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</span></span> <span data-ttu-id="ce7c1-403">方法`M4`类型的`C`显示`ID`属性的绑定实例和自变量。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-403">Method `M4` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce7c1-404">
            <paramref name="type" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-404">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-405">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-405">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-406">
            <paramref name="method" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-406">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-407">
            <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-407">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="ce7c1-408">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-408">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-409">
            <paramref name="type" /> 不是 <see langword="RuntimeType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-409">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="ce7c1-410">请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-410">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="ce7c1-411">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-411">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-412">无法绑定 <paramref name="method" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-412">
              <paramref name="method" /> cannot be bound.</span>
          </span>
          <span data-ttu-id="ce7c1-413">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-413">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-414">
            <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-414">
              <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span>
          </span>
          <span data-ttu-id="ce7c1-415">请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-415">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="ce7c1-416">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-416">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="ce7c1-417">调用方没有访问 <paramref name="method" /> 所必需的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-417">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-418">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-418">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-419">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-419">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ce7c1-420">要创建的委托的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-420">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="ce7c1-421">类实例，对其调用 <paramref name="method" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-421">The class instance on which <paramref name="method" /> is invoked.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ce7c1-422">委托要表示的实例方法的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-422">The name of the instance method that the delegate is to represent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-423">创建指定类型的委托，该委托表示要对指定的类实例调用的指定实例方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-423">Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-424">指定的类型的委托，表示要对指定的类实例调用的指定的实例方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-424">A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-425">此方法创建委托实例仅方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-425">This method creates delegates for instance methods only.</span></span> <span data-ttu-id="ce7c1-426">另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-426">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="ce7c1-427">此方法的重载是等效于调用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法重载，指定`false`有关`ignoreCase`并`true`为`throwOnBindFailure`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-427">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `false` for `ignoreCase` and `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-428">从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-428">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="ce7c1-429">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="ce7c1-429">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ce7c1-430">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-430">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce7c1-431">
            <paramref name="type" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-431">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-432">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-432">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-433">
            <paramref name="target" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-433">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-434">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-434">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-435">
            <paramref name="method" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-435">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-436">
            <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-436">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="ce7c1-437">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-437">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-438">
            <paramref name="type" /> 不是 <see langword="RuntimeType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-438">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="ce7c1-439">请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-439">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="ce7c1-440">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-440">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-441">
            <paramref name="method" /> 不是实例方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-441">
              <paramref name="method" /> is not an instance method.</span>
          </span>
          <span data-ttu-id="ce7c1-442">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-442">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-443">无法绑定 <paramref name="method" />，例如因为找不到它。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-443">
              <paramref name="method" /> cannot be bound, for example because it cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="ce7c1-444">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-444">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="ce7c1-445">调用方没有访问 <paramref name="method" /> 所必需的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-445">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-446">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-446">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-447">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-447">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ce7c1-448">要创建的委托的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-448">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ce7c1-449">描述该委托要表示的静态或实例方法的 <see cref="T:System.Reflection.MethodInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-449">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span>
          </span>
        </param>
        <param name="throwOnBindFailure">
          <span data-ttu-id="ce7c1-450">如果无法绑定 <paramref name="method" /> 时引发异常，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-450">
              <see langword="true" /> to throw an exception if <paramref name="method" /> cannot be bound; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-451">使用针对绑定失败的指定行为，创建用于表示指定静态方法的指定类型的委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-451">Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-452">表示指定静态方法的指定类型的委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-452">A delegate of the specified type to represent the specified static method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-453">此方法的重载可以创建开放的静态方法的委托并打开实例方法委托，公开的隐藏第一个参数的委托，它是实例方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-453">This method overload can create open static method delegates and open instance method delegates — that is, delegates that expose the hidden first argument of instance methods.</span></span> <span data-ttu-id="ce7c1-454">有关的详细说明，请参阅更多常规<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法重载，它允许你创建的打开或关闭委托的所有组合实例或静态方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-454">For a detailed explanation, see the more general <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-455">此方法应使用重载时委托未关闭通过其第一个参数，因为它在这种情况下是某种程度上更快。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-455">This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-456">从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-456">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="ce7c1-457">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="ce7c1-457">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ce7c1-458">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-458">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="ce7c1-459">兼容的参数类型和返回类型</span><span class="sxs-lookup"><span data-stu-id="ce7c1-459">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="ce7c1-460">参数类型和委托的返回类型必须与参数类型和委托表示; 方法的返回类型兼容类型不需要完全匹配。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-460">The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-461">在.NET Framework 1.0 和 1.1 版中，类型必须完全匹配。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-461">In the .NET Framework version 1.0 and 1.1, the types must match exactly.</span></span>  
  
 <span data-ttu-id="ce7c1-462">如果委托参数的类型的限制性强于方法参数的类型，则该委托的参数与该方法的相应参数兼容，因为这可保证传递给委托的参数可以安全地传递给方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-462">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="ce7c1-463">同样，如果方法的返回类型的限制性强于委托的返回类型，则该委托的返回类型与该方法的返回类型兼容，因为这可保证方法的返回值可以安全地强制转换为委托的返回类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-463">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="ce7c1-464">例如，一个委托，其类型的参数<xref:System.Collections.Hashtable>和返回类型为<xref:System.Object>可以表示具有类型的参数的方法<xref:System.Object>以及一个返回值类型的<xref:System.Collections.Hashtable>。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-464">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce7c1-465">本部分包含两个代码示例。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-465">This section contains two code examples.</span></span> <span data-ttu-id="ce7c1-466">第一个示例演示两种类型的委托可以使用此方法的重载来创建： 打开通过实例方法，并通过静态方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-466">The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</span></span>  
  
 <span data-ttu-id="ce7c1-467">第二个代码示例演示了兼容的参数类型和返回类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-467">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="ce7c1-468">**示例 1**</span><span class="sxs-lookup"><span data-stu-id="ce7c1-468">**Example 1**</span></span>  
  
 <span data-ttu-id="ce7c1-469">下面的代码示例演示了可以使用此重载创建委托的两种方法<xref:System.Delegate.CreateDelegate%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-469">The following code example demonstrates the two ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-470">有两个重载<xref:System.Delegate.CreateDelegate%2A>方法指定<xref:System.Reflection.MethodInfo>，但不是第一个参数; 它们的功能相同，只一个允许您指定是否引发失败时要将绑定，而是其他总是引发。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-470">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify a <xref:System.Reflection.MethodInfo> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="ce7c1-471">此代码示例使用两个重载。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-471">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="ce7c1-472">此示例声明一个类`C`静态方法一起`M2`和实例方法`M1`，和两个委托类型：`D1`的实例`C`和一个字符串，和`D2`采用一个字符串。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-472">The example declares a class `C` with a static method `M2` and an instance method `M1`, and two delegate types: `D1` takes an instance of `C` and a string, and `D2` takes a string.</span></span>  
  
 <span data-ttu-id="ce7c1-473">名为第二个类`Example`包含创建委托的代码。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-473">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="ce7c1-474">类型的委托`D1`，表示打开的实例方法，为实例方法创建`M1`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-474">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="ce7c1-475">当调用委托时，必须传递实例。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-475">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="ce7c1-476">类型的委托`D2`，表示打开的静态方法，为静态方法创建`M2`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-476">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="ce7c1-477">**示例 2**</span><span class="sxs-lookup"><span data-stu-id="ce7c1-477">**Example 2**</span></span>  
  
 <span data-ttu-id="ce7c1-478">下面的代码示例演示了兼容性的参数类型和返回类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-478">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-479">此代码示例使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-479">This code example uses the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span> <span data-ttu-id="ce7c1-480">使用其他重载采用<xref:System.Reflection.MethodInfo>类似。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-480">The use of other overloads that take <xref:System.Reflection.MethodInfo> is similar.</span></span>  
  
 <span data-ttu-id="ce7c1-481">代码示例定义名为的基类`Base`和一个名为类`Derived`派生`Base`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-481">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="ce7c1-482">派生的类具有`static`(`Shared`在 Visual Basic 中) 名为方法`MyMethod`类型的一个参数与`Base`和返回类型为`Derived`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-482">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="ce7c1-483">代码示例还定义名为的委托`Example`它具有一个参数的类型`Derived`和返回类型为`Base`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-483">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="ce7c1-484">代码示例演示委托名为`Example`可以用来表示该方法`MyMethod`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-484">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="ce7c1-485">该方法可以绑定到委托，因为：</span><span class="sxs-lookup"><span data-stu-id="ce7c1-485">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="ce7c1-486">委托的参数类型 (`Derived`) 的参数类型比的限制性更强`MyMethod`(`Base`)，以便它始终是安全传递到委托的自变量`MyMethod`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-486">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="ce7c1-487">返回类型`MyMethod`(`Derived`) 是限制性强于委托的参数类型 (`Base`)，以便它始终是安全的委托的返回类型的方法的返回类型转换。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-487">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="ce7c1-488">代码示例会生成任何输出。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-488">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce7c1-489">
            <paramref name="type" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-489">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-490">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-490">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-491">
            <paramref name="method" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-491">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-492">
            <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-492">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="ce7c1-493">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-493">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-494">
            <paramref name="type" /> 不是 <see langword="RuntimeType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-494">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="ce7c1-495">请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-495">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="ce7c1-496">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-496">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-497">无法绑定 <paramref name="method" />，且 <paramref name="throwOnBindFailure" /> 为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-497">
              <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span>
          </span>
          <span data-ttu-id="ce7c1-498">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-498">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-499">
            <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-499">
              <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span>
          </span>
          <span data-ttu-id="ce7c1-500">请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-500">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="ce7c1-501">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-501">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="ce7c1-502">调用方没有访问 <paramref name="method" /> 所必需的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-502">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-503">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-503">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-504">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-504">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ce7c1-505">要创建的委托的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-505">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="ce7c1-506">表示实现 <paramref name="method" /> 的类的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-506">The <see cref="T:System.Type" /> representing the class that implements <paramref name="method" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ce7c1-507">委托要表示的静态方法的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-507">The name of the static method that the delegate is to represent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-508">创建指定类型的委托，该委托表示指定类的指定静态方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-508">Creates a delegate of the specified type that represents the specified static method of the specified class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-509">指定类型的委托，该委托表示指定类的指定静态方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-509">A delegate of the specified type that represents the specified static method of the specified class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-510">此方法创建委托只为静态方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-510">This method creates delegates for static methods only.</span></span> <span data-ttu-id="ce7c1-511">另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-511">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="ce7c1-512">此方法的重载是等效于调用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法重载，指定`false`有关`ignoreCase`并`true`为`throwOnBindFailure`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-512">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `false` for `ignoreCase` and `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-513">从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-513">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="ce7c1-514">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="ce7c1-514">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ce7c1-515">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-515">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce7c1-516">
            <paramref name="type" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-516">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-517">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-517">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-518">
            <paramref name="target" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-518">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-519">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-519">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-520">
            <paramref name="method" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-520">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-521">
            <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-521">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="ce7c1-522">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-522">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-523">
            <paramref name="type" /> 不是 <see langword="RuntimeType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-523">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="ce7c1-524">请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-524">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="ce7c1-525">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-525">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-526">
            <paramref name="target" /> 不是 <see langword="RuntimeType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-526">
              <paramref name="target" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="ce7c1-527">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-527">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-528">
            <paramref name="target" /> 为开放式泛型类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-528">
              <paramref name="target" /> is an open generic type.</span>
          </span>
          <span data-ttu-id="ce7c1-529">也就是说，其 <see cref="P:System.Type.ContainsGenericParameters" /> 属性为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-529">That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</span>
          </span>
          <span data-ttu-id="ce7c1-530">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-530">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-531">
            <paramref name="method" /> 不是 <see langword="static" /> 方法（在 Visual Basic 中为 <see langword="Shared" /> 方法）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-531">
              <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).</span>
          </span>
          <span data-ttu-id="ce7c1-532">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-532">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-533">无法绑定 <paramref name="method" />，例如因为找不到它，并且 <paramref name="throwOnBindFailure" /> 为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-533">
              <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="ce7c1-534">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-534">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="ce7c1-535">调用方没有访问 <paramref name="method" /> 所必需的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-535">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-536">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-536">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-537">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-537">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ce7c1-538">一个 <see cref="T:System.Type" />，表示要创建的委托类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-538">A <see cref="T:System.Type" /> representing the type of delegate to create.</span>
          </span>
        </param>
        <param name="firstArgument">
          <span data-ttu-id="ce7c1-539">一个 <see cref="T:System.Object" />，它是委托表示的方法的第一个参数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-539">An <see cref="T:System.Object" /> that is the first argument of the method the delegate represents.</span>
          </span>
          <span data-ttu-id="ce7c1-540">对于实例方法，它必须与实例类型兼容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-540">For instance methods, it must be compatible with the instance type.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ce7c1-541">描述该委托要表示的静态或实例方法的 <see cref="T:System.Reflection.MethodInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-541">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span>
          </span>
        </param>
        <param name="throwOnBindFailure">
          <span data-ttu-id="ce7c1-542">如果无法绑定 <paramref name="method" /> 时引发异常，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-542">
              <see langword="true" /> to throw an exception if <paramref name="method" /> cannot be bound; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-543">使用指定的第一个自变量和针对绑定失败的指定行为，创建表示指定的静态方法或实例方法的指定类型的委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-543">Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-544">表示指定静态方法或实例方法的指定类型的委托；如果 <paramref name="throwOnBindFailure" /> 为 <see langword="false" />，并且委托无法绑定到 <paramref name="method" />，则为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-544">A delegate of the specified type that represents the specified static or instance method, or <see langword="null" /> if <paramref name="throwOnBindFailure" /> is <see langword="false" /> and the delegate cannot be bound to <paramref name="method" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-545">此方法的重载和<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29>方法重载，它总是引发绑定失败，提供最灵活的方式来创建委托。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-545">This method overload and the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> method overload, which always throws on failure to bind, provide the most flexible way to create delegates.</span></span> <span data-ttu-id="ce7c1-546">可以使用它们来创建委托的静态或实例方法，无论第一个参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-546">You can use them to create delegates for either static or instance methods, with or without a first argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-547">如果未提供第一个参数，使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法重载，以更好的性能。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-547">If you do not supply a first argument, use the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload for better performance.</span></span>  
  
 <span data-ttu-id="ce7c1-548">委托类型和方法必须具有兼容返回类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-548">The delegate type and the method must have compatible return types.</span></span> <span data-ttu-id="ce7c1-549">返回类型，即`method`必须是可赋值的返回类型为`type`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-549">That is, the return type of `method` must be assignable to the return type of `type`.</span></span>  
  
 <span data-ttu-id="ce7c1-550">如果`firstArgument`是提供，将它传递到`method`每次调用委托时;`firstArgument`称为绑定到委托，委托是说要关闭通过其第一个参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-550">If `firstArgument` is supplied, it is passed to `method` every time the delegate is invoked; `firstArgument` is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</span></span> <span data-ttu-id="ce7c1-551">如果`method`是`static`(`Shared`在 Visual Basic 中)，则参数调用委托时提供的列表包括除第一个; 以外的所有参数，如果`method`然后是实例方法，`firstArgument`传递到隐藏的实例参数 (由`this`在 C# 中，或由`Me`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-551">If `method` is `static` (`Shared` in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if `method` is an instance method, then `firstArgument` is passed to the hidden instance parameter (represented by `this` in C#, or by `Me` in Visual Basic).</span></span>  
  
 <span data-ttu-id="ce7c1-552">如果`firstArgument`提供，则第一个参数`method`必须是引用类型，和`firstArgument`必须与该类型兼容。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-552">If `firstArgument` is supplied, the first parameter of `method` must be a reference type, and `firstArgument` must be compatible with that type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ce7c1-553">如果`method`是`static`(`Shared`在 Visual Basic 中) 且其第一个参数的类型<xref:System.Object>或<xref:System.ValueType>，然后`firstArgument`可以是值类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-553">If `method` is `static` (`Shared` in Visual Basic) and its first parameter is of type <xref:System.Object> or <xref:System.ValueType>, then `firstArgument` can be a value type.</span></span> <span data-ttu-id="ce7c1-554">在这种情况下`firstArgument`自动装箱。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-554">In this case `firstArgument` is automatically boxed.</span></span> <span data-ttu-id="ce7c1-555">自动装箱不会发生的任何其他参数，因为它将在 C# 或 Visual Basic 函数中调用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-555">Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</span></span>  
  
 <span data-ttu-id="ce7c1-556">如果`firstArgument`为 null 引用和`method`是实例方法，结果取决于委托类型的签名`type`和`method`:</span><span class="sxs-lookup"><span data-stu-id="ce7c1-556">If `firstArgument` is a null reference and `method` is an instance method, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="ce7c1-557">如果签名`type`显式包含的隐藏第一个参数`method`，则委托被称为来表示打开的实例方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-557">If the signature of `type` explicitly includes the hidden first parameter of `method`, the delegate is said to represent an open instance method.</span></span> <span data-ttu-id="ce7c1-558">当调用委托时，参数列表中的第一个参数传递到隐藏的实例参数`method`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-558">When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of `method`.</span></span>  
  
-   <span data-ttu-id="ce7c1-559">如果签名的`method`和`type`匹配 （也就是说，所有参数类型都是兼容），则委托称为关闭通过空引用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-559">If the signatures of `method` and `type` match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="ce7c1-560">调用委托就像不是特别有用的办法就的 null 实例上调用实例方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-560">Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</span></span>  
  
 <span data-ttu-id="ce7c1-561">如果`firstArgument`为 null 引用和`method`是静态的结果依赖于委托类型的签名`type`和`method`:</span><span class="sxs-lookup"><span data-stu-id="ce7c1-561">If `firstArgument` is a null reference and `method` is static, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="ce7c1-562">如果签名`method`和`type`匹配 （也就是说，所有参数类型都是兼容），则委托被称为来表示开放的静态方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-562">If the signature of `method` and `type` match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</span></span> <span data-ttu-id="ce7c1-563">这是最常见的情况对静态方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-563">This is the most common case for static methods.</span></span> <span data-ttu-id="ce7c1-564">在这种情况下，通过获取性能稍好<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-564">In this case, you can get slightly better performance by using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload.</span></span>  
  
-   <span data-ttu-id="ce7c1-565">如果签名`type`开头的第二个参数`method`和参数类型的其余部分是兼容的设备，然后委托被称为封闭式 null 引用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-565">If the signature of `type` begins with the second parameter of `method` and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="ce7c1-566">调用委托时，将为 null 引用传递到的第一个参数`method`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-566">When the delegate is invoked, a null reference is passed to the first parameter of `method`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-567">从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-567">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="ce7c1-568">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="ce7c1-568">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ce7c1-569">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-569">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="ce7c1-570">兼容的参数类型和返回类型</span><span class="sxs-lookup"><span data-stu-id="ce7c1-570">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="ce7c1-571">参数类型和委托的返回类型必须与参数类型和委托表示; 方法的返回类型兼容类型不需要完全匹配。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-571">The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-572">.NET Framework 1.0 和 1.1 版中的类型必须完全匹配。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-572">In the .NET Framework version 1.0 and 1.1 the types must match exactly.</span></span>  
  
 <span data-ttu-id="ce7c1-573">如果委托参数的类型的限制性强于方法参数的类型，则该委托的参数与该方法的相应参数兼容，因为这可保证传递给委托的参数可以安全地传递给方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-573">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="ce7c1-574">同样，如果方法的返回类型的限制性强于委托的返回类型，则该委托的返回类型与该方法的返回类型兼容，因为这可保证方法的返回值可以安全地强制转换为委托的返回类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-574">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="ce7c1-575">例如，一个委托，其类型的参数<xref:System.Collections.Hashtable>和返回类型为<xref:System.Object>可以表示具有类型的参数的方法<xref:System.Object>以及一个返回值类型的<xref:System.Collections.Hashtable>。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-575">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a><span data-ttu-id="ce7c1-576">确定方法委托可以表示</span><span class="sxs-lookup"><span data-stu-id="ce7c1-576">Determining the Methods a Delegate Can Represent</span></span>  
 <span data-ttu-id="ce7c1-577">另一个有用方法看作的灵活性方面的此重载的<xref:System.Delegate.CreateDelegate%2A>是任何给定的委托可以表示四个不同的方法签名和方法的类型 （静态和实例） 的组合。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-577">Another useful way to think of the flexibility provided by this overload of <xref:System.Delegate.CreateDelegate%2A> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</span></span> <span data-ttu-id="ce7c1-578">委托类型，请考虑`D`带有一个自变量类型的`C`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-578">Consider a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="ce7c1-579">以下介绍的方法`D`可以表示，因为它必须匹配在所有情况下忽略的返回类型：</span><span class="sxs-lookup"><span data-stu-id="ce7c1-579">The following describes the methods `D` can represent, ignoring the return type since it must match in all cases:</span></span>  
  
-   <span data-ttu-id="ce7c1-580">`D` 可以表示有且只有一个参数类型的任何实例方法`C`，无论实例方法属于哪种类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-580">`D` can represent any instance method that has exactly one argument of type `C`, regardless of what type the instance method belongs to.</span></span> <span data-ttu-id="ce7c1-581">当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`是类型的实例`method`属于，和结果委托所说，通过该实例关闭。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-581">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of the type `method` belongs to, and the resulting delegate is said to be closed over that instance.</span></span> <span data-ttu-id="ce7c1-582">(一般而言，`D`如果还可以通过 null 引用封闭`firstArgument`是`null`。)</span><span class="sxs-lookup"><span data-stu-id="ce7c1-582">(Trivially, `D` can also be closed over a null reference if `firstArgument` is `null`.)</span></span>  
  
-   <span data-ttu-id="ce7c1-583">`D` 可以表示的实例方法`C`不带任何参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-583">`D` can represent an instance method of `C` that has no arguments.</span></span> <span data-ttu-id="ce7c1-584">当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`为 null 引用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-584">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="ce7c1-585">结果委托表示打开的实例方法，并且的实例`C`必须提供每次调用它时。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-585">The resulting delegate represents an open instance method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="ce7c1-586">`D` 可以表示采用一种参数类型的静态方法`C`，和方法可以属于任何类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-586">`D` can represent a static method that takes one argument of type `C`, and that method can belong to any type.</span></span> <span data-ttu-id="ce7c1-587">当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`为 null 引用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-587">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="ce7c1-588">结果委托表示开放的静态方法，并且的实例`C`必须提供每次调用它时。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-588">The resulting delegate represents an open static method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="ce7c1-589">`D` 可以表示所属类型的静态方法`F`并且有两个参数，类型为`F`并键入`C`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-589">`D` can represent a static method that belongs to type `F` and has two arguments, of type `F` and type `C`.</span></span> <span data-ttu-id="ce7c1-590">当<xref:System.Delegate.CreateDelegate%2A>调用时，`firstArgument`的一个实例`F`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-590">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of `F`.</span></span> <span data-ttu-id="ce7c1-591">生成委托表示静态方法，通过该实例的关闭`F`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-591">The resulting delegate represents a static method that is closed over that instance of `F`.</span></span> <span data-ttu-id="ce7c1-592">请注意，在这种情况其中`F`和`C`属于同一类型、 静态方法有两个参数为该类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-592">Note that in the case where `F` and `C` are the same type, the static method has two arguments of that type.</span></span> <span data-ttu-id="ce7c1-593">(在这种情况下，`D`如果通过 null 引用封闭`firstArgument`是`null`。)</span><span class="sxs-lookup"><span data-stu-id="ce7c1-593">(In this case, `D` is closed over a null reference if `firstArgument` is `null`.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce7c1-594">本部分包含三个代码示例。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-594">This section contains three code examples.</span></span> <span data-ttu-id="ce7c1-595">第一个示例演示了四种类型的可创建的委托： 关闭通过实例方法，通过实例方法，打开的静态方法，通过打开和关闭通过静态方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-595">The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</span></span>  
  
 <span data-ttu-id="ce7c1-596">第二个代码示例演示了兼容的参数类型和返回类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-596">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="ce7c1-597">第三个代码示例定义一个委托类型，并演示可以表示委托类型的所有方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-597">The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</span></span>  
  
 <span data-ttu-id="ce7c1-598">**示例 1**</span><span class="sxs-lookup"><span data-stu-id="ce7c1-598">**Example 1**</span></span>  
  
 <span data-ttu-id="ce7c1-599">下面的代码示例演示了可以使用此重载创建委托的四个方法<xref:System.Delegate.CreateDelegate%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-599">The following code example demonstrates the four ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-600">有两个重载<xref:System.Delegate.CreateDelegate%2A>指定的方法`firstArgument`和一个<xref:System.Reflection.MethodInfo>; 它们的功能相同，只一个允许您指定是否引发失败时要将绑定，而是其他总是引发。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-600">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="ce7c1-601">此代码示例使用两个重载。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-601">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="ce7c1-602">此示例声明一个类`C`使用静态方法`M2`和实例方法`M1`，和三个委托类型：`D1`的实例`C`和一个字符串，`D2`采用一个字符串，并`D3`没有参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-602">The example declares a class `C` with a static method `M2` and an instance method `M1`, and three delegate types: `D1` takes an instance of `C` and a string, `D2` takes a string, and `D3` has no arguments.</span></span>  
  
 <span data-ttu-id="ce7c1-603">名为第二个类`Example`包含创建委托的代码。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-603">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="ce7c1-604">类型的委托`D2`、 已关闭的实例`C`，为实例方法创建`M1`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-604">A delegate of type `D2`, closed over an instance of `C`, is created for the instance method `M1`.</span></span> <span data-ttu-id="ce7c1-605">使用不同的字符串，显示的绑定的实例调用`C`始终使用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-605">It is invoked with different strings, to show that the bound instance of `C` is always used.</span></span>  
  
-   <span data-ttu-id="ce7c1-606">类型的委托`D1`，表示打开的实例方法，为实例方法创建`M1`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-606">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="ce7c1-607">当调用委托时，必须传递实例。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-607">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="ce7c1-608">类型的委托`D2`，表示打开的静态方法，为静态方法创建`M2`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-608">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
-   <span data-ttu-id="ce7c1-609">最后，类型的委托`D3`、 已关闭的字符串上，为静态方法创建`M2`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-609">Finally, a delegate of type `D3`, closed over a string, is created for the static method `M2`.</span></span> <span data-ttu-id="ce7c1-610">调用方法以显示其使用的绑定的字符串。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-610">The method is invoked to show that it uses the bound string.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="ce7c1-611">**示例 2**</span><span class="sxs-lookup"><span data-stu-id="ce7c1-611">**Example 2**</span></span>  
  
 <span data-ttu-id="ce7c1-612">下面的代码示例演示了兼容性的参数类型和返回类型。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-612">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-613">此代码示例使用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-613">This code example uses the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span> <span data-ttu-id="ce7c1-614">使用其他重载采用<xref:System.Reflection.MethodInfo>类似。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-614">The use of other overloads that take <xref:System.Reflection.MethodInfo> is similar.</span></span>  
  
 <span data-ttu-id="ce7c1-615">代码示例定义名为的基类`Base`和一个名为类`Derived`派生`Base`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-615">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="ce7c1-616">派生的类具有`static`(`Shared`在 Visual Basic 中) 名为方法`MyMethod`类型的一个参数与`Base`和返回类型为`Derived`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-616">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="ce7c1-617">代码示例还定义名为的委托`Example`它具有一个参数的类型`Derived`和返回类型为`Base`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-617">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="ce7c1-618">代码示例演示委托名为`Example`可以用来表示该方法`MyMethod`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-618">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="ce7c1-619">该方法可以绑定到委托，因为：</span><span class="sxs-lookup"><span data-stu-id="ce7c1-619">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="ce7c1-620">委托的参数类型 (`Derived`) 的参数类型比的限制性更强`MyMethod`(`Base`)，以便它始终是安全传递到委托的自变量`MyMethod`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-620">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="ce7c1-621">返回类型`MyMethod`(`Derived`) 是限制性强于委托的参数类型 (`Base`)，以便它始终是安全的委托的返回类型的方法的返回类型转换。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-621">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="ce7c1-622">代码示例会生成任何输出。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-622">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 <span data-ttu-id="ce7c1-623">**示例 3**</span><span class="sxs-lookup"><span data-stu-id="ce7c1-623">**Example 3**</span></span>  
  
 <span data-ttu-id="ce7c1-624">下面的代码示例显示了一个委托类型可以表示的所有方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-624">The following code example shows all the methods a single delegate type can represent.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-625">有两个重载<xref:System.Delegate.CreateDelegate%2A>指定的方法`firstArgument`和一个<xref:System.Reflection.MethodInfo>; 它们的功能相同，只一个允许您指定是否引发失败时要将绑定，而是其他总是引发。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-625">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="ce7c1-626">此代码示例使用两个重载。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-626">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="ce7c1-627">代码示例定义两个类：`C`并`F`，和委托类型`D`带有一个自变量类型的`C`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-627">The code example defines two classes, `C` and `F`, and a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="ce7c1-628">类具有匹配的静态和实例方法`M1`， `M3`，并`M4`，和类`C`还具有实例方法`M2`不带任何参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-628">The classes have matching static and instance methods `M1`, `M3`, and `M4`, and class `C` also has an instance method `M2` that has no arguments.</span></span>  
  
 <span data-ttu-id="ce7c1-629">名为第三个类`Example`包含创建委托的代码。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-629">A third class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="ce7c1-630">委托实例创建方法`M1`类型的`C`并键入`F`; 每个已关闭对相应类型的实例。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-630">Delegates are created for instance method `M1` of type `C` and type `F`; each is closed over an instance of the respective type.</span></span> <span data-ttu-id="ce7c1-631">方法`M1`类型的`C`显示`ID`属性的绑定实例和自变量。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-631">Method `M1` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
-   <span data-ttu-id="ce7c1-632">方法创建委托`M2`类型的`C`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-632">A delegate is created for method `M2` of type `C`.</span></span> <span data-ttu-id="ce7c1-633">这是一个开放的实例的委托，委托自变量表示实例方法的隐藏第一个参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-633">This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</span></span> <span data-ttu-id="ce7c1-634">该方法具有任何其他参数。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-634">The method has no other arguments.</span></span>  
  
-   <span data-ttu-id="ce7c1-635">为静态方法创建委托`M3`类型的`C`并键入`F`; 这些是打开的静态委托。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-635">Delegates are created for static method `M3` of type `C` and type `F`; these are open static delegates.</span></span>  
  
-   <span data-ttu-id="ce7c1-636">最后，为静态方法创建委托`M4`类型的`C`并键入`F`; 每个方法具有作为其第一个参数的声明类型和提供的类型的实例，因此委托关闭通过其第一个参数.</span><span class="sxs-lookup"><span data-stu-id="ce7c1-636">Finally, delegates are created for static method `M4` of type `C` and type `F`; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</span></span> <span data-ttu-id="ce7c1-637">方法`M4`类型的`C`显示`ID`属性的绑定实例和自变量。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-637">Method `M4` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce7c1-638">
            <paramref name="type" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-638">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-639">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-639">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-640">
            <paramref name="method" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-640">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-641">
            <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-641">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="ce7c1-642">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-642">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-643">
            <paramref name="type" /> 不是 <see langword="RuntimeType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-643">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="ce7c1-644">请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-644">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="ce7c1-645">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-645">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-646">无法绑定 <paramref name="method" />，且 <paramref name="throwOnBindFailure" /> 为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-646">
              <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span>
          </span>
          <span data-ttu-id="ce7c1-647">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-647">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-648">
            <paramref name="method" /> 不是 <see langword="RuntimeMethodInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-648">
              <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span>
          </span>
          <span data-ttu-id="ce7c1-649">请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-649">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="ce7c1-650">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-650">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="ce7c1-651">调用方没有访问 <paramref name="method" /> 所必需的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-651">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-652">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-652">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-653">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-653">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ce7c1-654">要创建的委托的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-654">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="ce7c1-655">类实例，对其调用 <paramref name="method" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-655">The class instance on which <paramref name="method" /> is invoked.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ce7c1-656">委托要表示的实例方法的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-656">The name of the instance method that the delegate is to represent.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="ce7c1-657">一个布尔值，它指示在比较方法名称时是否忽略大小写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-657">A Boolean indicating whether to ignore the case when comparing the name of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-658">创建指定类型的委托，该委托表示要按指定的大小写敏感度对指定类实例调用的指定实例方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-658">Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-659">指定的类型的委托，表示要对指定的类实例调用的指定的实例方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-659">A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-660">此方法创建委托实例仅方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-660">This method creates delegates for instance methods only.</span></span> <span data-ttu-id="ce7c1-661">另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-661">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="ce7c1-662">此方法的重载是等效于调用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法重载，指定`true`为`throwOnBindFailure`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-662">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-663">从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-663">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="ce7c1-664">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="ce7c1-664">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ce7c1-665">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-665">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce7c1-666">
            <paramref name="type" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-666">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-667">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-667">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-668">
            <paramref name="target" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-668">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-669">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-669">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-670">
            <paramref name="method" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-670">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-671">
            <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-671">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="ce7c1-672">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-672">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-673">
            <paramref name="type" /> 不是 <see langword="RuntimeType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-673">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="ce7c1-674">请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-674">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="ce7c1-675">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-675">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-676">
            <paramref name="method" /> 不是实例方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-676">
              <paramref name="method" /> is not an instance method.</span>
          </span>
          <span data-ttu-id="ce7c1-677">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-677">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-678">无法绑定 <paramref name="method" />，例如因为找不到它。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-678">
              <paramref name="method" /> cannot be bound, for example because it cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="ce7c1-679">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-679">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="ce7c1-680">调用方没有访问 <paramref name="method" /> 所必需的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-680">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-681">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-681">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-682">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-682">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ce7c1-683">要创建的委托的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-683">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="ce7c1-684">表示实现 <paramref name="method" /> 的类的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-684">The <see cref="T:System.Type" /> representing the class that implements <paramref name="method" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ce7c1-685">委托要表示的静态方法的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-685">The name of the static method that the delegate is to represent.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="ce7c1-686">一个布尔值，它指示在比较方法名称时是否忽略大小写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-686">A Boolean indicating whether to ignore the case when comparing the name of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-687">使用用于指定是否区分大小写的值创建指定类型的委托，该委托表示指定类的指定静态方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-687">Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-688">指定类型的委托，该委托表示指定类的指定静态方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-688">A delegate of the specified type that represents the specified static method of the specified class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-689">此方法创建委托只为静态方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-689">This method creates delegates for static methods only.</span></span> <span data-ttu-id="ce7c1-690">另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-690">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="ce7c1-691">此方法的重载是等效于调用<xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29>方法重载，指定`true`为`throwOnBindFailure`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-691">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-692">从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-692">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="ce7c1-693">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="ce7c1-693">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ce7c1-694">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-694">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce7c1-695">
            <paramref name="type" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-695">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-696">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-696">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-697">
            <paramref name="target" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-697">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-698">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-698">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-699">
            <paramref name="method" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-699">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-700">
            <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-700">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="ce7c1-701">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-701">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-702">
            <paramref name="type" /> 不是 <see langword="RuntimeType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-702">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="ce7c1-703">请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-703">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="ce7c1-704">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-704">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-705">
            <paramref name="target" /> 不是 <see langword="RuntimeType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-705">
              <paramref name="target" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="ce7c1-706">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-706">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-707">
            <paramref name="target" /> 为开放式泛型类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-707">
              <paramref name="target" /> is an open generic type.</span>
          </span>
          <span data-ttu-id="ce7c1-708">也就是说，其 <see cref="P:System.Type.ContainsGenericParameters" /> 属性为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-708">That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</span>
          </span>
          <span data-ttu-id="ce7c1-709">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-709">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-710">
            <paramref name="method" /> 不是 <see langword="static" /> 方法（在 Visual Basic 中为 <see langword="Shared" /> 方法）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-710">
              <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).</span>
          </span>
          <span data-ttu-id="ce7c1-711">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-711">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-712">无法绑定 <paramref name="method" />，例如因为找不到它。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-712">
              <paramref name="method" /> cannot be bound, for example because it cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="ce7c1-713">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-713">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="ce7c1-714">调用方没有访问 <paramref name="method" /> 所必需的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-714">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-715">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-715">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-716">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-716">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ce7c1-717">要创建的委托的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-717">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="ce7c1-718">类实例，对其调用 <paramref name="method" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-718">The class instance on which <paramref name="method" /> is invoked.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ce7c1-719">委托要表示的实例方法的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-719">The name of the instance method that the delegate is to represent.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="ce7c1-720">一个布尔值，它指示在比较方法名称时是否忽略大小写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-720">A Boolean indicating whether to ignore the case when comparing the name of the method.</span>
          </span>
        </param>
        <param name="throwOnBindFailure">
          <span data-ttu-id="ce7c1-721">如果无法绑定 <paramref name="method" /> 时引发异常，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-721">
              <see langword="true" /> to throw an exception if <paramref name="method" /> cannot be bound; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-722">使用用于指定是否区分大小写的值和针对绑定失败的指定行为，创建指定类型的委托，该委托表示要对指定类实例调用的指定实例方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-722">Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-723">指定的类型的委托，表示要对指定的类实例调用的指定的实例方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-723">A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-724">此方法创建委托实例仅方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-724">This method creates delegates for instance methods only.</span></span> <span data-ttu-id="ce7c1-725">另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-725">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-726">从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-726">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="ce7c1-727">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="ce7c1-727">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ce7c1-728">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-728">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce7c1-729">
            <paramref name="type" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-729">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-730">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-730">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-731">
            <paramref name="target" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-731">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-732">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-732">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-733">
            <paramref name="method" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-733">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-734">
            <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-734">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="ce7c1-735">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-735">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-736">
            <paramref name="type" /> 不是 <see langword="RuntimeType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-736">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="ce7c1-737">请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-737">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="ce7c1-738">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-738">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-739">
            <paramref name="method" /> 不是实例方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-739">
              <paramref name="method" /> is not an instance method.</span>
          </span>
          <span data-ttu-id="ce7c1-740">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-740">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-741">无法绑定 <paramref name="method" />，例如因为找不到它，并且 <paramref name="throwOnBindFailure" /> 为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-741">
              <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="ce7c1-742">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-742">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="ce7c1-743">调用方没有访问 <paramref name="method" /> 所必需的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-743">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-744">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-744">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-745">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-745">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="ce7c1-746">要创建的委托的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-746">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="ce7c1-747">表示实现 <paramref name="method" /> 的类的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-747">The <see cref="T:System.Type" /> representing the class that implements <paramref name="method" />.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="ce7c1-748">委托要表示的静态方法的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-748">The name of the static method that the delegate is to represent.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="ce7c1-749">一个布尔值，它指示在比较方法名称时是否忽略大小写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-749">A Boolean indicating whether to ignore the case when comparing the name of the method.</span>
          </span>
        </param>
        <param name="throwOnBindFailure">
          <span data-ttu-id="ce7c1-750">如果无法绑定 <paramref name="method" /> 时引发异常，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-750">
              <see langword="true" /> to throw an exception if <paramref name="method" /> cannot be bound; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-751">使用用于指定是否区分大小写的值和针对绑定失败的指定行为，创建指定类型的委托，该委托表示指定类的指定静态方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-751">Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-752">指定类型的委托，该委托表示指定类的指定静态方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-752">A delegate of the specified type that represents the specified static method of the specified class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-753">此方法创建委托只为静态方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-753">This method creates delegates for static methods only.</span></span> <span data-ttu-id="ce7c1-754">另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-754">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce7c1-755">从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，可以使用此方法访问非公共方法，如果授予调用方<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标记线程和非公共方法的授予集限制到调用方的授予集或子集其中。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-755">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="ce7c1-756">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="ce7c1-756">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="ce7c1-757">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-757">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce7c1-758">
            <paramref name="type" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-758">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-759">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-759">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-760">
            <paramref name="target" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-760">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-761">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-761">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-762">
            <paramref name="method" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-762">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-763">
            <paramref name="type" /> 不继承 <see cref="T:System.MulticastDelegate" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-763">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="ce7c1-764">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-764">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-765">
            <paramref name="type" /> 不是 <see langword="RuntimeType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-765">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="ce7c1-766">请参阅[反射中的运行时类型](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-766">See [Runtime Types in Reflection](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="ce7c1-767">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-767">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-768">
            <paramref name="target" /> 不是 <see langword="RuntimeType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-768">
              <paramref name="target" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="ce7c1-769">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-769">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-770">
            <paramref name="target" /> 为开放式泛型类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-770">
              <paramref name="target" /> is an open generic type.</span>
          </span>
          <span data-ttu-id="ce7c1-771">也就是说，其 <see cref="P:System.Type.ContainsGenericParameters" /> 属性为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-771">That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</span>
          </span>
          <span data-ttu-id="ce7c1-772">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-772">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-773">
            <paramref name="method" /> 不是 <see langword="static" /> 方法（在 Visual Basic 中为 <see langword="Shared" /> 方法）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-773">
              <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).</span>
          </span>
          <span data-ttu-id="ce7c1-774">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-774">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-775">无法绑定 <paramref name="method" />，例如因为找不到它，并且 <paramref name="throwOnBindFailure" /> 为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-775">
              <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="ce7c1-776">找不到 <paramref name="type" /> 的 <see langword="Invoke" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-776">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="ce7c1-777">调用方没有访问 <paramref name="method" /> 所必需的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-777">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-778">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-778">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-779">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-779">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">
          <span data-ttu-id="ce7c1-780">作为自变量传递给当前委托所表示的方法的对象数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-780">An array of objects that are the arguments to pass to the method represented by the current delegate.</span>
          </span>
          <span data-ttu-id="ce7c1-781">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-781">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-782">如果当前委托所表示的方法不需要参数，则为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-782">
              <see langword="null" />, if the method represented by the current delegate does not require arguments.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-783">动态调用（后期绑定）由当前委托所表示的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-783">Dynamically invokes (late-bound) the method represented by the current delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-784">委托所表示的方法返回的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-784">The object returned by the method represented by the delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-785">此方法调用 <xref:System.Delegate.DynamicInvokeImpl%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-785">This method calls the <xref:System.Delegate.DynamicInvokeImpl%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="ce7c1-786">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-786">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
          <span data-ttu-id="ce7c1-787">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-787">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-788">
            <paramref name="args" /> 中列出的参数的数目、顺序或类型无效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-788">The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-789">对对象或类调用委托所表示的方法，但该对象或类不支持这种方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-789">The method represented by the delegate is invoked on an object or a class that does not support it.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="ce7c1-790">委托所表示的方法是实例方法，目标对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-790">The method represented by the delegate is an instance method and the target object is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-791">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-791">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-792">封装的方法之一引发异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-792">One of the encapsulated methods throws an exception.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-793">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-793">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-794">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-794">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">
          <span data-ttu-id="ce7c1-795">作为自变量传递给当前委托所表示的方法的对象数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-795">An array of objects that are the arguments to pass to the method represented by the current delegate.</span>
          </span>
          <span data-ttu-id="ce7c1-796">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-796">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-797">如果当前委托所表示的方法不需要参数，则为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-797">
              <see langword="null" />, if the method represented by the current delegate does not require arguments.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-798">动态调用（后期绑定）由当前委托所表示的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-798">Dynamically invokes (late-bound) the method represented by the current delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-799">委托所表示的方法返回的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-799">The object returned by the method represented by the delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-800">此方法实现 <xref:System.Delegate.DynamicInvoke%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-800">This method implements the <xref:System.Delegate.DynamicInvoke%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="ce7c1-801">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-801">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
          <span data-ttu-id="ce7c1-802">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-802">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-803">
            <paramref name="args" /> 中列出的参数的数目、顺序或类型无效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-803">The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-804">对对象或类调用委托所表示的方法，但该对象或类不支持这种方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-804">The method represented by the delegate is invoked on an object or a class that does not support it.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="ce7c1-805">委托所表示的方法是实例方法，目标对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-805">The method represented by the delegate is an instance method and the target object is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="ce7c1-806">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-806">-or-</span>
          </span>
          <span data-ttu-id="ce7c1-807">封装的方法之一引发异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-807">One of the encapsulated methods throws an exception.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-808">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-808">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-809">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-809">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="ce7c1-810">要与当前委托进行比较的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-810">The object to compare with the current delegate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-811">确定指定的对象和当前委托的类型是否相同，是否共享相同的目标、方法和调用列表。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-811">Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-812">如果 <paramref name="obj" /> 和当前委托具有相同的目标、方法和调用列表，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-812">
              <see langword="true" /> if <paramref name="obj" /> and the current delegate have the same targets, methods, and invocation list; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-813">如果两个委托不属于同一类型，它们不被视为相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-813">If the two delegates are not of the same type, they are not considered equal.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ce7c1-814">在.NET Framework 1.0 和 1.1 版中，两个委托已视为好像它们的目标、 方法和调用列表等于，即使委托是不同类型的相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-814">In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</span></span>  
  
 <span data-ttu-id="ce7c1-815">这些方法和目标进行比较的相等性，如下所示：</span><span class="sxs-lookup"><span data-stu-id="ce7c1-815">The methods and targets are compared for equality as follows:</span></span>  
  
-   <span data-ttu-id="ce7c1-816">如果所比较的两个方法都是静态并且同一类上的相同方法，这些方法被视为相等，这些目标也被视为相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-816">If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="ce7c1-817">如果要比较的两种方法是实例方法，并且同一对象上的相同方法，这些方法被视为相等，这些目标也被视为相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-817">If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="ce7c1-818">否则为方法不被视为相等，并且目标也不被视为相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-818">Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</span></span>  
  
 <span data-ttu-id="ce7c1-819">两个调用列表将被视为相同，仅当它们具有相同的顺序，从两个列表的相应元素表示相同的方法和目标。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-819">Two invocation lists are considered identical only if they have the same order and the corresponding elements from the two lists represent the same method and target.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="ce7c1-820">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-820">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-821">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-821">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-822">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-822">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ce7c1-823">返回委托的哈希代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-823">Returns a hash code for the delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-824">委托的哈希代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-824">A hash code for the delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-825">两个原因必须不保留此方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-825">The return value of this method must not be persisted for two reasons.</span></span> <span data-ttu-id="ce7c1-826">首先，可能会更改类的哈希函数生成更好的分布，使旧的哈希函数中的所有值都无用。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-826">First, the hash function of a class might be altered to generate a better distribution, rendering any values from the old hash function useless.</span></span> <span data-ttu-id="ce7c1-827">其次，此类的默认实现不保证不同实例将返回相同的值。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-827">Second, the default implementation of this class does not guarantee that the same value will be returned by different instances.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-828">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-828">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-829">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-829">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ce7c1-830">返回委托的调用列表。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-830">Returns the invocation list of the delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-831">委托构成的数组，表示当前委托的调用列表。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-831">An array of delegates representing the invocation list of the current delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-832">数组中的每个委托表示一个方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-832">Each delegate in the array represents exactly one method.</span></span>  
  
 <span data-ttu-id="ce7c1-833">数组中的委托的顺序是在其中为当前委托调用那些委托所表示的方法的相同顺序。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-833">The order of the delegates in the array is the same order in which the current delegate invokes the methods that those delegates represent.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ce7c1-834">下面的示例将三种方法分配给委托。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-834">The following example assigns three methods to a delegate.</span></span> <span data-ttu-id="ce7c1-835">然后，它调用<xref:System.Delegate.GetInvocationList%2A>方法获取的总计数以相反顺序执行委托并执行其名称不包括子字符串的方法分配给该委托的方法的"文件"。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-835">It then calls the  <xref:System.Delegate.GetInvocationList%2A> method to get a total count of the methods assigned to the delegate, to execute the delegates in reverse order, and to execute the methods whose name do not include the substring "File".</span></span>  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-836">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-836">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-837">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-837">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ce7c1-838">获取当前委托所表示的静态方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-838">Gets the static method represented by the current delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-839">描述当前委托表示的静态方法的 <see cref="T:System.Reflection.MethodInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-839">A <see cref="T:System.Reflection.MethodInfo" /> describing the static method represented by the current delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-840">此方法仅适用于当前委托表示静态方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-840">This method applies only if the current delegate represents a static method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="ce7c1-841">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-841">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-842">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-842">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-843">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-843">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="ce7c1-844">不支持。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-844">Not supported.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="ce7c1-845">不支持。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-845">Not supported.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-846">不支持。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-846">Not supported.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ce7c1-847">不支持此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-847">This method is not supported.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="ce7c1-848">直接调用方需要完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-848">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="ce7c1-849">不能由部分受信任的或透明的代码使用此成员。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-849">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ce7c1-850">获取委托所表示的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-850">Gets the method represented by the delegate.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ce7c1-851">描述委托所表示的方法的 <see cref="T:System.Reflection.MethodInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-851">A <see cref="T:System.Reflection.MethodInfo" /> describing the method represented by the delegate.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="ce7c1-852">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-852">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-853">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-853">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-854">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-854">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">
          <span data-ttu-id="ce7c1-855">要比较的第一个委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-855">The first delegate to compare.</span>
          </span>
        </param>
        <param name="d2">
          <span data-ttu-id="ce7c1-856">要比较的第二个委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-856">The second delegate to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-857">确定指定的委托是否相等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-857">Determines whether the specified delegates are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-858">如果 <see langword="true" /> 等于 <paramref name="d1" />，则为 <paramref name="d2" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-858">
              <see langword="true" /> if <paramref name="d1" /> is equal to <paramref name="d2" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-859">具有相同的目标、 方法和调用列表的相同类型的两个委托被视为相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-859">Two delegates of the same type with the same targets, methods, and invocation lists are considered equal.</span></span>  
  
 <span data-ttu-id="ce7c1-860">如果两个委托不属于同一类型，它们不被视为相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-860">If the two delegates are not of the same type, they are not considered equal.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ce7c1-861">在.NET Framework 1.0 和 1.1 版中，两个委托已视为好像它们的目标、 方法和调用列表等于，即使委托是不同类型的相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-861">In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</span></span>  
  
 <span data-ttu-id="ce7c1-862">这些方法和目标进行比较的相等性，如下所示：</span><span class="sxs-lookup"><span data-stu-id="ce7c1-862">The methods and targets are compared for equality as follows:</span></span>  
  
-   <span data-ttu-id="ce7c1-863">如果所比较的两个方法都是静态并且同一类上的相同方法，这些方法被视为相等，这些目标也被视为相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-863">If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="ce7c1-864">如果要比较的两种方法是实例方法，并且同一对象上的相同方法，这些方法被视为相等，这些目标也被视为相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-864">If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="ce7c1-865">否则为方法不被视为相等，并且目标也不被视为相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-865">Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</span></span>  
  
 <span data-ttu-id="ce7c1-866">如果它们具有相同的顺序，从两个列表的相应元素表示相同的方法和目标，两个调用列表将被视为相同。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-866">Two invocation lists are considered identical if they have the same order and the corresponding elements from the two lists represent the same method and target.</span></span>  
  
 <span data-ttu-id="ce7c1-867">此运算符的等效方法是 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ce7c1-867">The equivalent method for this operator is <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-868">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-868">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-869">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-869">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">
          <span data-ttu-id="ce7c1-870">要比较的第一个委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-870">The first delegate to compare.</span>
          </span>
        </param>
        <param name="d2">
          <span data-ttu-id="ce7c1-871">要比较的第二个委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-871">The second delegate to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-872">确定指定的委托是否不相等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-872">Determines whether the specified delegates are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-873">如果 <see langword="true" /> 不等于 <paramref name="d1" />，则为 <paramref name="d2" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-873">
              <see langword="true" /> if <paramref name="d1" /> is not equal to <paramref name="d2" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-874">两个委托被视为不相等如果它们都是不同类型，或具有不同的方法、 不同的目标或不同的调用列表。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-874">Two delegates are considered not equal if they are of different types, or have different methods, different targets, or different invocation lists.</span></span>  
  
 <span data-ttu-id="ce7c1-875">如果两个委托不属于同一类型，它们不被视为相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-875">If the two delegates are not of the same type, they are not considered equal.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ce7c1-876">在.NET Framework 1.0 和 1.1 版中，两个委托被视为好像它们的目标、 方法和调用列表等于，即使委托是不同类型的相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-876">In the .NET Framework version 1.0 and 1.1, two delegates are considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</span></span>  
  
 <span data-ttu-id="ce7c1-877">这些方法和目标进行比较的相等性，如下所示：</span><span class="sxs-lookup"><span data-stu-id="ce7c1-877">The methods and targets are compared for equality as follows:</span></span>  
  
-   <span data-ttu-id="ce7c1-878">如果所比较的两个方法都是静态并且同一类上的相同方法，这些方法被视为相等，这些目标也被视为相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-878">If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="ce7c1-879">如果要比较的两种方法是实例方法，并且同一对象上的相同方法，这些方法被视为相等，这些目标也被视为相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-879">If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="ce7c1-880">否则为方法不被视为相等，并且目标也不被视为相等。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-880">Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</span></span>  
  
 <span data-ttu-id="ce7c1-881">两个调用列表不相等，如果它们具有不同的大小，如果它们的顺序不同，或者从一个列表中至少一个元素表示的方法或不同于由其他列表中的对应元素的目标。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-881">Two invocation lists are not equal if they have different sizes, if they are ordered differently, or if at least one element from one list represents a method or target that is different from that represented by its corresponding element in the other list.</span></span>  
  
 <span data-ttu-id="ce7c1-882">此运算符的等效方法是 <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ce7c1-882">The equivalent method for this operator is <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-883">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-883">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-884">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-884">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="ce7c1-885">委托，将从中移除 <paramref name="value" /> 的调用列表。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-885">The delegate from which to remove the invocation list of <paramref name="value" />.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="ce7c1-886">委托，它提供将从其中移除 <paramref name="source" /> 的调用列表的调用列表。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-886">The delegate that supplies the invocation list to remove from the invocation list of <paramref name="source" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-887">从一个委托的调用列表中移除另一个委托的最后一个调用列表。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-887">Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-888">一个新委托，其调用列表的构成方法为：获取 <paramref name="source" /> 的调用列表，如果在 <paramref name="value" /> 的调用列表中找到了 <paramref name="value" /> 的调用列表，则从中移除 <paramref name="source" /> 的最后一个调用列表。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-888">A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing the last occurrence of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />.</span>
          </span>
          <span data-ttu-id="ce7c1-889">如果 <paramref name="source" /> 为 <see langword="null" />，或在 <paramref name="value" /> 的调用列表中没有找到 <paramref name="value" /> 的调用列表，则返回 <paramref name="source" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-889">Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />.</span>
          </span>
          <span data-ttu-id="ce7c1-890">如果 <paramref name="value" /> 的调用列表等于 <paramref name="source" /> 的调用列表，或 <paramref name="source" /> 为空引用，则返回空引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-890">Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" /> or if <paramref name="source" /> is a null reference.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-891">如果的调用列表`value`匹配一组相邻的调用列表中的元素`source`，然后调用列表`value`说过的调用列表中出现`source`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-891">If the invocation list of `value` matches a contiguous set of elements in the invocation list of `source`, then the invocation list of `value` is said to occur within the invocation list of `source`.</span></span> <span data-ttu-id="ce7c1-892">如果调用列表`value`的调用列表中出现多次`source`，删除最后一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-892">If the invocation list of `value` occurs more than once in the invocation list of `source`, the last occurrence is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="ce7c1-893">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-893">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-894">委托类型不匹配。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-894">The delegate types do not match.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-895">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-895">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-896">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-896">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="ce7c1-897">委托，将从中移除 <paramref name="value" /> 的调用列表。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-897">The delegate from which to remove the invocation list of <paramref name="value" />.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="ce7c1-898">委托，它提供将从其中移除 <paramref name="source" /> 的调用列表的调用列表。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-898">The delegate that supplies the invocation list to remove from the invocation list of <paramref name="source" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-899">从一个委托的调用列表中移除另一个委托的所有调用列表。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-899">Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-900">一个新委托，其调用列表的构成方法为：获取 <paramref name="source" /> 的调用列表，如果在 <paramref name="value" /> 的调用列表中找到了 <paramref name="value" /> 的调用列表，则从中移除 <paramref name="source" /> 的所有调用列表。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-900">A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing all occurrences of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />.</span>
          </span>
          <span data-ttu-id="ce7c1-901">如果 <paramref name="source" /> 为 <see langword="null" />，或在 <paramref name="value" /> 的调用列表中没有找到 <paramref name="value" /> 的调用列表，则返回 <paramref name="source" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-901">Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />.</span>
          </span>
          <span data-ttu-id="ce7c1-902">如果 <paramref name="value" /> 的调用列表等于 <paramref name="source" /> 的调用列表，如果 <paramref name="source" /> 只包含等于 <paramref name="value" /> 的调用列表的一系列调用列表，或者如果 <paramref name="source" /> 为空引用，则返回空引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-902">Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" />, if <paramref name="source" /> contains only a series of invocation lists that are equal to the invocation list of <paramref name="value" />, or if <paramref name="source" /> is a null reference.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-903">如果的调用列表`value`匹配一组相邻的调用列表中的元素`source`，然后调用列表`value`说过的调用列表中出现`source`。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-903">If the invocation list of `value` matches a contiguous set of elements in the invocation list of `source`, then the invocation list of `value` is said to occur within the invocation list of `source`.</span></span> <span data-ttu-id="ce7c1-904">如果调用列表`value`的调用列表中出现多次`source`，删除所有匹配项。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-904">If the invocation list of `value` occurs more than once in the invocation list of `source`, all occurrences are removed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="ce7c1-905">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-905">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ce7c1-906">委托类型不匹配。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-906">The delegate types do not match.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-907">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-907">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-908">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-908">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="ce7c1-909">委托，它提供要从当前委托的调用列表中移除的调用列表。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-909">The delegate that supplies the invocation list to remove from the invocation list of the current delegate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ce7c1-910">从一个委托的调用列表中移除另一个委托的调用列表。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-910">Removes the invocation list of a delegate from the invocation list of another delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ce7c1-911">一个新委托，其调用列表的构成方法为：获取当前委托的调用列表，如果在当前委托的调用列表中找到了 <paramref name="value" /> 的调用列表，则从中移除 <paramref name="value" /> 的调用列表。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-911">A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the current delegate's invocation list.</span>
          </span>
          <span data-ttu-id="ce7c1-912">如果 <paramref name="value" /> 为 <see langword="null" />，或者在当前委托的调用列表中没有找到 <paramref name="value" /> 的调用列表，则返回当前委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-912">Returns the current delegate if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the current delegate's invocation list.</span>
          </span>
          <span data-ttu-id="ce7c1-913">如果 <paramref name="value" /> 的调用列表等于当前委托的调用列表，则返回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-913">Returns <see langword="null" /> if the invocation list of <paramref name="value" /> is equal to the current delegate's invocation list.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-914">如果调用列表`value`匹配一组相邻的当前委托的调用列表，然后调用列表中的元素`value`说发生在当前委托的调用列表中。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-914">If the invocation list of `value` matches a contiguous set of elements in the current delegate's invocation list, then the invocation list of `value` is said to occur within the current delegate's invocation list.</span></span> <span data-ttu-id="ce7c1-915">如果调用列表的`value`出现不止一次当前委托的调用列表中删除最后一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-915">If the invocation list of `value` occurs more than once in the current delegate's invocation list, the last occurrence is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="ce7c1-916">调用方不能访问由委托表示的方法（例如，在方法为私有方法的情况下）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-916">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-917">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-917">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-918">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-918">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ce7c1-919">获取类实例，当前委托将对其调用实例方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-919">Gets the class instance on which the current delegate invokes the instance method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ce7c1-920">如果委托表示实例方法，则为当前委托对其调用实例方法的对象；如果委托表示静态方法，则为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-920">The object on which the current delegate invokes the instance method, if the delegate represents an instance method; <see langword="null" /> if the delegate represents a static method.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce7c1-921">另一实例方法是与类; 的实例相关联的方法静态方法是与类本身相关联的方法。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-921">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="ce7c1-922">如果该委托调用一个或多个实例方法，此属性将返回目标的最后一个实例方法的调用列表中。</span><span class="sxs-lookup"><span data-stu-id="ce7c1-922">If the delegate invokes one or more instance methods, this property returns the target of the last instance method in the invocation list.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="ce7c1-923">当调用后期绑定机制通过如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-923">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="ce7c1-924">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ce7c1-924">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>