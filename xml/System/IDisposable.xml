<Type Name="IDisposable" FullName="System.IDisposable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1e6b408b88af2e3e5027106be9c33751cc9e19c3" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34452195" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IDisposable" />
  <TypeSignature Language="VB.NET" Value="Public Interface IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供一种用于释放非托管资源的机制。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此接口的主要用途是释放非托管的资源。 垃圾回收器自动释放不再使用该对象时分配给托管对象的内存。 但是，不可能预测将发生垃圾回收。 此外，垃圾回收器具有不知道如窗口句柄的非托管资源，或打开文件和流。  
  
 使用<xref:System.IDisposable.Dispose%2A>的此接口可显式释放垃圾回收器结合使用的非托管的资源的方法。 不再需要该对象时，对象的使用者可以调用此方法。  
  
> [!WARNING]
>  它是一项重大更改添加<xref:System.IDisposable>到现有类的接口。 因为你类型的预先存在的使用者不能调用<xref:System.IDisposable.Dispose%2A>，则无法确保将释放由您的类型所持有的非托管的资源。  
  
 因为<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>不再需要实例拥有的资源时，调用将实现由一种类型的使用者，应当换行中的托管的对象<xref:System.Runtime.InteropServices.SafeHandle>（建议的替代项），也应重写<xref:System.Object.Finalize%2A?displayProperty=nameWithType>释放非托管的资源中，使用者忘记调用<xref:System.IDisposable.Dispose%2A>。  
  
> [!IMPORTANT]
>  在.NET Framework 中，c + + 编译器支持的资源进行确定性处置，并且不允许直接实现<xref:System.IDisposable.Dispose%2A>方法。  
  
 有关如何的详细讨论此接口与<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法使用，请参阅[垃圾回收](~/docs/standard/garbage-collection/index.md)和[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)主题。  
  
## <a name="using-an-object-that-implements-idisposable"></a>使用实现 IDisposable 的对象  
 如果你的应用程序只需使用实现的对象<xref:System.IDisposable>接口，你应调用对象的<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>实现在完成使用它时。 具体取决于您的编程语言，可以实现这两种方式之一：  
  
-   通过使用一种语言构造 （如`using`C# 和 Visual Basic 中的语句。  
  
-   通过包装到调用来<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>中的实现`try` / `finally`块。  
  
> [!NOTE]
>  文档类型实现<xref:System.IDisposable>请注意这一事实，包括提醒调用其<xref:System.IDisposable.Dispose%2A>实现。  
  
<a name="Using"></a>   
### <a name="the-c-and-visual-basic-using-statement"></a>C# 和 Visual Basic 使用语句  
 如果你的语言支持一种构造，如[使用](~/docs/csharp/language-reference/keywords/using.md)C# 中的语句和[使用](~/docs/visual-basic/language-reference/statements/using-statement.md)在 Visual Basic 中的语句，你可以使用它而不是显式调用<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>自己。 下面的示例使用此方法中定义`WordCount`会保留有关文件和在其中的单词数的信息的类。  
  
 [!code-csharp[System.IDisposable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling1.cs#1)]
 [!code-vb[System.IDisposable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling1.vb#1)]  
  
 `using`语句是实际在语法上方便。 在编译时的语言编译器实现的中间语言 (IL) 以`try` / `finally`块。  
  
 有关详细信息`using`语句，请参阅[Using 语句](~/docs/visual-basic/language-reference/statements/using-statement.md)或[using 语句](~/docs/csharp/language-reference/keywords/using-statement.md)主题。  
  
### <a name="the-tryfinally-block"></a>Try/Finally 块  
 如果您的编程语言不支持类似的构造`using`C# 或 Visual Basic 中的语句或如果你不希望使用它，则可以调用<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>实现从`finally`块`try` / `finally`语句。 下面的示例替换`using`块中，与前面的示例在`try` / `finally`块。  
  
 [!code-csharp[System.IDisposable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling2.cs#2)]
 [!code-vb[System.IDisposable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling2.vb#2)]  
  
 有关详细信息`try` / `finally`模式，请参阅[重试...Catch...Finally 语句](~/docs/visual-basic/language-reference/statements/try-catch-finally-statement.md)，[的 try-finally](~/docs/csharp/language-reference/keywords/try-finally.md)，或[try-finally 语句](http://msdn.microsoft.com/library/514400c1-c322-4bf3-9e48-3047240b8a82)。  
  
## <a name="implementing-idisposable"></a>正在实现 IDisposable  
 应实现<xref:System.IDisposable>仅当你的类型直接使用非托管的资源。 你的类型的使用者可以调用你<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>实现实例不再需要时释放资源。 若要处理它们无法调用的情况<xref:System.IDisposable.Dispose%2A>，应从派生的类使用<xref:System.Runtime.InteropServices.SafeHandle>来包装非托管的资源，或你应该重写<xref:System.Object.Finalize%2A?displayProperty=nameWithType>对于引用类型的方法。 在任一情况下，你使用<xref:System.IDisposable.Dispose%2A>方法来执行任何清理后必须使用的非托管的资源，如释放或重置非托管的资源。  
  
> [!IMPORTANT]
>  如果你正在定义的基类，它使用非托管的资源和，具有，或可能有，应释放的子类，则应实现<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>方法并提供的第二个重载`Dispose`，下一步中所述部分。  
  
<a name="BaseClasses"></a>   
## <a name="idisposable-and-the-inheritance-hierarchy"></a>IDisposable 和继承层次结构  
 具有应该是可释放的子类的基类必须实现<xref:System.IDisposable>，如下所示。 每当你实现时，应使用此模式<xref:System.IDisposable>上不是任何类型`sealed`(`NotInheritable`在 Visual Basic 中)。  
  
-   它应提供一个公共、 非虚拟<xref:System.IDisposable.Dispose>方法和受保护虚拟`Dispose(Boolean disposing)`方法。  
  
-   <xref:System.IDisposable.Dispose>方法必须调用`Dispose(true)`和应该禁止显示性能的终止。  
  
-   基类型不应包括任何终结器。  
  
 下面的代码段反映基类的释放模式。 它假定你的类型不会覆盖<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法。  
  
 [!code-csharp[System.IDisposable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
 [!code-vb[System.IDisposable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  
  
 如果你重写<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法，你的类应实现以下模式。  
  
 [!code-csharp[System.IDisposable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
 [!code-vb[System.IDisposable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  
  
 子类应实现以下可释放模式：  
  
-   它们必须重写 `Dispose(Boolean)` 并调用基类 `Dispose(Boolean)` 实现。  
  
-   如果需要，他们可以提供终结器。 终结器必须调用 `Dispose(false)`。  
  
 请注意，派生的类未本身实现<xref:System.IDisposable>接口，但不包括无参数<xref:System.IDisposable.Dispose%2A>方法。 它们仅重写基类`Dispose(Boolean)`方法。  
  
 下面的代码段反映派生类的释放模式。 它假定你的类型不会覆盖<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法。  
  
 [!code-csharp[System.IDisposable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
 [!code-vb[System.IDisposable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]  
  
   
  
## Examples  
 下面的示例演示如何实现资源类创建<xref:System.IDisposable>接口。  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" />
  </Docs>
  <Members>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IDisposable.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Dispose();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>执行与释放或重置非托管资源关联的应用程序定义的任务。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法关闭或释放非托管的资源，如文件、 流和由实现此接口的类实例所持有的句柄。 按照约定，此方法用于与释放对象，保持的资源的所有任务或准备对象以便重复使用。  
  
> [!WARNING]
>  如果你使用的一个类以实现<xref:System.IDisposable>接口，应调用其<xref:System.IDisposable.Dispose%2A>实现在完成使用类时。 有关详细信息，请参阅中的"使用实现 IDisposable 的对象"一节<xref:System.IDisposable>主题。  
  
 实现此方法时，请确保所有持有中传播的包含层次结构通过调用来释放资源。 例如，如果对象 A 分配一个对象 B，并且对象 B 分配对象 C，然后 A 的<xref:System.IDisposable.Dispose%2A>实现必须调用<xref:System.IDisposable.Dispose%2A>在 B 上，其必须反过来调用<xref:System.IDisposable.Dispose%2A>C 上  
  
> [!IMPORTANT]
>  C + + 编译器支持的资源进行确定性处置，并且不允许直接实现<xref:System.IDisposable.Dispose%2A>方法。  
  
 对象还必须调用<xref:System.IDisposable.Dispose%2A>如果基类实现其基本类的方法<xref:System.IDisposable>。 有关实现详细信息<xref:System.IDisposable>上基类和其子类，请参阅中的"IDisposable 和继承层次结构"部分<xref:System.IDisposable>主题。  
  
 如果对象的<xref:System.IDisposable.Dispose%2A>不止一次调用方法，该对象必须在第一个后忽略所有调用。 该对象一定不会引发异常，如果其<xref:System.IDisposable.Dispose%2A>多次调用方法。 实例方法以外<xref:System.IDisposable.Dispose%2A>可以引发<xref:System.ObjectDisposedException>已释放资源。  
  
 用户可能经历的资源类型，以使用特定的约定来表示已分配的状态和已释放的状态。 此示例是流类，该类通常想象成打开或关闭。 具有此类的约定的类实施者可以选择实现具有自定义名称的公共方法，如`Close`，则该调用<xref:System.IDisposable.Dispose%2A>方法。  
  
 因为<xref:System.IDisposable.Dispose%2A>方法必须显式调用时，还有很危险的非托管的资源不会释放，因为对象的使用者无法调用其<xref:System.IDisposable.Dispose%2A>方法。 有两种方法来避免这种情况：  
  
-   在从派生的对象中包装的托管的资源<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>。 你<xref:System.IDisposable.Dispose%2A>实现然后调用<xref:System.IDisposable.Dispose%2A>方法<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>实例。 有关详细信息，请参阅中的"SafeHandle 备用方法"部分<xref:System.Object.Finalize%2A?displayProperty=nameWithType>主题。  
  
-   实现终结器释放资源时<xref:System.IDisposable.Dispose%2A>不调用。 默认情况下，垃圾回收器自动回收其内存前调用对象的终结器。 但是，如果<xref:System.IDisposable.Dispose%2A>方法已被调用，它通常是不必要的垃圾回收器调用已释放的对象的终结器。 若要防止自动终止，<xref:System.IDisposable.Dispose%2A>实现可以调用<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。  
  
 当你使用一个对象，如访问非托管的资源， <xref:System.IO.StreamWriter>，很好的做法是创建与实例`using`语句。 `using`语句会自动关闭的流和调用<xref:System.IDisposable.Dispose%2A>上正在使用它的代码已完成的对象。 有关示例，请参阅<xref:System.IO.StreamWriter>类。  
  
   
  
## Examples  
 下面的示例演示如何实现<xref:System.IDisposable.Dispose%2A>方法。  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>