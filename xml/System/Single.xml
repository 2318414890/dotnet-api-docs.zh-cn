<Type Name="Single" FullName="System.Single">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a521e293e72337b734033ff9548b1c06255dcd64" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56391729" /></Metadata><TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Single" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IComparable(Of Single), IConvertible, IEquatable(Of Single), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示一个单精度浮点数。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single>值类型表示单精度 32 位数字，其值范围从-3.402823e38 到 + 3.402823 e 38，以及正或负零<xref:System.Single.PositiveInfinity>， <xref:System.Single.NegativeInfinity>，并不是数字 (<xref:System.Single.NaN>)。 它旨在表示 （如行星或星系之间的距离） 极大或非常小 （例如千克物质的分子大容量） 以及，通常是不精确 （例如另一个太阳系到地球的距离值). <xref:System.Single>类型符合 IEC 60559: 1989 (IEEE 754) 二进制浮点算术标准。  
  
 本主题包括以下各节：  
  
-   [浮点表示形式和精度](#Precision)  
  
-   [为确定相等性测试](#Equality)  
  
-   [浮点值和异常](#Exceptions)  
  
-   [类型转换和单个结构](#Conversion)  
  
-   [浮点功能](#Functionality)  
  
 <xref:System.Single?displayProperty=nameWithType> 提供方法来比较此类型，将实例的值转换为其字符串表示形式，并将数字的字符串表示形式转换为此类型的实例的实例。 格式规范代码如何控制值类型的字符串表示形式的信息，请参阅[格式设置类型](~/docs/standard/base-types/formatting-types.md)，[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)，和[自定义数值格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>浮点表示形式和精度  
 <xref:System.Single>数据类型将单精度浮点值存储在 32 位的二进制格式下, 表中所示：  
  
|部件|Bits|  
|----------|----------|  
|有效位数或尾数|0-22|  
|指数|23-30|  
|登录 (0 = 正数、 1 = 负)|31|  
  
 正如无法精确地表示一些小的数值小数部分 (如 1/3 或<xref:System.Math.PI?displayProperty=nameWithType>)，二进制分数的形式不能表示一些小数值。 例如，2/10，其通过.2 用一个十进制小数精确地表示为二进制分数，使用模式"1100"重复向无穷远的.0011111001001100 由表示。 在这种情况下，浮点值提供一个数字，它表示的不精确表示形式。 通常执行其他数学运算上原始浮点值会增加其缺少的精度。 例如，如果您比较.3 通过 10 相乘的结果，但添加到.3.3 九次，你将看到了这个生成不太精确的结果，因为它涉及到比乘法的八个更多操作。 请注意，仅当你显示这两个明显这种不一致<xref:System.Single>通过使用"R"的值[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)，而后者如果有必要，将显示所有 9 位精度支持<xref:System.Single>类型。  
  
 [!code-csharp[System.Single.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation1.cs#3)]
 [!code-vb[System.Single.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation1.vb#3)]  
  
 一些数字不能精确表示为小数部分的二进制值，因为浮点数可以只是近似的实际数量。  
  
 所有的浮点数必须有限的数量的有效位，它还确定浮点值准确程度近似于一个实数。 一个<xref:System.Single>值具有最多 7 个小数位的精度，尽管在内部维护最大 9 位。 这意味着某些浮点操作可能缺少若要更改的浮点值的精度。 下面的示例定义一个大型的单精度浮点值，并再添加的产品<xref:System.Single.Epsilon?displayProperty=nameWithType>和 1 千万亿到它。 但是，该产品是太小，无法修改原始的浮点值。 其最小有效位是千分之几秒，而在产品中的最高有效位是 10<sup>-30</sup>。  
  
 [!code-csharp[System.Single.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation2.cs#4)]
 [!code-vb[System.Single.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation2.vb#4)]  
  
 受限制的精度的浮点数具有以下若干影响：  
  
-   因为其最小有效位不同，两个看起来相等对于特定精度的浮点数可能比较相等。 在以下示例中，一系列数字加在一起，并其总与其预期的总数进行比较。 尽管两个值看起来是相同的调用`Equals`方法表示它们不是。  
  
     [!code-csharp[System.Single.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Single.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist3.vb#6)]  
  
     如果更改中的格式项<xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType>语句从`{0}`并`{1}`到`{0:R}`并`{1:R}`以显示全部有效数字的两个<xref:System.Single>很明显，两个值不相等的值，因为期间加法运算的精度损失。 在这种情况下，通过调用来解决此问题<xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType>方法将舍入<xref:System.Single>到执行比较前所需的精度的值。  
  
-   使用浮点数的算术或比较运算不一定产生相同的结果使用的是十进制数字，如果由于二进制浮点数可能不等于十进制数。 上一示例所示这显示相乘.3 通过 10 和添加.3 到.3 九次的结果。  
  
     重要带小数值的数字运算的准确性时，请使用<xref:System.Decimal>而不是键入<xref:System.Single>类型。 当在超出范围的整数值的数值运算中的准确性<xref:System.Int64>或<xref:System.UInt64>类型是重要的是，使用<xref:System.Numerics.BigInteger>类型。  
  
-   值可能不往返，如果涉及浮点数。 如果操作将原始浮点数转换为另一种形式，而相反运算转换回浮点数，转换后的窗体，最终的浮点数等于原始值被认为保存/还原浮点数。 在往返行程可能会失败，因为丢失或转换中更改一个或多个最小有效位。 在以下示例中，三个<xref:System.Single>值被转换为字符串并保存在文件中。 如输出所示，尽管看起来是相同的值，则还原的值不等于原始值。  
  
     [!code-csharp[System.Single.Structure#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist4a.cs#17)]
     [!code-vb[System.Single.Structure#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList4a.vb#17)]  
  
     在这种情况下，值可以是已成功往返过程通过使用"G9"[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)若要保留完整的精度<xref:System.Single>值，如以下示例所示。  
  
     [!code-csharp[System.Single.Structure#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/PrecisionList5a.cs#18)]
     [!code-vb[System.Single.Structure#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList5a.vb#18)]  
  
-   <xref:System.Single> 值，则必须比精度降低<xref:System.Double>值。 一个<xref:System.Single>值转换为看似等效<xref:System.Double>通常不等于<xref:System.Double>由于差异精度的值。 在以下示例中，相同的除法运算的结果分配给<xref:System.Double>值和一个<xref:System.Single>值。 之后<xref:System.Single>值强制转换为<xref:System.Double>，显示了两个值的比较，它们是否不相等。  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     若要避免此问题，请使用<xref:System.Double>数据类型来代替<xref:System.Single>数据类型或使用<xref:System.Math.Round%2A>方法，以便这两个值具有相同的精度。  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>为确定相等性测试  
 将被视为相等，两个<xref:System.Single>值必须代表完全相同的值。 但是，由于在精度值之间的差异或由于由一个或两个值的精度损失，都将通常是相同的浮点值会是由于其最小有效位之间的差异不相等。 因此，调用<xref:System.Single.Equals%2A>方法来确定两个值是否相等或调用<xref:System.Single.CompareTo%2A>方法来确定两个关系<xref:System.Single>值，通常会产生意外的结果。 这是很明显的以下示例中，其中两个显然等于<xref:System.Single>值会是不相等，因为第一个值具有 7 位精度，而第二个值具有 9。  
  
 [!code-csharp[System.Single.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Single.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison1.vb#9)]  
  
 计算的值，请按照不同的代码路径和，通常操作不同的方式证明不相等。 在以下示例中，一个<xref:System.Single>平方值，，然后计算平方根还原原始值。 第二个<xref:System.Single>乘以 3.51 和平方之前结果的平方根除以 3.51 还原原始值。 尽管两个值看起来完全相同，调用<xref:System.Single.Equals%28System.Single%29>方法指示它们是否不相等。 使用"G9"标准格式字符串返回显示的每个的全部有效数字的结果字符串<xref:System.Single>值显示的第二个值都是.0000000000001 小于第一个。  
  
 [!code-csharp[System.Single.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Single.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison2.vb#10)]  
  
 在精度降低可能会影响比较的结果的情况下，可以使用以下方法，而不是调用<xref:System.Single.Equals%2A>或<xref:System.Single.CompareTo%2A>方法：  
  
-   调用<xref:System.Math.Round%2A?displayProperty=nameWithType>方法，以确保这两个值具有相同的精度。 下面的示例修改上一个示例以使用这种方法，以便两个小数部分值相等。  
  
     [!code-csharp[System.Single.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Single.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison3.vb#11)]  
  
     请注意，精度问题仍适用于的中点值舍入。 有关更多信息，请参见 <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType> 方法。  
  
-   而非相等性的近似相等性测试。 此技术需要定义任一绝对量的两个值可依据不同但仍对等，或定义依据的较小值可以从较大的值发生偏离相对数量。  
  
    > [!WARNING]
    >  <xref:System.Single.Epsilon?displayProperty=nameWithType> 有时也用作两个之间的距离的绝对度量值<xref:System.Single>值时测试是否相等。  但是，<xref:System.Single.Epsilon?displayProperty=nameWithType>度量值的最小可能值，可以添加或减去，<xref:System.Single>其值为零。 对于大多数正和负<xref:System.Single>值、 的值<xref:System.Single.Epsilon?displayProperty=nameWithType>太小而无法检测到。 因此，除了为零的值，不建议在为确定相等性测试中的使用它。  
  
     下面的示例使用后一种方法来定义`IsApproximatelyEqual`方法用于测试两个值之间的相对差异。 它还对照了的调用的结果`IsApproximatelyEqual`方法和<xref:System.Single.Equals%28System.Single%29>方法。  
  
     [!code-csharp[System.Single.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Single.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>浮点值和异常  
 具有浮点值的操作不会引发异常，与使用整型类型，由零除或溢出中的非法操作，例如部门的情况下引发异常的操作不同。  相反，在这些情况下，浮点运算的结果是零个、 正无穷大、 负无穷大或非数值 (NaN):  
  
-   如果浮点运算的结果太小，目标格式，则结果为零。 两个非常小的浮点数相乘，如以下示例所示时会发生该错误。  
  
     [!code-csharp[System.Single.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Single.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional1.vb#1)]  
  
-   如果浮点运算的结果的大小超出目标格式的范围，该操作的结果是<xref:System.Single.PositiveInfinity>或<xref:System.Single.NegativeInfinity>以适合结果的符号。 溢出的操作结果<xref:System.Single.MaxValue?displayProperty=nameWithType>是<xref:System.Single.PositiveInfinity>，和溢出操作的结果<xref:System.Single.MinValue?displayProperty=nameWithType>是<xref:System.Single.NegativeInfinity>，如下面的示例所示。  
  
     [!code-csharp[System.Single.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Single.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Single.PositiveInfinity> 也通过零且正被除数，可能会造成一个部门和<xref:System.Single.NegativeInfinity>相除所得与负被除数为零。  
  
-   如果浮点运算无效，该操作的结果是<xref:System.Single.NaN>。 例如，<xref:System.Single.NaN>得出以下操作：  
  
    -   被零除与被除数为零。 注意除法运算的其他情况下由零个结果中任意一种<xref:System.Single.PositiveInfinity>或<xref:System.Single.NegativeInfinity>。  
  
    -   使用无效的输入的任何浮点操作。 例如，尝试查找是负数值的平方根返回<xref:System.Single.NaN>。  
  
    -   其值的参数与任何操作<xref:System.Single.NaN?displayProperty=nameWithType>。  
  
<a name="Conversion"></a>   
## <a name="type-conversions-and-the-single-structure"></a>类型转换和单个结构  
 <xref:System.Single>结构不定义任何显式或隐式转换运算符; 相反，由编译器实现的转换。  
  
 下表列出了可能的转换值的其他基元数值类型到<xref:System.Single>值，它也可以指示是否扩大或收缩转换以及是否生成<xref:System.Single>可能具有比精度降低原始值。  
  
|从|扩大/收缩|可能丢失精度|  
|---------------------|-------------------------|--------------------------------|  
|<xref:System.Byte>|Widening|No|  
|<xref:System.Decimal>|Widening<br /><br /> 请注意 C# 要求强制转换运算符。|可以。 <xref:System.Decimal> 支持 29 十进制数字的精度;<xref:System.Single>支持 9。|  
|<xref:System.Double>|收缩;超出范围值转换为<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>或<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>。|可以。 <xref:System.Double> 支持 17 十进制数字的精度;<xref:System.Single>支持 9。|  
|<xref:System.Int16>|Widening|No|  
|<xref:System.Int32>|Widening|可以。 <xref:System.Int32> 支持 10 个十进制数字的精度;<xref:System.Single>支持 9。|  
|<xref:System.Int64>|Widening|可以。 <xref:System.Int64> 支持 19 个十进制数字的精度;<xref:System.Single>支持 9。|  
|<xref:System.SByte>|Widening|No|  
|<xref:System.UInt16>|Widening|No|  
|<xref:System.UInt32>|Widening|可以。 <xref:System.UInt32> 支持 10 个十进制数字的精度;<xref:System.Single>支持 9。|  
|<xref:System.UInt64>|Widening|可以。 <xref:System.Int64> 支持 20 个十进制数字的精度;<xref:System.Single>支持 9。|  
  
 以下示例将转换为其他基元数值类型的最小值或最大值<xref:System.Single>值。  
  
 [!code-csharp[System.Single.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert1.cs#20)]
 [!code-vb[System.Single.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert1.vb#20)]  
  
 此外，<xref:System.Double>值<xref:System.Double.NaN?displayProperty=nameWithType>， <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>，和<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>到隐蔽<xref:System.Single.NaN?displayProperty=nameWithType>， <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>，和<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>分别。  
  
 请注意，对某些数值类型的值的转换<xref:System.Single>值可能涉及到精度损失。 如示例所示，转换时，为可能丢失精度<xref:System.Decimal>， <xref:System.Double>， <xref:System.Int32>， <xref:System.Int64>， <xref:System.UInt32>，并且<xref:System.UInt64>值到<xref:System.Single>值。  
  
 转换<xref:System.Single>值设为<xref:System.Double>的扩大转换。 转换可能会导致丢失精度，如果<xref:System.Double>类型不具有精确的表示形式的<xref:System.Single>值。  
  
 转换<xref:System.Single>值为任何基元数值数据类型的值，而<xref:System.Double>是收缩转换以及需要转换运算符 （在 C# 中) 或转换方法 （在 Visual Basic 中)。 不在范围内的目标数据类型，由目标类型定义的值`MinValue`和`MaxValue`属性下, 表中所示的行为。  
  
|目标类型|结果|  
|-----------------|------------|  
|任何整数类型|<xref:System.OverflowException>异常，则转换发生在 checked 上下文中。<br /><br /> 如果在转换发生在未检查的上下文 （在 C# 中默认值），转换操作会成功，但值溢出。|  
|<xref:System.Decimal>|<xref:System.OverflowException>异常，|  
  
 此外， <xref:System.Single.NaN?displayProperty=nameWithType>， <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>，并<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>引发<xref:System.OverflowException>转换成在 checked 的上下文中，但这些值溢出时未检查的上下文中转换成整数的整数。 转换成<xref:System.Decimal>，则始终会引发<xref:System.OverflowException>。 转换成<xref:System.Double>，它们将转换为<xref:System.Double.NaN?displayProperty=nameWithType>， <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>，和<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>分别。  
  
 请注意，通过转换可能会导致精度损失<xref:System.Single>到另一种数值类型的值。 在将非整型的转换的情况下<xref:System.Single>值，如示例输出所示，小数部分时，丢失<xref:System.Single>舍入 （如 Visual Basic 中) 或 （如 C#) 截断值。 转换成<xref:System.Decimal>值，<xref:System.Single>值中的目标数据类型不能有精确的表示形式。  
  
 以下示例将转换的大量<xref:System.Single>到多个其他数值类型的值。 在 Visual Basic （默认值） 和 C# 中检查的上下文中发生的转换 (由于[检查](~/docs/csharp/language-reference/keywords/checked.md)关键字)。 该示例的输出显示转换的结果中这两个检查未检查的上下文。 可以在 Visual Basic 中未检查的上下文中执行转换，通过使用进行编译`/removeintchecks+`编译器开关和 C# 通过注释掉`checked`语句。  
  
 [!code-csharp[System.Single.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert2.cs#21)]
 [!code-vb[System.Single.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert2.vb#21)]  
  
 数值类型的转换的详细信息，请参阅[.NET Framework 中的类型转换](~/docs/standard/base-types/type-conversion.md)并[类型转换表](~/docs/standard/base-types/conversion-tables.md)。  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>浮点功能  
 <xref:System.Single>结构和相关的类型提供多种方法来执行以下类别的操作：  
  
-   **值的比较**。 您可以调用<xref:System.Single.Equals%2A>方法来确定两个<xref:System.Single>值相等，或<xref:System.Single.CompareTo%2A>方法来确定两个值之间的关系。  
  
     <xref:System.Single>结构还支持一组完整的比较运算符。 例如，可以测试相等，或确定一个值是否大于或等于另一个值。 如果其中一个操作数<xref:System.Double>，则<xref:System.Single>值转换为<xref:System.Double>之前执行比较。 如果其中一个操作数是一种整型类型，它将转换为<xref:System.Single>之前执行比较。 虽然这些扩大转换，但它们可能需要精度损失。  
  
    > [!WARNING]
    >  由于差异精度，两个<xref:System.Single>您认为应该相等的值可能会发现不相等，这会影响比较的结果。 请参阅[测试是否相等](#Equality)详细了解比较两个部分<xref:System.Single>值。  
  
     您还可以调用<xref:System.Single.IsNaN%2A>， <xref:System.Single.IsInfinity%2A>， <xref:System.Single.IsPositiveInfinity%2A>，和<xref:System.Single.IsNegativeInfinity%2A>方法来测试这些特殊值。  
  
-   **数学运算**。 由语言编译器和公共中间语言 (CIL) 说明而不是实现常见的算术运算，例如加法、 减法、 乘法和除法<xref:System.Single>方法。 如果另一个操作数中的数学运算<xref:System.Double>，则<xref:System.Single>转换为<xref:System.Double>执行该操作和操作的结果也是之前<xref:System.Double>值。 如果另一个操作数是一种整型类型，它将转换为<xref:System.Single>执行该操作和操作的结果也是之前<xref:System.Single>值。  
  
     可以通过调用来执行其他数学运算`static`(`Shared`在 Visual Basic 中) 中的方法<xref:System.Math?displayProperty=nameWithType>类。 这些包括常用的算术的其他方法 (如<xref:System.Math.Abs%2A?displayProperty=nameWithType>， <xref:System.Math.Sign%2A?displayProperty=nameWithType>，并<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>)，geometry (如<xref:System.Math.Cos%2A?displayProperty=nameWithType>和<xref:System.Math.Sin%2A?displayProperty=nameWithType>)，和微积分 (如<xref:System.Math.Log%2A?displayProperty=nameWithType>)。  在所有情况下，<xref:System.Single>值转换为<xref:System.Double>。  
  
     您还可以操作中的单个位<xref:System.Single>值。 <xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType>方法返回其位模式中的字节数组。  通过将传递到该字节数组<xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType>方法，您还可以保留<xref:System.Single>值的位模式中的 32 位整数。  
  
-   **舍入**。 舍入为通常用作一种技术降低引起的问题的浮点表示形式和精度值之间的差异的影响。 可以舍入<xref:System.Single>值通过调用<xref:System.Math.Round%2A?displayProperty=nameWithType>方法。 但请注意，<xref:System.Single>值转换为<xref:System.Double>之前调用该方法，并转换可以会丢失精度。  
  
-   **格式设置**。 可以将转换<xref:System.Single>值为通过调用其字符串表示形式<xref:System.Single.ToString%2A>方法或使用[复合格式设置](~/docs/standard/base-types/composite-formatting.md)功能。 有关格式字符串如何控制浮点值的字符串表示形式的信息，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)主题。  
  
-   **分析字符串**。 可以将转换为浮点值的字符串表示形式<xref:System.Single>值通过调用<xref:System.Single.Parse%2A>或<xref:System.Single.TryParse%2A>方法。 如果分析操作失败，<xref:System.Single.Parse%2A>方法将引发异常，而<xref:System.Single.TryParse%2A>方法将返回`false`。  
  
-   **类型转换**。 <xref:System.Single>结构提供一个显式接口实现<xref:System.IConvertible>接口，支持任何两个标准的.NET Framework 数据类型之间的转换。 语言编译器还支持值的隐式转换时对于所有其他标准数值类型的转换除外<xref:System.Double>到<xref:System.Single>值。 以外的其他任何标准数值类型的值的转换<xref:System.Double>到<xref:System.Single>的扩大转换和不需要使用强制转换运算符或转换方法。  
  
     但是，32 位和 64 位整数值的转换可以会丢失精度。 下表列出了适用于 32 位、 64 位精度的差异和<xref:System.Double>类型：  
  
    |类型|最大精度 （以十进制数字）|内部精度 （以十进制数字）|  
    |----------|---------------------------------------------|----------------------------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int32> 和 <xref:System.UInt32>|10|10|  
    |<xref:System.Int64> 和 <xref:System.UInt64>|19|19|  
    |<xref:System.Single>|7|9|  
  
     精度问题最频繁影响<xref:System.Single>值转换为<xref:System.Double>值。 在以下示例中，生成的相同除法运算的两个值不相等，因为值之一是单精度浮点值转换为<xref:System.Double>。  
  
     [!code-csharp[System.Single.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Single.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist1.vb#5)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型所有成员都是线程安全。 看起来要修改实例状态的成员实际上返回使用新值进行初始化的新实例。 作为使用任何其他类型，读取和写入对共享变量包含此类型的实例必须受到使用锁来确保线程安全性。</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Double" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例与指定对象或其他 <see cref="T:System.Single" /> 实例进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于指定对象或其他 <see cref="T:System.Single" /> 实例的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要比较的对象，或为 <see langword="null" />。</param>
        <summary>将此实例与指定对象进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于指定对象的值。</summary>
        <returns>一个带符号数字，指示此实例和 <paramref name="value" /> 的相对值。  
  
 <list type="table"><listheader><term> 返回值 
 </term><description> 描述 
 </description></listheader><item><term> 小于零 
 </term><description> 此实例小于 <paramref name="value" />。  
  
- 或 - 
此实例不是数字 (<see cref="F:System.Single.NaN" />) 而 <paramref name="value" /> 是数字。  
  
 </description></item><item><term> 零 
 </term><description> 此实例等于 <paramref name="value" />。  
  
- 或 - 
此实例和值都不是数字 (<see cref="F:System.Single.NaN" />)、<see cref="F:System.Single.PositiveInfinity" /> 或 <see cref="F:System.Single.NegativeInfinity" />。  
  
 </description></item><item><term> 大于零 
 </term><description> 此实例大于 <paramref name="value" />。  
  
- 或 - 
此实例是数字而 <paramref name="value" /> 不是数字 (<see cref="F:System.Single.NaN" />)。  
  
- 或 - 
 <paramref name="value" /> 为 <see langword="null" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`参数必须是`null`的实例或<xref:System.Single>; 否则为将引发异常。 任何实例<xref:System.Single>，而不考虑其值被视为大于`null`。  
  
 值必须完全相同，将被视为相等。 尤其是当浮点值依赖于多个数学运算，是一种常见他们丢失精度，其值才能几乎完全相同，但其最小有效位除外。 正因为如此，返回值的<xref:System.Single.CompareTo%2A>方法有时可能有点令人惊讶。 例如，由相同的值的特定值除法后跟乘法运算应生成原始值，但在以下示例中，计算的值证明大于原始值。 通过使用"R"中显示的两个值的所有有效位数[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)指示计算出的值不同于其最小有效位中的原始值。 了解如何处理这种比较信息，请参阅备注部分的<xref:System.Single.Equals%28System.Single%29>方法。  
  
 [!code-csharp[System.Single.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Single.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto3.vb#2)]  
  
 实现此方法以支持<xref:System.IComparable>接口。 请注意，尽管<xref:System.Single.NaN>不等于另一个被视为<xref:System.Single.NaN>（即使是其自身），<xref:System.IComparable>接口需要`A.CompareTo(A)`返回零。  
  
## <a name="precision-in-comparisons"></a>在比较中的精度  
 超出有案可稽的精度的浮点数的精度是特定于实现和.NET Framework 版本。 因此，两个特定数字的比较可能会更改的.NET Framework 版本之间，因为数字的内部表示形式的精度可能会更改。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Single.CompareTo%2A>方法。  
  
 [!code-cpp[System.Single#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#16)]
 [!code-csharp[System.Single#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#16)]
 [!code-vb[System.Single#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 不是 <see cref="T:System.Single" />。</exception>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(float value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : single -&gt; int&#xA;override this.CompareTo : single -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">要比较的单精度浮点数。</param>
        <summary>将此实例与指定的单精度浮点数进行比较，并返回一个整数，该整数指示此实例的值是小于、等于还是大于指定单精度浮点数的值。</summary>
        <returns>一个带符号数字，指示此实例和 <paramref name="value" /> 的相对值。  
  
 <list type="table"><listheader><term> 返回值 
 </term><description> 描述 
 </description></listheader><item><term> 小于零 
 </term><description> 此实例小于 <paramref name="value" />。  
  
- 或 - 
此实例不是数字 (<see cref="F:System.Single.NaN" />) 而 <paramref name="value" /> 是数字。  
  
 </description></item><item><term> 零 
 </term><description> 此实例等于 <paramref name="value" />。  
  
- 或 - 
此实例和 <paramref name="value" /> 都不是数字 (<see cref="F:System.Single.NaN" />)、<see cref="F:System.Single.PositiveInfinity" /> 或 <see cref="F:System.Single.NegativeInfinity" />。  
  
 </description></item><item><term> 大于零 
 </term><description> 此实例大于 <paramref name="value" />。  
  
- 或 - 
此实例是数字而 <paramref name="value" /> 不是数字 (<see cref="F:System.Single.NaN" />)。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值必须完全相同，将被视为相等。 它是常见的浮点值会丢失精度，尤其是在值取决于多个数学运算时变得几乎完全相同，但其最小有效位，除外。 正因为如此，返回值的<xref:System.Single.CompareTo%2A>方法有时看上去可能令人惊讶。 例如，任何值后, 接部门通过相同的值乘以应生成原始值。 但是，在以下示例中，计算的值证明大于原始值。 通过使用"R"中显示的两个值的所有有效位数[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)指示计算出的值不同于其最小有效位中的原始值。 了解如何处理这种比较信息，请参阅备注部分的<xref:System.Single.Equals%28System.Single%29>方法。  
  
 [!code-csharp[System.Single.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Single.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto2.vb#1)]  
  
 此方法实现<xref:System.IComparable%601?displayProperty=nameWithType>接口，并且执行略微优于<xref:System.Single.CompareTo%2A?displayProperty=nameWithType>方法因为它不具有要转换`value`参数的对象。  
  
 请注意，虽然一个对象，其值是<xref:System.Single.NaN>不被视为等于另一个对象，其值是<xref:System.Single.NaN>（即使是其自身），<xref:System.IComparable%601>接口需要`A.CompareTo(A)`返回零。  
  
## <a name="widening-conversions"></a>扩大转换  
 具体取决于您的编程语言，有可能对代码<xref:System.Single.CompareTo%2A>方法的参数类型包含的位数少于 （是更窄） 比实例类型。 这可能是因为某些编程语言执行表示具有任意数量的位的实例作为类型参数的隐式扩大转换。  
  
 例如，假设实例类型是<xref:System.Single>且参数类型为<xref:System.Int32>。 Microsoft C# 编译器将生成表示形式的参数值的说明<xref:System.Single>对象，然后生成<xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType>进行比较的实例的值和参数加宽表示形式的方法。  
  
 请查阅您的编程语言的文档以确定其编译器是否执行数值类型的隐式扩大转换。 有关详细信息，请参阅[类型转换表](~/docs/standard/base-types/conversion-tables.md)主题。  
  
## <a name="precision-in-comparisons"></a>在比较中的精度  
 超出有案可稽的精度的浮点数的精度是特定于实现和.NET Framework 版本。 因此，两个特定数字的比较可能会更改的.NET Framework 版本之间，因为数字的内部表示形式的精度可能会更改。  
  
   
  
## Examples  
 下面的代码示例演示了泛型和非泛型版本的<xref:System.Single.CompareTo%2A>多个值和引用类型的方法。  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 Epsilon = float32(1.401298E-45)" />
      <MemberSignature Language="DocId" Value="F:System.Single.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Single  = 1.401298E-45" />
      <MemberSignature Language="C++ CLI" Value="public: float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : single" Usage="System.single.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>1.401298E-45</MemberValue>
      <Docs>
        <summary>表示大于零的最小正 <see cref="T:System.Single" /> 值。 此字段为常数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.Single.Epsilon>属性会反映出的最小正<xref:System.Single>非常重要数值操作或比较的值时的值<xref:System.Single>实例是零。 例如，以下代码所示的零和<xref:System.Single.Epsilon>被视为不相等的值，而零和一半的值<xref:System.Single.Epsilon>被视为相等。  
  
 [!code-csharp[System.Single.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Single.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon.vb#5)]  
  
 更确切地说，单精度浮点格式包含一个符号、 一个 23 位尾数或有效位数和一个 8 位指数。 如下面的示例所示，零具有-126 指数和尾数的 0 字节。 <xref:System.Single.Epsilon> 具有-126 指数和尾数的 1 字节。 这意味着<xref:System.Single.Epsilon?displayProperty=nameWithType>是最小正<xref:System.Single>值，该值大于零并表示可能的最小值和可能的最小增量<xref:System.Single>其指数是-126。  
  
 [!code-csharp[System.Single.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Single.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon1.vb#6)]  
  
 但是，<xref:System.Single.Epsilon>属性不是常规度量值的精度<xref:System.Single>类型; 它仅适用于<xref:System.Single>具有零值的实例。  
  
> [!NOTE]
>  值<xref:System.Single.Epsilon>属性并不等同于机 epsilon、 表示由于浮点运算中的舍入的相关错误的上限。  
  
 此常量的值为 1.4 e-45。  
  
 两个显然等效的浮点数的比较结果可能为不相等，因为其最小有效位之间的差异。 例如，C# 表达式`(float)1/3 == (float)0.33333`，不会不相等，因为除法运算左侧和右侧具有最大精度，而右侧常量是仅精确到指定的位。 如果创建自定义算法来确定是否可视为两个浮点数相等，则必须使用一个值，超过该值<xref:System.Single.Epsilon>要建立的可接受的绝对差异的两个值可供边距常量被视为相等。 (通常情况下，该边距的差异大于很多时候<xref:System.Single.Epsilon>。)  
  
## <a name="platform-notes"></a>平台说明  
 在 ARM 系统中，值<xref:System.Single.Epsilon>常量是太小，无法检测到，因此它相当于零。 可以定义一个备用 epsilon 值，等于 1.175494351E-38 相反。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示 <see cref="T:System.Single" /> 的两个实例是否表示同一个值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">与此实例进行比较的对象。</param>
        <summary>返回一个值，该值指示此实例是否等于指定的对象。</summary>
        <returns>如果 <see langword="true" /> 是 <paramref name="obj" /> 的实例并且等于此实例的值，则为 <see cref="T:System.Single" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.Equals%2A>应谨慎使用，使用方法，因为两个看似相等的值可能是由于两个值的精度不同不相等。 下面的示例报告<xref:System.Single>值.3333 和<xref:System.Single>返回除以 1 3 是否不相等。  
  
 [!code-csharp[System.Single.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#3)]
 [!code-vb[System.Single.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#3)]  
  
 而不是比较相等性，建议采用的一种方法是定义可接受两个值之间的差异的边距 (如。 01%的值之一)。 如果两个值之间的差的绝对值是小于或等于该边距，不同之处很可能是由于精度的不同，并且，因此，这些值很可能是相等。 下面的示例使用此技术比较.33333 和 1/3，这两个<xref:System.Single>前面的代码示例找到不相等的值。  
  
 [!code-csharp[System.Single.Epsilon#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#4)]
 [!code-vb[System.Single.Epsilon#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#4)]  
  
 在这种情况下，值相等。  
  
> [!NOTE]
>  因为<xref:System.Single.Epsilon>定义的最小的表达式必须大于差异的距其范围是接近于零的正值， <xref:System.Single.Epsilon>。 通常情况下，它是比<xref:System.Single.Epsilon>。  
  
 超出有案可稽的精度的浮点数的精度是特定于实现和.NET Framework 版本。 因此，两个特定数字的比较可能会更改的.NET Framework 版本之间，因为数字的内部表示形式的精度可能会更改。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Single.Equals%2A>方法。  
  
 [!code-cpp[System.Single#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#17)]
 [!code-csharp[System.Single#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#17)]
 [!code-vb[System.Single#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#17)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>编译器重载解析行为的两个明显的差异可能会考虑<see cref="M:System.Single.Equals(System.Object)" />方法重载。 如果之间的隐式转换<paramref name="obj" />自变量和一个<see cref="T:System.Single" />定义和自变量类型不是<see cref="T:System.Object" />，编译器可能会执行隐式转换和调用<see cref="M:System.Single.Equals(System.Single)" />方法。 否则，调用方法<see cref="M:System.Single.Equals(System.Object)" />方法，它始终返回<see langword="false" />如果其<paramref name="obj" />参数不是<see cref="T:System.Single" />值。 下面的示例说明了两个方法重载之间的行为差异。 在除所有基元数值类型的情况下<see cref="T:System.Double" />在 Visual Basic 和除<see cref="T:System.Decimal" />并<see cref="T:System.Double" />在 C# 中，第一次比较返回<see langword="true" />因为编译器会自动执行扩大转换和调用<see cref="M:System.Single.Equals(System.Single)" />方法，而第二个比较返回<see langword="false" />因为编译器将调用<see cref="M:System.Single.Equals(System.Object)" />方法。  
  
[!code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [!code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (float obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(float obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : single -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="obj">与此实例进行比较的对象。</param>
        <summary>返回一个值，该值指示此实例和指定的 <see cref="T:System.Single" /> 对象是否表示相同的值。</summary>
        <returns>如果 <see langword="true" /> 与此实例相等，则为 <paramref name="obj" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法实现<xref:System.IEquatable%601?displayProperty=nameWithType>接口，并且执行略微优于<xref:System.Single.Equals%2A>因为它不具有要转换`obj`参数的对象。  
  
## <a name="widening-conversions"></a>扩大转换  
 具体取决于您的编程语言，有可能对代码<xref:System.Single.Equals%2A>方法的参数类型包含的位数少于 （是更窄） 比实例类型。 这可能是因为某些编程语言执行表示具有任意数量的位的实例作为类型参数的隐式扩大转换。  
  
 例如，假设实例类型是<xref:System.Single>且参数类型为<xref:System.Int32>。 Microsoft C# 编译器将生成表示形式的参数值的说明<xref:System.Single>对象，并生成<xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType>进行比较的实例的值和参数加宽表示形式的方法。  
  
 请查阅您的编程语言的文档以确定其编译器是否执行数值类型的隐式扩大转换。 有关详细信息，请参阅[类型转换表](~/docs/standard/base-types/conversion-tables.md)主题。  
  
## <a name="precision-in-comparisons"></a>在比较中的精度  
 <xref:System.Single.Equals%2A>应谨慎使用，使用方法，因为两个看似相等的值可能是由于两个值的精度不同不相等。 下面的示例报告<xref:System.Single>值.3333 和<xref:System.Single>返回除以 1 3 是否不相等。  
  
 [!code-csharp[System.Single.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#1)]
 [!code-vb[System.Single.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#1)]  
  
 一次比较技术，可避免比较相等性涉及定义两个值之间的差异的可接受幅度与相关的问题 (如。 01%的值之一)。 如果两个值之间的差的绝对值是小于或等于该边距的区别是，可能需要的精度之间的差异的结果，并且，因此，值很可能相等。 下面的示例使用此方法比较.33333 和 1/3，这两种<xref:System.Single>前面的代码示例找到不相等的值。  
  
 [!code-csharp[System.Single.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#2)]
 [!code-vb[System.Single.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#2)]  
  
 在这种情况下，值相等。  
  
> [!NOTE]
>  因为<xref:System.Single.Epsilon>定义的最小的表达式必须大于差异的距其范围是接近于零的正值， <xref:System.Single.Epsilon>。 通常情况下，它是比<xref:System.Single.Epsilon>。 因此，我们建议不要使用<xref:System.Double.Epsilon>比较时<xref:System.Double>值是否相等。  
  
 另一种技术能够避免与比较相等性相关的问题涉及比较两个浮点数与某些绝对值的数值之间的差异。 其差异是小于或等于该绝对值的数值，如果数字相等。 如果超出该时间，则数字不相等。 若要执行此操作的一种方法是任意选择一个绝对值。 但是，这是有问题，，因为差异的可接受幅度取决于度量值的<xref:System.Single>值。 第二种方式利用某个设计功能上的浮点格式：两个浮点值的整数表示形式中的尾数组件之间的差异指示分隔的两个值的可能的浮点值数。 例如，0.0 之间的差异并<xref:System.Single.Epsilon>为 1，因为<xref:System.Single.Epsilon>使用时是最小的可表示值<xref:System.Single>其值为零。 下面的示例使用此方法比较.33333 和 1/3，这两种<xref:System.Double>的值与前面的代码示例<xref:System.Single.Equals%28System.Single%29>方法找到不相等。 请注意，该示例使用<xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>和<xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType>方法将单精度浮点值转换为整数表示形式。  
  
 [!code-csharp[System.Single.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Single.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsabs1.vb#1)]  
  
 超出有案可稽的精度的浮点数的精度是特定于实现和.NET Framework 版本。 因此，两个数字的比较可能会产生不同的结果，具体取决于.NET Framework 的版本，因为数字的内部表示形式的精度可能会更改。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>编译器重载解析行为的两个明显的差异可能会考虑<see cref="M:System.Single.Equals(System.Object)" />方法重载。 如果之间的隐式转换<paramref name="obj" />自变量和一个<see cref="T:System.Single" />定义和自变量类型不是<see cref="T:System.Object" />，编译器可能会执行隐式转换和调用<see cref="M:System.Single.Equals(System.Single)" />方法。 否则，调用方法<see cref="M:System.Single.Equals(System.Object)" />方法，它始终返回<see langword="false" />如果其<paramref name="obj" />参数不是<see cref="T:System.Single" />值。 下面的示例说明了两个方法重载之间的行为差异。 在除所有基元数值类型的情况下<see cref="T:System.Double" />在 Visual Basic 和除<see cref="T:System.Decimal" />并<see cref="T:System.Double" />在 C# 中，第一次比较返回<see langword="true" />因为编译器会自动执行扩大转换和调用<see cref="M:System.Single.Equals(System.Single)" />方法，而第二个比较返回<see langword="false" />因为编译器将调用<see cref="M:System.Single.Equals(System.Object)" />方法。  
  
[!code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [!code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.Equals(System.Object)" />
        <altmember cref="Overload:System.Single.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="single.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此实例的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="single.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回值类型 <see cref="T:System.TypeCode" /> 的 <see cref="T:System.Single" />。</summary>
        <returns>枚举常数 <see cref="F:System.TypeCode.Single" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsFinite(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(float f);" />
      <MemberSignature Language="F#" Value="static member IsFinite : single -&gt; bool" Usage="System.single.IsFinite f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : single -&gt; bool" Usage="System.single.IsInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">单精度浮点数。</param>
        <summary>返回一个值，该值指示指定数字是计算为负无穷大还是正无穷大。</summary>
        <returns>如果 <paramref name="f" /> 的计算结果为 <see cref="F:System.Single.PositiveInfinity" /> 或 <see cref="F:System.Single.NegativeInfinity" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回浮点运算<xref:System.Single.PositiveInfinity>或<xref:System.Single.NegativeInfinity>发出信号的溢出条件。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Single.IsInfinity%2A>方法。  
  
 [!code-cpp[System.Single#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#11)]
 [!code-csharp[System.Single#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#11)]
 [!code-vb[System.Single#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNaN(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(float f);" />
      <MemberSignature Language="F#" Value="static member IsNaN : single -&gt; bool" Usage="System.single.IsNaN f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">单精度浮点数。</param>
        <summary>返回一个值，该值指示指定的值是否不为数字 (<see cref="F:System.Single.NaN" />)。</summary>
        <returns>如果 <paramref name="f" /> 计算为非数字 (<see cref="F:System.Single.NaN" />)，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮点运算返回<xref:System.Single.NaN>发出信号的操作的结果是不确定。 例如，将除以 0.0 0.0 导致<xref:System.Single.NaN>。  
  
> [!NOTE]
>  <xref:System.Single.IsNaN%2A> 返回`false`如果<xref:System.Single>值为<xref:System.Single.PositiveInfinity>或<xref:System.Single.NegativeInfinity>。 若要测试这些值，请使用<xref:System.Single.IsInfinity%2A>， <xref:System.Single.IsPositiveInfinity%2A>，和<xref:System.Single.IsNegativeInfinity%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Single.IsNaN%2A>方法。  
  
 [!code-cpp[System.Single#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#8)]
 [!code-csharp[System.Single#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#8)]
 [!code-vb[System.Single#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegative(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegative : single -&gt; bool" Usage="System.single.IsNegative f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegativeInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : single -&gt; bool" Usage="System.single.IsNegativeInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">单精度浮点数。</param>
        <summary>返回一个值，通过该值指示指定数字是否计算为负无穷大。</summary>
        <returns>如果 <paramref name="f" /> 的计算结果为 <see cref="F:System.Single.NegativeInfinity" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮点运算返回<xref:System.Single.NegativeInfinity>发出信号的溢出条件。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Single.IsNegativeInfinity%2A>方法。  
  
 [!code-cpp[System.Single#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#13)]
 [!code-csharp[System.Single#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#13)]
 [!code-vb[System.Single#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsNormal : single -&gt; bool" Usage="System.single.IsNormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsPositiveInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : single -&gt; bool" Usage="System.single.IsPositiveInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">单精度浮点数。</param>
        <summary>返回一个值，通过该值指示指定数字是否计算为正无穷大。</summary>
        <returns>如果 <paramref name="f" /> 的计算结果为 <see cref="F:System.Single.PositiveInfinity" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浮点运算返回<xref:System.Single.PositiveInfinity>发出信号的溢出条件。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Single.IsPositiveInfinity%2A>方法。  
  
 [!code-cpp[System.Single#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#12)]
 [!code-csharp[System.Single#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#12)]
 [!code-vb[System.Single#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsSubnormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : single -&gt; bool" Usage="System.single.IsSubnormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MaxValue = float32(3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Single  = 3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : single" Usage="System.single.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.402823E+38</MemberValue>
      <Docs>
        <summary>表示 <see cref="T:System.Single" /> 的最大可能值。 此字段为常数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此常量的值为正 3.40282347e+38。  
  
 超过了操作的结果<xref:System.Single.MaxValue?displayProperty=nameWithType>是<xref:System.Single.PositiveInfinity?displayProperty=nameWithType>。 在以下示例中，<xref:System.Single.PositiveInfinity?displayProperty=nameWithType>得到的加法、 乘法和求幂运算时结果超出了<xref:System.Single.MaxValue?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Single.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Single.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Single.MaxValue>常量。  
  
 [!code-cpp[System.Single#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#4)]
 [!code-csharp[System.Single#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#4)]
 [!code-vb[System.Single#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const float MinValue = -3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MinValue = float32(-3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Single  = -3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MinValue = -3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : single" Usage="System.single.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-3.402823E+38</MemberValue>
      <Docs>
        <summary>表示 <see cref="T:System.Single" /> 的最小可能值。 此字段为常数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此常量的值为-3.402823 e 38。  
  
 是操作的结果小于<xref:System.Single.MinValue?displayProperty=nameWithType>是<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>。 在以下示例中，<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>得到的减法和乘法操作时的结果是小于<xref:System.Single.MinValue?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Single.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Single.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Single.MinValue>常量。  
  
 [!code-cpp[System.Single#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#5)]
 [!code-csharp[System.Single#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#5)]
 [!code-vb[System.Single#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const float NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NaN = float32(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Single  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: float NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : single" Usage="System.single.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>表示非数字 (<see langword="NaN" />)。 此字段为常数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法或运算符返回<xref:System.Single.NaN>时操作的结果是不确定。 例如，零被零除的结果是<xref:System.Single.NaN>，如下面的示例所示。 (但请注意，返回一个非零数字除以 0 或者<xref:System.Single.PositiveInfinity>或<xref:System.Single.NegativeInfinity>，取决除数的符号。)  
  
 [!code-csharp[System.Single.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#1)]
 [!code-vb[System.Single.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#1)]  
  
 此外，一种方法调用<xref:System.Single.NaN>值或上的一个操作<xref:System.Single.NaN>值返回<xref:System.Single.NaN>，如下面的示例所示。  
  
 [!code-csharp[System.Single.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#2)]
 [!code-vb[System.Single.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#2)]  
  
 使用<xref:System.Single.IsNaN%2A>方法来确定值是否不是一个数字。 一般情况下，<xref:System.Single>不能使用运算符来比较<xref:System.Single.NaN?displayProperty=nameWithType>与其他<xref:System.Single>值，尽管比较方法 (如<xref:System.Single.Equals%2A>和<xref:System.Single.CompareTo%2A>) 可以。 下面的示例阐释了之间的行为差异<xref:System.Single>比较运算符和方法。  
  
 [!code-csharp[System.Single.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/single.nan4.cs#4)]
 [!code-vb[System.Single.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/single.nan4.vb#4)]  
  
   
  
## Examples  
 下面的示例演示<xref:System.Single.NaN>常量。  
  
 [!code-cpp[System.Single#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#7)]
 [!code-csharp[System.Single#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#7)]
 [!code-vb[System.Single#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNaN(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NegativeInfinity = float32(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Single  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : single" Usage="System.single.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>表示负无穷。 此字段为常数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此常量的值是负数除以 0 的结果。  
  
 操作的结果时返回此常量小于<xref:System.Single.MinValue>。  
  
 使用<xref:System.Single.IsNegativeInfinity%2A>来确定值是否计算为负无穷大。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Single.NegativeInfinity>常量。  
  
 [!code-cpp[System.Single#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#9)]
 [!code-csharp[System.Single#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#9)]
 [!code-vb[System.Single#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Equality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : single * single -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示两个指定的 <see cref="T:System.Single" /> 值是否相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_Equality%2A>方法定义的相等运算符<xref:System.Single>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : single * single -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示指定的 <see cref="T:System.Single" /> 值是否大于另一个指定的 <see cref="T:System.Single" /> 值。</summary>
        <returns>如果 <see langword="true" /> 大于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_GreaterThan%2A>方法定义的较大的操作-比运算符<xref:System.Single>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : single * single -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示指定的 <see cref="T:System.Single" /> 值是否大于或等于另一个指定的 <see cref="T:System.Single" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 大于等于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_GreaterThanOrEqual%2A>方法定义为大于或等于运算符的运算<xref:System.Single>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Inequality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : single * single -&gt; bool" Usage="System.single.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示两个指定的 <see cref="T:System.Single" /> 值是否不相等。</summary>
        <returns>如果 <paramref name="left" /> 和 <paramref name="right" /> 不相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_Inequality%2A>方法定义为不等运算符<xref:System.Single>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : single * single -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示指定的 <see cref="T:System.Single" /> 值是否小于另一个指定的 <see cref="T:System.Single" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_LessThan%2A>方法定义小于运算的运算符比<xref:System.Single>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : single * single -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个值。</param>
        <param name="right">要比较的第二个值。</param>
        <summary>返回一个值，该值指示指定的 <see cref="T:System.Single" /> 值是否小于或等于另一个指定的 <see cref="T:System.Single" /> 值。</summary>
        <returns>如果 <paramref name="left" /> 小于等于 <paramref name="right" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_LessThanOrEqual%2A>方法定义为小于或等于运算符的运算<xref:System.Single>值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数字的字符串表示形式转换为它的等效单精度浮点数。</summary>
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; single" Usage="System.single.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的数字的字符串。</param>
        <summary>将数字的字符串表示形式转换为它的等效单精度浮点数。</summary>
        <returns>与 <paramref name="s" /> 中指定的数值或符号等效的单精度浮点数字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `s`参数可以包含当前区域性<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>，或格式的字符串：  
  
 [*ws*][*sign*] [*integral-digits*[*,*]]*integral-digits*[*.*[*fractional-digits*]][e[*sign*]*exponential-digits*][*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列的空白字符。|  
|*sign*|负号符号或正号符号。 有效的符号字符由<xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType>当前区域性的属性。 可以使用前导符号。|  
|*integral-digits*|一系列的位范围从 0 到 9 的指定数目的整数部分。 运行的*整型数字*组分隔符符号可以对其进行分区。 例如，在某些区域性中逗号 （，） 作为千位分隔符。 *整型数字*元素可以是当字符串包含*小数位数*元素。|  
|*，*|特定于区域性的千位分隔符号。|  
|*.*|特定于区域性的小数点符号。|  
|*fractional-digits*|一系列的位范围从 0 到 9 的指定数字的小数部分。|  
|E|"E"或者"E"字符，指示指数 （科学型） 表示法表示值。|  
|*exponential-digits*|一系列的范围从 0 到 9 的指定指数的位数。|  
  
 `s`参数被解释使用的组合<xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>标志。 这意味着该空白和千位分隔符允许但不是货币符号。 若要显式定义的元素 (如货币符号，千位分隔符和空格)，可能会包含`s`，使用<xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>方法重载。  
  
 `s`通过使用中的格式设置信息分析参数<xref:System.Globalization.NumberFormatInfo>对象，将初始化为当前系统区域性。 有关详情，请参阅<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>。 若要使用特定区域性的格式设置信息分析一个字符串，请使用<xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29>或<xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>方法。  
  
 通常，如果传递<xref:System.Single.Parse%2A>方法中，通过调用创建的字符串<xref:System.Single.ToString%2A>方法时，原始<xref:System.Single>返回值。 但是，由于丢失精度，值可能不相等。  
  
 如果分隔符时遇到`s`参数在分析操作，以及适用的货币或十进制数和组分隔符是相同的分析操作假定，分隔符是十进制分隔符，而不是一组分隔符。 有关分隔符的详细信息，请参阅<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Single.Parse%28System.String%29>方法，将一个字符串数组转换为等效<xref:System.Single>值。  
  
 [!code-csharp[System.Single.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse1.cs#2)]
 [!code-vb[System.Single.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不表示具有有效格式的数字。</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> 表示一个小于 <see cref="F:System.Single.MinValue" /> 或大于 <see cref="F:System.Single.MaxValue" /> 的数字。</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">分析 .NET 中的数字字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; single" Usage="System.single.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的数字的字符串。</param>
        <param name="style">枚举值的按位组合，用于指示可出现在 <paramref name="s" /> 中的样式元素。 一个用来指定的典型值为 <see cref="F:System.Globalization.NumberStyles.Float" /> 与 <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> 的组合。</param>
        <summary>将具有指定样式的数字的字符串表示形式转换为它的等效单精度浮点数。</summary>
        <returns>与在 <paramref name="s" /> 中指定的数值或符号等效的单精度浮点数字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style`参数定义的样式元素 (如空白、 千位分隔符和货币符号) 中允许`s`分析操作成功的参数。 它必须是从位标志的组合<xref:System.Globalization.NumberStyles>枚举。 以下<xref:System.Globalization.NumberStyles>不支持成员：  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s`参数可以包含当前区域性<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>。 具体取决于值`style`，它还可以采用以下形式：  
  
 [*ws*][*$*][*sign*][*integral-digits*[*,*]]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表对每个元素进行了描述。  
  
 *ws*  
 一系列空白字符。 空白可以出现在开头`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>标志，它可以出现在末尾`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>标志。  
  
 $  
 特定于区域性的货币符号。 在字符串中的位置由<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType>当前区域性的属性。 当前区域性的货币符号可以出现在`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>标志。  
  
 *sign*  
 负号符号 （-） 或正号符号 （+）。 符号可以显示在开头`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>标志，它可以出现在末尾`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>标志。 可以在使用括号`s`指示负值`style`包括<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>标志。  
  
 *integral-digits*  
 一系列的位范围从 0 到 9 的指定数目的整数部分。 *整型数字*元素可以是当字符串包含*小数位数*元素。  
  
 ,  
 特定于区域性的组分隔符。 当前区域性的组分隔符符号可以出现在`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>标志  
  
 .  
 特定于区域性的小数点符号。 当前区域性的小数点符号可以出现在`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>标志。  
  
 *fractional-digits*  
 一系列的位范围从 0 到 9 的指定数字的小数部分。 在中出现的小数位`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>标志。  
  
 E  
 "E"或者"E"字符，指示指数 （科学型） 表示法表示值。 `value`参数可以表示指数表示法的数字，如果`style`包括<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>标志。  
  
 *exponential-digits*  
 一系列的范围从 0 到 9 的指定指数的位数。  
  
> [!NOTE]
> 中的任何终止 NUL (U + 0000) 字符`s`在分析操作，而不考虑的值，将忽略`style`参数。

 仅为数字的字符串 (对应于<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>样式) 总是可以分析成功。 剩余<xref:System.Globalization.NumberStyles?displayProperty=nameWithType>成员控件可能会显示，但不是要求是存在于输入字符串中的元素。 下表指示个别<xref:System.Globalization.NumberStyles>标志将影响可能会出现在元素`s`。  
  
|NumberStyles 值|元素中允许使用`s`除数字之外|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*整型数字*仅元素。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小数点 (*。*) 和*小数位数*元素。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E"或者"E"字符，它指示指数记数法。 此标志本身支持窗体的值*位数*E*数字*; 其他标志需要为成功分析此类元素为正或负号和小数点符号的字符串。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*开头的元素`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*结尾的元素`s`。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*符号*开头的元素`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*符号*结尾的元素`s`。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*登录*形式的括号内包含的数字值的元素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|千位分隔符 （，） 元素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|货币 （$） 元素中。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有元素。 但是，`s`不能表示十六进制数或指数表示法的数字。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*元素的开头或末尾`s`，*登录*开头`s`，和小数点 （.） 符号。 `s`参数还可以使用指数记数法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`， `sign`，千位分隔符 （，） 和小数点 （.） 元素。|  
|<xref:System.Globalization.NumberStyles.Any>|所有元素。 但是，`s`不能表示十六进制数。|  
  
 一些示例`s`包括"100"、"-123456789"、"123.45 e + 6"、"+ 500"、"5e2"、"3.1416"，"600"，"-。 123" 和"-Infinity"。  
  
 `s`使用中的格式设置信息分析参数<xref:System.Globalization.NumberFormatInfo>对象，将初始化为当前系统区域性。 若要指定其格式设置信息用于分析操作的区域性，调用<xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>重载。  
  
 通常，如果传递<xref:System.Single.Parse%2A>方法中，通过调用创建的字符串<xref:System.Single.ToString%2A>方法时，原始<xref:System.Single>返回值。 但是，由于丢失精度，值可能不相等。  
  
 如果分隔符时遇到`s`参数在分析操作，以及适用的货币或十进制数和组分隔符是相同的分析操作假定，分隔符是十进制分隔符，而不是一组分隔符。 有关分隔符的详细信息，请参阅<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>方法，以便分析的字符串表示形式<xref:System.Single>值。 该示例使用 EN-US 区域性的格式设置信息。  
  
 [!code-csharp[System.Single.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse2.cs#3)]
 [!code-vb[System.Single.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不是一个具有有效格式的数字。</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> 表示一个小于 <see cref="F:System.Single.MinValue" /> 或大于 <see cref="F:System.Single.MaxValue" /> 的数字。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
- 或 - 
 <paramref name="style" /> 包括 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 值。</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">分析 .NET 中的数字字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; single" Usage="System.single.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的数字的字符串。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式设置信息。</param>
        <summary>将具有指定区域性特定格式的数字的字符串表示形式转换为它的等效单精度浮点数。</summary>
        <returns>与 <paramref name="s" /> 中指定的数值或符号等效的单精度浮点数字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载通常用于将可以各种方式格式化文本转换<xref:System.Single>值。 例如，它可以用于将输入到 HTML 文本中用户的数字值的文本转换。  
  
 `s`参数被解释使用的组合<xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>标志。 `s`参数可以包含<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>，或<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>为指定的区域性`provider`，也可以包含格式的字符串：  
  
 [*ws*][*sign*]*integral-digits*[*.*[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 可选元素括在方括号 （[和]）。 包含字词"数字"的元素包含一系列的范围从 0 到 9 的数字字符。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列空白字符。|  
|*sign*|负号符号 （-） 或正号符号 （+）。|  
|*integral-digits*|一系列的位范围从 0 到 9 的指定数目的整数部分。 运行的*整型数字*组分隔符符号可以对其进行分区。 例如，在某些区域性中逗号 （，） 作为千位分隔符。 *整型数字*元素可以是当字符串包含*小数位数*元素。|  
|.|特定于区域性的小数点符号。|  
|*fractional-digits*|一系列的位范围从 0 到 9 的指定数字的小数部分。|  
|E|"E"或者"E"字符，指示指数 （科学型） 表示法表示值。|  
|*exponential-digits*|一系列的范围从 0 到 9 的指定指数的位数。|  
  
 有关数值格式的详细信息，请参阅[格式设置类型](~/docs/standard/base-types/formatting-types.md)主题。  
  
 `provider`参数是<xref:System.IFormatProvider>实现其<xref:System.IFormatProvider.GetFormat%2A>方法将返回<xref:System.Globalization.NumberFormatInfo>提供特定于区域性的格式设置信息的对象。 当<xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29>调用方法时，它调用`provider`参数的<xref:System.IFormatProvider.GetFormat%2A>方法并将其传递<xref:System.Type>对象，表示<xref:System.Globalization.NumberFormatInfo>类型。 <xref:System.IFormatProvider.GetFormat%2A>方法随后返回<xref:System.Globalization.NumberFormatInfo>提供的格式有关的信息的对象`s`参数。 有三种方法使用`provider`参数来提供到分析操作的自定义格式设置信息：  
  
-   可以将传递<xref:System.Globalization.CultureInfo>对象，表示提供格式设置信息的区域性。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法将返回<xref:System.Globalization.NumberFormatInfo>提供该区域性的数字格式设置信息的对象。  
  
-   您可以将传递的实际<xref:System.Globalization.NumberFormatInfo>提供数字格式设置信息的对象。 (其实现<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>只返回其自身。)  
  
-   可以传递用于实现的自定义对象<xref:System.IFormatProvider>。 其<xref:System.IFormatProvider.GetFormat%2A>方法实例化并返回<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`或<xref:System.Globalization.NumberFormatInfo>无法获取，格式设置信息将使用在当前系统区域性。  
  
 如果分隔符时遇到`s`参数在分析操作，以及适用的货币或十进制数和组分隔符是相同的分析操作假定，分隔符是十进制分隔符，而不是一组分隔符。 有关分隔符的详细信息，请参阅<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
 一些示例`s`包括"100"、"-123456789"、"123.45 e + 6"、"+ 500"、"5e2"、"3.1416"，"600"，"-。 123" 和"-Infinity"。  
  
   
  
## Examples  
 下面的示例是按钮单击事件处理程序的 Web 窗体。 它使用返回的数组<xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType>属性来确定用户的区域设置。 它然后实例化<xref:System.Globalization.CultureInfo>对应于该区域设置的对象。 <xref:System.Globalization.NumberFormatInfo>所属的对象的<xref:System.Globalization.CultureInfo>对象然后传递给<xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29>方法将用户输入转换为<xref:System.Single>值。  
  
 [!code-csharp[ParseMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#1)]
 [!code-vb[ParseMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不表示具有有效格式的数字。</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> 表示一个小于 <see cref="F:System.Single.MinValue" /> 或大于 <see cref="F:System.Single.MaxValue" /> 的数字。</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">分析 .NET 中的数字字符串</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Single" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的数字的字符串。</param>
        <param name="style">枚举值的按位组合，用于指示可出现在 <paramref name="s" /> 中的样式元素。 一个用来指定的典型值为 <see cref="F:System.Globalization.NumberStyles.Float" /> 与 <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> 的组合。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式设置信息。</param>
        <summary>将具有指定样式和区域性特定格式的数字的字符串表示形式转换为它的等效单精度浮点数。</summary>
        <returns>与 <paramref name="s" /> 中指定的数值或符号等效的单精度浮点数字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style`参数定义的样式元素 (如空白、 千位分隔符和货币符号) 中允许`s`分析操作成功的参数。 它必须是从位标志的组合<xref:System.Globalization.NumberStyles>枚举。 以下<xref:System.Globalization.NumberStyles>不支持成员：  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s`参数可以包含<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>，或<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>为指定的区域性`provider`。 具体取决于值`style`，它还可以采用以下形式：  
  
 [*ws*] [*$*] [*sign*][*integral-digits*,]*integral-digits*[.[*fractional-digits*]][E[*sign*]*exponential-digits*][*ws*]  
  
 括在方括号 （[和]） 是可选的元素。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列空白字符。 空白可以出现在开头`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>标志，它可以出现在末尾`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>标志。|  
|$|特定于区域性的货币符号。 在字符串中的位置由<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType>和<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType>当前区域性的属性。 当前区域性的货币符号可以出现在`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>标志。|  
|*sign*|负号符号 （-） 或正号符号 （+）。 符号可以显示在开头`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>标志，它可以出现在末尾`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>标志。 可以在使用括号`s`指示负值`style`包括<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>标志。|  
|*integral-digits*|一系列的位范围从 0 到 9 的指定数目的整数部分。 *整型数字*元素可以是当字符串包含*小数位数*元素。|  
|,|特定于区域性的组分隔符。 当前区域性的组分隔符符号可以出现在`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>标志|  
|.|特定于区域性的小数点符号。 当前区域性的小数点符号可以出现在`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>标志。|  
|*fractional-digits*|一系列的位范围从 0 到 9 的指定数字的小数部分。 在中出现的小数位`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>标志。|  
|E|"E"或者"E"字符，指示指数 （科学型） 表示法表示值。 `s`参数可以表示指数表示法的数字，如果`style`包括<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>标志。|  
|*exponential-digits*|一系列的范围从 0 到 9 的指定指数的位数。|  
  
> [!NOTE]
> 中的任何终止 NUL (U + 0000) 字符`s`在分析操作，而不考虑的值，将忽略`style`参数。

 仅为数字的字符串 (对应于<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>样式) 总是可以分析成功。 剩余<xref:System.Globalization.NumberStyles?displayProperty=nameWithType>成员控件可能会显示，但不是要求是存在于输入字符串中的元素。 下表指示个别<xref:System.Globalization.NumberStyles>标志将影响可能会出现在元素`s`。  
  
|NumberStyles 值|元素中允许使用`s`除数字之外|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*整型数字*仅元素。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小数点 (*。*) 和*小数位数*元素。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E"或者"E"字符，它指示指数记数法。 此标志本身支持窗体的值*位数*E*数字*; 其他标志需要为成功分析此类元素为正或负号和小数点符号的字符串。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*开头的元素`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*结尾的元素`s`。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*符号*开头的元素`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*符号*结尾的元素`s`。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*登录*形式的括号内包含的数字值的元素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|千位分隔符 （，） 元素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|货币 （$） 元素中。|  
|<xref:System.Globalization.NumberStyles.Currency>|所有元素。 但是，`s`不能表示十六进制数或指数表示法的数字。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*元素的开头或末尾`s`，*登录*开头`s`，和小数点 （.） 符号。 `s`参数还可以使用指数记数法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`， `sign`，千位分隔符 （，） 和小数点 （.） 元素。|  
|<xref:System.Globalization.NumberStyles.Any>|所有元素。 但是，`s`不能表示十六进制数。|  
  
 `provider`参数是<xref:System.IFormatProvider>实现。 其<xref:System.IFormatProvider.GetFormat%2A>方法将返回<xref:System.Globalization.NumberFormatInfo>对象，它提供特定于区域性的格式信息`value`。 通常情况下，`provider`可以是以下之一：  
  
-   一个<xref:System.Globalization.CultureInfo>对象，表示提供数字格式设置信息的区域性。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法将返回<xref:System.Globalization.NumberFormatInfo>提供数字格式设置信息的对象。  
  
-   一个<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。 (其实现<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>只返回其自身。)  
  
-   实现一个自定义对象<xref:System.IFormatProvider>，并使用<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>方法以实例化并返回<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`，则<xref:System.Globalization.NumberFormatInfo>对象使用当前区域性。  
  
 如果分隔符时遇到`s`参数在分析操作，以及适用的货币或十进制数和组分隔符是相同的分析操作假定，分隔符是十进制分隔符，而不是一组分隔符。 有关分隔符的详细信息，请参阅<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>方法，以便分析的字符串表示形式<xref:System.Single>值。 数组中的每个字符串进行分析使用 EN-US、 NL-NL 和一个自定义区域性的格式设置约定。 自定义区域性为下划线 ("_") 和两个作为其组大小定义其组分隔符符号。  
  
 [!code-csharp[System.Single.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse3.cs#4)]
 [!code-vb[System.Single.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> 不表示一个数值。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
- 或 - 
 <paramref name="style" /> 是 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 值。</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> 表示一个小于 <see cref="F:System.Single.MinValue" /> 或大于 <see cref="F:System.Single.MaxValue" /> 的数字。</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">分析 .NET 中的数字字符串</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const float PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PositiveInfinity = float32(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Single  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : single" Usage="System.single.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>表示正无穷。 此字段为常数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此常量的值是正数除以 0 的结果。  
  
 大于运算的结果时返回此常量<xref:System.Single.MaxValue>。  
  
 使用<xref:System.Single.IsPositiveInfinity%2A>来确定值是否计算为正无穷大。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Single.PositiveInfinity>常量。  
  
 [!code-cpp[System.Single#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#10)]
 [!code-csharp[System.Single#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#10)]
 [!code-vb[System.Single#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />。</summary>
        <returns>如果当前实例的值不为零，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Single> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.Byte" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Single> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>不支持此转换。 不返回任何值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>不支持此转换。 不返回任何值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.Decimal" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Single> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.Double" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Single> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.Int16" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Single> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.Int32" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Single> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.Int64" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Single> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.SByte" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Single> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，未更改。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Single> 实例强制转换为 <xref:System.IConvertible> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">此 <see cref="T:System.Single" /> 值要转换为的类型。</param>
        <param name="provider">提供有关返回值格式信息的对象。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <paramref name="type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Single> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用`static`(`Shared`在 Visual Basic 中)<xref:System.Convert.ChangeType%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.UInt16" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Single> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.UInt32" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Single> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">忽略此参数。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />。</summary>
        <returns>当前实例的值，已转换为 <see cref="T:System.UInt64" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Single> 实例强制转换为 <xref:System.IConvertible> 接口时使用。 建议的替代项是调用<xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例的数值转换为其等效的字符串表示形式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="single.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此实例的数值转换为其等效的字符串表示形式。</summary>
        <returns>此实例的值的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString>方法格式<xref:System.Single>默认值 （"G"或常规） 中的值的当前区域性的格式。 如果你想要指定不同的格式或区域性，使用的其他重载<xref:System.Single.ToString%2A>方法，按如下所示：  
  
|若要使用格式|区域性|使用重载|  
|-------------------|-----------------|----------------------|  
|默认值 ("G") 格式|特定区域性|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|特定的格式|默认值 （当前） 区域性|<xref:System.Single.ToString%28System.String%29>|  
|特定的格式|特定区域性|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 返回值可以是<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>，或格式的字符串：  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 可选元素括在方括号 （[和]）。 包含字词"数字"的元素包含一系列的范围从 0 到 9 的数字字符。 下表列出了每个元素：  
  
|元素|描述|  
|-------------|-----------------|  
|*sign*|负号或正号符号。|  
|*integral-digits*|一系列的位指定数目的整数部分。 整型数字可以是不存在如果小数位数。|  
|'.'|特定于区域性的小数点符号。|  
|*fractional-digits*|一系列的位指定数字的小数部分。|  
|e|小写字符 e，该值指示指数 （科学型） 表示法。|  
|*exponential-digits*|一系列的位指定一个指数。|  
  
 返回值的一些示例包括"100"、"-123456789"、"123.45 e + 6"、"500"、"3.1416"、"600"、"-0.123"和"-Infinity"。  
  
 .NET Framework 提供了广泛的格式设置支持，其格式设置的以下主题中更详细地介绍：  
  
-   有关数字格式说明符的详细信息，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   有关格式设置的详细信息，请参阅[格式设置类型](~/docs/standard/base-types/formatting-types.md)。  
  
   
  
## Examples  
 下面的示例使用默认值<xref:System.Single.ToString%2A?displayProperty=nameWithType>方法来显示的字符串表示形式的数<xref:System.Single>值。  
  
 [!code-csharp[System.Single.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#1)]
 [!code-vb[System.Single.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#1)]  
  
 下面的代码示例演示如何使用<xref:System.Single.Parse%28System.String%29>方法以及<xref:System.Single.ToString>方法。  
  
 [!code-cpp[System.Single#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#3)]
 [!code-csharp[System.Single#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#3)]
 [!code-vb[System.Single#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="single.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <summary>使用指定的区域性特定格式信息，将此实例的数值转换为它的等效字符串表示形式。</summary>
        <returns>此实例的值的字符串表示形式，由 <paramref name="provider" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.IFormatProvider%29>方法格式<xref:System.Single>默认值 （"G"或常规） 中的值指定的区域性的格式。 如果你想要指定不同的格式或当前区域性，使用的其他重载<xref:System.Single.ToString%2A>方法，按如下所示：  
  
|若要使用格式|区域性|使用重载|  
|-------------------|-----------------|----------------------|  
|默认值 ("G") 格式|默认值 （当前） 区域性|<xref:System.Single.ToString>|  
|特定的格式|默认值 （当前） 区域性|<xref:System.Single.ToString%28System.String%29>|  
|特定的格式|特定区域性|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 返回值可以是<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>，或格式的字符串：  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 可选元素括在方括号 （[和]）。 包含字词"数字"的元素包含一系列的范围从 0 到 9 的数字字符。 下表列出了每个元素。  
  
|元素|描述|  
|-------------|-----------------|  
|Sign|负号或正号符号。|  
|integral-digits|一系列的位指定数目的整数部分。 整型数字可以是不存在如果小数位数。|  
|'.'|特定于区域性的小数点符号。|  
|fractional-digits|一系列的位指定数字的小数部分。|  
|e|小写字符 e，该值指示指数 （科学型） 表示法。|  
|exponential-digits|一系列的位指定一个指数。|  
  
 返回值的一些示例包括"100"、"-123456789"、"123.45 e + 6"、"500"、"3.1416"、"600"、"-0.123"和"-Infinity"。  
  
 .NET Framework 提供了广泛的格式设置支持，其格式设置的以下主题中更详细地介绍：  
  
-   有关数字格式说明符的详细信息，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   有关格式设置的详细信息，请参阅[格式设置类型](~/docs/standard/base-types/formatting-types.md)。  
  
 `provider`参数是<xref:System.IFormatProvider>实现其<xref:System.IFormatProvider.GetFormat%2A>方法将返回<xref:System.Globalization.NumberFormatInfo>对象。 通常情况下，`provider`是<xref:System.Globalization.CultureInfo>对象或<xref:System.Globalization.NumberFormatInfo>对象。 `provider`参数提供设置格式时使用的区域性特定信息。 如果`provider`是`null`，返回值进行格式设置使用<xref:System.Globalization.NumberFormatInfo>为当前区域性的数据。  
  
 要转换<xref:System.Single>为使用指定的区域性和特定的格式字符串，调用其字符串表示形式的值<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例显示两个字符串表示形式<xref:System.Single>值使用<xref:System.Globalization.CultureInfo>代表多个不同区域的对象。  
  
 [!code-csharp[System.Single.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#2)]
 [!code-vb[System.Single.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="single.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">一个数值格式字符串。</param>
        <summary>使用指定的格式，将此实例的数值转换为它的等效字符串表示形式。</summary>
        <returns>此实例的值的字符串表示形式，由 <paramref name="format" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.String%29>方法格式<xref:System.Single>使用当前区域性的约定将指定格式的值。 如果想要使用默认值 （"G"或常规） 格式或指定不同的区域性，请使用的其他重载<xref:System.Single.ToString%2A>方法，按如下所示：  
  
|若要使用格式|区域性|使用重载|  
|-------------------|-----------------|----------------------|  
|默认值 ("G") 格式|默认值 （当前） 区域性|<xref:System.Single.ToString>|  
|默认值 ("G") 格式|特定区域性|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|特定的格式|特定区域性|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 返回值可以是<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>，或由指定的当前实例的值的字符串表示形式`format`。  
  
 `format`参数可以是除 D 和 X，任何有效的标准数字格式说明符以及任何自定义数字格式说明符的组合。 如果格式是`null`或空字符串，返回值格式与常规的数字格式说明符 ("G")。  
  
 .NET Framework 提供了广泛的格式设置支持，其格式设置的以下主题中更详细地介绍：  
  
-   有关数字格式说明符的详细信息，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   有关格式设置的详细信息，请参阅[格式设置类型](~/docs/standard/base-types/formatting-types.md)。  
  
 默认情况下，返回的值仅包含 7 位精度尽管在内部维护最大 9 位。 如果此实例的值有超过 7 位<xref:System.Single.ToString%28System.String%29>将返回<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>或<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>而不是预期的数字。 如果需要更高的精度时，指定`format`"G9"格式规范中，始终返回 9 位精度或"R"，表示将返回的 7 位数字在数字可以用使用该精度或 9 位数字，如果只能表示数量最大精度。  
  
   
  
## Examples  
 以下示例定义一个数值，并将其格式化为货币值，通过使用"C"标准数字格式字符串为三个小数位的数字值以及通过使用"N"标准数字格式字符串。 通过使用 EN-US 区域性的约定格式化的结果字符串。 数字格式字符串的详细信息，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
 [!code-csharp[System.Single.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString7.cs#7)]
 [!code-vb[System.Single.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString7.vb#7)]  
  
 下面的示例显示几个<xref:System.Single>使用每个受支持的标准数字格式说明符以及两个自定义数字格式字符串值。 这些自定义格式字符串中的一个演示如何填充<xref:System.Single>带前导零的值。 在将该数字值转换为字符串，该示例使用 EN-US 区域性的格式设置约定。  
  
 [!code-csharp[System.Single.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#3)]
 [!code-vb[System.Single.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">如何：用前导零填充数字</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="single.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">一个数值格式字符串。</param>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <summary>使用指定的格式和区域性特定格式信息，将此实例的数值转换为它的等效字符串表示形式。</summary>
        <returns>此实例的值的字符串表示形式，由 <paramref name="format" /> 和 <paramref name="provider" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>方法格式<xref:System.Single>中指定的区域性的指定格式的值。 如果你想要使用默认格式或区域性设置，使用的其他重载<xref:System.Single.ToString%2A>方法，按如下所示：  
  
|若要使用格式|区域性|使用重载|  
|-------------------|-----------------|----------------------|  
|默认值 ("G") 格式|默认值 （当前） 区域性|<xref:System.Single.ToString>|  
|默认值 ("G") 格式|特定区域性|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|特定的格式|默认值 （当前） 区域性|<xref:System.Single.ToString%28System.String%29>|  
  
 返回值可以是<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>，或由指定的当前实例的值的字符串表示形式`format`。  
  
 `format`参数可以是除 D 和 X，任何有效的标准数字格式说明符以及任何自定义数字格式说明符的组合。 如果`format`是`null`或空字符串，此实例的返回值格式与常规的数字格式说明符 ("G")。  
  
 .NET Framework 提供了广泛的格式设置支持，其格式设置的以下主题中更详细地介绍：  
  
-   有关数字格式说明符的详细信息，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)并[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。  
  
-   有关格式设置的详细信息，请参阅[格式设置类型](~/docs/standard/base-types/formatting-types.md)。  
  
 `provider`参数是<xref:System.IFormatProvider>实现其<xref:System.IFormatProvider.GetFormat%2A>方法将返回<xref:System.Globalization.NumberFormatInfo>对象。 通常情况下，`provider`是<xref:System.Globalization.CultureInfo>对象或<xref:System.Globalization.NumberFormatInfo>对象。 `provider`参数提供设置格式时使用的区域性特定信息。 如果`provider`是`null`，返回值进行格式设置<xref:System.Globalization.NumberFormatInfo>为当前区域性的对象。  
  
 默认情况下，返回的值仅包含 7 位精度尽管在内部维护最大 9 位。 如果此实例的值有超过 7 位<xref:System.Single.ToString%2A>将返回<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>或<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>而不是预期的数字。 如果需要更高的精度时，指定`format`"G9"格式规范中，始终返回 9 位精度或"R"，表示将返回的 7 位数字在数字可以用使用该精度或 9 位数字，如果只能表示数量最大精度。  
  
   
  
## Examples  
 下面的示例显示<xref:System.Single>值的多个不同的区域性使用的每个受支持的标准数字格式说明符。  
  
 [!code-csharp[System.Single.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#4)]
 [!code-vb[System.Single.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">如何：用前导零填充数字</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="single.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数字的字符串表示形式转换为它的等效单精度浮点数。 一个指示转换是否成功的返回值。</summary>
        <altmember cref="Overload:System.Single.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">表示要转换的数字的字符串。</param>
        <param name="result">当此方法返回时，如果转换成功，则包含与 <paramref name="s" /> 所包含的数值或符号等效的单精度浮点数字；如果转换失败，则包含零。 如果 <paramref name="s" /> 参数为 <see langword="null" /> 或 <see cref="F:System.String.Empty" />、不是有效格式的数字，或者表示的数字小于 <see cref="F:System.Single.MinValue" /> 或大于 <see cref="F:System.Single.MaxValue" />，则转换失败。 此参数未经初始化即进行传递；最初在 <paramref name="result" /> 中提供的任何值都会被覆盖。</param>
        <summary>将数字的字符串表示形式转换为它的等效单精度浮点数。 一个指示转换是否成功的返回值。</summary>
        <returns>如果 <see langword="true" /> 成功转换，则为 <paramref name="s" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载不同于<xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType>通过返回一个布尔值，该值指示是否分析操作成功而不是返回的已分析的数字值的方法。 它消除了需要使用异常处理来测试<xref:System.FormatException>的事件中`s`无效，不能成功分析。  
  
 `s`参数可以包含<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> （字符串比较是区分大小写） 或格式的字符串：  
  
 [ws][sign][integral-digits,]integral-digits[.[fractional-digits]][e[sign]exponential-digits][ws]  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|一系列空白字符。|  
|*sign*|负号或正号符号。|  
|*integral-digits*|一系列数字字符范围从 0 到 9 的指定数目的整数部分。 整型数字可以是不存在如果小数位数。|  
|*，*|特定于区域性的组分隔符符号。|  
|*.*|特定于区域性的小数点符号。|  
|*fractional-digits*|一系列数字字符范围从 0 到 9 的指定数字的小数部分。|  
|*E*|一个大写或小写字符 e，用于指示指数 （科学型） 表示法。|  
|*exponential-digits*|一系列数字字符范围从 0 到 9，指定一个指数。|  
  
 `s`参数被解释使用的组合<xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>和<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>标志。 这意味着该空白和千位分隔符允许但不是货币符号。 若要显式定义的元素 (如货币符号，千位分隔符和空格)，可能会包含`s`，使用<xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29>方法重载。  
  
 `s`使用中的格式设置信息分析参数<xref:System.Globalization.NumberFormatInfo>对象，将初始化为当前系统区域性。 有关详情，请参阅<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>。 将字符串分析使用的格式信息的其他某个指定区域性，请使用<xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29>方法重载。  
  
 通常，如果传递<xref:System.Single.TryParse%2A?displayProperty=nameWithType>方法中，通过调用创建的字符串<xref:System.Single.ToString%2A?displayProperty=nameWithType>方法时，原始<xref:System.Single>返回值。 但是，由于丢失精度，值可能不相等。  
  
 如果分隔符时遇到`s`参数在分析操作，以及适用的货币或十进制数和组分隔符是相同的分析操作假定，分隔符是十进制分隔符，而不是一组分隔符。 有关分隔符的详细信息，请参阅<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29>方法将转换为数字值的字符串表示<xref:System.Single>值。 它假定该 EN-US 当前区域性。  
  
 [!code-csharp[System.Single.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Single.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">分析 .NET 中的数字字符串</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">表示要转换的数字的字符串。</param>
        <param name="style">枚举值的一个按位组合，指示 <paramref name="s" /> 所允许的格式。 一个用来指定的典型值为 <see cref="F:System.Globalization.NumberStyles.Float" /> 与 <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> 的组合。</param>
        <param name="provider">一个对象，提供有关 <paramref name="s" /> 的区域性特定格式设置信息。</param>
        <param name="result">当此方法返回时，如果转换成功，则包含与 <paramref name="s" /> 所包含的数值或符号等效的单精度浮点数字；如果转换失败，则包含零。 如果 <paramref name="s" /> 参数为 <see langword="null" /> 或 <see cref="F:System.String.Empty" />、格式不符合 <paramref name="style" />、表示的数字小于<see cref="F:System.Single.MinValue" /> 或大于 <see cref="F:System.Single.MaxValue" />，或者 <paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 枚举的常数的有效组合，则转换失败。 此参数未经初始化即进行传递；最初在 <paramref name="result" /> 中提供的任何值都会被覆盖。</param>
        <summary>将具有指定样式和区域性特定格式的数字的字符串表示形式转换为它的等效单精度浮点数。 一个指示转换是否成功的返回值。</summary>
        <returns>如果 <see langword="true" /> 成功转换，则为 <paramref name="s" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载不同于<xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>通过返回一个布尔值，该值指示是否分析操作成功而不是返回的已分析的数字值的方法。 它消除了需要使用异常处理来测试<xref:System.FormatException>的事件中`s`无效，不能成功分析。  
  
 `style`参数定义的允许的格式`s`分析操作成功的参数。 它必须是从位标志的组合<xref:System.Globalization.NumberStyles>枚举。 以下<xref:System.Globalization.NumberStyles>不支持成员：  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 `s`参数可以包含<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>， <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>，<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>由指定的区域性`provider`。 此外，具体取决于值`style`，则`s`参数可能包含以下元素：  
  
 [ws] [$] [sign][integral-digits,]integral-digits[.fractional-digits][e[sign]exponential-digits][ws]  
  
 方括号 ([ and ]) 中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*ws*|可选的空白区域。 空白可以出现在开头`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>标志。 它可以显示在末尾`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>标志。|  
|*$*|特定于区域性的货币符号。 在字符串中的位置由<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType>或<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType>的属性<xref:System.Globalization.NumberFormatInfo>返回的对象<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>方法`provider`参数。 货币符号可以出现在`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>标志。|  
|*sign*|一个可选符号后。 符号可以显示在开头`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>标志，它可以出现在末尾`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>标志。 可以在使用括号`s`指示负值`style`包括<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>标志。|  
|*integral-digits*|一系列的位范围从 0 到 9 的指定数目的整数部分。 整型数字可以是不存在如果小数位数。|  
|*，*|特定于区域性的千位分隔符号。 当前区域性的千位分隔符符号可以出现在`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>标志。|  
|*.*|特定于区域性的小数点符号。 当前区域性的小数点符号可以出现在`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>标志。|  
|*fractional-digits*|一系列的位范围从 0 到 9 的指定数字的小数部分。 在中出现的小数位`s`如果`style`包括<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>标志。|  
|*e*|E 或 E 字符，指示`s`可以表示的数字使用指数记数法。 `s`参数可以表示指数表示法的数字，如果样式包含<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>标志。|  
|*exponential-digits*|一系列的范围从 0 到 9 的指定指数的位数。|  
  
> [!NOTE]
> 中的任何终止 NUL (U + 0000) 字符`s`在分析操作，而不考虑的值，将忽略`style`参数。

 仅为数字的字符串 (对应于<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>样式) 总是可以分析成功。 剩余<xref:System.Globalization.NumberStyles?displayProperty=nameWithType>成员控件可能但不是要求必须包含在输入字符串中的元素。 下表指示个别<xref:System.Globalization.NumberStyles>标志将影响可能会出现在元素`s`。  
  
|NumberStyles 值|除数字之外 s 中允许的元素|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*整型数字*仅元素。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|*.* 并*小数位数*元素。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|`s`参数还可以使用指数记数法。 此标志本身支持窗体的值*整型数字*E*指数数字*; 其他标志需要为成功分析字符串中与作为此类元素的指数表示法正或负号和小数点符号。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*开头的元素`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*结尾的元素`s`。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*符号*开头的元素`s`。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*符号*结尾的元素`s`。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*登录*形式的括号内包含的数字值的元素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|*，* 元素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|*$* 元素。|  
|<xref:System.Globalization.NumberStyles.Currency>|全部。 `s`参数不能表示十六进制数或指数表示法的数字。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*元素的开头或末尾`s`，*登录*开头`s`，和 *。* 符号。 `s`参数还可以使用指数记数法。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`， `sign`，千位分隔符 (*，)，* 和小数点 (*。*) 元素。|  
|<xref:System.Globalization.NumberStyles.Any>|所有样式，除非`s`不能表示十六进制数。|  
  
 `provider`参数是<xref:System.IFormatProvider>实现其<xref:System.IFormatProvider.GetFormat%2A>方法将返回<xref:System.Globalization.NumberFormatInfo>提供特定于区域性的格式设置信息的对象。 当<xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29>调用方法时，它调用`provider`参数的<xref:System.IFormatProvider.GetFormat%2A>方法并将其传递<xref:System.Type>对象，表示<xref:System.Globalization.NumberFormatInfo>类型。 <xref:System.IFormatProvider.GetFormat%2A>方法随后返回<xref:System.Globalization.NumberFormatInfo>提供的格式有关的信息的对象`s`参数。 有三种方法使用`provider`参数来提供到分析操作的自定义格式设置信息：  
  
-   可以将传递<xref:System.Globalization.CultureInfo>对象，表示提供格式设置信息的区域性。 其<xref:System.Globalization.CultureInfo.GetFormat%2A>方法将返回<xref:System.Globalization.NumberFormatInfo>提供该区域性的数字格式设置信息的对象。  
  
-   您可以将传递的实际<xref:System.Globalization.NumberFormatInfo>提供数字格式设置信息的对象。 (其实现<xref:System.Globalization.NumberFormatInfo.GetFormat%2A>只返回其自身。)  
  
-   可以传递用于实现的自定义对象<xref:System.IFormatProvider>。 其<xref:System.IFormatProvider.GetFormat%2A>方法实例化并返回<xref:System.Globalization.NumberFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`的格式设置`s`被解释基于<xref:System.Globalization.NumberFormatInfo>当前区域性的对象。  
  
 如果分隔符时遇到`s`参数在分析操作，以及适用的货币或十进制数和组分隔符是相同的分析操作假定，分隔符是十进制分隔符，而不是一组分隔符。 有关分隔符的详细信息，请参阅<xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>， <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>，和<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>。  
  
   
  
## Examples  
 下面的示例演示如何将<xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType>方法来分析具有特定样式，并且使用特定区域性的约定进行格式化的数字的字符串表示形式。  
  
 [!code-csharp[System.Single.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#2)]
 [!code-vb[System.Single.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> 不是 <see cref="T:System.Globalization.NumberStyles" /> 值。  
  
- 或 - 
 <paramref name="style" /> 是 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 值。</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">分析 .NET 中的数字字符串</related>
      </Docs>
    </Member>
  </Members>
</Type>