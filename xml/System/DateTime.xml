<Type Name="DateTime" FullName="System.DateTime">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0e0f91e3e6e3eea5c50028b600eadc103187a955" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731461" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct DateTime : IComparable, IComparable&lt;DateTime&gt;, IConvertible, IEquatable&lt;DateTime&gt;, IFormattable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit DateTime extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.DateTime&gt;, class System.IConvertible, class System.IEquatable`1&lt;valuetype System.DateTime&gt;, class System.IFormattable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.DateTime" />
  <TypeSignature Language="VB.NET" Value="Public Structure DateTime&#xA;Implements IComparable, IComparable(Of DateTime), IConvertible, IEquatable(Of DateTime), IFormattable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public value class DateTime : IComparable, IComparable&lt;DateTime&gt;, IConvertible, IEquatable&lt;DateTime&gt;, IFormattable, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.DateTime&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.DateTime&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>表示时间上的一刻，通常以日期和当天的时间表示。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

## <a name="quick-links-to-example-code"></a>指向代码示例的快速链接

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

本文包括使用的几个示例`DateTime`类型：

**初始化示例**      
 [调用构造函数](#initialization-01)     
 [调用隐式的默认构造函数](#initialization-02)     
 [分配的返回值](#initialization-03)     
 [分析表示的日期和时间的字符串](#initialization-04)     
 [Visual Basic 语法来初始化的日期和时间](#initialization-05)     

**格式设置`DateTime`以字符串形式的对象**  
 [使用默认的日期时间格式](#formatting-01)     
 [设置日期和时间使用非特定区域性的格式](#formatting-02)     
 [使用标准或自定义格式字符串为日期时间格式](#formatting-03)     
 [指定一个格式字符串和特定区域性](#formatting-04)     
 [格式为 ISO 8601 标准用于 web 服务的日期时间](#formatting-05)     

**分析字符串作为`DateTime`对象**  
 [使用`Parse`或`TryParse`将字符串转换为日期和时间](#parsing-01)     
 [使用`ParseExact`或`TryParseExact`将已知的格式字符串转换](#parsing-02)     
 [将从 ISO 8601 字符串表示形式转换为日期和时间](#parsing-03)     

**`DateTime` 解决方法**  
 [浏览日期和时间值的解决方法](#resolution-01)     
 [在容许范围内的相等性比较](#comparison-01)     

**区域性和日历**  
 [显示使用区域性特定日历的日期和时间值](#calendars-01)     
 [分析根据区域性特定日历的字符串](#calendars-02)     
 [初始化的日期和时间从特定区域性的日历](#calendars-03)     
 [访问使用特定区域性的日历的日期和时间属性](#calendars-04)     
 [检索使用区域性特定日历年的某一周](#calendars-05)     

**持久性**  
 [将日期和时间值为本地时区中的字符串](#persistence-01)     
 [区域性和时间的固定格式的字符串的形式将日期和时间值](#persistence-02)     
 [将日期和时间值为整数](#persistence-03)     
 [使用保留的日期和时间值 `XmlSerializer`](#persistence-04)     
 [使用保留的日期和时间值 `BinaryFormatter`](#persistence-05)     
 [保留的日期和时间值与时区数据](#persistence-06)     

## <a name="quick-links-to-remarks-topics"></a>快速链接到备注主题。

本部分包含的许多常见的主题`DateTime`结构：
  
 [初始化`DateTime`对象](#initializing-a-datetime-object)   
 [DateTime 值和其字符串表示形式](#datetime-values-and-their-string-representations)   
 [从字符串分析的日期时间值](#parsing-datetime-values-from-strings)   
 [日期时间值](#datetime-values)   
 [DateTime 操作](#datetime-operations)   
 [DateTime 解析](#datetime-resolution)   
 [日期时间值和日历](#datetime-values-and-calendars)   
 [保留日期时间值](#persisting-datetime-values)   
 [DateTime vs。TimeSpan](#datetime-vs-timespan)   
 [是否在容许范围内的相等比较](#comparing-for-equality-within-tolerance) [COM 互操作注意事项](#com-interop-considerations)  
   
<xref:System.DateTime>值类型表示日期和时间范围内的值从 00:00:00 （午夜），1 月 1 日 0001 公元 （基督纪元） 11:59:59 PM，通过使用到公元 9999 年 12 月 31 日 (C.E.)在公历日历中。  
  
时间值以调用计时周期的 100 毫微秒为单位进行衡量。 特定日期是自午夜 12:00 到公元 0001 年 1 月 1 日以来的计时周期数 (C.E.)在<xref:System.Globalization.GregorianCalendar>日历。 数排除将添加闰秒的刻度。 例如，刻度值 31241376000000000l 表示的日期星期五，年 1 月 0100 日午夜 12:00:00。 A<xref:System.DateTime>值始终表示中的上下文显式或默认日历。  
  
> [!NOTE]
>  如果你正在使用计时周期值是否想要转换为其他时间间隔，如分钟或秒，应使用<xref:System.TimeSpan.TicksPerDay?displayProperty=nameWithType>， <xref:System.TimeSpan.TicksPerHour?displayProperty=nameWithType>， <xref:System.TimeSpan.TicksPerMinute?displayProperty=nameWithType>， <xref:System.TimeSpan.TicksPerSecond?displayProperty=nameWithType>，或<xref:System.TimeSpan.TicksPerMillisecond?displayProperty=nameWithType>常量，以执行转换。 例如，若要添加的秒数表示通过指定到的计时周期数<xref:System.DateTime.Second%2A>组件的<xref:System.DateTime>值，你可以使用表达式`dateValue.Second + nTicks/Timespan.TicksPerSecond`。  

你可以查看这篇文章中的示例的整个集的源中任意一种[Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/System.DateTime/)或[C#](https://github.com/dotnet/samples/tree/master/snippets/csharp/System.DateTime/)从 GitHub 上的文档存储库。

> [!NOTE]
>  一种替代方法<xref:System.DateTime>结构使用的日期和时间值中特定时区为<xref:System.DateTimeOffset>结构。 <xref:System.DateTimeOffset>结构将日期和时间信息存储在私有<xref:System.DateTime>字段和依据该日期和时间的分钟数与 UTC 的差异在私有<xref:System.Int16>字段。 这样便能为<xref:System.DateTimeOffset>值以反映特定时区中的时间，而<xref:System.DateTime>仅 UTC 和本地时区的时间，可以明确地反映值。 有关何时使用讨论<xref:System.DateTime>结构或<xref:System.DateTimeOffset>结构使用日期和时间值时，请参阅[选择之间 DateTime、 DateTimeOffset、 TimeSpan 和 TimeZoneInfo](~/docs/standard/datetime/choosing-between-datetime.md)。  
  
### <a name="initializing-a-datetime-object"></a>初始化一个 DateTime 对象  

你可以将初始值分配到一个新`DateTime`许多不同的方式的值：

- 调用构造函数，其中任意一个你在其中指定自变量的值，或使用隐式的默认构造函数。
- 分配`DateTime`到属性或方法的返回值。
- 分析`DateTime`从其字符串表示形式的值。
- 使用 Visual Basic 特定的语言功能来实例化`DateTime`。 

下面的代码段显示每个的示例：

#### <a name="invoke-constructors"></a>调用构造函数

调用的重载任一<xref:System.DateTime>指定元素 （例如年、 月和天或计时周期数） 的日期和时间值的构造函数。 下面的代码创建特定日期使用<xref:System.DateTime>构造函数指定年、 月、 日、 小时、 分钟和秒。  

<a name="initialization-01"></a> [!code-vb[System.DateTime.Instantiation#1](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#1)]  
[!code-csharp-interactive[System.DateTime.Instantiation#1](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#1)]

调用`DateTime`结构的隐式的默认构造函数时所需`DateTime`初始化为其默认值。 (有关值类型的隐式的默认构造函数的详细信息，请参阅[值类型](~/docs/csharp/language-reference/keywords/value-types.md)。)某些编译器还支持声明<xref:System.DateTime>而无需显式将值分配给它的值。 创建没有显式初始化的值也会产生的默认值。 下面的示例演示<xref:System.DateTime>C# 和 Visual Basic 中的隐式的默认构造函数以及<xref:System.DateTime>声明不在 Visual Basic 中的分配。  

<a name="initialization-02"></a> [!code-vb[System.DateTime.Instantiation#5](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#5)]  
[!code-csharp-interactive[System.DateTime.Instantiation#5](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#5)]
    
#### <a name="assigning-a-computed-value"></a>分配计算的值

你可以分配<xref:System.DateTime>对象通过属性或方法返回的日期和时间值。 下面的示例将当前日期和时间、 当前的协调世界时 (UTC) 日期和时间，以及当前日期为三个新<xref:System.DateTime>变量。  

<a name="initialization-03"></a> [!code-vb[System.DateTime.Instantiation#3](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#3)]  
[!code-csharp[System.DateTime.Instantiation#3](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#3)]

#### <a name="parsing-a-string-that-represents-a-datetime"></a>分析表示的日期时间的字符串

<xref:System.DateTime.Parse%2A>， <xref:System.DateTime.ParseExact%2A>， <xref:System.DateTime.TryParse%2A>，和<xref:System.DateTime.TryParseExact%2A>所有方法将字符串都转换为其等效的日期和时间值。 下面的示例使用<xref:System.DateTime.Parse%2A>和<xref:System.DateTime.ParseExact%2A>方法分析字符串并将其转换为<xref:System.DateTime>值。 第二个格式使用的形式通过受支持[ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html)标准表示日期和时间格式字符串。 此标准的表示形式通常用于传输 web 服务中的日期信息。

<a name="initialization-04"></a> [!code-vb[System.DateTime.Instantiation#4](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#4)]  
[!code-csharp[System.DateTime.Instantiation#4](~/samples/snippets/csharp/System.DateTime/Instantiation.cs#4)]

<xref:System.DateTime.TryParse%2A>和<xref:System.DateTime.TryParseExact%2A>方法指示一个字符串是否是有效表示形式<xref:System.DateTime>值，并且，如果是，将执行转换。  

#### <a name="language-specific-syntax-for-visual-basic"></a>适用于 Visual Basic 的特定于语言的语法

下面的 Visual Basic 语句初始化新<xref:System.DateTime>值。  

<a name="initialization-05"></a> [!code-vb[System.DateTime.Instantiation#2](~/samples/snippets/visualbasic/System.DateTime/Instantiation.vb#2)]  

### <a name="datetime-values-and-their-string-representations"></a>DateTime 值和其字符串表示形式  

在内部，所有<xref:System.DateTime>值表示为 0001 年 1 月 1 日午夜 12:00:00 以来所经历的计时周期 （100 毫微秒隔数） 数。 实际<xref:System.DateTime>值时显示此值的显示的方式无关。 外观<xref:System.DateTime>值是将值转换为其字符串表示形式的格式设置操作的结果。  
  
日期和时间值的外观会依赖于区域性、 国际标准、 应用程序要求和个人首选项。 <xref:System.DateTime>结构提供格式化日期和时间值通过重载的灵活性<xref:System.DateTime.ToString%2A>。 默认值<xref:System.DateTime.ToString?displayProperty=nameWithType>方法返回的字符串表示形式使用当前区域性的短日期和长时间模式的日期和时间值。 下面的示例使用默认值<xref:System.DateTime.ToString?displayProperty=nameWithType>方法。 它显示的日期和时间使用当前区域性的短日期和长时间模式。 EN-US 区域性为在其运行该示例的计算机上的当前区域性。  
  
<a name="formatting-01"></a> [!code-csharp-interactive[System.DateTime.Formatting#1](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#1)]
[!code-vb[System.DateTime.Formatting#1](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#1)]  

你可能需要设置特定区域性中的日期，以支持 web 方案中，服务器可能会在从客户端不同区域性中的格式。 指定区域性使用<xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法来创建在特定区域性的短日期和长时间表示形式。 下面的示例使用<xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法来显示日期和时间使用短日期和长时间模式为 FR-FR 区域性。  
  
<a name="formatting-02"></a> [!code-csharp-interactive[System.DateTime.Formatting#2](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#2)]
[!code-vb[System.DateTime.Formatting#2](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#2)]  

 其他应用程序可能需要不同的字符串表示形式的日期。 <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType>方法返回通过使用当前区域性的格式设置约定的标准或自定义格式说明符定义的字符串表示。 下面的示例使用<xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType>方法以显示完整的日期和时间模式为 EN-US 区域性，在其运行该示例的计算机上的当前区域性。  
  
<a name="formatting-03"></a> [!code-csharp-interactive[System.DateTime.Formatting#3](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#3)]
[!code-vb[System.DateTime.Formatting#3](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#3)]  

 最后，你可以在其中指定的区域性和格式使用<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法。 下面的示例使用<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法以显示完整的日期和时间为 FR-FR 区域性的模式。  

<a name="formatting-04"></a> [!code-csharp-interactive[System.DateTime.Formatting#4](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#4)]
[!code-vb[System.DateTime.Formatting#4](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#4)]  

<xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType>重载还可与自定义格式字符串来指定其他格式。 下面的示例演示如何设置格式字符串使用[ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html)通常用于 web 服务的标准格式。 Iso 8601 格式没有相应的标准格式字符串。

<a name="formatting05"></a> [!code-csharp-interactive[System.DateTime.Formatting#5](~/samples/snippets/csharp/System.DateTime/StringFormat.cs#5)]
[!code-vb[System.DateTime.Formatting#5](~/samples/snippets/visualbasic/System.DateTime/StringFormat.vb#5)]  

有关格式设置的详细信息<xref:System.DateTime>值，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。  

### <a name="parsing-datetime-values-from-strings"></a>从字符串分析的日期时间值

分析将转换的字符串表示形式的日期和时间<xref:System.DateTime>值。 通常情况下，日期和时间字符串具有两个不同的用法，在应用程序中：  
  
-   日期和时间采用各种形式，并反映当前区域性或特定区域性的约定。 例如，应用程序允许的用户当前区域性为 EN-US 输入的日期值为"2013 年 12 月 15 日"或"2013 年 12 月 15 日"。 它允许的用户当前区域性为 en 的 gb 输入的日期值为"12/15/2013"或"15 2013 年 12 月。"  
  
-   在预定义的格式表示日期和时间。 例如，应用程序序列化的日期为"20130103"独立于在其运行应用程序的区域性。 应用程序可能需要在当前区域性的短日期格式的输入日期。
  
你使用<xref:System.DateTime.Parse%2A>或<xref:System.DateTime.TryParse%2A>方法将字符串转换从一个区域性使用的常见日期和时间格式<xref:System.DateTime>值。 下面的示例演示如何使用<xref:System.DateTime.TryParse%2A>要转换到不同的区域性特定格式的日期字符串<xref:System.DateTime>值。 将当前区域性更改为英语 （英国），并调用<xref:System.DateTime.GetDateTimeFormats>方法生成的日期和时间的字符串数组。 它然后传递到数组中的每个元素<xref:System.DateTime.TryParse%2A>方法。 示例输出显示分析方法能够成功地将每个特定于区域性的日期和时间字符串转换。  
  
<a name="parsing-01"></a> [!code-csharp-interactive[System.DateTime.Parsing#1](~/samples/snippets/csharp/System.DateTime/Parsing.cs#1)]
[!code-vb[System.DateTime.Parsing#1](~/samples/snippets/visualbasic/System.DateTime/Parsing.vb#1)]  

你使用<xref:System.DateTime.ParseExact%2A>和<xref:System.DateTime.TryParseExact%2A>方法将特定的格式或到的格式必须与匹配的 string 转换<xref:System.DateTime>值。 作为分析方法的参数指定一个或多个日期和时间格式字符串。 下面的示例使用<xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29>方法将必须位于"yyyyMMdd"格式或到"HHmmss"格式的字符串转换<xref:System.DateTime>值。  
  
<a name="parsing-02"></a> [!code-csharp-interactive[System.DateTime.Parsing#2](~/samples/snippets/csharp/System.DateTime/Parsing.cs#2)]
[!code-vb[System.DateTime.Parsing#2](~/samples/snippets/visualbasic/System.DateTime/Parsing.vb#2)]  

一个常见用途<xref:System.DateTime.ParseExact%2A>是要转换的字符串表示从 web 服务时，通常在[ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html)标准格式。 下面的代码演示要使用的正确的格式字符串：

<a name="parsing-03"></a> [!code-csharp-interactive[System.DateTime.Parsing#3](~/samples/snippets/csharp/System.DateTime/Parsing.cs#3)]
[!code-vb[System.DateTime.Parsing#3](~/samples/snippets/visualbasic/System.DateTime/Parsing.vb#3)]  

如果无法解析一个字符串，<xref:System.DateTime.Parse%2A>和<xref:System.DateTime.ParseExact%2A>方法引发异常。 <xref:System.DateTime.TryParse%2A>和<xref:System.DateTime.TryParseExact%2A>方法返回<xref:System.Boolean>值，该值指示转换是成功还是失败。 应使用<xref:System.DateTime.TryParse%2A>或<xref:System.DateTime.TryParseExact%2A>性能很重要的方案中的方法。 日期和时间的字符串在分析操作倾向于具有高故障率，和异常处理将占用大量资源。 使用这些方法，如果字符串输入由用户还是来自未知源。 
  
有关分析日期和时间值的详细信息，请参阅[分析日期和时间字符串](~/docs/standard/base-types/parsing-datetime.md)。  

### <a name="datetime-values"></a>日期时间值

中的时间值的说明<xref:System.DateTime>类型通常表示使用协调世界时 (UTC) 标准。 协调世界时是国际上认可的名称为格林威治标准时间 (GMT)。 协调世界时是在经度零度，UTC 原点测量的时间。 夏时制不适用于 UTC。  
  
本地时间是特定的时区相对路径。 时区为时区偏移量与相关联。 时区偏移量的度量在时间从 UTC 原点的时区偏移量。 此外，本地时间 （可选） 受夏时制，增加或减少的时间间隔调整的影响。 本地时间的计算通过将时区偏移量添加到 UTC 和调整为夏时制如有必要。 在 UTC 原点的时区偏移量为零。  
  
UTC 时间文件是适用于计算、 比较和存储日期和时间。 本地时间都适用于在桌面应用程序的用户界面中显示。 时区感知应用程序 （例如许多 Web 应用程序） 也需要使用大量的其他时区。  
  
如果<xref:System.DateTime.Kind%2A>属性<xref:System.DateTime>对象是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>，没有指定所表示的时间是本地时间、 UTC 时间或某些其他时区的时间。  

### <a name="datetime-resolution"></a>DateTime 解析
  
> [!NOTE]
>  作为执行日期和时间运算上的替代方法<xref:System.DateTime>值来测量运行时间，你可以使用<xref:System.Diagnostics.Stopwatch>类。  
  
<xref:System.DateTime.Ticks%2A>属性表示的秒的一千万分之一单位的日期和时间值。 <xref:System.DateTime.Millisecond%2A>属性中的日期和时间值返回分之几秒。 使用重复的调用<xref:System.DateTime.Now%2A?displayProperty=nameWithType>属性来测量运行时间是依赖于系统时钟。 Windows 7 和 Windows 8 的系统上的系统时钟已大约 15 毫秒的分辨率。 此解决方案影响较短时间间隔小于 100 毫秒。 
  
下面的示例演示当前日期和时间值的依赖于系统时钟的分辨率。 在示例中，将外部循环重复 20 倍，并且内部循环用于延迟外部循环。 如果外部循环计数器的值为 10，调用<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法引入了五个毫秒延迟。 下面的示例演示返回的毫秒数`DateTime.Now.Milliseconds`属性更改后调用，才<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>。  

<a name="resolution-01"></a> [!code-csharp-interactive[System.DateTime.Resolution#1](~/samples/snippets/csharp/System.DateTime/Resolution.cs#1)]
[!code-vb[System.DateTime.Resolution#1](~/samples/snippets/visualbasic/System.DateTime/Resolution.vb#1)]  

### <a name="datetime-operations"></a>DateTime 操作  

计算使用<xref:System.DateTime>结构，如<xref:System.DateTime.Add%2A>或<xref:System.DateTime.Subtract%2A>，不会修改该结构的值。 相反，计算返回一个新<xref:System.DateTime>结构其值的计算结果。  
  
时区 （例如 UTC 和当地时间之间或者一个时区，另一个） 之间的转换操作会考虑夏时制，但算术和比较运算不这样做。  
  
<xref:System.DateTime>结构本身提供用于从一个时区转换到另一个的有限的支持。 你可以使用<xref:System.DateTime.ToLocalTime%2A>方法将 UTC 转换为本地时间，也可以使用<xref:System.DateTime.ToUniversalTime%2A>方法将从本地时间转换为 UTC。 但是，一套完整的时区转换方法可用于<xref:System.TimeZoneInfo>类。 转换时区中的任何其他时间使用这些方法的时间用任何一种世界上最时区的时间。  
  
计算和比较<xref:System.DateTime>对象有意义的仅当这些对象表示在相同的时区的时间。 你可以使用<xref:System.TimeZoneInfo>对象以代表<xref:System.DateTime>值的时区，尽管两个松散耦合。 A<xref:System.DateTime>对象不具有返回一个表示该日期和时间值的时区对象的属性。 <xref:System.DateTime.Kind%2A>属性指示如果`DateTime`表示 UTC，本地时间，或未指定。 在时区识别应用程序中，你必须依赖于某些外部机制来确定在其中时区<xref:System.DateTime>创建对象。 你可以使用结构来包装<xref:System.DateTime>值和<xref:System.TimeZoneInfo>对象，表示<xref:System.DateTime>值的时区。 有关详细信息在计算和比较中使用 UTC<xref:System.DateTime>值，请参阅[使用日期和时间执行算术操作](~/docs/standard/datetime/performing-arithmetic-operations.md)。  
  
每个<xref:System.DateTime>成员隐式使用公历来执行其操作。 例外情况是隐式指定日历的方法。 这些活动包括指定日历的构造函数和方法的参数派生自<xref:System.IFormatProvider>，如<xref:System.Globalization.DateTimeFormatInfo?displayProperty=nameWithType>。  
  
操作的成员<xref:System.DateTime>类型考虑帐户详细信息，例如闰年和每个月的最大天数。  

## <a name="datetime-values-and-calendars"></a>日期时间值和日历  

.NET Framework 类库包括了多个日历类，它们都派生自<xref:System.Globalization.Calendar>类。  它们是：  
  
-   <xref:System.Globalization.ChineseLunisolarCalendar> 类。  
-   <xref:System.Globalization.EastAsianLunisolarCalendar> 类。  
-   <xref:System.Globalization.GregorianCalendar> 类。  
-   <xref:System.Globalization.HebrewCalendar> 类。  
-   <xref:System.Globalization.HijriCalendar> 类。  
-   <xref:System.Globalization.JapaneseCalendar> 类。  
-   <xref:System.Globalization.JapaneseLunisolarCalendar> 类。  
-   <xref:System.Globalization.JulianCalendar> 类。  
-   <xref:System.Globalization.KoreanCalendar> 类。  
-   <xref:System.Globalization.KoreanLunisolarCalendar> 类。  
-   <xref:System.Globalization.PersianCalendar> 类。  
-   <xref:System.Globalization.TaiwanCalendar> 类。  
-   <xref:System.Globalization.TaiwanLunisolarCalendar> 类。  
-   <xref:System.Globalization.ThaiBuddhistCalendar> 类。  
-   <xref:System.Globalization.UmAlQuraCalendar> 类。  
  
每种区域性使用的默认日历定义其只读<xref:System.Globalization.CultureInfo.Calendar%2A?displayProperty=nameWithType>属性。 每种区域性可能支持一个或多个日历定义其只读<xref:System.Globalization.CultureInfo.OptionalCalendars%2A?displayProperty=nameWithType>属性。 当前使用特定的日历<xref:System.Globalization.CultureInfo>对象由定义其<xref:System.Globalization.DateTimeFormatInfo.Calendar%2A?displayProperty=nameWithType>属性。 它必须是之一中找到的日历<xref:System.Globalization.CultureInfo.OptionalCalendars%2A?displayProperty=nameWithType>数组。  
  
区域性的当前日历用在针对该区域性的所有格式设置操作中。 例如，泰国佛区域性的默认日历是泰国佛纪元日历，由表示<xref:System.Globalization.ThaiBuddhistCalendar>类。  当<xref:System.Globalization.CultureInfo>对象以表示泰国佛区域性使用的日期和时间格式设置操作中，泰国佛纪元日历使用默认情况下。 仅当使用公历区域性的<xref:System.Globalization.DateTimeFormatInfo.Calendar%2A?displayProperty=nameWithType>属性更改，如以下示例所示：  

<a name="calendars-01"></a> [!code-csharp-interactive[System.DateTime.Calendar#1](~/samples/snippets/csharp/System.DateTime/Calendar.cs#1)]
[!code-vb[System.DateTime.Calendar#1](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#1)]  

也将区域性的当前日历用在所有分析操作对于该区域性，如以下示例所示。  
  
<a name="calendars-02"></a> [!code-csharp-interactive[System.DateTime.Calendar#2](~/samples/snippets/csharp/System.DateTime/Calendar.cs#2)]
[!code-vb[System.DateTime.Calendar#2](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#2)]  

实例化<xref:System.DateTime>值通过调用中使用日期和时间 （年、 月和日的数） 的元素特定日历[DateTime 构造函数](xref:System.DateTime.%23ctor%2A)包括`calendar`参数并将其传递<xref:System.Globalization.CultureInfo.Calendar%2A>对象，表示该日历。 下面的示例使用中的日期和时间元素<xref:System.Globalization.ThaiBuddhistCalendar>日历。  
  
<a name="calendars-03"></a> [!code-csharp-interactive[System.DateTime.Calendar#3](~/samples/snippets/csharp/System.DateTime/Calendar.cs#3)]
[!code-vb[System.DateTime.Calendar#3](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#3)]  

<xref:System.DateTime> 构造函数不包含`calendar`参数假定为公历日历中的单位表示的日期和时间的元素。  
  
所有其他<xref:System.DateTime>属性和方法使用公历。 例如，<xref:System.DateTime.Year%2A?displayProperty=nameWithType>属性返回公历日历中中的年份和<xref:System.DateTime.IsLeapYear%28System.Int32%29?displayProperty=nameWithType>方法假设`year`参数是公历日历中的每一年。  每个<xref:System.DateTime>使用公历的成员都有相应的成员<xref:System.Globalization.CultureInfo.Calendar%2A>使用特定日历的类。 例如，<xref:System.Globalization.Calendar.GetYear%2A?displayProperty=nameWithType>方法在特定日历中，返回年份和<xref:System.Globalization.Calendar.IsLeapYear%2A?displayProperty=nameWithType>方法将解释`year`参数作为特定日历的年数字。 下面的示例使用这两个<xref:System.DateTime>和的相应成员<xref:System.Globalization.ThaiBuddhistCalendar>类。  
  
<a name="calendars-04"></a> [!code-csharp-interactive[System.DateTime.Calendar#4](~/samples/snippets/csharp/System.DateTime/Calendar.cs#4)]
[!code-vb[System.DateTime.Calendar#4](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#4)]  

<xref:System.DateTime>结构包括<xref:System.DateTime.DayOfWeek%2A>属性返回公历日历中的日期是星期几。 它不包括允许您检索年的周数的成员。 若要检索年的某一周，调用各个日历<xref:System.Globalization.Calendar.GetWeekOfYear%2A?displayProperty=nameWithType>方法。 下面的示例进行了这方面的演示。  
  
<a name="calendars-05"></a> [!code-csharp-interactive[System.DateTime.Calendar#5](~/samples/snippets/csharp/System.DateTime/Calendar.cs#5)]
[!code-vb[System.DateTime.Calendar#5](~/samples/snippets/visualbasic/System.DateTime/Calendar.vb#5)]  

日期和日历的详细信息，请参阅[使用日历](~/docs/standard/datetime/working-with-calendars.md)。  
  
### <a name="persisting-datetime-values"></a>保留日期时间值  

您可以保留<xref:System.DateTime>四种方法的值：  
  
-   你[将它们转换为字符串](#persisting-values-as-strings)和保留字符串。  
-   你[将它们转换为 64 位整数值](#persisting-values-as-integers)(的值<xref:System.DateTime.Ticks%2A>属性) 和保留的整数。  
-   你[序列化的 DateTime 值](#serializing-dateTime-values)。  
-   你[序列化以及时区信息将日期时间值](#serializing-datetime-and-time-zone-data)。  
  
你必须确保还原的例程<xref:System.DateTime>值不会丢失数据或引发的异常而不考虑何种技术，你选择。 <xref:System.DateTime> 值应往返。 即，原始值和还原的值应为相同。 如果原始<xref:System.DateTime>值表示单个瞬间，它应标识还原时的时间在同一时刻。  
  
#### <a name="persisting-values-as-strings"></a>以字符串形式的保持值  

若要成功恢复<xref:System.DateTime>作为字符串保留的值遵循以下规则：  
  
-   做出有关特定于区域性的格式设置还原为当你保存的位置的字符串时相同的假设。 若要确保可以在其当前区域性为不同于系统保存的区域性的系统还原一个字符串，调用<xref:System.DateTime.ToString%2A>重载以将字符串保存通过使用固定区域性的约定。 调用<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>或<xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29>重载以还原通过使用固定区域性的约定的字符串。 永远不会使用<xref:System.DateTime.ToString>， <xref:System.DateTime.Parse%28System.String%29>，或<xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29>重载，使用当前线程区域性的约定。  
  
-   如果该日期表示为单个片刻时间，请确保它表示相同时间点还原时，即使在不同的时区。 将转换<xref:System.DateTime>保存它之前的值为协调世界时 (UTC)。 你还可以序列化以及时区信息的值。 有关这种方法的详细信息，请参阅[序列化的日期时间和时区数据](#TimeZone)。  
  
 最常见的错误时保持进行<xref:System.DateTime>作为字符串的值是依赖于默认值或当前区域性的格式设置约定。 如果当前区域性为不同保存和还原字符串时，会出现问题。 下面的示例阐释了这些问题。 它将保存使用当前区域性，在这种情况下为英语 （美国） 的格式设置约定的五个日期。 它会还原使用不同的区域性，它在此情况下为英语 （英国） 的格式设置约定的日期。 因为两个区域性的格式设置约定不同，无法还原两个日期，并不正确地解释的剩余的三个日期。 此外，如果原始的日期和时间值表示单个时刻，恢复时间不正确的因为当时区信息丢失。  
  
<a name="persistence-01"></a> [!code-csharp[System.DateTime.Persistence#1](~/samples/snippets/csharp/System.DateTime/Persistence.cs#1)]
[!code-vb[System.DateTime.Persistence#1](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#1)]  

保存/还原<xref:System.DateTime>值成功，请按照下列步骤：  
  
1.  如果此值表示单个分钟的时间，将它们转换从本地时间到 UTC 通过调用<xref:System.DateTime.ToUniversalTime%2A>方法。  
1.  将日期转换为其字符串表示形式，通过调用<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29>或<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>重载。 通过指定使用固定区域性的格式设置约定<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>作为`provider`自变量。 指定的值应使用"O"或"R"标准格式字符串往返。  
  
若要还原的保留<xref:System.DateTime>值而不丢失数据，请按照下列步骤：  
  
1.  通过调用分析的数据<xref:System.DateTime.ParseExact%2A>或<xref:System.DateTime.TryParseExact%2A>重载。 指定<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>作为`provider`自变量，并使用相同的标准格式字符串用于`format`转换期间的自变量。 包括<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>中的值`styles`自变量。  
1.  如果<xref:System.DateTime>值表示单个时刻，调用<xref:System.DateTime.ToLocalTime%2A>方法将已分析的日期而从 UTC 转换为本地时间。  
  
下面的示例使用固定区域性和"O"标准格式字符串以确保<xref:System.DateTime>值保存和还原表示相同时间点而不考虑系统、 区域性或源和目标系统的时区。  
  
<a name="persistence-02"></a> [!code-csharp[System.DateTime.Persistence#2](~/samples/snippets/csharp/System.DateTime/Persistence.cs#2)]
[!code-vb[System.DateTime.Persistence#2](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#2)]  

#### <a name="persisting-values-as-integers"></a>保持值为整数  

您可以保留将日期和时间作为<xref:System.Int64>值，该值表示的计时周期数。 在这种情况下，你无需考虑的系统区域性<xref:System.DateTime>值是保留和还原上。  
  
若要保留<xref:System.DateTime>数值类型为整数的值：  
  
-   如果<xref:System.DateTime>值表示单个时刻、 将它们转换为 UTC，通过调用<xref:System.DateTime.ToUniversalTime%2A>方法。  
-   检索所表示的计时周期数<xref:System.DateTime>值从其<xref:System.DateTime.Ticks%2A>属性。  
  
若要还原<xref:System.DateTime>已保存为一个整数的值：  
  
1.  实例化一个新<xref:System.DateTime>通过传递的对象<xref:System.Int64>值赋给<xref:System.DateTime.%23ctor%28System.Int64%29>构造函数。  
1.  如果<xref:System.DateTime>值表示单个时间点，将其转换而从 UTC 为本地时间通过调用<xref:System.DateTime.ToLocalTime%2A>方法。  
  
下面的示例仍然存在的数组<xref:System.DateTime>为美国太平洋时区中的系统上的整数值。 它在 UTC 时区中的系统上将其还原。 包含整数的文件包括<xref:System.Int32>值，该值指示的总次数<xref:System.Int64>之后紧挨着它的值。  
  
<a name="persistence-03"></a> [!code-csharp[System.DateTime.Persistence#3](~/samples/snippets/csharp/System.DateTime/Persistence.cs#3)]
[!code-vb[System.DateTime.Persistence#3](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#3)]  

#### <a name="serializing-datetime-values"></a>序列化的日期时间值  

您可以保留<xref:System.DateTime>值通过序列化到流或文件，然后还原其通过反序列化。 <xref:System.DateTime> 数据被序列中某些指定的对象格式。 将对象还原时它们将反序列化。 格式化程序或序列化程序，如<xref:System.Xml.Serialization.XmlSerializer>或<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>，处理序列化和反序列化的过程。 有关序列化和类型的.NET Framework 支持的序列化的详细信息，请参阅[序列化](~/docs/standard/serialization/index.md)。
  
下面的示例使用<xref:System.Xml.Serialization.XmlSerializer>类进行序列化和反序列化<xref:System.DateTime>值。 值表示二十一世纪中的所有闰年天。 如果示例在当前区域性为英语 （英国） 的系统上运行，则输出表示的结果。 因为你已反序列化<xref:System.DateTime>对象本身，则无需处理日期和时间格式的区域性差异。  
  
<a name="persistence-04"></a> [!code-csharp[System.DateTime.Persistence#4](~/samples/snippets/csharp/System.DateTime/Persistence.cs#4)]
[!code-vb[System.DateTime.Persistence#4](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#4)]  

前面的示例不包括时间信息。 如果<xref:System.DateTime>值表示时间某个时间点，并且表示为本地时间、 将其转换从本地时间到 UTC 通过调用进行序列化之前<xref:System.DateTime.ToUniversalTime%2A>方法。 你反序列化后，将其转换而从 UTC 为本地时间通过调用<xref:System.DateTime.ToLocalTime%2A>方法。 下面的示例使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>类来序列化<xref:System.DateTime>在美国太平洋时区中的系统上的数据太平洋标准时区并在美国的系统上进行反序列化中央标准区域。  
  
<a name="persistence-05"></a> [!code-csharp[System.DateTime.Persistence#5](~/samples/snippets/csharp/System.DateTime/Persistence.cs#5)]
[!code-vb[System.DateTime.Persistence#5](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#5)]  

#### <a name="serializing-datetime-and-time-zone-data"></a>序列化的日期时间和时区的数据  

所有前面的示例假定<xref:System.DateTime>值表示为本地时间。 代码转换 UTC 和当地时间之间的值，使其反映在源和目标系统上的相同那一刻。 <xref:System.DateTime> 值还可能反映中而不是本地的时区与 UTC 的时刻。 因为<xref:System.DateTime>结构不是时区感知型，则必须序列化同时<xref:System.DateTime>值和<xref:System.TimeZoneInfo>对象，表示其所在的时区。 创建其字段同时包含这两者类型<xref:System.DateTime>值和其所在的时区。 下面的示例定义`DateWithTimeZone`结构。  
  
<a name="persistence-06"></a> [!code-csharp[System.DateTime.Persistence#6](~/samples/snippets/csharp/System.DateTime/DateWithTimeZone.cs#6)]
[!code-vb[System.DateTime.Persistence#6](~/samples/snippets/visualbasic/System.DateTime/DateWithTimeZone.vb#6)]  

> [!IMPORTANT]
>  `DateWithTimeZone`结构使用在下面的两个示例中，该序列化和反序列化的数组`DateWithTimeZone`对象。 你可以查看这篇文章中的示例的整个集的源中任意一种[Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/System.DateTime/)或[C#](https://github.com/dotnet/samples/tree/master/snippets/csharp/System.DateTime/)从 GitHub 上的文档存储库。
  
通过使用`DateWithTimeZone`结构，你就可以保留日期和时间和时区信息。 下面的示例使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>类来序列化的数组`DateWithTimeZone`对象。  
  
[!code-csharp[System.DateTime.Persistence#7](~/samples/snippets/csharp/System.DateTime/Persistence.cs#7)]
[!code-vb[System.DateTime.Persistence#7](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#7)]  

下面的示例然后调用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType>方法来反序列化。  
  
[!code-csharp[System.DateTime.Persistence#8](~/samples/snippets/csharp/System.DateTime/Persistence.cs#8)]
[!code-vb[System.DateTime.Persistence#8](~/samples/snippets/visualbasic/System.DateTime/Persistence.vb#8)]  

### <a name="datetime-vs-timespan"></a>DateTime vs。TimeSpan  

<xref:System.DateTime>和<xref:System.TimeSpan>值类型的差异在于<xref:System.DateTime>及时表示某个时刻，而<xref:System.TimeSpan>表示一个时间间隔。 可以用减去的一个实例<xref:System.DateTime>从另一个用来获取<xref:System.TimeSpan>表示它们之间的时间间隔的对象。 你可以添加一个值为正或者<xref:System.TimeSpan>到当前<xref:System.DateTime>获取<xref:System.DateTime>值，该值表示未来的某个日期。  
  
你可以添加或减去的时间间隔从<xref:System.DateTime>对象。 时间间隔可以是负数或正数，并且它们可以表示单元个时钟周期，如秒，或被<xref:System.TimeSpan>对象。  

### <a name="comparing-for-equality-within-tolerance"></a>在容许范围内的相等性比较

有关的相等性比较<xref:System.DateTime>确切的有效值。 这意味着必须将两个值表示为相同数量的计时周期将被视为相等。 精度通常是不需要或甚至对于许多应用程序不正确。 通常情况下，你想要测试如果<xref:System.DateTime>对象**大致相等**。 

下面的示例演示如何比较大致等效<xref:System.DateTime>。 声明它们相等时，它接受小边距的差异。  
  
<a name="comparison-02"></a> [!code-csharp[System.DateTime.Comparisons#1](~/samples/snippets/csharp/System.DateTime/DateTimeComparisons.cs#1)]
[!code-vb[System.DateTime.Comparisons#1](~/samples/snippets/visualbasic/System.DateTime/DateTimeComparisons.vb#1)]  

### <a name="com-interop-considerations"></a>COM 互操作注意事项  

A<xref:System.DateTime>值传输到 COM 应用程序，然后传输回托管应用程序，这称为往返。 但是，<xref:System.DateTime>值，该值指定仅在时间不正如所料往返。  
  
如果你往返仅时间，如下午 3 点、 最后一个日期和时间为公元 1899 年 12 月 30 日 下午 3:00，而不是 1 月 1日日公元 0001 年 在下午 3:00 .NET Framework 和 COM 假定指定仅在时间时的默认日期。 但是，COM 系统采用的基准日期为 1899 年 12 月 30 日开始，而.NET Framework 采用的基准的 1 月 1 日日期公元 0001 年  
  
当仅在时间从.NET Framework 传递给 COM 时，执行特殊处理，将时间转换为 com 使用的格式 当仅在时间从 COM 传递到.NET Framework 时，因为这会破坏合法的日期和时间或 1899 年 12 月 30 日之前不执行任何特殊处理。 如果日期是从 COM 开始其往返，.NET Framework 和 COM 保留日期。  
  
.NET Framework 和 COM 的行为意味着，如果你的应用程序往返<xref:System.DateTime>，仅指定了时间，你的应用程序必须记得修改或忽略从最后一个错误日期<xref:System.DateTime>对象。  
     
 ]]></format>
    </remarks>
    <threadsafe>此类型的所有成员都是线程安全。 实际上，看起来要修改实例状态的成员返回使用新值初始化的新实例。 作为与任何其他类型，读取和写入到共享的变量，其中包含此类型的实例必须受使用锁来确保的线程安全性。</threadsafe>
    <altmember cref="T:System.DateTimeOffset" />
    <altmember cref="T:System.TimeSpan" />
    <altmember cref="T:System.Globalization.Calendar" />
    <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
    <altmember cref="T:System.TimeZoneInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.DateTime" /> 结构的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (long ticks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 ticks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ticks As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(long ticks);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ticks" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ticks">一个日期和时间，以公历 0001 年 1 月 1 日 00:00:00.000 以来所经历的以 100 纳秒为间隔的间隔数来表示。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定的刻度数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将 <xref:System.DateTime.Kind%2A> 属性初始化为 <xref:System.DateTimeKind.Unspecified>。  
  
 对于应用程序感知的可移植性日期和时间数据或时区的有限的度很重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  
  
   
  
## Examples  
 下面的示例演示之一<xref:System.DateTime>构造函数。  
  
 [!code-cpp[datetime.ctor_Int64#1](~/samples/snippets/cpp/VS_Snippets_CLR/datetime.ctor_Int64/CPP/ticks.cpp#1)]
 [!code-csharp[datetime.ctor_Int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/datetime.ctor_Int64/CS/ticks.cs#1)]
 [!code-vb[datetime.ctor_Int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/datetime.ctor_Int64/VB/ticks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="ticks" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (long ticks, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 ticks, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int64,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ticks As Long, kind As DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(long ticks, DateTimeKind kind);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ticks" Type="System.Int64" />
        <Parameter Name="kind" Type="System.DateTimeKind" />
      </Parameters>
      <Docs>
        <param name="ticks">一个日期和时间，以公历 0001 年 1 月 1 日 00:00:00.000 以来所经历的以 100 纳秒为间隔的间隔数来表示。</param>
        <param name="kind">枚举值之一，该值指示 <c>ticks</c> 是指定了本地时间、协调世界时 (UTC)，还是两者皆未指定。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定的计时周期数以及协调世界时 (UTC) 或本地时间。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于应用程序感知的可移植性日期和时间数据或时区的有限的度很重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="ticks" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="kind" /> 不是 <see cref="T:System.DateTimeKind" /> 值之一。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 9999）。</param>
        <param name="month">月（1 到 12）。</param>
        <param name="day">日（1 到 <c>month</c>中的天数）。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定的年、月和日。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数将解释`year`， `month`，和`day`作为年、 月和公历日历中的天。 若要实例化<xref:System.DateTime>通过使用另一个日历，调用中的年、 月和日值<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29>构造函数。  
  
 为生成的一天的时间<xref:System.DateTime>是午夜 (00: 00:00)。 将 <xref:System.DateTime.Kind%2A> 属性初始化为 <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>构造函数实例化<xref:System.DateTime>值。 示例还演示了此重载创建<xref:System.DateTime>其时间组成部分等于午夜的值 (或 0:00)。  
  
 [!code-csharp[System.DateTime.Constructor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#1)]
 [!code-vb[System.DateTime.Constructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> 小于 1 或大于 9999。  
  
 或  
  
 <paramref name="month" /> 小于 1 或大于 12。  
  
 或  
  
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, System.Globalization.Calendar calendar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, class System.Globalization.Calendar calendar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Globalization.Calendar)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, System::Globalization::Calendar ^ calendar);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 <c>calendar</c> 中的年数）。</param>
        <param name="month">月（1 到 <c>calendar</c> 中的月数）。</param>
        <param name="day">日（1 到 <c>month</c>中的天数）。</param>
        <param name="calendar">用于解释 <c>year</c>、<c>month</c> 和 <c>day</c> 的日历。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定日历的指定年、月和日。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为生成的一天的时间<xref:System.DateTime>是午夜 (00: 00:00)。 将 <xref:System.DateTime.Kind%2A> 属性初始化为 <xref:System.DateTimeKind.Unspecified>。  
  
 允许值为`year`， `month`，和`day`依赖于`calendar`。 如果指定的日期和时间不能使用来表示引发异常`calendar`。  
  
 <xref:System.Globalization>命名空间提供多个包括的日历<xref:System.Globalization.GregorianCalendar>和<xref:System.Globalization.JulianCalendar>。  
  
   
  
## Examples  
 下面的示例调用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29>构造函数两次以实例化两个<xref:System.DateTime>值。 第一次调用实例化<xref:System.DateTime>值使用<xref:System.Globalization.PersianCalendar>对象。 因为波斯历不能指定为区域性的默认日历，显示日期与波斯历必须单独调用其<xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>， <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>，和<xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType>方法。 构造函数的第二个调用实例化<xref:System.DateTime>值使用<xref:System.Globalization.HijriCalendar>对象。 该示例将当前区域性更改为阿拉伯语 （叙利亚），并为回历更改当前区域性的默认日历。 因为回历是当前区域性的默认日历<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用它来设置日期格式。 还原以前的当前区域性 （这在此情况下是英语 （美国）） 时，<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用当前区域性的默认公历日历来设置日期格式。  
  
 [!code-csharp[System.DateTime.Constructor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample2.cs#2)]
 [!code-vb[System.DateTime.Constructor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="calendar" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> 不在 <paramref name="calendar" /> 支持的范围内。  
  
 或  
  
 <paramref name="month" /> 小于 1 或大于 <paramref name="calendar" /> 中的月数。  
  
 或  
  
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 9999）。</param>
        <param name="month">月（1 到 12）。</param>
        <param name="day">日（1 到 <c>month</c>中的天数）。</param>
        <param name="hour">小时（0 到 23）。</param>
        <param name="minute">分（0 到 59）。</param>
        <param name="second">秒（0 到 59）。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定的年、月、日、小时、分钟和秒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将 <xref:System.DateTime.Kind%2A> 属性初始化为 <xref:System.DateTimeKind.Unspecified>。  
  
 此构造函数将解释`year`， `month`，和`day`作为年、 月和公历日历中的天。 若要实例化<xref:System.DateTime>通过使用另一个日历，调用中的年、 月和日值<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29>构造函数。  
  
 对于应用程序感知的可移植性日期和时间数据或时区的有限的度很重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.%23ctor%2A>构造函数实例化<xref:System.DateTime>值。  
  
 [!code-csharp[System.DateTime.Constructor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#3)]
 [!code-vb[System.DateTime.Constructor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> 小于 1 或大于 9999。  
  
 或  
  
 <paramref name="month" /> 小于 1 或大于 12。  
  
 或  
  
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。  
  
 或  
  
 <paramref name="hour" /> 小于 0 或大于 23。  
  
 或  
  
 <paramref name="minute" /> 小于 0 或大于 59。  
  
 或  
  
 <paramref name="second" /> 小于 0 或大于 59。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, kind As DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="kind" Type="System.DateTimeKind" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 9999）。</param>
        <param name="month">月（1 到 12）。</param>
        <param name="day">日（1 到 <c>month</c>中的天数）。</param>
        <param name="hour">小时（0 到 23）。</param>
        <param name="minute">分（0 到 59）。</param>
        <param name="second">秒（0 到 59）。</param>
        <param name="kind">枚举值之一，该值指示 <c>year</c>、<c>month</c>、<c>day</c>、<c>hour</c>、<c>minute</c> 和 <c>second</c> 指定了本地时间、协调世界时 (UTC)，还是两者皆未指定。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定年、月、日、小时、分钟、秒和协调世界时 (UTC) 或本地时间。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数将解释`year`， `month`，和`day`作为年、 月和公历日历中的天。 若要实例化<xref:System.DateTime>通过使用另一个日历，调用中的年、 月和日值<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%2CSystem.DateTimeKind%29>构造函数。  
  
 对于应用程序感知的可移植性日期和时间数据或时区的有限的度很重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.DateTimeKind%29>构造函数实例化<xref:System.DateTime>值。  
  
 [!code-csharp[System.DateTime.Constructor#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#7)]
 [!code-vb[System.DateTime.Constructor#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> 小于 1 或大于 9999。  
  
 或  
  
 <paramref name="month" /> 小于 1 或大于 12。  
  
 或  
  
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。  
  
 或  
  
 <paramref name="hour" /> 小于 0 或大于 23。  
  
 或  
  
 <paramref name="minute" /> 小于 0 或大于 59。  
  
 或  
  
 <paramref name="second" /> 小于 0 或大于 59。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="kind" /> 不是 <see cref="T:System.DateTimeKind" /> 值之一。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, System.Globalization.Calendar calendar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, class System.Globalization.Calendar calendar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Globalization.Calendar)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, System::Globalization::Calendar ^ calendar);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 <c>calendar</c> 中的年数）。</param>
        <param name="month">月（1 到 <c>calendar</c> 中的月数）。</param>
        <param name="day">日（1 到 <c>month</c>中的天数）。</param>
        <param name="hour">小时（0 到 23）。</param>
        <param name="minute">分（0 到 59）。</param>
        <param name="second">秒（0 到 59）。</param>
        <param name="calendar">用于解释 <c>year</c>、<c>month</c> 和 <c>day</c> 的日历。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定日历的年、月、日、小时、分钟和秒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将 <xref:System.DateTime.Kind%2A> 属性初始化为 <xref:System.DateTimeKind.Unspecified>。  
  
 允许值为`year`， `month`，和`day`依赖于`calendar`。 如果指定的日期和时间不能使用来表示引发异常`calendar`。  
  
 <xref:System.Globalization>命名空间提供多个包括的日历<xref:System.Globalization.GregorianCalendar>和<xref:System.Globalization.JulianCalendar>。  
  
   
  
## Examples  
 下面的示例调用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29>构造函数两次以实例化两个<xref:System.DateTime>值。 第一次调用实例化<xref:System.DateTime>值使用<xref:System.Globalization.PersianCalendar>对象。 因为波斯历不能指定为区域性的默认日历，显示日期与波斯历必须单独调用其<xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>， <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>，和<xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType>方法。 构造函数的第二个调用实例化<xref:System.DateTime>值使用<xref:System.Globalization.HijriCalendar>对象。 该示例将当前区域性更改为阿拉伯语 （叙利亚），并为回历更改当前区域性的默认日历。 因为回历是当前区域性的默认日历<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用它来设置日期格式。 还原以前的当前区域性 （这在此情况下是英语 （美国）） 时，<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用当前区域性的默认公历日历来设置日期格式。  
  
 [!code-csharp[System.DateTime.Constructor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample4.cs#4)]
 [!code-vb[System.DateTime.Constructor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="calendar" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> 不在 <paramref name="calendar" /> 支持的范围内。  
  
 或  
  
 <paramref name="month" /> 小于 1 或大于 <paramref name="calendar" /> 中的月数。  
  
 或  
  
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。  
  
 或  
  
 <paramref name="hour" /> 小于 0 或大于 23  
  
 或  
  
 <paramref name="minute" /> 小于 0 或大于 59。  
  
 或  
  
 <paramref name="second" /> 小于 0 或大于 59。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, millisecond As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="millisecond" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 9999）。</param>
        <param name="month">月（1 到 12）。</param>
        <param name="day">日（1 到 <c>month</c>中的天数）。</param>
        <param name="hour">小时（0 到 23）。</param>
        <param name="minute">分（0 到 59）。</param>
        <param name="second">秒（0 到 59）。</param>
        <param name="millisecond">毫秒（0 到 999）。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定的年、月、日、小时、分钟、秒和毫秒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数将解释`year`， `month`，和`day`作为年、 月和公历日历中的天。 若要实例化<xref:System.DateTime>通过使用另一个日历，调用中的年、 月和日值<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29>构造函数。  
  
 将 <xref:System.DateTime.Kind%2A> 属性初始化为 <xref:System.DateTimeKind.Unspecified>。  
  
 对于应用程序感知的可移植性日期和时间数据或时区的有限的度很重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>构造函数实例化<xref:System.DateTime>值。  
  
 [!code-csharp[System.DateTime.Constructor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#5)]
 [!code-vb[System.DateTime.Constructor#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> 小于 1 或大于 9999。  
  
 或  
  
 <paramref name="month" /> 小于 1 或大于 12。  
  
 或  
  
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。  
  
 或  
  
 <paramref name="hour" /> 小于 0 或大于 23。  
  
 或  
  
 <paramref name="minute" /> 小于 0 或大于 59。  
  
 或  
  
 <paramref name="second" /> 小于 0 或大于 59。  
  
 或  
  
 <paramref name="millisecond" /> 小于 0 或大于 999。</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, millisecond As Integer, kind As DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="millisecond" Type="System.Int32" />
        <Parameter Name="kind" Type="System.DateTimeKind" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 9999）。</param>
        <param name="month">月（1 到 12）。</param>
        <param name="day">日（1 到 <c>month</c>中的天数）。</param>
        <param name="hour">小时（0 到 23）。</param>
        <param name="minute">分（0 到 59）。</param>
        <param name="second">秒（0 到 59）。</param>
        <param name="millisecond">毫秒（0 到 999）。</param>
        <param name="kind">枚举值之一，该值指示 <c>year</c>、<c>month</c>、<c>day</c>、<c>hour</c>、<c>minute</c>、<c>second</c> 和 <c>millisecond</c> 指定了本地时间、协调世界时 (UTC)，还是两者皆未指定。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定年、月、日、小时、分钟、秒、毫秒和协调世界时 (UTC) 或本地时间。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数将解释`year`， `month`，和`day`作为年、 月和公历日历中的天。 若要实例化<xref:System.DateTime>通过使用另一个日历，调用中的年、 月和日值<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%2CSystem.DateTimeKind%29>构造函数。  
  
 对于应用程序感知的可移植性日期和时间数据或时区的有限的度很重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.DateTimeKind%29>构造函数实例化<xref:System.DateTime>值。  
  
 [!code-csharp[System.DateTime.Constructor#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample1.cs#8)]
 [!code-vb[System.DateTime.Constructor#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> 小于 1 或大于 9999。  
  
 或  
  
 <paramref name="month" /> 小于 1 或大于 12。  
  
 或  
  
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。  
  
 或  
  
 <paramref name="hour" /> 小于 0 或大于 23。  
  
 或  
  
 <paramref name="minute" /> 小于 0 或大于 59。  
  
 或  
  
 <paramref name="second" /> 小于 0 或大于 59。  
  
 或  
  
 <paramref name="millisecond" /> 小于 0 或大于 999。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="kind" /> 不是 <see cref="T:System.DateTimeKind" /> 值之一。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond, class System.Globalization.Calendar calendar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Globalization.Calendar)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System::Globalization::Calendar ^ calendar);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="millisecond" Type="System.Int32" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 <c>calendar</c> 中的年数）。</param>
        <param name="month">月（1 到 <c>calendar</c> 中的月数）。</param>
        <param name="day">日（1 到 <c>month</c>中的天数）。</param>
        <param name="hour">小时（0 到 23）。</param>
        <param name="minute">分（0 到 59）。</param>
        <param name="second">秒（0 到 59）。</param>
        <param name="millisecond">毫秒（0 到 999）。</param>
        <param name="calendar">用于解释 <c>year</c>、<c>month</c> 和 <c>day</c> 的日历。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定日历的指定年、月、日、小时、分钟、秒和毫秒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将 <xref:System.DateTime.Kind%2A> 属性初始化为 <xref:System.DateTimeKind.Unspecified>。  
  
 允许值为`year`， `month`，和`day`依赖于`calendar`。 如果指定的日期和时间不能使用来表示引发异常`calendar`。  
  
 对于应用程序感知的可移植性日期和时间数据或时区的有限的度很重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  
  
 <xref:System.Globalization>命名空间提供多个包括的日历<xref:System.Globalization.GregorianCalendar>和<xref:System.Globalization.JulianCalendar>。  
  
   
  
## Examples  
 下面的示例调用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%29>构造函数两次以实例化两个<xref:System.DateTime>值。 第一次调用实例化<xref:System.DateTime>值使用<xref:System.Globalization.PersianCalendar>对象。 因为波斯历不能指定为区域性的默认日历，显示日期与波斯历必须单独调用其<xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>， <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>，和<xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType>方法。 构造函数的第二个调用实例化<xref:System.DateTime>值使用<xref:System.Globalization.HijriCalendar>对象。 该示例将当前区域性更改为阿拉伯语 （叙利亚），并为回历更改当前区域性的默认日历。 因为回历是当前区域性的默认日历<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用它来设置日期格式。 还原以前的当前区域性 （这在此情况下是英语 （美国）） 时，<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用当前区域性的默认公历日历来设置日期格式。  
  
 [!code-csharp[System.DateTime.Constructor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample6.cs#6)]
 [!code-vb[System.DateTime.Constructor#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="calendar" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> 不在 <paramref name="calendar" /> 支持的范围内。  
  
 或  
  
 <paramref name="month" /> 小于 1 或大于 <paramref name="calendar" /> 中的月数。  
  
 或  
  
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。  
  
 或  
  
 <paramref name="hour" /> 小于 0 或大于 23。  
  
 或  
  
 <paramref name="minute" /> 小于 0 或大于 59。  
  
 或  
  
 <paramref name="second" /> 小于 0 或大于 59。  
  
 或  
  
 <paramref name="millisecond" /> 小于 0 或大于 999。</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTime (int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond, class System.Globalization.Calendar calendar, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Globalization.Calendar,System.DateTimeKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System::Globalization::Calendar ^ calendar, DateTimeKind kind);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="millisecond" Type="System.Int32" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" />
        <Parameter Name="kind" Type="System.DateTimeKind" />
      </Parameters>
      <Docs>
        <param name="year">年（1 到 <c>calendar</c> 中的年数）。</param>
        <param name="month">月（1 到 <c>calendar</c> 中的月数）。</param>
        <param name="day">日（1 到 <c>month</c>中的天数）。</param>
        <param name="hour">小时（0 到 23）。</param>
        <param name="minute">分（0 到 59）。</param>
        <param name="second">秒（0 到 59）。</param>
        <param name="millisecond">毫秒（0 到 999）。</param>
        <param name="calendar">用于解释 <c>year</c>、<c>month</c> 和 <c>day</c> 的日历。</param>
        <param name="kind">枚举值之一，该值指示 <c>year</c>、<c>month</c>、<c>day</c>、<c>hour</c>、<c>minute</c>、<c>second</c> 和 <c>millisecond</c> 指定了本地时间、协调世界时 (UTC)，还是两者皆未指定。</param>
        <summary>将 <see cref="T:System.DateTime" /> 结构的新实例初始化为指定日历的指定年、月、日、小时、分钟、秒、毫秒和协调世界时 (UTC) 或本地时间。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 允许值为`year`， `month`，和`day`参数依赖于`calendar`参数。 如果指定的日期和时间不能使用来表示引发异常`calendar`。  
  
 对于应用程序感知的可移植性日期和时间数据或时区的有限的度很重要，可以使用相应<xref:System.DateTimeOffset>构造函数。  
  
 <xref:System.Globalization>命名空间提供多个包括的日历<xref:System.Globalization.GregorianCalendar>和<xref:System.Globalization.JulianCalendar>。  
  
   
  
## Examples  
 下面的示例调用<xref:System.DateTime.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%2CSystem.DateTimeKind%29>构造函数两次以实例化两个<xref:System.DateTime>值。 第一次调用实例化<xref:System.DateTime>值使用<xref:System.Globalization.PersianCalendar>对象。 因为波斯历不能指定为区域性的默认日历，显示日期与波斯历必须单独调用其<xref:System.Globalization.PersianCalendar.GetMonth%2A?displayProperty=nameWithType>， <xref:System.Globalization.PersianCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>，和<xref:System.Globalization.PersianCalendar.GetYear%2A?displayProperty=nameWithType>方法。 构造函数的第二个调用实例化<xref:System.DateTime>值使用<xref:System.Globalization.HijriCalendar>对象。 该示例将当前区域性更改为阿拉伯语 （叙利亚），并为回历更改当前区域性的默认日历。 因为回历是当前区域性的默认日历<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用它来设置日期格式。 还原以前的当前区域性 （这在此情况下是英语 （美国）） 时，<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法使用当前区域性的默认公历日历来设置日期格式。  
  
 [!code-csharp[System.DateTime.Constructor#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.constructor/cs/ctorexample9.cs#9)]
 [!code-vb[System.DateTime.Constructor#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.constructor/vb/ctorexample9.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="calendar" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> 不在 <paramref name="calendar" /> 支持的范围内。  
  
 或  
  
 <paramref name="month" /> 小于 1 或大于 <paramref name="calendar" /> 中的月数。  
  
 或  
  
 <paramref name="day" /> 小于 1 或大于 <paramref name="month" /> 中的天数。  
  
 或  
  
 <paramref name="hour" /> 小于 0 或大于 23。  
  
 或  
  
 <paramref name="minute" /> 小于 0 或大于 59。  
  
 或  
  
 <paramref name="second" /> 小于 0 或大于 59。  
  
 或  
  
 <paramref name="millisecond" /> 小于 0 或大于 999。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="kind" /> 不是 <see cref="T:System.DateTimeKind" /> 值之一。</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public DateTime Add (TimeSpan value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime Add(valuetype System.TimeSpan value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Add(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (value As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime Add(TimeSpan value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="value">正或负时间间隔。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定 <see cref="T:System.TimeSpan" /> 的值添加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的时间间隔之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用<xref:System.DateTime.Add%2A>方法在单个操作中添加多个一种类型的时间间隔 （天、 小时、 分钟、 秒或毫秒为单位）。 此方法的行为等同于的加法运算符。 <xref:System.DateTime>结构还支持专用的加法 (如<xref:System.DateTime.AddDays%2A>， <xref:System.DateTime.AddHours%2A>，和<xref:System.DateTime.AddMinutes%2A>) 为每个时间间隔。  
  
 <xref:System.DateTime.Add%2A>方法将考虑闰年和执行日期时算术一个月的最大天数。  
  
 此方法不会更改此值<xref:System.DateTime>。 相反，它将返回一个新<xref:System.DateTime>其值是此操作的结果。 <xref:System.DateTime.Kind%2A>属性的新<xref:System.DateTime>实例是否与当前实例相同。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Add%2A>方法。 此公式计算的一周中的此一刻为 36 天 （864 小时数） 的天。  
  
 [!code-cpp[DateTime.Add#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Add/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Add/CS/class1.cs#1)]
 [!code-vb[DateTime.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Add/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="M:System.TimeSpan.Add(System.TimeSpan)" />
      </Docs>
    </Member>
    <Member MemberName="AddDays">
      <MemberSignature Language="C#" Value="public DateTime AddDays (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddDays(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddDays(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddDays (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddDays(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">由整数和小数部分组成的天数。 <c>value</c> 参数可以是负数也可以是正数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的天数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的天数之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此值<xref:System.DateTime>。 相反，它将返回一个新<xref:System.DateTime>其值是此操作的结果。  
  
 小数部分`value`是一天的小数部分。 例如，4.5 相当于 4 天 12 小时 0 分钟 0 秒，0 毫秒，0 计时周期。  
  
 `value`参数舍入为最接近的毫秒。  
  
 <xref:System.DateTime.AddDays%2A>方法将考虑闰年和执行日期时算术一个月的最大天数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.AddDays%2A>方法来确定星期几 36 天后的当前日期。  
  
 [!code-cpp[DateTime.AddDays#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.AddDays/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.AddDays#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.AddDays/CS/class1.cs#1)]
 [!code-vb[DateTime.AddDays#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.AddDays/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="AddHours">
      <MemberSignature Language="C#" Value="public DateTime AddHours (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddHours(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddHours(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddHours (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddHours(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">由整数和小数部分组成的小时数。 <c>value</c> 参数可以是负数也可以是正数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的小时数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的小时数之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此值<xref:System.DateTime>。 相反，它将返回一个新<xref:System.DateTime>其值是此操作的结果。 <xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象是相同的`value`。  
  
 小数部分`value`是一小时的小数部分。 例如，4.5 相当于 4 小时 30 分钟 0 秒，0 毫秒，0 计时周期。  
  
 `value`参数舍入为最接近的毫秒。  
  
 如果结果为非终止循环小数，则将不会超过一小时的时间间隔转换为一小部分可能涉及精度损失。 （例如，一分钟是 0.016667 小时。）如果这有问题，则可以使用<xref:System.DateTime.Add%2A>方法，它使你可以在单个方法调用中指定的时间间隔的多个类型并无需转换为一小时的小数部分的时间间隔。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.AddHours%2A>方法将大量的整数和小数部分值添加到的日期和时间。 它还说明了通过将该方法传递包含小数部分的值引起的精度损失。  
  
 [!code-csharp[System.DateTime.AddHours#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.AddHours/cs/AddHours1.cs#1)]
 [!code-vb[System.DateTime.AddHours#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.AddHours/vb/AddHours1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="M:System.DateTime.Add(System.TimeSpan)" />
      </Docs>
    </Member>
    <Member MemberName="AddMilliseconds">
      <MemberSignature Language="C#" Value="public DateTime AddMilliseconds (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddMilliseconds(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddMilliseconds(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMilliseconds (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddMilliseconds(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">由整数和小数部分组成的毫秒数。 <c>value</c> 参数可以是负数也可以是正数。 请注意，该值被舍入到最近的整数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的毫秒数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的毫秒数之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此值<xref:System.DateTime>。 相反，它将返回一个新<xref:System.DateTime>其值是此操作的结果。  
  
 小数部分`value`是以毫秒为单位的小数部分。 例如，4.5 相当于 4 毫秒，5000 个时钟周期，其中 1 毫秒 = 10000 刻度。  
  
 `value`参数舍入为最接近的整数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.AddMilliseconds%2A>方法将添加一个毫秒和到 1.5 毫秒<xref:System.DateTime>值。 然后，它将显示每个新值并显示它和原始值之间的差异。 时间跨度，而且作为的计时周期数，显示的区别。 示例使清晰地表明 1 毫秒等于 10000 个计时周期。 它还演示在执行加法; 之前，舍入毫秒的小数部分<xref:System.DateTime>通过添加到原始日期 1.5 毫秒的值是 2 毫秒大于原始日期。  
  
 [!code-csharp[System.DateTime.AddMilliseconds#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addmilliseconds/cs/addmilliseconds2.cs#1)]
 [!code-vb[System.DateTime.AddMilliseconds#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addmilliseconds/vb/addmilliseconds2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="AddMinutes">
      <MemberSignature Language="C#" Value="public DateTime AddMinutes (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddMinutes(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddMinutes(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMinutes (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddMinutes(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">由整数和小数部分组成的分钟数。 <c>value</c> 参数可以是负数也可以是正数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的分钟数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的分钟数之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此值<xref:System.DateTime>。 相反，它将返回一个新<xref:System.DateTime>其值是此操作的结果。  
  
 小数部分`value`是一分钟的小数部分。 例如，4.5 相当于 4 分钟，30 秒，0 毫秒，0 计时周期。  
  
 `value`参数舍入为最接近的毫秒。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.AddMinutes%2A>方法将大量的整数和小数部分值添加到的日期和时间。  
  
 [!code-cpp[System.DateTime.AddMinutes#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.datetime.addminutes/cpp/addminutes1.cpp#1)]
 [!code-csharp[System.DateTime.AddMinutes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addminutes/cs/addminutes1.cs#1)]
 [!code-vb[System.DateTime.AddMinutes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addminutes/vb/addminutes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="AddMonths">
      <MemberSignature Language="C#" Value="public DateTime AddMonths (int months);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddMonths(int32 months) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddMonths(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMonths (months As Integer) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddMonths(int months);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="months" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="months">月份数。 <c>months</c> 参数可以是负数也可以是正数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的月数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="months" /> 所表示的时间之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此值<xref:System.DateTime>对象。 相反，它将返回一个新<xref:System.DateTime>对象，其值是此操作的结果。  
  
 <xref:System.DateTime.AddMonths%2A>方法计算结果的月份和年份，考虑到帐户闰年和一个月的最大天数然后调整所产生的日部分<xref:System.DateTime>对象。 如果结果的日期不是结果的月份中的有效日期，则使用生成的每月的最后一个有效的一天。 例如，3 月 31 日 + 1 个月 = 4 月 30 日和年 3 月 31-1 个月 = 2 月 28 日为非-闰年和年 2 月月 29 日为闰年。  
  
 所生成的一天时间部分<xref:System.DateTime>对象仍保留此实例相同。  
  
   
  
## Examples  
 下面的示例将介于零和十五个月添加到 2015 年 12 月的最后一天中。 在这种情况下，AddMonths 方法返回的每个月的最后一天的日期，并成功处理闰年。  
  
 [!code-csharp[System.DateTime.AddMonths#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addmonths/cs/addmonths1.cs#1)]
 [!code-vb[System.DateTime.AddMonths#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addmonths/vb/addmonths1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。  
  
 或  
  
 <paramref name="months" /> 小于 -120,000 或大于 120,000。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddSeconds">
      <MemberSignature Language="C#" Value="public DateTime AddSeconds (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddSeconds(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddSeconds(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddSeconds (value As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddSeconds(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">由整数和小数部分组成的秒数。 <c>value</c> 参数可以是负数也可以是正数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的秒数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的秒数之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此值<xref:System.DateTime>。 相反，它将返回一个新<xref:System.DateTime>其值是此操作的结果。  
  
 小数部分`value`是一秒的小数部分。 例如，4.5 相当于 4 秒、 500 毫秒，0 计时周期。  
  
 `value`参数舍入为最接近的毫秒。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.AddSeconds%2A>方法将添加到的一天中的 30 秒和秒数<xref:System.DateTime>值。 然后，它将显示每个新值并显示它和原始值之间的差异。 时间跨度，而且作为的计时周期数，显示的区别。  
  
 [!code-csharp[System.DateTime.AddSeconds#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addseconds/cs/addseconds1.cs#1)]
 [!code-vb[System.DateTime.AddSeconds#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addseconds/vb/addseconds1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="AddTicks">
      <MemberSignature Language="C#" Value="public DateTime AddTicks (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddTicks(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddTicks(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddTicks (value As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddTicks(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">以 100 纳秒为单位的计时周期数。 <c>value</c> 参数可以是正数也可以是负数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的刻度数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的时间之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此值<xref:System.DateTime>。 相反，它将返回一个新<xref:System.DateTime>其值是此操作的结果。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="T:System.Int64" />
        <altmember cref="P:System.DateTime.Ticks" />
      </Docs>
    </Member>
    <Member MemberName="AddYears">
      <MemberSignature Language="C#" Value="public DateTime AddYears (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime AddYears(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.AddYears(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddYears (value As Integer) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime AddYears(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">年份数。 <c>value</c> 参数可以是负数也可以是正数。</param>
        <summary>返回一个新的 <see cref="T:System.DateTime" />，它将指定的年份数加到此实例的值上。</summary>
        <returns>一个对象，其值是此实例所表示的日期和时间与 <paramref name="value" /> 所表示的年份数之和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不会更改此值<xref:System.DateTime>对象。 相反，它将返回一个新<xref:System.DateTime>对象，其值是此操作的结果。  
  
 <xref:System.DateTime.AddYears%2A>方法计算所得的年份考虑闰年。 所生成的月份和时间的日期部分<xref:System.DateTime>对象仍保留此实例相同。  
  
 如果当前实例表示在闰年闰日，返回的值取决于目标日期：  
  
-   如果`value`  +  <xref:System.DateTime.Year%2A?displayProperty=nameWithType>也是闰年，返回值表示该年闰日。 例如，如果为四年添加到 2012 年 2 月 29 日，返回的日期是 2016 年 2 月 29 日。  
  
-   如果`value`  +  <xref:System.DateTime.Year%2A?displayProperty=nameWithType>不是闰年，返回值表示该年闰日前一天。 例如，如果一年添加到 2012 年 2 月 29 日，返回的日期是 2013 年 2 月 28 日。  
  
 下面的示例演示如何使用<xref:System.DateTime.AddYears%2A>方法替换<xref:System.DateTime>闰年某一天表示的值。 它之前十五年和 15 年数，请按照显示的日期 2000 年 2 月 29 日。  
  
 [!code-csharp[System.DateTime.AddYears#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.addyears/cs/addyears1.cs#1)]
 [!code-vb[System.DateTime.AddYears#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.addyears/vb/addyears1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> 或生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (t1 As DateTime, t2 As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(DateTime t1, DateTime t2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">要比较的第一个对象。</param>
        <param name="t2">要比较的第二个对象。</param>
        <summary>对两个 <see cref="T:System.DateTime" /> 的实例进行比较，并返回一个指示第一个实例是早于、等于还是晚于第二个实例的整数。</summary>
        <returns>有符号数字，指示 <paramref name="t1" /> 和 <paramref name="t2" /> 的相对值。  
  
 <list type="table"><listheader><term> 值类型  
  
 </term><description> 条件  
  
 </description></listheader><item><term> 小于零  
  
 </term><description><paramref name="t1" /> 早于 <paramref name="t2" />。  
  
 </description></item><item><term> 零  
  
 </term><description><paramref name="t1" /> 与 <paramref name="t2" /> 相同。  
  
 </description></item><item><term> 大于零  
  
 </term><description><paramref name="t1" /> 晚于 <paramref name="t2" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定之间的关系`t1`到`t2`、<xref:System.DateTime.Compare%2A>方法进行比较<xref:System.DateTime.Ticks%2A>属性`t1`和`t2`，但将忽略其<xref:System.DateTime.Kind%2A>属性。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Compare%2A>方法。  
  
 [!code-csharp[System.DateTime.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.compare/cs/compare1.cs#1)]
 [!code-vb[System.DateTime.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.compare/vb/compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例的值与指定的 <see cref="T:System.DateTime" /> 值相比较，并指示此实例是早于、等于还是晚于指定的 <see cref="T:System.DateTime" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 两个重载的<xref:System.DateTime.CompareTo%2A>方法返回一个指示此实例的相对值的带符号的数字和`value`自变量下, 表中所示。  
  
|“值”|描述|  
|-----------|-----------------|  
|小于零|此实例早于 `value`。|  
|零|此实例与 `value` 相同。|  
|大于零|此实例晚于 `value`。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.CompareTo(System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(DateTime value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">要与当前类型进行比较的对象。</param>
        <summary>将此实例的值与指定的 <see cref="T:System.DateTime" /> 值相比较，并返回一个整数，该整数指示此实例是早于、等于还是晚于指定的 <see cref="T:System.DateTime" /> 值。</summary>
        <returns>有符号数字，指示此实例和 <paramref name="value" /> 参数的相对值。  
  
 <list type="table"><listheader><term> 值  
  
 </term><description> 描述  
  
 </description></listheader><item><term> 小于零  
  
 </term><description> 此实例早于 <paramref name="value" />。  
  
 </description></item><item><term> 零  
  
 </term><description> 此实例等于 <paramref name="value" />。  
  
 </description></item><item><term> 大于零  
  
 </term><description> 此实例晚于 <paramref name="value" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定当前实例的关系`value`、<xref:System.DateTime.CompareTo%2A>方法进行比较<xref:System.DateTime.Ticks%2A>的当前实例的属性和`value`，但将忽略其<xref:System.DateTime.Kind%2A>属性。  然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 你可以执行此操作通过比较的值及其<xref:System.DateTime.Kind%2A>属性。  
  
 此方法实现<xref:System.IComparable%601?displayProperty=nameWithType>接口，并且执行效果略好于<xref:System.DateTime.CompareTo%28System.Object%29?displayProperty=nameWithType>方法重载，因为它没有要转换`value`对对象的参数。  
  
   
  
## Examples  
 下面的示例实例化三个<xref:System.DateTime>对象，一个表示今天的日期，另一个，它表示日期的一年以前，和第三个，表示日期在将来一年。 然后，它调用<xref:System.DateTime.CompareTo%28System.DateTime%29>方法，并显示比较结果。  
  
 [!code-csharp[DateTime.CompareTo.2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.CompareTo.2/CS/CompareTo_CS1_24564.cs#1)]
 [!code-vb[DateTime.CompareTo.2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.CompareTo.2/VB/CompareTo_VB1_24564.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要比较的装箱对象，或 <see langword="null" />。</param>
        <summary>将此实例的值与包含指定的 <see cref="T:System.DateTime" /> 值的指定对象相比较，并返回一个整数，该整数指示此实例是早于、等于还是晚于指定的 <see cref="T:System.DateTime" /> 值。</summary>
        <returns>一个带符号数字，指示此实例和 <paramref name="value" /> 的相对值。  
  
 <list type="table"><listheader><term> 值  
  
 </term><description> 描述  
  
 </description></listheader><item><term> 小于零  
  
 </term><description> 此实例早于 <paramref name="value" />。  
  
 </description></item><item><term> 零  
  
 </term><description> 此实例等于 <paramref name="value" />。  
  
 </description></item><item><term> 大于零  
  
 </term><description> 此实例晚于 <paramref name="value" />，或 <paramref name="value" /> 为 <see langword="null" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定当前实例的关系`value`、<xref:System.DateTime.CompareTo%2A>方法进行比较<xref:System.DateTime.Ticks%2A>的当前实例的属性和`value`，但将忽略其<xref:System.DateTime.Kind%2A>属性。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 你可以执行此操作通过比较的值及其<xref:System.DateTime.Kind%2A>属性。  
  
 任何实例<xref:System.DateTime>，无论其值被视为大于`null`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.CompareTo%2A>方法。  
  
 [!code-cpp[DateTime.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.CompareTo/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.CompareTo/CS/class1.cs#1)]
 [!code-vb[DateTime.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.CompareTo/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> 不是 <see cref="T:System.DateTime" />。</exception>
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Date" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例的日期部分。</summary>
        <value>一个新对象，其日期与此实例相同，时间值设置为午夜 12:00:00 (00:00:00)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.DateTime.Kind%2A>属性返回的<xref:System.DateTime>值均与当前实例相同。  
  
 因为<xref:System.DateTime>类型表示两个日期和时间在单个类型很重要，避免错误解释返回日期<xref:System.DateTime.Date%2A>属性作为日期和时间。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.Date%2A>属性提取的日期部分<xref:System.DateTime>其时间组成部分设置为零的值 (或 0:00:00 或午夜)。 它还阐释了，具体取决于显示时使用的格式字符串<xref:System.DateTime>值，时间组件可以继续出现在格式化输出。  
  
 [!code-cpp[System.DateTime.Date#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Date/cpp/date1.cpp#1)]
 [!code-csharp[System.DateTime.Date#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Date/cs/Date1.cs#1)]
 [!code-vb[System.DateTime.Date#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Date/vb/Date1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Day">
      <MemberSignature Language="C#" Value="public int Day { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Day" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Day" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Day As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Day { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示的日期为该月中的第几天。</summary>
        <value>日组成部分，表示为 1 和 31 之间的一个值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Day%2A>属性始终返回每月天数在公历日历中，即使当前<xref:System.DateTime>值已使用其他日历实例化，或如果当前线程区域性的默认日历不为公历。 若要检索特定日期使用某些其他日历月的天，调用该日历<xref:System.Globalization.Calendar.GetDayOfMonth%2A?displayProperty=nameWithType>方法。 下面的示例使用这两个<xref:System.DateTime.Day%2A>属性和<xref:System.Globalization.HijriCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>方法来检索其中的每月的某<xref:System.DateTime>使用回历实例化的值。  
  
 [!code-csharp[System.DateTime.Day#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Day/cs/Day1.cs#1)]
 [!code-vb[System.DateTime.Day#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Day/vb/Day1.vb#1)]  
  
 同样，下面的示例使用这两个<xref:System.DateTime.Day%2A>属性和<xref:System.Globalization.HijriCalendar.GetDayOfMonth%2A?displayProperty=nameWithType>方法来检索当前线程区域性时 AR-SA，使用回历作为其默认日历月的天。  
  
 [!code-csharp[System.DateTime.Day#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Day/cs/Day2.cs#2)]
 [!code-vb[System.DateTime.Day#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Day/vb/Day2.vb#2)]  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Day%2A>属性。  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DayOfWeek">
      <MemberSignature Language="C#" Value="public DayOfWeek DayOfWeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DayOfWeek DayOfWeek" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.DayOfWeek" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DayOfWeek As DayOfWeek" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DayOfWeek DayOfWeek { DayOfWeek get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DayOfWeek</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示的日期是星期几。</summary>
        <value>一个枚举常量，指示此 <see cref="T:System.DateTime" /> 值是星期几。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的常量的值<xref:System.DayOfWeek>枚举的范围从<xref:System.DayOfWeek.Sunday?displayProperty=nameWithType>到<xref:System.DayOfWeek.Saturday?displayProperty=nameWithType>。 如果强制转换为一个整数，其值的范围是从零 (指示<xref:System.DayOfWeek.Sunday?displayProperty=nameWithType>) 为 6 个 (指示<xref:System.DayOfWeek.Saturday?displayProperty=nameWithType>)。  
  
 <xref:System.DateTime.DayOfWeek%2A>属性返回的枚举的常数; 它不会反映系统的区域和语言设置。 若要检索表示特定日期的本地化的星期几名称的字符串，调用的重载之一<xref:System.DateTime.ToString%2A>包含方法中，`format`参数并将其传递是`ddd`或`dddd`自定义格式字符串。 有关详细信息，请参阅[如何： 从特定日期中提取日期是星期几](~/docs/standard/base-types/how-to-extract-the-day-of-the-week-from-a-specific-date.md)。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.DayOfWeek%2A>属性和<xref:System.DayOfWeek?displayProperty=nameWithType>枚举。  
  
 [!code-cpp[DateTime.DayOfWeek#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.DayOfWeek/CPP/dow.cpp#1)]
 [!code-csharp[DateTime.DayOfWeek#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.DayOfWeek/CS/dow.cs#1)]
 [!code-vb[DateTime.DayOfWeek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.DayOfWeek/VB/dow.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTime.Ticks" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="DayOfYear">
      <MemberSignature Language="C#" Value="public int DayOfYear { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DayOfYear" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.DayOfYear" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DayOfYear As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DayOfYear { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示的日期是该年中的第几天。</summary>
        <value>该年中的第几天，表示为 1 和 366 之间的一个值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.DayOfYear%2A>属性将闰年考虑在内时它计算每年的日期。 属性值始终反映在公历日历中，而不考虑当前线程区域性的当前日历年的某一天。 若要检索不同日历中每年的日期，调用<xref:System.Globalization.Calendar.GetDayOfYear%2A?displayProperty=nameWithType>该日历的方法。  
  
   
  
## Examples  
 下面的示例在公历日历显示年内 2010年 2020 年 12 月 31 日的某天。 请注意，该示例演示 12 月 31 日是闰年中每年的第 366 天。  
  
 [!code-csharp[System.DateTime.DayOfYear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.dayofyear/cs/dayofyear2.cs#1)]
 [!code-vb[System.DateTime.DayOfYear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.dayofyear/vb/dayofyear2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Globalization.Calendar.GetDayOfYear(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="DaysInMonth">
      <MemberSignature Language="C#" Value="public static int DaysInMonth (int year, int month);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 DaysInMonth(int32 year, int32 month) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.DaysInMonth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DaysInMonth (year As Integer, month As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int DaysInMonth(int year, int month);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">年。</param>
        <param name="month">月（介于 1 到 12 之间的一个数字）。</param>
        <summary>返回指定年和月中的天数。</summary>
        <returns>指定 <paramref name="month" /> 中 <paramref name="year" /> 中的天数。  
  
 例如，如果 <paramref name="month" /> 等于 2（表示二月），则返回值为 28 或 29，具体取决于 <paramref name="year" /> 是否为闰年。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.DaysInMonth%2A>方法总是将解释`month`和`year`作为在月份和年份的公历日历日历即使公历日历不是当前区域性的当前日历。 若要获取在特定日历的指定月份的天数，调用该日历的<xref:System.Globalization.Calendar.GetDaysInMonth%2A>方法。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.DateTime.DaysInMonth%2A>方法来确定 2001 年 7 月，年 2 月的最大天数 1998 年 （非-闰年） 和 1996 年 2 月 （闰年）。  
  
 [!code-cpp[DateTime.DaysInMonth#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.DaysInMonth/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.DaysInMonth#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.DaysInMonth/CS/class1.cs#1)]
 [!code-vb[DateTime.DaysInMonth#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.DaysInMonth/VB/class1.vb#1)]  
  
 下面的示例显示每个月内整数数组中指定的年份的天数。  
  
 [!code-csharp[System.DateTime.DaysInMonth#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.daysinmonth/cs/daysinmonth3.cs#1)]
 [!code-vb[System.DateTime.DaysInMonth#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.daysinmonth/vb/daysinmonth3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="month" /> 小于 1 或大于 12。  
  
 或  
  
 <paramref name="year" /> 小于 1 或大于 9999。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个值，该值指示两个 <see cref="T:System.DateTime" /> 对象，或者一个 <see cref="T:System.DateTime" /> 实例和另一个对象或 <see cref="T:System.DateTime" /> 是否具有相同的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Equals(System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(DateTime value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">要与此实例进行比较的对象。</param>
        <summary>返回一个值，该值指示此实例的值是否等于指定 <see cref="T:System.DateTime" /> 实例的值。</summary>
        <returns>
          如果 <paramref name="value" /> 参数等于此实例的值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前实例和`value`相等，如果其<xref:System.DateTime.Ticks%2A>属性值是否相等。 其<xref:System.DateTime.Kind%2A>相等性测试中未考虑属性值。  
  
 此方法实现<xref:System.IEquatable%601?displayProperty=nameWithType>接口，并且执行效果略好于<xref:System.DateTime.Equals%2A>方法因为`value`参数没有要转换为对象。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Equals%2A>方法。  
  
 [!code-csharp[System.DateTime.Equals-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/cs/sample.cs#1)]
 [!code-vb[System.DateTime.Equals-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Equals(System.Object)" />
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要与此实例进行比较的对象。</param>
        <summary>返回一个值，该值指示此实例是否等于指定的对象。</summary>
        <returns>
          如果 <see langword="true" /> 是 <paramref name="value" /> 的实例并且等于此实例的值，则为 <see cref="T:System.DateTime" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前实例和`value`相等，如果其<xref:System.DateTime.Ticks%2A>属性值是否相等。 其<xref:System.DateTime.Kind%2A>相等性测试中未考虑属性值。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Equals%2A>方法。  
  
 [!code-csharp[System.DateTime.Equals-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/cs/sample.cs#1)]
 [!code-vb[System.DateTime.Equals-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Equals-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Equals(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(DateTime t1, DateTime t2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">要比较的第一个对象。</param>
        <param name="t2">要比较的第二个对象。</param>
        <summary>返回一个值，该值指示的两个 <see cref="T:System.DateTime" /> 实例是否具有同一个日期和时间值。</summary>
        <returns>
          如果两个值相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `t1` 和`t2`相等，如果其<xref:System.DateTime.Ticks%2A>属性值是否相等。 其<xref:System.DateTime.Kind%2A>相等性测试中未考虑属性值。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Equals%2A>方法。  
  
 [!code-cpp[DateTime.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Equals/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Equals/CS/class1.cs#1)]
 [!code-vb[DateTime.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Equals/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.DateTime.Compare(System.DateTime,System.DateTime)" />
        <altmember cref="M:System.DateTime.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FromBinary">
      <MemberSignature Language="C#" Value="public static DateTime FromBinary (long dateData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromBinary(int64 dateData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromBinary(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromBinary (dateData As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromBinary(long dateData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateData" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="dateData">64 位带符号整数，它对 2 位字段的 <see cref="P:System.DateTime.Kind" /> 属性以及 62 位字段的 <see cref="P:System.DateTime.Ticks" /> 属性进行了编码。</param>
        <summary>反序列化一个 64 位二进制值，并重新创建序列化的 <see cref="T:System.DateTime" /> 初始对象。</summary>
        <returns>一个对象，它等效于由 <see cref="T:System.DateTime" /> 方法序列化的 <see cref="M:System.DateTime.ToBinary" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.DateTime.ToBinary%2A>方法将转换的当前值<xref:System.DateTime>为二进制值的对象。 随后，使用的二进制值和<xref:System.DateTime.FromBinary%2A>方法来重新创建原始<xref:System.DateTime>对象。  
  
> [!IMPORTANT]
>  在某些情况下，<xref:System.DateTime>返回值<xref:System.DateTime.FromBinary%2A>方法不是与原始<xref:System.DateTime>值提供给<xref:System.DateTime.ToBinary%2A>方法。 有关详细信息，请参阅下一部分中，"本地时间调整"。  
  
## <a name="local-time-adjustment"></a>本地时间调整  
 本地时间，这是将其调整为本地时区协调世界时，由<xref:System.DateTime>结构，它的<xref:System.DateTime.Kind%2A>属性具有值<xref:System.DateTimeKind.Local>。 还原本地时<xref:System.DateTime>从由生成的二进制表示的值<xref:System.DateTime.ToBinary%2A>方法，<xref:System.DateTime.FromBinary%2A>方法可能会调整重新创建的值，以便不等于原始值。 在下列条件下，可能会出现这种情况：  
  
-   如果本地<xref:System.DateTime>对象序列中由一个时区<xref:System.DateTime.ToBinary%2A>方法，然后通过不同的时区中反序列化和<xref:System.DateTime.FromBinary%2A>方法时，表示所生成的本地时间<xref:System.DateTime>自动调整对象为第二个时区。  
  
     例如，考虑<xref:System.DateTime>表示下午 3 点的本地时间的对象 在美国太平洋时区中执行的应用程序太平洋时区使用<xref:System.DateTime.ToBinary%2A>方法以将其转换<xref:System.DateTime>为二进制值的对象。 在美国太平洋时区中执行的另一个应用程序然后使用东部标准时间时区<xref:System.DateTime.FromBinary%2A>方法将二进制值转换为一个新<xref:System.DateTime>对象。 新值<xref:System.DateTime>对象是 6 P.M.，表示作为原始的下午 3 的时间相同的点 值，但将会调整为东部时区中的本地时间。  
  
-   如果的二进制表示形式本地<xref:System.DateTime>值表示系统上的本地时区的时间无效<xref:System.DateTime.FromBinary%2A>是调用，该时间调整以使它有效。  
  
     例如，从标准时间转换为夏时制发生在美国太平洋时区中 2010 年 3 月 14 日凌晨 2:00，时间前进一小时，成为凌晨 3:00。 此时间间隔是无效时间，即，该时区中不存在的时间间隔。 下面的示例演示，当范围内的时间此范围将被转换为二进制值通过<xref:System.DateTime.ToBinary%2A>方法，然后通过还原<xref:System.DateTime.FromBinary%2A>方法，原始值进行调整，以成为有效的时间。 你可以确定是否一个特定日期和时间值可能会遭受修改将其传递到<xref:System.TimeZoneInfo.IsInvalidTime%2A?displayProperty=nameWithType>方法，与示例演示。  
  
     [!code-csharp[System.DateTime.FromBinary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.frombinary/cs/frombinary1.cs#1)]
     [!code-vb[System.DateTime.FromBinary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.frombinary/vb/frombinary1.vb#1)]  
  
## <a name="version-considerations"></a>版本注意事项  
 从.NET Framework 2.0 版中，开始<xref:System.DateTime>结构包含的私有类型字段，该值指示是否指定的时间为本地时间、 协调世界时 (UTC) 还是既不，连接到专用的计时周期字段，其中包含指定的日期和时间的 100 毫微秒计时周期数。 可通过访问的刻度数<xref:System.DateTime.Ticks%2A>属性和 theKind 字段可通过访问<xref:System.DateTime.Kind%2A>属性。  
  
 在.NET Framework 2.0 中，如果你序列化之前<xref:System.DateTime>对象手动而不是使用序列化接口如<xref:System.Runtime.Serialization.ISerializable?displayProperty=nameWithType>，需要进行序列化仅中的计时周期数据<xref:System.DateTime>。 从.NET Framework 2.0 开始，你还必须序列化类型的数据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="dateData" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="M:System.DateTime.ToBinary" />
      </Docs>
    </Member>
    <Member MemberName="FromFileTime">
      <MemberSignature Language="C#" Value="public static DateTime FromFileTime (long fileTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromFileTime(int64 fileTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromFileTime(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromFileTime (fileTime As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromFileTime(long fileTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileTime" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileTime">以计时周期表示的 Windows 文件时间。</param>
        <summary>将指定的 Windows 文件时间转换为等效的本地时间。</summary>
        <returns>一个表示本地时间的对象，等效于由 <paramref name="fileTime" /> 参数表示的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 文件时间是 64 位值，表示第午夜 12:00 到公元 1601 年 1 月 1 日以来经过的 100 毫微秒隔数 (C.E.)协调世界时 (UTC)。 Windows 使用的文件时间应用程序创建、 访问，或将写入文件时进行记录。  
  
 `fileTime`参数指定以 100 毫微秒计时周期表示的文件时间。  
  
 从.NET Framework 2.0 版开始，则返回值是<xref:System.DateTime>其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.FromFileTime%2A>方法。  
  
 [!code-cpp[DateTime.FromFileTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.FromFileTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.FromFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.FromFileTime/CS/class1.cs#1)]
 [!code-vb[DateTime.FromFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.FromFileTime/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="fileTime" /> 小于 0 或表示大于 <see cref="F:System.DateTime.MaxValue" /> 的时间。</exception>
        <block subset="none" type="usage">
          <para>通常，<see cref="M:System.DateTime.FromFileTime(System.Int64)" />方法还原<see cref="T:System.DateTime" />保存的值<see cref="M:System.DateTime.ToFileTime" />方法。 但是，在以下情况下可能与不同的两个值：  
  
-   如果序列化和反序列化<see cref="T:System.DateTime" />值出现在不同时区。 例如，如果<see cref="T:System.DateTime" />时间为下午 12:30 的值 在美国美国东部时间区域的序列化，并在美国然后反序列化太平洋时区，中午 12:30 的原始值 调整到上午 9:30 以反映两个时区之间的差异。  
  
-   如果<see cref="T:System.DateTime" />序列化的值表示本地时区的时间无效。 在这种情况下，<see cref="M:System.DateTime.ToFileTime" />方法调整还原<see cref="T:System.DateTime" />值，使其本地时区表示有效的时间。  
  
     例如，从标准时间转换为夏时制发生在美国在 2010 年 3 月 14 日凌晨 2:00，时间前进一小时，上午 3:00 到太平洋时区 此时间间隔是无效时间，即，该时区中不存在的时间间隔。 下面的示例演示，当范围内的时间此范围将被转换为长整型值通过<see cref="M:System.DateTime.ToFileTime" />方法，然后通过还原<see cref="M:System.DateTime.FromFileTime(System.Int64)" />方法，原始值进行调整，以成为有效的时间。 你可以确定是否一个特定日期和时间值可能会遭受修改将其传递到<see cref="M:System.TimeZoneInfo.IsInvalidTime(System.DateTime)" />方法，与示例演示。  
  
     [!code-csharp[System.DateTime.FromFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.fromfiletime/cs/fromfiletime1.cs#1)]
     [!code-vb[System.DateTime.FromFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.fromfiletime/vb/fromfiletime1.vb#1)]</para>
        </block>
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="FromFileTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime FromFileTimeUtc (long fileTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromFileTimeUtc(int64 fileTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromFileTimeUtc(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromFileTimeUtc (fileTime As Long) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromFileTimeUtc(long fileTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileTime" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileTime">以计时周期表示的 Windows 文件时间。</param>
        <summary>将指定的 Windows 文件时间转换为等效的 UTC 时间。</summary>
        <returns>一个表示 UTC 时间的对象，等效于由 <paramref name="fileTime" /> 参数表示的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 文件时间是 64 位值，表示第午夜 12:00 到公元 1601 年 1 月 1 日以来经过的 100 毫微秒隔数 (C.E.)协调世界时 (UTC)。 Windows 使用的文件时间应用程序创建、 访问，或将写入文件时进行记录。  
  
 `fileTime`参数指定以 100 毫微秒计时周期表示的文件时间。  
  
 从.NET Framework 2.0 版开始，则返回值是<xref:System.DateTime>其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Utc>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="fileTime" /> 小于 0 或表示大于 <see cref="F:System.DateTime.MaxValue" /> 的时间。</exception>
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
        <altmember cref="M:System.DateTime.FromFileTime(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FromOADate">
      <MemberSignature Language="C#" Value="public static DateTime FromOADate (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FromOADate(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.FromOADate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromOADate (d As Double) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FromOADate(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">OLE 自动化日期值。</param>
        <summary>返回与指定的 OLE 自动化日期等效的 <see cref="T:System.DateTime" />。</summary>
        <returns>一个对象，它表示与 <paramref name="d" /> 相同的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `d`参数是的双精度浮点数，它将日期表示的基日期，午夜，30 1899 年 12 月之前或之后的天数。 符号和整数部分`d`将日期编码为 30 1899 年 12 月，正负日偏移量和绝对值的数值的小数部分的`d`将编码为从午夜天的偏移量的一小部分的一天的时间。 `d` 必须是负 657435.0 到正 2958465.99999999 之间的值。  
  
 请注意，由于日期进行编码的方法，有两种表示当天 30 1899 年 12 月的任何时间。 例如，-0.5 和 0.5 都意味着中午 1899 年 12 月 30，因为天的偏移量加或减基零天仍然是基的日期，并且从午夜的半天位移中午。  
  
 请参阅<xref:System.DateTime.ToOADate%2A>的 OLE 自动化的详细信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">日期不是有效的 OLE 自动化日期值。</exception>
        <altmember cref="M:System.DateTime.ToOADate" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDateTimeFormats">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例的值转换为标准日期和时间格式说明符支持的所有字符串表示形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  不应假定多个调用<xref:System.DateTime.GetDateTimeFormats%2A>重载将返回相同的数据。 具体取决于特定的重载中，如果当前区域性更改用户重写单个的区域性设置，或者系统的区域性数据进行更新，则可以更改此方法返回的数据。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此实例的值转换为标准日期和时间格式说明符支持的所有字符串表示形式。</summary>
        <returns>字符串数组，其中每个元素都表示此实例的以标准日期和时间格式说明符之一进行格式设置的一个值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的字符串数组<xref:System.DateTime.GetDateTimeFormats?displayProperty=nameWithType>方法相当于组合到单独的调用返回的字符串数组<xref:System.DateTime.GetDateTimeFormats%28System.Char%29?displayProperty=nameWithType>使用"d"、"D"、"f"、"F"、"g"、"G"、"m"、"o"、"r"、"s"、"t"、"T"、"u"、"U"和"y"标准格式字符串的方法。 有关标准格式说明符的详细信息，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)。  
  
 返回值的每个元素都使用来自当前区域性的信息。 有关当前区域性的区域性特定格式设置信息的详细信息，请参阅<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>。  
  
> [!IMPORTANT]
>  由于此方法使用区分区域性的数据，你不应假定对方法的多个调用将返回相同的数据。 如果当前区域性更改用户重写单个的区域性设置，或者系统的区域性数据进行更新，则可以更改此方法返回的数据。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.GetDateTimeFormats?displayProperty=nameWithType>方法。 它显示的字符串表示形式在计算机的当前区域性，在这种情况下为 EN-US 中使用的所有可能的标准日期和时间格式的日期。  
  
 [!code-cpp[DateTime.GetDateTimeFormats#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.GetDateTimeFormats#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#1)]
 [!code-vb[DateTime.GetDateTimeFormats#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#1)]  
  
 该示例显示下面的输出：  
  
```  
7/28/2009  
7/28/09  
07/28/09  
07/28/2009  
09/07/28  
2009-07-28  
28-Jul-09  
Tuesday, July 28, 2009  
July 28, 2009  
Tuesday, 28 July, 2009  
28 July, 2009  
Tuesday, July 28, 2009 5:23 AM  
Tuesday, July 28, 2009 05:23 AM  
Tuesday, July 28, 2009 5:23  
Tuesday, July 28, 2009 05:23  
July 28, 2009 5:23 AM  
July 28, 2009 05:23 AM  
July 28, 2009 5:23  
July 28, 2009 05:23  
Tuesday, 28 July, 2009 5:23 AM  
Tuesday, 28 July, 2009 05:23 AM  
Tuesday, 28 July, 2009 5:23  
Tuesday, 28 July, 2009 05:23  
28 July, 2009 5:23 AM  
28 July, 2009 05:23 AM  
28 July, 2009 5:23  
28 July, 2009 05:23  
Tuesday, July 28, 2009 5:23:15 AM  
Tuesday, July 28, 2009 05:23:15 AM  
Tuesday, July 28, 2009 5:23:15  
Tuesday, July 28, 2009 05:23:15  
July 28, 2009 5:23:15 AM  
July 28, 2009 05:23:15 AM  
July 28, 2009 5:23:15  
July 28, 2009 05:23:15  
Tuesday, 28 July, 2009 5:23:15 AM  
Tuesday, 28 July, 2009 05:23:15 AM  
Tuesday, 28 July, 2009 5:23:15  
Tuesday, 28 July, 2009 05:23:15  
28 July, 2009 5:23:15 AM  
28 July, 2009 05:23:15 AM  
28 July, 2009 5:23:15  
28 July, 2009 05:23:15  
7/28/2009 5:23 AM  
7/28/2009 05:23 AM  
7/28/2009 5:23  
7/28/2009 05:23  
7/28/09 5:23 AM  
7/28/09 05:23 AM  
7/28/09 5:23  
7/28/09 05:23  
07/28/09 5:23 AM  
07/28/09 05:23 AM  
07/28/09 5:23  
07/28/09 05:23  
07/28/2009 5:23 AM  
07/28/2009 05:23 AM  
07/28/2009 5:23  
07/28/2009 05:23  
09/07/28 5:23 AM  
09/07/28 05:23 AM  
09/07/28 5:23  
09/07/28 05:23  
2009-07-28 5:23 AM  
2009-07-28 05:23 AM  
2009-07-28 5:23  
2009-07-28 05:23  
28-Jul-09 5:23 AM  
28-Jul-09 05:23 AM  
28-Jul-09 5:23  
28-Jul-09 05:23  
7/28/2009 5:23:15 AM  
7/28/2009 05:23:15 AM  
7/28/2009 5:23:15  
7/28/2009 05:23:15  
7/28/09 5:23:15 AM  
7/28/09 05:23:15 AM  
7/28/09 5:23:15  
7/28/09 05:23:15  
07/28/09 5:23:15 AM  
07/28/09 05:23:15 AM  
07/28/09 5:23:15  
07/28/09 05:23:15  
07/28/2009 5:23:15 AM  
07/28/2009 05:23:15 AM  
07/28/2009 5:23:15  
07/28/2009 05:23:15  
09/07/28 5:23:15 AM  
09/07/28 05:23:15 AM  
09/07/28 5:23:15  
09/07/28 05:23:15  
2009-07-28 5:23:15 AM  
2009-07-28 05:23:15 AM  
2009-07-28 5:23:15  
2009-07-28 05:23:15  
28-Jul-09 5:23:15 AM  
28-Jul-09 05:23:15 AM  
28-Jul-09 5:23:15  
28-Jul-09 05:23:15  
July 28  
July 28  
2009-07-28T05:23:15.0160000  
2009-07-28T05:23:15.0160000  
Tue, 28 Jul 2009 05:23:15 GMT  
Tue, 28 Jul 2009 05:23:15 GMT  
2009-07-28T05:23:15  
5:23 AM  
05:23 AM  
5:23  
05:23  
5:23:15 AM  
05:23:15 AM  
5:23:15  
05:23:15  
2009-07-28 05:23:15Z  
Tuesday, July 28, 2009 12:23:15 PM  
Tuesday, July 28, 2009 12:23:15 PM  
Tuesday, July 28, 2009 12:23:15  
Tuesday, July 28, 2009 12:23:15  
July 28, 2009 12:23:15 PM  
July 28, 2009 12:23:15 PM  
July 28, 2009 12:23:15  
July 28, 2009 12:23:15  
Tuesday, 28 July, 2009 12:23:15 PM  
Tuesday, 28 July, 2009 12:23:15 PM  
Tuesday, 28 July, 2009 12:23:15  
Tuesday, 28 July, 2009 12:23:15  
28 July, 2009 12:23:15 PM  
28 July, 2009 12:23:15 PM  
28 July, 2009 12:23:15  
28 July, 2009 12:23:15  
July, 2009  
July, 2009  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats (char format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats(char format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats (format As Char) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats(char format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="format">标准日期和时间格式字符串。</param>
        <summary>将此实例的值转换为指定的标准日期和时间格式说明符支持的所有字符串表示形式。</summary>
        <returns>符串数组，其中每个元素都表示此实例的以 <paramref name="format" /> 标准日期和时间格式说明符之一进行格式设置的一个值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `format`参数可以是任何标准日期和时间格式说明符。 其中包括 d、 D、 f、 F、 g、 G、 M （或 m），O （或 o），R （或 r），s、 t、 T、 u、 U 和 Y （或 y）。 有关详细信息，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)。  
  
 返回值的每个元素都使用来自当前区域性的信息。 有关当前区域性的区域性特定格式设置信息的详细信息，请参阅<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>。  
  
> [!IMPORTANT]
>  由于此方法使用区分区域性的数据，你不应假定对方法的多个调用将返回相同的数据。 如果当前区域性更改用户重写单个的区域性设置，或者系统的区域性数据进行更新，则可以更改此方法返回的数据。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.GetDateTimeFormats%28System.Char%29>方法。 它显示的字符串表示形式使用当前区域性的长日期格式说明符 ("D") 的日期。  
  
 [!code-csharp[DateTime.GetDateTimeFormats#3](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#3)]
 [!code-vb[DateTime.GetDateTimeFormats#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 不是有效的标准日期和时间格式说明符。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats (provider As IFormatProvider) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个对象，它提供有关此实例的区域性特定格式设置信息。</param>
        <summary>将此实例的值转换为标准日期和时间格式说明符和指定的区域性特定格式信息支持的所有字符串表示形式。</summary>
        <returns>字符串数组，其中每个元素都表示此实例的以标准日期和时间格式说明符之一进行格式设置的一个值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的字符串数组<xref:System.DateTime.GetDateTimeFormats%28System.IFormatProvider%29?displayProperty=nameWithType>方法相当于组合到单独的调用返回的字符串数组<xref:System.DateTime.GetDateTimeFormats%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>使用"d"、"D"、"f"、"F"、"g"、"G"、"m"、"o"、"r"、"s"、"t"、"T"、"u"、"U"和"y"标准格式字符串的方法。 有关标准格式说明符的详细信息，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)。  
  
 返回值的每个元素格式都是使用提供的区域性特定信息`provider`。  
  
> [!IMPORTANT]
>  由于此方法使用区分区域性的数据，你不应假定对方法的多个调用会返回相同的数据，除非`provider`是<xref:System.Globalization.CultureInfo>表示固定区域性的对象。 如果用户重写的各种区域性设置，可以更改此方法返回的数据`provider`或如果系统的区域性数据进行更新，则`provider`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.GetDateTimeFormats%28System.IFormatProvider%29?displayProperty=nameWithType>方法。 它显示的字符串表示形式为 FR-FR 区域性使用的所有可能的标准日期和时间格式的日期。  
  
 [!code-cpp[DateTime.GetDateTimeFormats#2](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CPP/class1.cpp#2)]
 [!code-csharp[DateTime.GetDateTimeFormats#2](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#2)]
 [!code-vb[DateTime.GetDateTimeFormats#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#2)]  
  
 该示例显示下面的输出：  
  
```  
28/07/2009  
28/07/09  
28.07.09  
28-07-09  
2009-07-28  
mardi 28 juillet 2009  
28 juil. 09  
28 juillet 2009  
mardi 28 juillet 2009 05:23  
mardi 28 juillet 2009 5:23  
mardi 28 juillet 2009 05.23  
mardi 28 juillet 2009 05 h 23  
28 juil. 09 05:23  
28 juil. 09 5:23  
28 juil. 09 05.23  
28 juil. 09 05 h 23  
28 juillet 2009 05:23  
28 juillet 2009 5:23  
28 juillet 2009 05.23  
28 juillet 2009 05 h 23  
mardi 28 juillet 2009 05:23:15  
mardi 28 juillet 2009 5:23:15  
mardi 28 juillet 2009 05.23  
mardi 28 juillet 2009 05 h 23  
28 juil. 09 05:23:15  
28 juil. 09 5:23:15  
28 juil. 09 05.23  
28 juil. 09 05 h 23  
28 juillet 2009 05:23:15  
28 juillet 2009 5:23:15  
28 juillet 2009 05.23  
28 juillet 2009 05 h 23  
28/07/2009 05:23  
28/07/2009 5:23  
28/07/2009 05.23  
28/07/2009 05 h 23  
28/07/09 05:23  
28/07/09 5:23  
28/07/09 05.23  
28/07/09 05 h 23  
28.07.09 05:23  
28.07.09 5:23  
28.07.09 05.23  
28.07.09 05 h 23  
28-07-09 05:23  
28-07-09 5:23  
28-07-09 05.23  
28-07-09 05 h 23  
2009-07-28 05:23  
2009-07-28 5:23  
2009-07-28 05.23  
2009-07-28 05 h 23  
28/07/2009 05:23:15  
28/07/2009 5:23:15  
28/07/2009 05.23  
28/07/2009 05 h 23  
28/07/09 05:23:15  
28/07/09 5:23:15  
28/07/09 05.23  
28/07/09 05 h 23  
28.07.09 05:23:15  
28.07.09 5:23:15  
28.07.09 05.23  
28.07.09 05 h 23  
28-07-09 05:23:15  
28-07-09 5:23:15  
28-07-09 05.23  
28-07-09 05 h 23  
2009-07-28 05:23:15  
2009-07-28 5:23:15  
2009-07-28 05.23  
2009-07-28 05 h 23  
28 juillet  
28 juillet  
2009-07-28T05:23:15.0160000  
2009-07-28T05:23:15.0160000  
Tue, 28 Jul 2009 05:23:15 GMT  
Tue, 28 Jul 2009 05:23:15 GMT  
2009-07-28T05:23:15  
05:23  
5:23  
05.23  
05 h 23  
05:23:15  
5:23:15  
05.23  
05 h 23  
2009-07-28 05:23:15Z  
mardi 28 juillet 2009 12:23:15  
mardi 28 juillet 2009 12:23:15  
mardi 28 juillet 2009 12.23  
mardi 28 juillet 2009 12 h 23  
28 juil. 09 12:23:15  
28 juil. 09 12:23:15  
28 juil. 09 12.23  
28 juil. 09 12 h 23  
28 juillet 2009 12:23:15  
28 juillet 2009 12:23:15  
28 juillet 2009 12.23  
28 juillet 2009 12 h 23  
juillet 2009  
juillet 2009  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeFormats">
      <MemberSignature Language="C#" Value="public string[] GetDateTimeFormats (char format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDateTimeFormats(char format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetDateTimeFormats(System.Char,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeFormats (format As Char, provider As IFormatProvider) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDateTimeFormats(char format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.Char" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">标准和时间格式字符串。</param>
        <param name="provider">一个对象，它提供有关此实例的区域性特定格式设置信息。</param>
        <summary>将此实例的值转换为指定的标准日期和时间格式说明符和区域性特定格式信息支持的所有字符串表示形式。</summary>
        <returns>字符串数组，其中每个元素都表示此实例的以标准日期和时间格式说明符之一进行格式设置的一个值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该格式参数可以是任何标准日期和时间格式说明符。 其中包括 d、 D、 f、 F、 g、 G、 M （或 m），O （或 o），R （或 r），s、 t、 T、 u、 U 和 Y （或 y）。 有关详细信息，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)。  
  
 返回值的每个元素格式都是使用提供的区域性特定信息`provider`。  
  
> [!IMPORTANT]
>  由于此方法使用区分区域性的数据，你不应假定对方法的多个调用会返回相同的数据，除非`provider`是<xref:System.Globalization.CultureInfo>表示固定区域性的对象。 如果用户重写的各种区域性设置，可以更改此方法返回的数据`provider`或如果系统的区域性数据进行更新，则`provider`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.GetDateTimeFormats%28System.Char%2CSystem.IFormatProvider%29>方法。 它显示的字符串表示形式使用 FR-FR 区域性的短日期格式说明符 ("d") 的日期。  
  
 [!code-csharp[DateTime.GetDateTimeFormats#4](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.GetDateTimeFormats/CS/class1.cs#4)]
 [!code-vb[DateTime.GetDateTimeFormats#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.GetDateTimeFormats/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 不是有效的标准日期和时间格式说明符。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此实例的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回值类型 <see cref="T:System.TypeCode" /> 的 <see cref="T:System.DateTime" />。</summary>
        <returns>枚举常数 <see cref="F:System.TypeCode.DateTime" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hour">
      <MemberSignature Language="C#" Value="public int Hour { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Hour" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Hour" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Hour As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Hour { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示日期的小时部分。</summary>
        <value>小时组成部分，表示为 0 和 23 之间的一个值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.DateTime.Hour%2A>始终使用 24 小时制表示属性。 若要检索表示日期和时间采用 12 小时制的小时的字符串，调用<xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType>或<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法使用"h"自定义格式说明符。 例如:  
  
 [!code-csharp[System.DateTime.Hour#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Hour/cs/Hour1.cs#1)]
 [!code-vb[System.DateTime.Hour#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Hour/vb/Hour1.vb#1)]  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Hour%2A>属性。  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDaylightSavingTime">
      <MemberSignature Language="C#" Value="public bool IsDaylightSavingTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDaylightSavingTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.IsDaylightSavingTime" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDaylightSavingTime () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDaylightSavingTime();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示此 <see cref="T:System.DateTime" /> 实例是否在当前时区的夏时制范围内。</summary>
        <returns>
          如果 <see langword="true" /> 属性的值为 <see cref="P:System.DateTime.Kind" /> 或 <see cref="F:System.DateTimeKind.Local" />，并且 <see cref="F:System.DateTimeKind.Unspecified" /> 的此实例的值在当前时区的夏时制范围内，则为 <see cref="T:System.DateTime" />；如果 <see langword="false" /> 为 <see cref="P:System.DateTime.Kind" />，则为 <see cref="F:System.DateTimeKind.Utc" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可确定是否当前<xref:System.DateTime>值处于夏时制范围内的本地时区，即<xref:System.TimeZoneInfo.Local%2A?displayProperty=nameWithType>属性。 你可以确定是否时区支持夏令制检索的值的其<xref:System.TimeZoneInfo.SupportsDaylightSavingTime%2A?displayProperty=nameWithType>属性。 观察夏令时的时区，你可以确定通过检索到 / 从夏时制转换时<xref:System.TimeZoneInfo.AdjustmentRule?displayProperty=nameWithType>返回时区的数组<xref:System.TimeZoneInfo.GetAdjustmentRules%2A?displayProperty=nameWithType>属性。  
  
 如果当前<xref:System.DateTime>值表示本地时区不明确或时间无效，该方法返回`false`。  
  
 上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统，<xref:System.DateTime.IsDaylightSavingTime%2A>方法识别只将当前的调整规则时确定当前实例是否为夏时制。 因此，该方法可能无法准确报告的当前实例是否是当前的调整规则生效之前一段夏时制。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.TimeZoneInfo.IsDaylightSavingTime(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="IsLeapYear">
      <MemberSignature Language="C#" Value="public static bool IsLeapYear (int year);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLeapYear(int32 year) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.IsLeapYear(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLeapYear (year As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLeapYear(int year);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="year">四位数年份。</param>
        <summary>返回指定的年份是否为闰年的指示。</summary>
        <returns>
          如果 <see langword="true" /> 是闰年，则为 <paramref name="year" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `year` 指定为 4 位基 10 数字;例如，1996。  
  
 `year` 始终会解释为公历日历中每一年。 若要确定某个特定年度是否为闰年某些其他日历中，请调用该日历对象`IsLeapYear`方法。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.IsLeapYear%2A>方法来确定哪些之间 1994年和 2014 年是闰年。 该示例还说明了结果时<xref:System.DateTime.AddYears%2A>方法用于将每一年添加到闰日。  
  
 [!code-csharp[System.DateTime.IsLeapYear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.IsLeapYear/cs/IsLeapYear1.cs#1)]
 [!code-vb[System.DateTime.IsLeapYear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.IsLeapYear/vb/IsLeapYear1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> 小于 1 或大于 9999。</exception>
      </Docs>
    </Member>
    <Member MemberName="Kind">
      <MemberSignature Language="C#" Value="public DateTimeKind Kind { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTimeKind Kind" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Kind" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Kind As DateTimeKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTimeKind Kind { DateTimeKind get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeKind</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示由此实例表示的时间是基于本地时间、协调世界时 (UTC)，还是两者皆否。</summary>
        <value>用于指示当前时间表示的含义的枚举值之一。 默认值为 <see cref="F:System.DateTimeKind.Unspecified" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以显式设置<xref:System.DateTime.Kind%2A>属性的新<xref:System.DateTime>为特定值<xref:System.DateTimeKind>值通过调用<xref:System.DateTime.SpecifyKind%2A>方法。  
  
 <xref:System.DateTime.Kind%2A>属性允许<xref:System.DateTime>值以清楚地反映协调世界时 (UTC) 或本地时间。 与此相反，<xref:System.DateTimeOffset>结构可以明确地反映任何时区中的任何时间为单个点时间。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.SpecifyKind%2A>方法演示如何<xref:System.DateTime.Kind%2A>属性影响<xref:System.DateTime.ToLocalTime%2A>和<xref:System.DateTime.ToUniversalTime%2A>转换方法。  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.SpecifyKind(System.DateTime,System.DateTimeKind)" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public static readonly DateTime MaxValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTime MaxValue" />
      <MemberSignature Language="DocId" Value="F:System.DateTime.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxValue As DateTime " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTime MaxValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="T:System.DateTime" /> 的最大可能值。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此常量的值为等效于 23:59:59.9999999 UTC，年 12 月 31 日 9999 在公历日历中，00:00:00 UTC，10000 年 1 月 1 日之前的恰好一个 100 纳秒为刻度线。  
  
 如日历<xref:System.Globalization.ThaiBuddhistCalendar>，支持早于上部日期范围<xref:System.DateTime.MaxValue>。 在这些情况下，尝试访问<xref:System.DateTime.MaxValue>变量赋值或格式设置和分析操作中可以引发<xref:System.ArgumentOutOfRangeException>。 而不是检索的值的<xref:System.DateTime.MaxValue?displayProperty=nameWithType>，你可以检索由指定的区域性的最新的有效日期值的值<xref:System.Globalization.Calendar.MaxSupportedDateTime?displayProperty=nameWithType>属性。  
  
   
  
## Examples  
 下面的示例实例化<xref:System.DateTime>对象向其构造函数传递<xref:System.Int64>值，该值表示的计时周期数。 在调用构造函数之前, 示例可确保，此值是大于或等于`DateTime.MinValue.Ticks`且小于或等于`DateTime.MaxValue.Ticks`。 如果不是，它引发<xref:System.ArgumentOutOfRangeException>。  
  
 [!code-csharp[System.DateTime.MinValue#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.MinValue/cs/MinValue.cs#2)]
 [!code-vb[System.DateTime.MinValue#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.MinValue/vb/MinValue.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.DateTime.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="Millisecond">
      <MemberSignature Language="C#" Value="public int Millisecond { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Millisecond" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Millisecond" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Millisecond As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Millisecond { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示日期的毫秒部分。</summary>
        <value>毫秒组成部分，表示为 0 和 999 之间的一个值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以显示的字符串表示形式<xref:System.DateTime.Millisecond%2A>通过使用"fff"格式说明符的属性。 例如，下面的代码显示包含的日期和时间到控制台中的毫秒数的字符串。  
  
 [!code-csharp[System.DateTime.Millisecond#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Millisecond/cs/Millisecond.cs#1)]
 [!code-vb[System.DateTime.Millisecond#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Millisecond/vb/Millisecond.vb#1)]  
  
 此外可以通过使用"o"标准格式说明符来显示日期和时间值的其他组件一起的毫秒数部分。 例如:  
  
 [!code-csharp[System.DateTime.Millisecond#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Millisecond/cs/Millisecond.cs#2)]
 [!code-vb[System.DateTime.Millisecond#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Millisecond/vb/Millisecond.vb#2)]  
  
 但是，"o"格式说明符旨在用于显示比往返或存储不太<xref:System.DateTime>值。 你也可以通过使用自定义格式字符串，如以下示例所示显示以及日期和时间的其他组件的毫秒。  
  
 [!code-csharp[System.DateTime.Millisecond#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Millisecond/cs/Millisecond.cs#3)]
 [!code-vb[System.DateTime.Millisecond#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Millisecond/vb/Millisecond.vb#3)]  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Millisecond%2A>属性。  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Minute">
      <MemberSignature Language="C#" Value="public int Minute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Minute" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Minute" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Minute As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Minute { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示日期的分钟部分。</summary>
        <value>分钟组成部分，表示为 0 和 59 之间的一个值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示<xref:System.DateTime.Minute%2A>属性。  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public static readonly DateTime MinValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTime MinValue" />
      <MemberSignature Language="DocId" Value="F:System.DateTime.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinValue As DateTime " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTime MinValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="T:System.DateTime" /> 的最小可能值。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此常量的值等效于 00:00:00.0000000 UTC，1 月 1 日 0001，公历日历中。  
  
 <xref:System.DateTime.MinValue> 定义的日期和时间分配给未初始化<xref:System.DateTime>变量。 下面的示例阐释了这一点。  
  
 [!code-csharp[System.DateTime.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.MinValue/cs/MinValue.cs#1)]
 [!code-vb[System.DateTime.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.MinValue/vb/MinValue.vb#1)]  
  
 <xref:System.DateTime.MinValue>和<xref:System.DateTime.MaxValue>属性可以用于确保将其传递给之前值不受支持的范围内<xref:System.DateTime>构造函数。 示例部分中的代码阐释了这种用法。  
  
   
  
## Examples  
 下面的示例实例化<xref:System.DateTime>对象向其构造函数传递<xref:System.Int64>值，该值表示的计时周期数。 在调用构造函数之前, 示例可确保，此值是大于或等于`DateTime.MinValue.Ticks`且小于或等于`DateTime.MaxValue.Ticks`。 如果不是，它引发<xref:System.ArgumentOutOfRangeException>。  
  
 [!code-csharp[System.DateTime.MinValue#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.MinValue/cs/MinValue.cs#2)]
 [!code-vb[System.DateTime.MinValue#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.MinValue/vb/MinValue.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Month">
      <MemberSignature Language="C#" Value="public int Month { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Month" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Month" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Month As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Month { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示日期的月份部分。</summary>
        <value>月组成部分，表示为 1 和 12 之间的一个值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示<xref:System.DateTime.Month%2A>属性。  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Now">
      <MemberSignature Language="C#" Value="public static DateTime Now { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.DateTime Now" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Now" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Now As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property DateTime Now { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.DateTime" /> 对象，该对象设置为此计算机上的当前日期和时间，表示为本地时间。</summary>
        <value>其值为当前日期和时间的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Now%2A>属性返回<xref:System.DateTime>值，该值表示当前日期和本地计算机上的时间。 请注意，没有之间存在的差异<xref:System.DateTime>值，该值表示 0001 年 1 月 1 日午夜以来所经历的计时周期数和的字符串表示形式，<xref:System.DateTime>值，该值表示中的日期和时间值特定于区域性特定的格式。 有关格式设置的日期和时间值的信息，请参阅<xref:System.DateTime.ToString%2A>方法。 下面的示例显示在大量的区域性特定格式的短日期和时间字符串。  
  
 [!code-cpp[System.DateTime.Now#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.datetime.now/cpp/now1.cpp#2)]
 [!code-csharp[System.DateTime.Now#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.now/cs/now1.cs#2)]
 [!code-vb[System.DateTime.Now#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.now/vb/now1.vb#2)]  
  
 此属性的解决方法取决于系统计时器，具体取决于基础操作系统。 它往往是之间 0.5 和 15 毫秒。 因此，重复调用<xref:System.DateTime.Now%2A>在短时间间隔，例如在循环中的属性可能会返回相同的值。  
  
 <xref:System.DateTime.Now%2A>属性经常用来测量性能。 但是，由于其低的解决方法，不适合用作基准测试工具。 更好的替代方法是使用<xref:System.Diagnostics.Stopwatch>类。  
  
 从.NET Framework 2.0 版开始，则返回值是<xref:System.DateTime>其<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。  
  
> [!NOTE]
>  你还可以使用<xref:System.DateTimeOffset.Now%2A?displayProperty=nameWithType>要检索的当前日期和时间属性。 它允许明确地表示为单个点时间，从而在该时间值可移植跨计算机本地时间。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.Now%2A>和<xref:System.DateTime.UtcNow%2A>属性，以检索本地日期和时间的当前值和当前通用协调 (UTC) 日期和时间。 它然后使用大量的区域性的格式设置约定的值以及显示的字符串，其<xref:System.DateTime.Kind%2A>属性。  
  
 [!code-cpp[System.DateTime.Now#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.datetime.now/cpp/now2.cpp#3)]
 [!code-csharp[System.DateTime.Now#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.now/cs/now2.cs#3)]
 [!code-vb[System.DateTime.Now#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.now/vb/now2.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTimeOffset.Now" />
        <altmember cref="P:System.DateTime.UtcNow" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static DateTime operator + (DateTime d, TimeSpan t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTime op_Addition(valuetype System.DateTime d, valuetype System.TimeSpan t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Addition(System.DateTime,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (d As DateTime, t As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime operator +(DateTime d, TimeSpan t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.DateTime" />
        <Parameter Name="t" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="d">要添加的日期和时间值。</param>
        <param name="t">待添加的时间间隔。</param>
        <summary>将指定的时间间隔加到指定的日期和时间以生成新的日期和时间。</summary>
        <returns>一个对象，它是 <paramref name="d" /> 和 <paramref name="t" /> 值的和。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[此运算符的等效方法是 <xref:System.DateTime.Add%28System.TimeSpan%29?displayProperty=nameWithType>  
  
## Examples  
 下面的示例演示加法运算符。  
  
 [!code-cpp[DateTime Operators#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime Operators/CPP/class1.cpp#1)]
 [!code-csharp[DateTime Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime Operators/CS/class1.cs#1)]
 [!code-vb[DateTime Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime Operators/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="M:System.DateTime.Add(System.TimeSpan)" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="P:System.DateTime.Ticks" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (DateTime d1, DateTime d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.DateTime d1, valuetype System.DateTime d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Equality(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As DateTime, d2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(DateTime d1, DateTime d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.DateTime" />
        <Parameter Name="d2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="d1">要比较的第一个对象。</param>
        <param name="d2">要比较的第二个对象。</param>
        <summary>确定 <see cref="T:System.DateTime" /> 的两个指定的实例是否相等。</summary>
        <returns>
          如果 <paramref name="d1" /> 和 <paramref name="d2" /> 表示同一日期和时间，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_Equality%2A>运算符确定两个<xref:System.DateTime>值是否相等的通过比较其计时周期数。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 可以通过比较其 <xref:System.DateTime.Kind%2A> 属性的值来执行此操作。  
  
 此运算符的等效方法是 <xref:System.DateTime.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 下面的示例演示相等运算符。  
  
 [!code-cpp[DateTime Operators#2](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime Operators/CPP/class1.cpp#2)]
 [!code-csharp[DateTime Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime Operators/CS/class1.cs#2)]
 [!code-vb[DateTime Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime Operators/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Equals(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_GreaterThan(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(DateTime t1, DateTime t2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">要比较的第一个对象。</param>
        <param name="t2">要比较的第二个对象。</param>
        <summary>确定指定的 <see cref="T:System.DateTime" /> 是否晚于另一个指定的 <see cref="T:System.DateTime" />。</summary>
        <returns>
          如果 <see langword="true" /> 晚于 <paramref name="t1" />，则为 <paramref name="t2" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_GreaterThan%2A>运算符确定两个之间的关系<xref:System.DateTime>通过比较其计时周期数的值。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 可以通过比较其 <xref:System.DateTime.Kind%2A> 属性的值来执行此操作。  
  
 此运算符的等效方法是 <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_GreaterThanOrEqual(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(DateTime t1, DateTime t2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">要比较的第一个对象。</param>
        <param name="t2">要比较的第二个对象。</param>
        <summary>确定一个指定的 <see cref="T:System.DateTime" /> 表示的日期和时间等于还是晚于另一个指定的 <see cref="T:System.DateTime" />。</summary>
        <returns>
          如果 <paramref name="t1" /> 晚于或与 <paramref name="t2" /> 相同，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_GreaterThanOrEqual%2A>运算符确定两个之间的关系<xref:System.DateTime>通过比较其计时周期数的值。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 可以通过比较其 <xref:System.DateTime.Kind%2A> 属性的值来执行此操作。  
  
 此运算符的等效方法是 <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (DateTime d1, DateTime d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.DateTime d1, valuetype System.DateTime d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Inequality(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As DateTime, d2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(DateTime d1, DateTime d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.DateTime" />
        <Parameter Name="d2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="d1">要比较的第一个对象。</param>
        <param name="d2">要比较的第二个对象。</param>
        <summary>确定 <see cref="T:System.DateTime" /> 的两个指定的实例是否不等。</summary>
        <returns>
          如果 <see langword="true" /> 和 <paramref name="d1" /> 不表示同一日期和时间，则为 <paramref name="d2" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_Inequality%2A>运算符确定两个<xref:System.DateTime>值是否不相等通过比较其计时周期数。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 可以通过比较其 <xref:System.DateTime.Kind%2A> 属性的值来执行此操作。  
  
 此运算符的等效方法是 <xref:System.DateTime.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_LessThan(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(DateTime t1, DateTime t2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">要比较的第一个对象。</param>
        <param name="t2">要比较的第二个对象。</param>
        <summary>确定指定的 <see cref="T:System.DateTime" /> 是否早于另一个指定的 <see cref="T:System.DateTime" />。</summary>
        <returns>
          如果 <see langword="true" /> 早于 <paramref name="t1" />，则为 <paramref name="t2" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_LessThan%2A>运算符确定两个之间的关系<xref:System.DateTime>通过比较其计时周期数的值。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 可以通过比较其 <xref:System.DateTime.Kind%2A> 属性的值来执行此操作。  
  
 此运算符的等效方法是 <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (DateTime t1, DateTime t2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.DateTime t1, valuetype System.DateTime t2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_LessThanOrEqual(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (t1 As DateTime, t2 As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(DateTime t1, DateTime t2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t1" Type="System.DateTime" />
        <Parameter Name="t2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="t1">要比较的第一个对象。</param>
        <param name="t2">要比较的第二个对象。</param>
        <summary>确定一个指定的 <see cref="T:System.DateTime" /> 表示的日期和时间等于还是早于另一个指定的 <see cref="T:System.DateTime" />。</summary>
        <returns>
          如果 <paramref name="t1" /> 等于或早于 <paramref name="t2" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_LessThanOrEqual%2A>运算符确定两个之间的关系<xref:System.DateTime>通过比较其计时周期数的值。 然后再比较<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 可以通过比较其 <xref:System.DateTime.Kind%2A> 属性的值来执行此操作。  
  
 此运算符的等效方法是 <xref:System.DateTime.Compare%28System.DateTime%2CSystem.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.CompareTo(System.DateTime)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Subtraction">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从指定的 <see cref="T:System.DateTime" /> 减去指定的 <see cref="T:System.DateTime" /> 或 <see cref="T:System.TimeSpan" />。</summary>
        <altmember cref="M:System.DateTime.Subtract(System.DateTime)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static TimeSpan operator - (DateTime d1, DateTime d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.TimeSpan op_Subtraction(valuetype System.DateTime d1, valuetype System.DateTime d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Subtraction(System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (d1 As DateTime, d2 As DateTime) As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TimeSpan operator -(DateTime d1, DateTime d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.DateTime" />
        <Parameter Name="d2" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="d1">要从中减去的日期和时间值（被减数）。</param>
        <param name="d2">要减去的日期和时间值（减数）。</param>
        <summary>将指定的日期和时间与另一个指定的日期和时间相减，返回一个时间间隔。</summary>
        <returns>
          <paramref name="d1" /> 和 <paramref name="d2" /> 之间的时间间隔；即 <paramref name="d1" /> 减去 <paramref name="d2" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.op_Subtraction%28System.DateTime%2CSystem.DateTime%29>方法不考虑的值<xref:System.DateTime.Kind%2A>这两个属性<xref:System.DateTime>值时执行减法。 相减之前<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 否则，结果将包括时区之间的差异。  
  
> [!NOTE]
>  <xref:System.DateTimeOffset.op_Subtraction%28System.DateTimeOffset%2CSystem.DateTimeOffset%29?displayProperty=nameWithType>方法一定会考虑执行减法时的时区之间的差异。  
  
 此运算符的等效方法是 <xref:System.DateTime.Subtract%28System.DateTime%29?displayProperty=nameWithType>  
  
## Examples  
 下面的示例演示<xref:System.DateTime.Subtract%2A>方法和减法运算符。  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.Subtract(System.DateTime)" />
        <altmember cref="P:System.DateTime.Ticks" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static DateTime operator - (DateTime d, TimeSpan t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTime op_Subtraction(valuetype System.DateTime d, valuetype System.TimeSpan t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.op_Subtraction(System.DateTime,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (d As DateTime, t As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime operator -(DateTime d, TimeSpan t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.DateTime" />
        <Parameter Name="t" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="d">要从其中减去的日期和时间值。</param>
        <param name="t">待减去的时间间隔。</param>
        <summary>从指定的日期和时间减去指定的时间间隔，返回新的日期和时间。</summary>
        <returns>一个对象，其值为 <paramref name="d" /> 的值减去 <paramref name="t" /> 的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法中的刻度值减去`t`的刻度值`d`。  
  
 此运算符的等效方法是 <xref:System.DateTime.Subtract%28System.DateTime%29?displayProperty=nameWithType>  
  
## Examples  
 下面的示例演示<xref:System.DateTime.Subtract%2A>方法和减法运算符。  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">生成的 <see cref="T:System.DateTime" /> 小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="M:System.DateTime.Subtract(System.TimeSpan)" />
        <altmember cref="P:System.DateTime.Ticks" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将日期和时间的字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本节内容：  
  
 [请勿调用的方法？](#Tasks)   
 [要分析的字符串](#StringToParse)   
 [分析和区域性约定](#Culture)   
 [分析和样式元素](#Styles)   
 [返回值和 DateTime.Kind](#kind)
 
<a name="Tasks"></a>   
### <a name="which-method-do-i-call"></a>请勿调用的方法？  
  
|到|Call|  
|--------|----------|  
|通过使用当前区域性的约定分析日期和时间的字符串。|<xref:System.DateTime.Parse%28System.String%29> 重载|  
|通过使用特定区域性的约定分析日期和时间的字符串。|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> 重载 (请参阅[分析以及文化习俗](#Culture))|  
|分析 （如空白或没有空白） 的特殊的样式元素的日期和时间字符串。|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> 重载|  
|分析必须采用特定格式的日期和时间字符串。|<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> 或 <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType>|
|分析日期和时间字符串并执行转换为 UTC 或本地时间。|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> 重载|  
|分析而不处理异常的日期和时间的字符串。|<xref:System.DateTime.TryParse%2A?displayProperty=nameWithType> 方法|  
|还原 （往返） 创建的日期和时间值的格式设置操作。|"O"或"r"标准格式将字符串传递给<xref:System.DateTime.ToString%28System.String%29>方法，并且调用<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>重载 <xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>|  
|跨计算机 （和可能区域性） 的边界分析固定格式的日期和时间字符串。|<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> 或<xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType>方法|  
  
<a name="StringToParse"></a>   
### <a name="the-string-to-parse"></a>要分析的字符串  
 <xref:System.DateTime.Parse%2A>方法尝试将转换到的日期和时间值的字符串表示其<xref:System.DateTime>等效。 它尝试完全分析的输入的字符串，而不引发<xref:System.FormatException>异常。  
  
> [!IMPORTANT]
>  如果在分析操作失败由于无法识别的字符串格式，<xref:System.DateTime.Parse%2A>方法抛出异常<xref:System.FormatException>，而<xref:System.DateTime.TryParse%2A>方法返回`false`。 由于异常处理可能很昂贵，您应使用<xref:System.DateTime.Parse%2A>时应在分析操作成功，因为输入的源是受信任。 <xref:System.DateTime.TryParse%2A> 当分析失败可能时，特别是因为的输入的源不受信任，或你拥有的合理的默认值，用于替换无法成功分析的字符串，则更为可取。   

 要分析的字符串可以采用以下形式之一：  
  
-   具有日期和时间部分字符串。  
  
-   包含日期但不包含时间组成部分的字符串。 如果时间组件不存在，则该方法假定午夜 12:00。 如果的日期部分具有两位数年份，它将转换为基于年份<xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType>的当前区域性的当前日历或指定的区域性的当前日历 (如果你使用非 null 的重载`provider`自变量)。  
  
- 带有包括仅月份和年份的日期组件但不包含日期组成部分的字符串。 该方法假定该月的第一天。

- 带有包括仅月和日的日期组件，但没有年份部分的字符串。 该方法假定当前年份。

-   带有时间而不包含日期组成部分的字符串。 该方法假定当前日期，除非调用<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>重载并包括<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType>中`styles`自变量，在其中用例方法采用的 1 月 1 日的日期 0001。  

- 带有时间组件包含仅的小时和 AM/PM 指示符，与不包含日期组成部分的字符串。 该方法假定当前日期和时间的任何分钟，没有秒数。 你可以通过调用来更改此行为<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>重载并包括<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType>中`styles`自变量，在其中用例方法采用的 1 月 1 日的日期 0001。

-   包含时区信息且符合 ISO 8601 字符串。 在以下示例中，第一个的字符串表示协调世界时 (UTC)，第二个表示为七个小时的时区中的时间早于 UTC:  
  
    "2008-11-01T19:35:00.0000000Z"   
    "2008-11-01T19:35:00.0000000-07:00"  
  
-   一个字符串，包括格林威治标准时间指示符，并符合 RFC 1123 时间格式;例如：  
  
     "周六至，01 年 11 月 2008年 19:35:00 GMT"  
  
-   一个字符串，包含的日期和时间以及时区偏移量信息;例如：  
  
     "03/01/2009 05:42:00 -5:00"  

下面的示例通过使用当前区域性，在这种情况下即 EN-US 区域性的格式设置约定分析在每个这些格式的字符串：

[!code-csharp-interactive[Default parsing](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse6.cs)]
[!code-vb[Default parsing](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse6.vb)]  
  
 如果输入的字符串表示闰日闰年中的分析方法使用的日历中 (请参阅[分析和区域性约定](#Culture))，则<xref:System.DateTime.Parse%2A>方法已成功分析字符串。 如果输入的字符串表示闰日中非-闰年，则该方法将引发<xref:System.FormatException>。  
  
 因为<xref:System.DateTime.Parse%2A>方法尝试分析的字符串表示形式的日期和时间通过当前或指定的区域性，尝试跨不同区域性中分析字符串的格式设置规则可能会失败。 若要分析跨不同的区域设置特定日期和时间格式，请使用的重载之一<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>方法并提供的格式说明符。  
  
<a name="Culture"></a>   
### <a name="parsing-and-cultural-conventions"></a>分析和区域性约定  
 所有重载<xref:System.DateTime.Parse%2A>方法是区分区域性的除非要分析的字符串 (这由`s`下表中) 是否符合 ISO 8601 模式。 在分析操作使用中的格式设置信息<xref:System.Globalization.DateTimeFormatInfo>，如下所示派生的对象：  
  
|如果调用|和`provider`是|格式设置信息派生自|  
|-----------------|-----------------------|--------------------------------------------|  
|<xref:System.DateTime.Parse%28System.String%29>|-|当前线程区域性 (<xref:System.Globalization.DateTimeFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>属性)|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> 或 <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|A<xref:System.Globalization.DateTimeFormatInfo>对象|指定<xref:System.Globalization.DateTimeFormatInfo>对象|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> 或 <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|`null`|当前线程区域性 (<xref:System.Globalization.DateTimeFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>属性)|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> 或 <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|A<xref:System.Globalization.CultureInfo>对象|<xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> 属性|  
|<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29> 或 <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>|自定义<xref:System.IFormatProvider>实现|<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> 方法|  
  
 格式设置信息从派生时<xref:System.Globalization.DateTimeFormatInfo>对象，<xref:System.Globalization.DateTimeFormatInfo.Calendar%2A?displayProperty=nameWithType>属性定义在分析操作中使用的日历。  
  
 如果通过使用分析日期和时间字符串<xref:System.Globalization.DateTimeFormatInfo>对象的自定义不同的标准区域性的设置，请使用<xref:System.DateTime.ParseExact%2A>方法而不是<xref:System.DateTime.Parse%2A>方法来提高成功转换的概率。 非标准日期和时间字符串可以很复杂且难以进行分析。 <xref:System.DateTime.Parse%2A>方法尝试分析多种隐式分析模式，它们都可能会失败的字符串。 与此相反，<xref:System.DateTime.ParseExact%2A>方法要求你显式指定一个或多个可能会成功的确切的分析模式。 有关详细信息，请参阅中的"DateTimeFormatInfo 和动态数据"部分<xref:System.Globalization.DateTimeFormatInfo>主题。  
  
> [!IMPORTANT]
>  请注意，针对特定区域性的格式设置约定是动态的并且可能受更改影响。 这意味着，依赖于默认 （当前） 区域性或格式设置约定的分析操作指定<xref:System.IFormatProvider>如果发生以下任一情况，可能意外失败表示固定区域性以外区域性的对象：  
>   
> -   特定于区域性的数据已更改之间主要或次要版本的.NET framework 或作为对现有的.NET Framework 版本的更新的结果。  
> -   特定于区域性的数据反映用户首选项，从计算机到计算机或会话到另一个会话而异。  
> -   特定于区域性的数据表示一个替代的设置的标准区域性或自定义区域性的替换区域性。  
>   
>  若要防止分析区域性数据中的更改关联的数据和时间字符串的困难，可以通过使用固定区域性，分析日期和时间字符串，也可以调用<xref:System.DateTime.ParseExact%2A>或<xref:System.DateTime.TryParseExact%2A>方法并指定所需的格式要分析的字符串。 如果您要序列化和反序列化的日期和时间数据，你可以使用固定区域性的格式设置约定也可以序列化和反序列化<xref:System.DateTime>以二进制格式的值。  
>   
>  有关详细信息，请参阅中的"动态区域性数据"部分<xref:System.Globalization.CultureInfo>主题，并将"将日期时间值"部分中<xref:System.DateTime>主题。  
  
<a name="Styles"></a>   
### <a name="parsing-and-style-elements"></a>分析和样式元素  
 所有<xref:System.DateTime.Parse%2A>重载忽略输入字符串中的前导、 内部或尾随空白字符 (这由`s`下表中)。 日期和时间可以使用一对前导空格和尾随数字符号字符 （"#"，U + 0023），括起来，并可以尾随一个或多个 NULL 字符 (U + 0000)。  
  
 此外，<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>重载具有`styles`包含的一个或多个成员的参数<xref:System.Globalization.DateTimeStyles>枚举。 此参数定义如何`s`应解释和分析操作应将转换如何`s`为日期和时间。 下表描述了每个效果<xref:System.Globalization.DateTimeStyles>上分析操作的成员。  
  
|DateTimeStyles 成员|对转换的影响|  
|---------------------------|--------------------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|分析`s`并且，如果有必要，请将其转换为 UTC，，如下所示：<br /><br /> -如果`s`包括时区偏移量，或者如果`s`不包含任何时区信息但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeLocal>标志，该方法分析字符串，调用<xref:System.DateTime.ToUniversalTime%2A>要转换返回<xref:System.DateTime>值赋给UTC，并设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。<br />-如果`s`指示它表示 UTC，或如果`s`不包含时区信息但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeUniversal>标志，该方法分析字符串，对返回执行任何时区转换<xref:System.DateTime>值，并设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。<br />-在所有其他情况下，标记有任何影响。|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|忽略此值。 内部的空格始终允许的日期和时间元素中`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|忽略此值。 前导空白字符始终允许的日期和时间元素中`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|忽略此值。 尾随空格的日期和时间元素中始终允许`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|指定`s`可能包含前导、 内部和尾随空格。 这是默认行为。 不能重写通过提供限制性更强<xref:System.Globalization.DateTimeStyles>枚举值，如<xref:System.Globalization.DateTimeStyles.None>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|指定，如果`s`缺少假定任何时区信息，本地时间。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>标志位于<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>值设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|指定，如果`s`缺少假定任何时区信息，UTC。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>标志存在，该方法将返回<xref:System.DateTime>于 UTC 的值为本地时间和设置其<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.None>|虽然有效，但将忽略此值。|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|对于包含时区信息的字符串，尝试阻止的日期和时间字符串的转换<xref:System.DateTime>值，该值表示本地时间的其<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 通常情况下，通过调用创建此类字符串<xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType>方法以及通过使用"o"、"r"或"u"标准格式说明符。|  

<a name="kind"></a>   
### <a name="the-return-value-and-datetimekind"></a>返回值和 DateTime.Kind

`DateTime.Parse`重载返回<xref:System.DateTime>值其<xref:System.DateTime.Kind>属性包括时区信息。 它可能表示的时间：

- 协调世界时 (<xref:System.DateTimeKind.Utc?displayProperty=fullName>)。
- 在本地时区内的时间 (<xref:System.DateTimeKind.Local?displayProperty=fullName>)。
- 未知的时区中的时间 (xref:System.DateTimeKind.Unspecified?displayProperty=fullName >)。
 
 通常情况下，<xref:System.DateTime.Parse%2A>方法返回<xref:System.DateTime>对象，其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 但是，<xref:System.DateTime.Parse%2A>方法还可以执行时区转换并设置的值<xref:System.DateTime.Kind%2A>属性的值决定以不同方式，`s`和`styles`参数：  
  
|如果|转换时区|类型的属性|  
|--------|--------------------------|-------------------|  
|`s` 包含时区信息。|日期和时间转换为时间本地时区。|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|  
|`s` 包含时区信息和`styles`包括<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>标志。|日期和时间转换为协调世界时 (UTC)。|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|  
|`s` 包含 Z 或格林威治标准时间的时区指示符，和`styles`包括<xref:System.Globalization.DateTimeStyles.RoundtripKind>标志。|日期和时间被解释为 UTC。|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|  
  
 下面的示例将包含时间中的本地时区的时区信息的日期字符串为：  
  
 [!code-csharp-interactive[System.DateTime.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse2.cs#2)]
 [!code-vb[System.DateTime.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse2.vb#2)]  

  您还可以保留的值的日期和时间的<xref:System.DateTime.Kind%2A>属性的格式设置和通过分析操作期间<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>标志。 下面的示例演示如何<xref:System.Globalization.DateTimeStyles.RoundtripKind>标志会在分析操作影响上<xref:System.DateTime>通过使用"o"、"r"或"u"格式说明符将转换为字符串的值。  
  
 [!code-csharp-interactive[System.DateTime.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse5.cs#5)]
 [!code-vb[System.DateTime.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse5.vb#5)]  
  
### Examples

调用的大量示例`DateTime.Parse`方法散布在整个[备注](#remarks)部分本文以及个人的文档`DateTime.Parse`重载。

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

你也可以下载一组完整的`DateTime.Parse`示例，它包括在[对于 C#.NET 核心 2.0 项目](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/DateTime.Parse.zip)和[适用于 Visual Basic.NET 核心 2.0 项目](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/DateTime.Parse.zip)，从[dotnet/文档GitHub 存储库](https://github.com/dotnet/docs)。

 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider)" />
        <altmember cref="Overload:System.DateTime.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime Parse(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。 有关详细信息，请参阅[要分析的字符串](#StringToParse)。</param>
        <summary>使用当前线程区域性的约定将日期和时间的字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。</summary>
        <returns>一个对象，它等效于 <paramref name="s" /> 中包含的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
如果`s`包含时区信息，该方法返回<xref:System.DateTime>值其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>，并将转换的日期和时间`s`为本地时间。 否则为它不执行任何时区转换，且返回<xref:System.DateTime>值其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。

此重载试图分析`s`通过使用当前区域性的格式设置约定。 当前的区域性将由<xref:System.Globalization.CultureInfo.CurrentCulture>属性。 若要分析使用特定区域性的格式设置约定的字符串，调用<xref:System.DateTime.Parse(System.String,System.IFormatProvider)>或<xref:System.DateTime.Parse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)>重载。

此重载试图分析`s`使用<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces?displayProperty=nameWithType>样式。

## <a name="example"></a>示例

下面的示例分析的字符串表示形式的几个日期和时间值：

- 使用默认的格式提供程序，它提供用于生成此示例输出的计算机的当前线程区域性的格式设置约定。 此示例的输出将反映 EN-US 区域性的格式设置约定。

- 使用默认样式值，该值是<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces?displayProperty=nameWIthType>。 

它处理<xref:System.FormatException>方法尝试通过使用某些其他区域性分析的字符串表示形式的日期和时间时引发的异常的格式设置约定。 它还演示如何为成功分析不使用当前线程区域性的格式设置约定的日期和时间值。  
  
 [!code-csharp-interactive[System.DateTime.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.DateTime.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse1.vb#1)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> 中不包含有效的日期和时间的字符串表示形式。</exception>
        <altmember cref="Overload:System.DateTime.TryParse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。 有关详细信息，请参阅[要分析的字符串](#StringToParse)。</param>
        <param name="provider">一个对象，提供有关 <c>s</c> 的区域性特定格式信息。  请参阅[分析和区域性约定](#Culture)</param>
        <summary>使用指定的区域性特定格式设置信息，将日期和时间的字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。</summary>
        <returns>一个对象，它等效于 <paramref name="s" /> 中包含的日期和时间，由 <paramref name="provider" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
如果`s`包含时区信息，该方法返回<xref:System.DateTime>值其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>，并将转换的日期和时间`s`为本地时间。 否则为它不执行任何时区转换，且返回<xref:System.DateTime>值其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。

此重载试图分析`s`使用<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces?displayProperty=nameWithType>样式。

## <a name="example"></a>示例

下面的示例通过使用 EN-US、 FR-FR，和 DE-DE 区域性的约定分析日期字符串的数组。 它演示了可以跨不同的区域性以不同的方式解释的字符串表示形式单个日期。  
  
[!code-csharp-interactive[System.DateTime.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse3.cs#3)]
[!code-vb[System.DateTime.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> 中不包含有效的日期和时间的字符串表示形式。</exception>
        <altmember cref="Overload:System.DateTime.TryParse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (ReadOnlySpan&lt;char&gt; s, IFormatProvider provider = null, System.Globalization.DateTimeStyles styles = System.Globalization.DateTimeStyles.None);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional provider As IFormatProvider = null, Optional styles As DateTimeStyles = System.Globalization.DateTimeStyles.None) As DateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="styles">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTime Parse (string s, IFormatProvider provider, System.Globalization.DateTimeStyles styles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime Parse(string s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Parse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider, styles As DateTimeStyles) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime Parse(System::String ^ s, IFormatProvider ^ provider, System::Globalization::DateTimeStyles styles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。 有关详细信息，请参阅[要分析的字符串](#StringToParse)。</param>
        <param name="provider">一个对象，提供有关 <c>s</c> 的区域性特定格式设置信息。  请参阅[分析和区域性约定](#Culture)</param>
        <param name="styles">枚举值的按位组合，用于指示 <c>s</c> 成功执行分析操作所需的样式元素以及定义如何根据当前时区或当前日期解释已分析日期的样式元素。 要指定的一个典型值为 <see cref="F:System.Globalization.DateTimeStyles.None" />。</param>
        <summary>使用指定的区域性特定格式设置信息和格式类型，将日期和时间的字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。</summary>
        <returns>一个对象，它等效于 <paramref name="s" /> 中包含的日期和时间，由 <paramref name="provider" /> 和 <paramref name="styles" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

此方法重载将转换的日期和时间`s`和设置<xref:System.DateTime.Kind%2A>属性返回的<xref:System.DateTime>值，如下所示：

|如果 |转换时区|类型的属性|   
|-----|-----|-----|  
|`s` 包含没有时区信息。|无。|<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>|
|`s` 包含时区信息。|为本地时区中的时间|<xref:System.DateTimeKind.Local?displayProperty=nameWithType>|
|`s` 包含时区信息，和样式包括<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志。|为协调的通用时 (UTC)|<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>|
|`s` 包含 Z 或格林威治标准时间的时区指示符，和`styles`包括<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>。|无。|<xref:System.DateTimeKind.Utc>| 

## <a name="example"></a>示例

下面的示例演示<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>方法，并显示的值<xref:System.DateTime.Kind%2A>属性生成<xref:System.DateTime>值。  
  
[!code-csharp-interactive[System.DateTime.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Parse/cs/Parse4.cs#4)]
[!code-vb[System.DateTime.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Parse/vb/Parse4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> 中不包含有效的日期和时间的字符串表示形式。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="styles" /> 包含 <see cref="T:System.Globalization.DateTimeStyles" /> 值的无效组合。 例如，<see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> 和 <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />。</exception>
        <altmember cref="Overload:System.DateTime.TryParse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ParseExact">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将日期和时间的指定字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。 字符串表示形式的格式必须与指定的格式完全匹配，否则会引发异常。</summary>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (string s, string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(string s, string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As String, format As String, provider As IFormatProvider) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ParseExact(System::String ^ s, System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。</param>
        <param name="format">用于定义所需的 <c>s</c> 格式的格式说明符。 有关详细信息，请参阅“备注”部分。</param>
        <param name="provider">一个对象，提供有关 <c>s</c> 的区域性特定格式信息。</param>
        <summary>使用指定的格式和区域性特定格式信息，将日期和时间的指定字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。 字符串表示形式的格式必须与指定的格式完全匹配。</summary>
        <returns>一个对象，它等效于 <paramref name="s" /> 中包含的日期和时间，由 <paramref name="format" /> 和 <paramref name="provider" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法分析的字符串表示形式必须是定义的格式的日期`format`参数。 它还要求\<日期 > 和\<时间 > 元素的字符串表示形式的日期和时间显示在指定的顺序中`format`，且`s`具有没有空格，而不是允许的`format`. 如果`format`定义的日期与没有时间元素和分析操作成功，则生成<xref:System.DateTime>值必须在时间内的午夜 (00: 00:00)。 如果`format`定义的时间与没有日期元素，并且分析操作成功，则生成<xref:System.DateTime>值具有日期`DateTime.Now.Date`。  
  
 如果`s`不的表示时间以特定时区和分析操作成功，<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>值是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 如果`s`确实表示特定时区的时间和`format`允许存在的时区信息 (例如，如果`format`等同于"o"、"r"或"u"标准格式说明符，或如果它包含"z"、"zz"或"zzz"自定义格式说明符）<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>值是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。  
  
 `format`参数是一个字符串，包含单个标准格式说明符或一个或多个定义的所需的格式的自定义格式说明符`s`。 有关有效格式设置代码的详细信息，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)或[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。  
  
> [!NOTE]
>  如果`format`是不包含日期或时间分隔符 （如"yyyyMMddHHmm")，可使用的固定区域性的自定义格式模式`provider`参数以及提供给最大形式的每个自定义格式说明符。 例如，如果你想要指定的格式模式中的小时数，请指定较宽的形式"HH"，而不是较窄的形式，"H"。  
  
 特定日期和时间符号和字符串 （例如，特定语言线的星期几名称） 中使用`s`由定义`provider`参数，则精确格式`s`如果`format`是标准的格式说明符字符串。 `provider`参数可以是任何以下：  
  
-   A<xref:System.Globalization.CultureInfo>对象，表示用于解释的区域性`s`。 <xref:System.Globalization.DateTimeFormatInfo>对象由其<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性定义的符号和中的格式设置`s`。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>定义的日期和时间数据格式的对象。  
  
-   自定义<xref:System.IFormatProvider>实现其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.CultureInfo>对象或<xref:System.Globalization.DateTimeFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`、<xref:System.Globalization.CultureInfo>使用对应于当前区域性的对象。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.ParseExact%2A>方法。  
  
 [!code-csharp[System.DateTime.ParseExact#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ParseExact/cs/ParseExact1.cs#1)]
 [!code-vb[System.DateTime.ParseExact#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ParseExact/vb/ParseExact1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 或 <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> 或 <paramref name="format" /> 是一个空字符串。  
  
 或  
  
 <paramref name="s" /> 不包含与 <paramref name="format" /> 中指定的模式相对应的日期和时间。  
  
 或  
  
 <paramref name="s" /> 中的小时组成部分和 AM/PM 指示符不一致。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、<see cref="Overload:System.DateTime.ParseExact" />方法抛出异常<see cref="T:System.FormatException" />如果要分析的字符串包含小时组成部分和 AM/PM 指示符，并不一致。 在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和早期版本中，AM/PM 指示符将被忽略。</para>
        </block>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider provider, System.Globalization.DateTimeStyles style = System.Globalization.DateTimeStyles.None);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As ReadOnlySpan(Of Char), format As ReadOnlySpan(Of Char), provider As IFormatProvider, Optional style As DateTimeStyles = System.Globalization.DateTimeStyles.None) As DateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (ReadOnlySpan&lt;char&gt; s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style = System.Globalization.DateTimeStyles.None);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.ReadOnlySpan{System.Char},System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As ReadOnlySpan(Of Char), formats As String(), provider As IFormatProvider, Optional style As DateTimeStyles = System.Globalization.DateTimeStyles.None) As DateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="formats">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (string s, string format, IFormatProvider provider, System.Globalization.DateTimeStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(string s, string format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As String, format As String, provider As IFormatProvider, style As DateTimeStyles) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ParseExact(System::String ^ s, System::String ^ format, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。</param>
        <param name="format">用于定义所需的 <c>s</c> 格式的格式说明符。 有关详细信息，请参阅“备注”部分。</param>
        <param name="provider">一个对象，提供有关 <c>s</c> 的区域性特定格式设置信息。</param>
        <param name="style">枚举值的按位组合，提供有关以下内容的附加信息：<c>s</c>、可能出现在 <c>s</c> 中的样式元素或从 <c>s</c> 到 <see cref="T:System.DateTime" /> 值的转换。 要指定的一个典型值为 <see cref="F:System.Globalization.DateTimeStyles.None" />。</param>
        <summary>使用指定的格式、区域性特定的格式信息和样式将日期和时间的指定字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。 字符串表示形式的格式必须与指定的格式完全匹配，否则会引发异常。</summary>
        <returns>一个对象，它等效于 <paramref name="s" /> 中包含的日期和时间，由 <paramref name="format" />、<paramref name="provider" /> 和 <paramref name="style" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法分析的字符串表示形式必须是定义的格式的日期`format`参数。 它还要求中的日期和时间元素`s`显示在指定的顺序`format`。 如果`s`不匹配的模式`format`参数，并具有定义的任何变体`style`参数，该方法将引发<xref:System.FormatException>。 与此相反，<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法分析的字符串表示形式中任何一种识别的格式提供程序的格式的日期<xref:System.Globalization.DateTimeFormatInfo>对象。 <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法还允许中的日期和时间元素`s`若要按任何顺序出现。  
  
 如果`s`参数包含仅在时间，并没有日期，当前日期用于除非`style`参数包含<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType>标志，在这种情况下的默认日期 (`DateTime.Date.MinValue`) 使用。 如果`s`参数包含仅的日期和没有时间、 午夜 (00: 00:00) 使用。 `style`参数还确定是否`s`参数可以包含前导、 内部或尾随空格字符。  
  
 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 可以使用更改此行为<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>，或通过使用<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>和<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果`s`包含时区信息，如有必要，将时间转换为本地时间和<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 可以使用更改此行为<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>标志以不将协调世界时 (UTC) 转换为本地时间，并设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。  
  
 `format`参数定义的所需的模式`s`参数。 它可以包含一个或多个自定义格式说明符从[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)表或单个标准格式说明符，它标识预定义的模式，从[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)表。  
  
 如果你不使用自定义格式模式中的日期或时间分隔符，使用固定区域性的`provider`参数以及提供给最大形式的每个自定义格式说明符。 例如，如果你想要指定模式中的小时数，请指定较宽的形式"HH"，而不是较窄的形式，"H"。  
  
> [!NOTE]
>  而不是要求`s`符合使分析操作成功的一种格式，您可以调用<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法并指定多种允许的格式。 这使得更可能会成功分析操作。  
  
 `styles`参数包含一个或多个成员的<xref:System.Globalization.DateTimeStyles>确定是否以及在何处的空白区域未定义的枚举`format`可以出现在`s`和控制分析操作的确切行为。 下表描述了每个成员的<xref:System.Globalization.DateTimeStyles>枚举会影响的操作<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>方法。  
  
|DateTimeStyles 成员|描述|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|分析`s`并且，如果有必要，请将其转换为 UTC。 如果`s`包括时区偏移量，或者如果`s`不包含任何时区信息但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，该方法分析字符串，调用<xref:System.DateTime.ToUniversalTime%2A>要转换返回<xref:System.DateTime>为 UTC 值并将设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果`s`指示它表示 UTC，或如果`s`不包含时区信息但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>标志，该方法分析字符串，对返回执行任何时区转换<xref:System.DateTime>值，并设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 在所有其他情况下，标记有任何影响。|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|指定未定义的空白`format`可以出现在任何单个的日期或时间元素之间。|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|指定未定义的空白`format`可以出现的开始处`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|指定未定义的空白`format`可以出现在结尾处`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|指定`s`可能包含前导、 内部和尾随空格未定义的`format`。|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|指定，如果`s`缺少的任何时区信息，则假定它表示本地时间。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志位于<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>值设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|指定，如果`s`缺少的任何时区信息，则假定它表示 UTC。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志存在，该方法将返回<xref:System.DateTime>于 UTC 的值为本地时间和设置其<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|如果`s`包含时间不包含日期信息的返回值的日期设置为`DateTime.MinValue.Date`。|  
|<xref:System.Globalization.DateTimeStyles.None>|`s`使用默认值分析参数。 没有空格，而不是中提供的`format`允许。 如果`s`缺少返回日期的日期部分，<xref:System.DateTime>值设置为 0001 年 1 月 1 日。 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 如果时区信息位于`s`，将时间转换为本地时间和<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|对于包含时区信息的字符串，尝试阻止转换为<xref:System.DateTime>值日期和时间与其<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 此标志主要是阻止将本地时间到 UTC 时间的转换。|  
  
 特定日期和时间符号和字符串 （例如，由特定语言星期几的名称） 中使用`s`由定义`provider`参数，则精确格式`s`如果`format`是标准的格式说明符字符串。 `provider`参数可以是任何以下：  
  
-   A<xref:System.Globalization.CultureInfo>对象，表示用于解释的区域性`s`。 <xref:System.Globalization.DateTimeFormatInfo>对象由其<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性定义的符号和中的格式设置`s`。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>定义的日期和时间数据格式的对象。  
  
-   自定义<xref:System.IFormatProvider>实现其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.CultureInfo>对象或<xref:System.Globalization.DateTimeFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`、<xref:System.Globalization.CultureInfo>使用对应于当前区域性的对象。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%29>方法。 请注意，字符串"5/01/2009年上午 8:30"无法成功分析时`styles`参数等于<xref:System.Globalization.DateTimeStyles.None?displayProperty=nameWithType>因为通过不允许有前导空格`format`。 此外，字符串"5/01/2009年 09:00"不能与成功分析`format`的"MM/dd/yyyyhh:mm"因为日期字符串前面不带前导零的月份数作为`format`要求。  
  
 [!code-csharp[System.DateTime.ParseExact#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ParseExact/cs/parseexact2.cs#2)]
 [!code-vb[System.DateTime.ParseExact#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ParseExact/vb/parseexact2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 或 <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> 或 <paramref name="format" /> 是一个空字符串。  
  
 或  
  
 <paramref name="s" /> 不包含与 <paramref name="format" /> 中指定的模式相对应的日期和时间。  
  
 或  
  
 <paramref name="s" /> 中的小时组成部分和 AM/PM 指示符不一致。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> 包含 <see cref="T:System.Globalization.DateTimeStyles" /> 值的无效组合。 例如，<see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> 和 <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、<see cref="Overload:System.DateTime.ParseExact" />方法抛出异常<see cref="T:System.FormatException" />如果要分析的字符串包含小时组成部分和 AM/PM 指示符，并不一致。 在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和早期版本中，AM/PM 指示符将被忽略。</para>
        </block>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTime ParseExact (string s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ParseExact(string s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ParseExact(System.String,System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (s As String, formats As String(), provider As IFormatProvider, style As DateTimeStyles) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime ParseExact(System::String ^ s, cli::array &lt;System::String ^&gt; ^ formats, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。</param>
        <param name="formats">
          <c>s</c> 的允许格式的数组。 有关详细信息，请参阅“备注”部分。</param>
        <param name="provider">一个对象，提供有关 <c>s</c> 的区域性特定格式信息。</param>
        <param name="style">枚举值的按位组合，指示 <c>s</c> 允许使用的格式。 要指定的一个典型值为 <see cref="F:System.Globalization.DateTimeStyles.None" />。</param>
        <summary>使用指定的格式数组、区域性特定格式信息和样式，将日期和时间的指定字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。 字符串表示形式的格式必须至少与指定的格式之一完全匹配，否则会引发异常。</summary>
        <returns>一个对象，它等效于 <paramref name="s" /> 中包含的日期和时间，由 <paramref name="formats" />、<paramref name="provider" /> 和 <paramref name="style" /> 指定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法分析的字符串表示形式符合任一分配到的模式的日期`formats`参数。 如果字符串`s`与任何定义的变体不匹配的这些模式任一`styles`参数，该方法将引发<xref:System.FormatException>。 除了比较`s`到多个格式设置模式，而不是单个的格式设置模式，此重载的行为完全相同<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法。  
  
 `s`参数包含要分析的日期和时间。 如果`s`参数包含仅在时间，并没有日期，当前日期用于除非`style`参数包含<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType>标志，在这种情况下的默认日期 (`DateTime.Date.MinValue`) 使用。 如果`s`参数包含仅的日期和没有时间、 午夜 (00: 00:00) 使用。 `style`参数还确定是否`s`参数可以包含前导、 内部或尾随空格字符其他比允许的格式字符串在之一`formats`。  
  
 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 可以使用更改此行为<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>，或通过使用<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>和<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果`s`包含时区信息，如有必要，将时间转换为本地时间和<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 可以使用更改此行为<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>标志以不将协调世界时 (UTC) 转换为本地时间和将设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。  
  
 `formats`参数包含数组的模式，其中`s`必须完全匹配分析操作成功。 中的模式`formats`参数从的一个或多个自定义格式说明符组成[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)表或用于标识预定义的模式，从单个标准格式说明符[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)表。  
  
 如果你不使用自定义格式模式中的日期或时间分隔符，使用固定区域性的`provider`参数以及提供给最大形式的每个自定义格式说明符。 例如，如果你想要指定模式中的小时数，请指定较宽的形式"HH"，而不是较窄的形式，"H"。  
  
 `styles`参数包含一个或多个成员的<xref:System.Globalization.DateTimeStyles>确定是否以及在何处的空白区域未定义的枚举`format`可以出现在`s`和控制分析操作的确切行为。 下表描述了每个成员的<xref:System.Globalization.DateTimeStyles>枚举会影响的操作<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29>方法。  
  
|DateTimeStyles 成员|描述|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|分析`s`并且，如果有必要，请将其转换为 UTC。 如果`s`包括时区偏移量，或者如果`s`不包含任何时区信息但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，该方法分析字符串，调用<xref:System.DateTime.ToUniversalTime%2A>要转换返回<xref:System.DateTime>为 UTC 值并将设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果`s`指示它表示 UTC，或如果`s`不包含时区信息但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>标志，该方法分析字符串，对返回执行任何时区转换<xref:System.DateTime>值，并设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 在所有其他情况下，标记有任何影响。|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|指定未定义的空白`format`可以出现在任何单个的日期或时间元素之间。|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|指定未定义的空白`format`可以出现的开始处`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|指定未定义的空白`format`可以出现在结尾处`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|指定`s`可能包含前导、 内部和尾随空格未定义的`format`。|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|指定，如果`s`缺少的任何时区信息，则假定它表示本地时间。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志位于<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>值设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|指定，如果`s`缺少的任何时区信息，则假定它表示 UTC。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志存在，该方法将返回<xref:System.DateTime>于 UTC 的值为本地时间和设置其<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|如果`s`包含时间不包含日期信息的返回值的日期设置为`DateTime.MinValue.Date`。|  
|<xref:System.Globalization.DateTimeStyles.None>|`s`使用默认值分析参数。 没有空格，而不是中提供的`format`允许。 如果`s`缺少返回日期的日期部分，<xref:System.DateTime>值设置为 0001 年 1 月 1 日。 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 如果时区信息位于`s`，将时间转换为本地时间和<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|对于包含时区信息的字符串，尝试地阻止转换为日期和时间与其<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 此标志主要是阻止将本地时间到 UTC 时间的转换。|  
  
 特定日期和时间符号和字符串 （例如，由特定语言星期几的名称） 中使用`s`由定义`provider`参数，则精确格式`s`如果`format`是标准的格式说明符字符串。 `provider`参数可以是任何以下：  
  
-   A<xref:System.Globalization.CultureInfo>对象，表示用于解释的区域性`s`。 <xref:System.Globalization.DateTimeFormatInfo>对象由其<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性定义的符号和中的格式设置`s`。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>定义的日期和时间数据格式的对象。  
  
-   自定义<xref:System.IFormatProvider>实现其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.CultureInfo>对象或<xref:System.Globalization.DateTimeFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`、<xref:System.Globalization.CultureInfo>使用对应于当前区域性的对象。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法，以确保可以成功分析中大量的可能格式的字符串。  
  
 [!code-csharp[System.Datetime.ParseExact#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ParseExact/cs/parseexact3.cs#3)]
 [!code-vb[System.Datetime.ParseExact#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ParseExact/vb/parseexact3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 或 <paramref name="formats" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> 是一个空字符串。  
  
 或  
  
 <paramref name="formats" /> 的一个元素是空字符串。  
  
 或  
  
 <paramref name="s" /> 不包含与 <paramref name="formats" /> 中的任何元素对应的日期和时间。  
  
 或  
  
 <paramref name="s" /> 中的小时组成部分和 AM/PM 指示符不一致。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> 包含 <see cref="T:System.Globalization.DateTimeStyles" /> 值的无效组合。 例如，<see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> 和 <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、<see cref="Overload:System.DateTime.ParseExact" />方法抛出异常<see cref="T:System.FormatException" />如果要分析的字符串包含小时组成部分和 AM/PM 指示符，并不一致。 在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和早期版本中，AM/PM 指示符将被忽略。</para>
        </block>
        <altmember cref="Overload:System.DateTime.TryParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Second">
      <MemberSignature Language="C#" Value="public int Second { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Second" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Second" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Second As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Second { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示日期的秒部分。</summary>
        <value>秒组成部分，表示为 0 和 59 之间的一个值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示<xref:System.DateTime.Second%2A>属性。  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpecifyKind">
      <MemberSignature Language="C#" Value="public static DateTime SpecifyKind (DateTime value, DateTimeKind kind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime SpecifyKind(valuetype System.DateTime value, valuetype System.DateTimeKind kind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.SpecifyKind(System.DateTime,System.DateTimeKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SpecifyKind (value As DateTime, kind As DateTimeKind) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime SpecifyKind(DateTime value, DateTimeKind kind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
        <Parameter Name="kind" Type="System.DateTimeKind" />
      </Parameters>
      <Docs>
        <param name="value">日期和时间。</param>
        <param name="kind">枚举值之一，该值指示新对象是表示本地时间、UTC，还是两者皆否。</param>
        <summary>创建新的 <see cref="T:System.DateTime" /> 对象，该对象具有与指定的 <see cref="T:System.DateTime" /> 相同的刻度数，但是根据指定的 <see cref="T:System.DateTimeKind" /> 值的指示，指定为本地时间或协调世界时 (UTC)，或者两者皆否。</summary>
        <returns>一个新对象，它与由 <paramref name="value" /> 参数和由 <see cref="T:System.DateTimeKind" /> 参数指定的 <paramref name="kind" /> 值代表的对象具有相同刻度数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.DateTime>对象包含的类型的字段，该值指示是否时间值基于本地时间、 协调世界时 (UTC)，或，并包含时间值的刻度字段以 100 毫微秒为单位。 <xref:System.DateTime.SpecifyKind%2A>方法创建一个新<xref:System.DateTime>对象使用指定`kind`参数和原始的时间值。  
  
> [!IMPORTANT]
>  返回<xref:System.DateTime>值不表示相同即时时间`value`参数，和<xref:System.DateTime.SpecifyKind%2A>不是一个时区转换方法。 相反，则会使指定的时间`value`参数保持不变，并设置<xref:System.DateTime.Kind%2A>属性`kind`。 有关时区转换的信息，请参阅[转换时间之间的时区](~/docs/standard/datetime/converting-between-time-zones.md)。  
  
 <xref:System.DateTime.SpecifyKind%2A>方法是从何处获得的互操作性方案中十分有用<xref:System.DateTime>对象未指定的类型字段中，但你可以确定由独立于意味着 Ticks 字段表示本地时间还是基于 UTC。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.SpecifyKind%2A>方法演示如何<xref:System.DateTime.Kind%2A>属性影响<xref:System.DateTime.ToLocalTime%2A>和<xref:System.DateTime.ToUniversalTime%2A>转换方法。  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从此实例中减去指定的时间或持续时间。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public TimeSpan Subtract (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan Subtract(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Subtract(System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract (value As DateTime) As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan Subtract(DateTime value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">要减去的日期和时间值。</param>
        <summary>从此实例中减去指定的日期和时间。</summary>
        <returns>一个时间间隔，它等于此实例所表示的日期和时间减去 <paramref name="value" /> 所表示的日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Subtract%28System.DateTime%29>方法确定两个日期之间的差异。 若要减去的时间间隔从当前实例，调用<xref:System.DateTime.Subtract%28System.TimeSpan%29>方法。 要减去从当前实例的特定时间间隔，调用将该时间间隔加到当前日期，该方法并提供负值作为方法自变量。 例如，若要从当前日期的两个月中减去，请调用<xref:System.DateTime.AddMonths%28System.Int32%29>值为-2 的方法。  
  
 日期和时间的当前实例是早于`value`，该方法返回<xref:System.TimeSpan>表示负时间跨度的对象。 所有其非零值属性的值 (如<xref:System.TimeSpan.Days%2A>或<xref:System.TimeSpan.Ticks%2A>) 为负。  
  
 <xref:System.DateTime.Subtract%28System.DateTime%29>方法不考虑的值<xref:System.DateTime.Kind%2A>这两个属性<xref:System.DateTime>值时执行减法。 相减之前<xref:System.DateTime>对象，请确保这些对象表示在相同的时区的时间。 否则，结果将包括时区之间的差异。  
  
> [!NOTE]
>  <xref:System.DateTimeOffset.Subtract%28System.DateTimeOffset%29?displayProperty=nameWithType>方法一定会考虑执行减法时的时区之间的差异。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Subtract%2A>方法和减法运算符。  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">结果小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public DateTime Subtract (TimeSpan value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime Subtract(valuetype System.TimeSpan value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.Subtract(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract (value As TimeSpan) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime Subtract(TimeSpan value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="value">待减去的时间间隔。</param>
        <summary>从此实例中减去指定持续时间。</summary>
        <returns>一个对象，它等于此实例所表示的日期和时间减去 <paramref name="value" /> 所表示的时间间隔。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Subtract%28System.TimeSpan%29>方法返回当前实例中指定的时间间隔差异的日期。 若要确定两个日期之间的时间间隔，请调用<xref:System.DateTime.Subtract%28System.DateTime%29>方法。 要减去从当前实例的特定时间间隔，调用将该时间间隔加到当前日期，该方法并提供负值作为方法自变量。 例如，若要从当前日期的两个月中减去，请调用<xref:System.DateTime.AddMonths%28System.Int32%29>值为-2 的方法。  
  
 此方法不会更改此值<xref:System.DateTime>。 相反，它将返回一个新<xref:System.DateTime>其值是此操作的结果。  
  
 通常，<xref:System.DateTime.Subtract%28System.TimeSpan%29?displayProperty=nameWithType>方法中减去<xref:System.TimeSpan>表示正时间跨度，返回的对象<xref:System.DateTime>早于的日期和时间的当前实例的值。 但是，如果<xref:System.TimeSpan>对象表示负时间跨度，<xref:System.DateTime.Subtract%28System.TimeSpan%29?displayProperty=nameWithType>方法返回<xref:System.DateTime>晚于的日期和时间的当前实例的值。  
  
 <xref:System.DateTime.Subtract%28System.TimeSpan%29?displayProperty=nameWithType>方法允许你要减去包含的时间 （给定的小时数） 和指定的分钟数等的多个单位的时间间隔。 要从中减去的时间 （例如年、 月或天） 的单个单元<xref:System.DateTime>实例，你可以负的数字值将作为参数传递到任何以下方法：  
  
-   <xref:System.DateTime.AddYears%2A>要减去的特定从当前日期和时间实例的年数。  
  
-   <xref:System.DateTime.AddMonths%2A>要减去的特定从当前日期和时间实例的月数。  
  
-   <xref:System.DateTime.AddDays%2A>要减去的特定天从当前日期和时间实例数。  
  
-   <xref:System.DateTime.AddHours%2A>要减去的特定从当前日期和时间实例的小时数。  
  
-   <xref:System.DateTime.AddMinutes%2A>要减去的特定从当前日期和时间实例的分钟数。  
  
-   <xref:System.DateTime.AddSeconds%2A>要减去的特定从当前日期和时间实例的秒数。  
  
-   <xref:System.DateTime.AddMilliseconds%2A>要减去的特定从当前日期和时间实例的毫秒数。  
  
-   <xref:System.DateTime.AddTicks%2A>要减去的特定从当前日期和时间实例的计时周期数。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Subtract%2A>方法和减法运算符。  
  
 [!code-cpp[DateTime.Subtraction#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.Subtraction/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.Subtraction#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Subtraction/CS/class1.cs#1)]
 [!code-vb[DateTime.Subtraction#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Subtraction/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">结果小于 <see cref="F:System.DateTime.MinValue" /> 或大于 <see cref="F:System.DateTime.MaxValue" />。</exception>
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>返回当前 <see cref="T:System.DateTime" /> 对象。</summary>
        <returns>当前对象。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">所需类型。</param>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象转换为指定类型的对象。</summary>
        <returns>由 <paramref name="type" /> 参数指定的类型的对象，其值与当前 <see cref="T:System.DateTime" /> 对象等效。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidCastException">
          <see cref="T:System.DateTime" /> 类型不支持此转换。</exception>
        <altmember cref="T:System.Convert" />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个实现 <see cref="T:System.IFormatProvider" /> 接口的对象。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>不支持此转换。 尝试使用此方法将引发 <see cref="T:System.InvalidCastException" />。</summary>
        <returns>未使用此成员的返回值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">在所有情况下。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">要填充数据的对象。</param>
        <param name="context">此序列化的目标。 （未使用此参数；指定 <see langword="null" />。）</param>
        <summary>使用序列化当前的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象所需的所有数据填充 <see cref="T:System.DateTime" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法填充`info`参数<xref:System.DateTime.Ticks%2A>和<xref:System.DateTime.Kind%2A>属性值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="Ticks">
      <MemberSignature Language="C#" Value="public long Ticks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Ticks" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Ticks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Ticks As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Ticks { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取表示此实例的日期和时间的计时周期数。</summary>
        <value>表示此实例的日期和时间的计时周期数。 该值介于 <see langword="DateTime.MinValue.Ticks" /> 和 <see langword="DateTime.MaxValue.Ticks" /> 之间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 单个的计时周期表示一百纳秒的一千万分之一。 有 10000 个计时周期中以毫秒为单位或 1000 万个第二个刻度。  
  
 此属性的值表示 0001 年 1 月 1 日午夜 12:00:00 以来所经历的 100 毫微秒隔数 (0: 00:00 年 1 月 1 日 UTC 0001，以公历)，后者表示<xref:System.DateTime.MinValue?displayProperty=nameWithType>。 它不包括归因于闰秒的刻度的数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.Ticks%2A>属性以显示二十一世纪开始以来所经历的计时周期数，以及要实例化<xref:System.TimeSpan>对象。 <xref:System.TimeSpan>对象用来显示逝去的时间使用多个其他时间间隔。  
  
 [!code-csharp[System.DateTime.Ticks#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Ticks/cs/Ticks.cs#1)]
 [!code-vb[System.DateTime.Ticks#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Ticks/vb/Ticks.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeOfDay">
      <MemberSignature Language="C#" Value="public TimeSpan TimeOfDay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeOfDay" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.TimeOfDay" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeOfDay As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeOfDay { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例的当天的时间。</summary>
        <value>一个时间间隔，它表示当天自午夜以来已经过时间的部分。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.DateTime.Date%2A>属性。 它将返回<xref:System.DateTime>值，该值表示不带其时间部分中，日期<xref:System.DateTime.TimeOfDay%2A>属性返回<xref:System.TimeSpan>值，该值表示<xref:System.DateTime>值的时间组件。  
  
 如果你想要显示的当天的时间或检索的字符串表示形式的一天的时间<xref:System.DateTime>值，可以改为调用的重载<xref:System.DateTime.ToString%2A>方法具有`format`参数或使用[复合格式设置](~/docs/standard/base-types/composite-formatting.md)与"t"或"T"标准格式字符串的功能。  
  
   
  
## Examples  
 下面的示例显示的值<xref:System.DateTime.TimeOfDay%2A>数组的属性<xref:System.DateTime>值。 它还返回复合格式设置操作中的"t"标准格式字符串的字符串与对比返回的值。  
  
 [!code-csharp[System.DateTime.TimeOfDay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.timeofday/cs/timeofday1.cs#1)]
 [!code-vb[System.DateTime.TimeOfDay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.timeofday/vb/timeofday1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="ToBinary">
      <MemberSignature Language="C#" Value="public long ToBinary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToBinary() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToBinary" />
      <MemberSignature Language="VB.NET" Value="Public Function ToBinary () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToBinary();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象序列化为一个 64 位二进制值，该值随后可用于重新创建 <see cref="T:System.DateTime" /> 对象。</summary>
        <returns>64 位有符号整数，它对 <see cref="P:System.DateTime.Kind" /> 和 <see cref="P:System.DateTime.Ticks" /> 属性进行了编码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.DateTime.ToBinary%2A>方法将转换的当前值<xref:System.DateTime>为二进制值的对象。 随后，使用的二进制值和<xref:System.DateTime.FromBinary%2A>方法来重新创建原始<xref:System.DateTime>对象。  
  
> [!IMPORTANT]
>  在某些情况下，<xref:System.DateTime>返回值<xref:System.DateTime.FromBinary%2A>方法不是与原始<xref:System.DateTime>值提供给<xref:System.DateTime.ToBinary%2A>方法。 有关详细信息，请参阅下一部分中，"本地时间调整"。  
  
## <a name="local-time-adjustment"></a>本地时间调整  
 本地时间，这是将其调整为本地时区协调世界时，由<xref:System.DateTime>结构，它的<xref:System.DateTime.Kind%2A>属性具有值<xref:System.DateTimeKind.Local>。 还原本地时<xref:System.DateTime>从由生成的二进制表示的值<xref:System.DateTime.ToBinary%2A>方法，<xref:System.DateTime.FromBinary%2A>方法可能会调整重新创建的值，以便不等于原始值。 在下列条件下，可能会出现这种情况：  
  
-   如果本地<xref:System.DateTime>对象序列中由一个时区<xref:System.DateTime.ToBinary%2A>方法，然后通过不同的时区中反序列化和<xref:System.DateTime.FromBinary%2A>方法时，表示所生成的本地时间<xref:System.DateTime>自动调整对象为第二个时区。  
  
     例如，考虑<xref:System.DateTime>表示下午 3 点的本地时间的对象 在美国太平洋时区中执行的应用程序太平洋时区使用<xref:System.DateTime.ToBinary%2A>方法以将其转换<xref:System.DateTime>为二进制值的对象。 在美国太平洋时区中执行的另一个应用程序美国东部时区使用<xref:System.DateTime.FromBinary%2A>方法将二进制值转换为一个新<xref:System.DateTime>对象。 新值<xref:System.DateTime>对象是 6 P.M.，表示作为原始的下午 3 的时间相同的点 值，但将会调整为东部时区中的本地时间。  
  
-   如果的二进制表示形式本地<xref:System.DateTime>值表示系统上的本地时区的时间无效<xref:System.DateTime.FromBinary%2A>是调用，该时间调整以使它有效。  
  
     例如，从标准时间转换为夏时制发生在美国在 2010 年 3 月 14 日凌晨 2:00，时间前进一小时，上午 3:00 到太平洋时区 此时间间隔是无效时间，即，该时区中不存在的时间间隔。 下面的示例演示，当范围内的时间此范围将被转换为二进制值通过<xref:System.DateTime.ToBinary%2A>方法，然后通过还原<xref:System.DateTime.FromBinary%2A>方法，原始值进行调整，以成为有效的时间。 你可以确定是否一个特定日期和时间值可能会遭受修改将其传递到<xref:System.TimeZoneInfo.IsInvalidTime%2A?displayProperty=nameWithType>方法，与示例演示。  
  
     [!code-csharp[System.DateTime.FromBinary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.frombinary/cs/frombinary1.cs#1)]
     [!code-vb[System.DateTime.FromBinary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.frombinary/vb/frombinary1.vb#1)]  
  
## <a name="version-considerations"></a>版本注意事项  
 从.NET Framework 2.0 版中，开始<xref:System.DateTime>结构组成的私有类型字段，该值指示指定的时间值基于本地时间、 协调世界时 (UTC) 还是既不和一个专用的计时周期字段，其中包含指定的日期和时间的 100 毫微秒计时周期数。 可通过访问 Ticks 字段<xref:System.DateTime.Ticks%2A>属性和类型的字段可通过访问<xref:System.DateTime.Kind%2A>属性。  
  
 在.NET Framework 2.0 中，如果你序列化之前<xref:System.DateTime>对象手动而不是使用序列化接口如<xref:System.Runtime.Serialization.ISerializable?displayProperty=nameWithType>，仅需序列化中的计时周期数据<xref:System.DateTime>结构。 从 2.0 版开始，你还必须序列化类型的数据。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTime.FromBinary(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="Today">
      <MemberSignature Language="C#" Value="public static DateTime Today { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.DateTime Today" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Today" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Today As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property DateTime Today { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前日期。</summary>
        <value>一个对象，设置为当天日期，其时间组成部分设置为 00:00:00。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从.NET Framework 2.0 版开始，则返回值是<xref:System.DateTime>其<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTimeKind.Local>。  
  
 因为它返回无当前时间，当前日期<xref:System.DateTime.Today%2A>属性是适合在仅使用日期的应用程序中使用。 有关详细信息，请参阅[选择之间 DateTime、 DateTimeOffset、 TimeSpan 和 TimeZoneInfo](~/docs/standard/datetime/choosing-between-datetime.md)。 与此相反，<xref:System.DateTime.TimeOfDay%2A>属性返回当前日期，未的当前时间和<xref:System.DateTime.Now%2A>属性返回当前日期和当前时间。  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.Date%2A>属性来检索当前日期。 它还阐释如何<xref:System.DateTime>可使用某些标准日期和时间格式字符串的格式设置值。 请注意，输出生成到第三个调用<xref:System.DateTime.ToString%28System.String%29>方法使用 g 格式说明符来包括时间组件，它是零。  
  
 [!code-csharp[System.DateTime.Today#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Today/cs/Today1.cs#1)]
 [!code-vb[System.DateTime.Today#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Today/vb/Today1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTime.Now" />
        <altmember cref="P:System.DateTime.TimeOfDay" />
      </Docs>
    </Member>
    <Member MemberName="ToFileTime">
      <MemberSignature Language="C#" Value="public long ToFileTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToFileTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToFileTime" />
      <MemberSignature Language="VB.NET" Value="Public Function ToFileTime () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToFileTime();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为 Windows 文件时间。</summary>
        <returns>表示为 Windows 文件时间的当前 <see cref="T:System.DateTime" /> 对象的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 文件时间是 64 位值，表示第午夜 12:00 到公元 1601 年 1 月 1 日以来经过的 100 毫微秒隔数 (C.E.)协调世界时 (UTC)。 Windows 使用的文件时间应用程序创建、 访问，或将写入文件时进行记录。  
  
 <xref:System.DateTime.ToFileTime%2A>方法使用<xref:System.DateTime.Kind%2A>属性来确定是否当前<xref:System.DateTime>对象是本地时间、 UTC 时间或一个未指定的类型的时间被视为本地时间。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.ToFileTime%2A>方法。  
  
 [!code-cpp[DateTime.ToFileTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.ToFileTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.ToFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToFileTime/CS/class1.cs#1)]
 [!code-vb[DateTime.ToFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToFileTime/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">所生成的文件时间将表示公元 1601 年 1 月 1 日午夜 12:00 之前的日期和时间。 UTC。</exception>
        <block subset="none" type="usage">
          <para>通常，<see cref="M:System.DateTime.FromFileTime(System.Int64)" />方法还原<see cref="T:System.DateTime" />保存的值<see cref="M:System.DateTime.ToFileTime" />方法。 但是，在以下情况下可能与不同的两个值：  
  
-   如果序列化和反序列化<see cref="T:System.DateTime" />值出现在不同时区。 例如，如果<see cref="T:System.DateTime" />时间为下午 12:30 的值 在美国美国东部时间区域的序列化，并在美国然后反序列化太平洋时区，中午 12:30 的原始值 调整到上午 9:30 以反映两个时区之间的差异。  
  
-   如果<see cref="T:System.DateTime" />序列化的值表示本地时区的时间无效。 在这种情况下，<see cref="M:System.DateTime.ToFileTime" />方法调整还原<see cref="T:System.DateTime" />值，使其本地时区表示有效的时间。  
  
     例如，从标准时间转换为夏时制发生在美国在 2010 年 3 月 14 日凌晨 2:00，时间前进一小时，上午 3:00 到太平洋时区 此时间间隔是无效时间，即，该时区中不存在的时间间隔。 下面的示例演示，当范围内的时间此范围将被转换为长整型值通过<see cref="M:System.DateTime.ToFileTime" />方法，然后通过还原<see cref="M:System.DateTime.FromFileTime(System.Int64)" />方法，原始值进行调整，以成为有效的时间。 你可以确定是否一个特定日期和时间值可能会遭受修改将其传递到<see cref="M:System.TimeZoneInfo.IsInvalidTime(System.DateTime)" />方法，与示例演示。  
  
     [!code-csharp[System.DateTime.FromFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.fromfiletime/cs/fromfiletime1.cs#1)]
     [!code-vb[System.DateTime.FromFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.fromfiletime/vb/fromfiletime1.vb#1)]</para>
        </block>
        <altmember cref="M:System.DateTime.ToFileTimeUtc" />
        <altmember cref="T:System.Int64" />
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="ToFileTimeUtc">
      <MemberSignature Language="C#" Value="public long ToFileTimeUtc ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToFileTimeUtc() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToFileTimeUtc" />
      <MemberSignature Language="VB.NET" Value="Public Function ToFileTimeUtc () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToFileTimeUtc();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为 Windows 文件时间。</summary>
        <returns>表示为 Windows 文件时间的当前 <see cref="T:System.DateTime" /> 对象的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 文件时间是 64 位值，表示第午夜 12:00 到公元 1601 年 1 月 1 日以来经过的 100 毫微秒隔数 (C.E.)协调世界时 (UTC)。 Windows 使用的文件时间应用程序创建、 访问，或将写入文件时进行记录。  
  
 <xref:System.DateTime.ToFileTimeUtc%2A>方法使用<xref:System.DateTime.Kind%2A>属性来确定是否当前<xref:System.DateTime>对象是本地时间、 UTC 时间或一个未指定的类型的时间被视为 UTC 时间。 如果是本地时间，它将时间转换为 UTC 之前执行为 Windows 文件时间转换。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">所生成的文件时间将表示公元 1601 年 1 月 1 日午夜 12:00 之前的日期和时间。 UTC。</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTime.ToFileTimeUtc" />方法有时用于将本地时间转换为 UTC，并随后通过调用来还原该<see cref="M:System.DateTime.FromFileTimeUtc(System.Int64)" />方法跟<see cref="M:System.DateTime.ToLocalTime" />方法。 但是，如果使用原始时间表示本地时区的时间无效，则两个本地时间值将不相等。 有关其他信息，请参阅<see cref="M:System.DateTime.ToLocalTime" />方法。</para>
        </block>
        <altmember cref="M:System.DateTime.ToFileTime" />
        <altmember cref="T:System.Int64" />
        <altmember cref="M:System.DateTime.ToUniversalTime" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="ToLocalTime">
      <MemberSignature Language="C#" Value="public DateTime ToLocalTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime ToLocalTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToLocalTime" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLocalTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime ToLocalTime();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为本地时间。</summary>
        <returns>一个对象，其 <see cref="P:System.DateTime.Kind" /> 属性为 <see cref="F:System.DateTimeKind.Local" />，并且其值为等效于当前 <see cref="T:System.DateTime" /> 对象的值的本地时间；如果经转换的值过大以至于不能由 <see cref="F:System.DateTime.MaxValue" /> 对象表示，则为 <see cref="T:System.DateTime" />，或者，如果经转换的值过小以至于不能表示为 <see cref="F:System.DateTime.MinValue" /> 对象，则为 <see cref="T:System.DateTime" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本地时间等于的协调世界时 (UTC) 时间加上 UTC 偏移量。 有关的 UTC 偏移量的详细信息，请参阅<xref:System.TimeZone.GetUtcOffset%2A?displayProperty=nameWithType>。 转换还会考虑夏时制规则适用于由当前所表示的时间<xref:System.DateTime>对象。  
  
> [!IMPORTANT]
>  上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统，<xref:System.DateTime.ToLocalTime%2A>方法识别只将当前的调整规则，而从 UTC 转换为本地时间时。 因此，当前的调整规则生效之前的转换可能不准确地反映 UTC 和当地时间之间的差异。  
  
 从.NET Framework 2.0 版中，返回的值开始<xref:System.DateTime.ToLocalTime%2A>方法通过确定<xref:System.DateTime.Kind%2A>属性的当前<xref:System.DateTime>对象。 下表描述了可能的结果。  
  
|类型|结果|  
|----------|-------------|  
|<xref:System.DateTimeKind.Utc>|此实例<xref:System.DateTime>转换为本地时间。|  
|<xref:System.DateTimeKind.Local>|不执行任何转换。|  
|<xref:System.DateTimeKind.Unspecified>|此实例<xref:System.DateTime>被假定为 UTC 时间，并执行转换就像<xref:System.DateTime.Kind%2A>已<xref:System.DateTimeKind.Utc>。|  
  
> [!NOTE]
>  <xref:System.DateTime.ToLocalTime%2A>方法将<xref:System.DateTime>为本地时间而从 UTC 值。 若要将任何指定的时区的时间转换为本地时间，使用<xref:System.TimeZoneInfo.ConvertTime%2A?displayProperty=nameWithType>方法。  
  
 返回转换的值是<xref:System.DateTime>其<xref:System.DateTime.Kind%2A>属性始终返回<xref:System.DateTimeKind.Local>。 因此，返回有效的结果即使<xref:System.DateTime.ToLocalTime%2A>重复应用于相同<xref:System.DateTime>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.ToLocalTime%2A>方法。 请注意，准确的输出取决于当前的区域性和运行它的系统的本地时区。  
  
 [!code-cpp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CS/class1.cs#1)]
 [!code-vb[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/VB/class1.vb#1)]  
  
 下面的示例使用<xref:System.DateTime.SpecifyKind%2A>方法演示如何<xref:System.DateTime.Kind%2A>属性影响<xref:System.DateTime.ToLocalTime%2A>和<xref:System.DateTime.ToUniversalTime%2A>转换方法。  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>你可以使用<see cref="M:System.DateTime.ToLocalTime" />方法，使还原的本地日期和时间值，已转换为 UTC<see cref="M:System.DateTime.ToUniversalTime" />或<see cref="M:System.DateTime.FromFileTimeUtc(System.Int64)" />方法。 但是，如果使用原始时间表示本地时区的时间无效，它将不还原与值匹配。 当<see cref="M:System.DateTime.ToLocalTime" />方法将时间转换为 utc 时区，它也会使其成为有效的时间调整本地时区。  
  
 例如，从标准时间转换为夏时制发生在美国在 2010 年 3 月 14 日凌晨 2:00，时间前进一小时，上午 3:00 到太平洋时区 此时间间隔是无效时间，即，该时区中不存在的时间间隔。 下面的示例演示，当范围内的时间此范围将被转换为 UTC<see cref="M:System.DateTime.ToUniversalTime" />方法，然后通过还原<see cref="M:System.DateTime.ToLocalTime" />方法，原始值进行调整，以成为有效的时间。 你可以确定是否一个特定日期和时间值可能会遭受修改将其传递到<see cref="M:System.TimeZoneInfo.IsInvalidTime(System.DateTime)" />方法，与示例演示。  
  
 [!code-csharp[System.DateTime.ToLocalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tolocaltime/cs/tolocaltime1.cs#1)]
 [!code-vb[System.DateTime.ToLocalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tolocaltime/vb/tolocaltime1.vb#1)]</para>
        </block>
        <altmember cref="T:System.TimeZone" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
        <altmember cref="M:System.TimeZone.GetDaylightChanges(System.Int32)" />
        <altmember cref="M:System.DateTime.ToUniversalTime" />
      </Docs>
    </Member>
    <Member MemberName="ToLongDateString">
      <MemberSignature Language="C#" Value="public string ToLongDateString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLongDateString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToLongDateString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLongDateString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLongDateString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为其等效的长日期字符串表示形式。</summary>
        <returns>一个字符串，它包含当前 <see cref="T:System.DateTime" /> 对象的长日期字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前值<xref:System.DateTime>对象格式都是使用定义的模式<xref:System.Globalization.DateTimeFormatInfo.LongDatePattern%2A>与当前线程区域性关联的属性。 返回值是通过指定"D"返回的值相同[标准 DateTime 格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)与<xref:System.DateTime.ToString%28System.String%29>方法。  
  
> [!IMPORTANT]
>  返回的字符串<xref:System.DateTime.ToLongDateString%2A>方法是区分区域性的。 它反映当前区域性定义的模式<xref:System.Globalization.DateTimeFormatInfo>对象。 例如，对于 EN-US 区域性，标准的长日期模式为"dddd，MMMMdd，yyyy";对于 DE-DE 区域性中，它为"dddd，d。 MMMMyyyy";对于 JA-JP 区域性，它是"yyyy？M？d'？ '"。 特定计算机上的特定的格式字符串可以还自定义，以便它不同于标准的长日期格式字符串。  
  
 有关当前线程区域性的详细信息，请参阅<xref:System.Threading.Thread.CurrentCulture%2A>属性。 它们将生成有关格式字符、 格式模式和输出的详细信息，请参阅[格式化类型](~/docs/standard/base-types/formatting-types.md)主题。 有关更改与格式字符关联的格式模式的详细信息，请参阅<xref:System.Globalization.DateTimeFormatInfo>类。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.ToLongDateString%2A>方法。  
  
 [!code-csharp[DateTime.ToShortLongString#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToShortLongString/cs/sls.cs#1)]
 [!code-vb[DateTime.ToShortLongString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToShortLongString/vb/sls.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
      </Docs>
    </Member>
    <Member MemberName="ToLongTimeString">
      <MemberSignature Language="C#" Value="public string ToLongTimeString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLongTimeString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToLongTimeString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLongTimeString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLongTimeString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为其等效的长时间字符串表示形式。</summary>
        <returns>一个字符串，它包含当前 <see cref="T:System.DateTime" /> 对象的长时间字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前值<xref:System.DateTime>对象格式都是使用定义的模式<xref:System.Globalization.DateTimeFormatInfo.LongTimePattern%2A?displayProperty=nameWithType>与当前线程区域性关联的属性。 返回值是通过指定"T"返回的值相同[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)与<xref:System.DateTime.ToString%28System.String%29>方法。  
  
> [!IMPORTANT]
>  返回的字符串<xref:System.DateTime.ToLongTimeString%2A>方法是区分区域性的。 它反映定义的模式<xref:System.Globalization.DateTimeFormatInfo.LongTimePattern%2A>属性的当前区域性的<xref:System.Globalization.DateTimeFormatInfo>对象。 例如，对于 EN-US 区域性，标准长时间模式为"h:mm: ss tt";对于 DE-DE 区域性中，它是"hh: mm:";对于 JA-JP 区域性，它是"h:mm: ss"。 特定计算机上的特定的格式字符串可以还自定义，以便它不同于标准长时间格式字符串。  
  
 有关当前线程区域性的详细信息，请参阅<xref:System.Threading.Thread.CurrentCulture%2A>属性。 它们将生成有关格式字符、 格式模式和输出的详细信息，请参阅[格式化类型](~/docs/standard/base-types/formatting-types.md)主题。 有关更改与格式字符关联的格式模式的详细信息，请参阅<xref:System.Globalization.DateTimeFormatInfo>类。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.ToLongTimeString%2A>方法。  
  
 [!code-csharp[System.DateTime.ToLongTimeString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tolongtimestring/cs/sls.cs#1)]
 [!code-vb[System.DateTime.ToLongTimeString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tolongtimestring/vb/sls.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
      </Docs>
    </Member>
    <Member MemberName="ToOADate">
      <MemberSignature Language="C#" Value="public double ToOADate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 ToOADate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToOADate" />
      <MemberSignature Language="VB.NET" Value="Public Function ToOADate () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double ToOADate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此实例的值转换为等效的 OLE 自动化日期。</summary>
        <returns>一个双精度浮点数，它包含与此实例的值等效的 OLE 自动化日期。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 其必不可少的组成部分是之前或之后 30 年 12 月 1899 年 12，午夜天数，其小数部分表示时间除以 24 该天的浮点数作为实现的 OLE 自动化日期。 例如，午夜，1899 年 12 月 31 日表示 1.0;上午 6，1900 年 1 月 1 表示通过 2.25;午夜，由-1.0; 表示 29 1899 年 12 月上午 6，1899 年 12 月 29 由-1.25。  
  
 基的 OLE 自动化日期是 1899 年 12 月 30 日午夜。 最小的 OLE 自动化日期是午夜，1 年 1 月 0100年。 最大的 OLE 自动化日期等同于<xref:System.DateTime.MaxValue?displayProperty=nameWithType>、 31 年 12 月的最后时刻 9999。  
  
 <xref:System.DateTime.ToOADate%2A>方法抛出异常<xref:System.OverflowException>如果当前实例表示的日期晚于<xref:System.DateTime.MinValue>，但早于 0100 January1，午夜。 但是，如果当前实例的值是<xref:System.DateTime.MinValue>，该方法返回 0。  
  
 有关 OLE 自动化的详细信息，请参阅[MSDN 库](http://go.microsoft.com/fwlink/?linkid=37118)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">此实例的值无法表示为 OLE 自动化日期。</exception>
        <altmember cref="T:System.Double" />
        <altmember cref="M:System.DateTime.FromOADate(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="ToShortDateString">
      <MemberSignature Language="C#" Value="public string ToShortDateString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToShortDateString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToShortDateString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToShortDateString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToShortDateString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为其等效的短日期字符串表示形式。</summary>
        <returns>一个字符串，它包含当前 <see cref="T:System.DateTime" /> 对象的短日期字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前值<xref:System.DateTime>对象格式都是使用定义的模式<xref:System.Globalization.DateTimeFormatInfo.ShortDatePattern%2A?displayProperty=nameWithType>与当前线程区域性关联的属性。 返回值是通过指定"d"返回的值相同[标准 DateTime 格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)与<xref:System.DateTime.ToString%28System.String%29>方法。  
  
> [!IMPORTANT]
>  返回的字符串<xref:System.DateTime.ToShortDateString%2A>方法是区分区域性的。 它反映当前区域性定义的模式<xref:System.Globalization.DateTimeFormatInfo>对象。 例如，对于 EN-US 区域性，标准的短日期模式为"年-/ yyyy";对于 DE-DE 区域性中，它是"dd。MM.yyyy";对于 JA-JP 区域性，它是"yyyy/M/d"。 特定计算机上的特定的格式字符串可以还自定义，以便它不同于标准短日期格式字符串。  
  
 有关当前线程区域性的详细信息，请参阅<xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>属性。 它们将生成有关格式字符、 格式模式和输出的详细信息，请参阅[格式化类型](~/docs/standard/base-types/formatting-types.md)主题。 有关更改与格式字符关联的格式模式的详细信息，请参阅<xref:System.Globalization.DateTimeFormatInfo>类。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.ToShortDateString%2A>方法。 它还演示调用<xref:System.DateTime.ToShortDateString%2A>方法相当于调用<xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType>方法替换为该格式参数的"d"。  
  
 [!code-csharp[System.DateTime.ToShortDateString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToShortDateString/cs/ToShortDateString.cs#1)]
 [!code-vb[System.DateTime.ToShortDateString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToShortDateString/vb/ToShortDateString.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
      </Docs>
    </Member>
    <Member MemberName="ToShortTimeString">
      <MemberSignature Language="C#" Value="public string ToShortTimeString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToShortTimeString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToShortTimeString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToShortTimeString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToShortTimeString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为其等效的短时间字符串表示形式。</summary>
        <returns>一个字符串，它包含当前 <see cref="T:System.DateTime" /> 对象的短时间字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前值<xref:System.DateTime>对象格式都是使用定义的模式<xref:System.Globalization.DateTimeFormatInfo.ShortTimePattern%2A?displayProperty=nameWithType>与当前线程区域性关联的属性。 返回值是通过指定"t"返回的值相同[标准 DateTime 格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)与<xref:System.DateTime.ToString%28System.String%29>方法。  
  
> [!IMPORTANT]
>  返回的字符串<xref:System.DateTime.ToShortTimeString%2A>方法是区分区域性的。 它反映当前区域性定义的模式<xref:System.Globalization.DateTimeFormatInfo>对象。 例如，对于 EN-US 区域性，标准短时间模式为"h:mm tt";对于 DE-DE 区域性中，它是"hh: mm";对于 JA-JP 区域性，它是"H:mm"。 特定计算机上的特定的格式字符串可以还自定义，以便它不同于标准短时间格式字符串。  
  
 有关当前线程区域性的详细信息，请参阅<xref:System.Threading.Thread.CurrentCulture%2A>属性。 它们将生成有关格式字符、 格式模式和输出的详细信息，请参阅[格式化类型](~/docs/standard/base-types/formatting-types.md)主题。 有关更改与格式字符关联的格式模式的详细信息，请参阅<xref:System.Globalization.DateTimeFormatInfo>类。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.ToShortTimeString%2A>方法。  
  
 [!code-csharp[DateTime.ToShortLongString#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToShortLongString/cs/sls.cs#1)]
 [!code-vb[DateTime.ToShortLongString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToShortLongString/vb/sls.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="P:System.Globalization.CultureInfo.DateTimeFormat" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="M:System.DateTime.ToString" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为其等效的字符串表示形式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用当前的区域性格式约定将当前 <see cref="T:System.DateTime" /> 对象的值转换为它的等效字符串表示形式。</summary>
        <returns>当前 <see cref="T:System.DateTime" /> 对象的值的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前值<xref:System.DateTime>对象格式都是使用常规日期和时间格式说明符 (G)。 若要设置其使用的特定日期和时间格式说明符的格式，调用<xref:System.DateTime.ToString%28System.String%29>方法。 若要设置其特定区域性使用的常规日期和时间格式说明符 (G) 格式，调用<xref:System.DateTime.ToString%28System.IFormatProvider%29>方法。 若要设置其使用特定的日期和时间格式说明符和特定区域性的约定格式，调用<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29>方法。  
  
 此方法使用派生自当前区域性的格式设置信息。 具体而言，它还将返回自定义格式字符串组合<xref:System.Globalization.DateTimeFormatInfo.ShortDatePattern%2A>和<xref:System.Globalization.DateTimeFormatInfo.LongTimePattern%2A>属性<xref:System.Globalization.DateTimeFormatInfo>返回对象`Thread.CurrentThread.CurrentCulture.DateTimeFormat`属性。 有关详情，请参阅<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>。 其他重载<xref:System.DateTime.ToString%2A>方法使您能够指定区域性的格式设置的使用以及定义的输出模式<xref:System.DateTime>值。  
  
   
  
## Examples  
 下面的示例演示如何的字符串表示形式<xref:System.DateTime>返回值<xref:System.DateTime.ToString>方法取决于线程的当前区域性。 它为 FR-FR 为 JA-JP 从 EN-US 更改当前线程区域性。 在每种情况下调用<xref:System.DateTime.ToString>方法返回的字符串表示形式使用该区域性的日期和时间值。  
  
 [!code-csharp[System.DateTime.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.DateTime.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">此日期和时间超出了当前区域性所用日历支持的日期范围。</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTime.ToString" />方法使用当前区域性的日历中返回的字符串表示形式的日期和时间。 如果当前的值<see cref="T:System.DateTime" />实例是早于<see cref="P:System.Globalization.Calendar.MinSupportedDateTime" />或晚于<see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />，该方法将引发<see cref="T:System.ArgumentOutOfRangeException" />。 下面的示例进行了这方面的演示。 它会尝试设置日期超出范围的格式<see cref="T:System.Globalization.HijriCalendar" />类时的当前区域性为阿拉伯语 （叙利亚）。  
  
 [!code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception2.cs#2)]
 [!code-vb[System.DateTime.ToString.ArgumentOutOfRangeException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/datetime.tostring.argumentoutofrangeexception2.vb#2)]</para>
        </block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <summary>使用指定的区域性特定格式信息将当前 <see cref="T:System.DateTime" /> 对象的值转换为它的等效字符串表示形式。</summary>
        <returns>由 <see cref="T:System.DateTime" /> 指定的当前 <paramref name="provider" /> 对象的值的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前值<xref:System.DateTime>对象格式都是使用常规日期和时间格式说明符 (G)，使用短日期模式和长时间模式的输出格式设置。  
  
 短日期和长时间模式的格式由定义`provider`参数。 `provider`参数可以是任何以下：  
  
-   A<xref:System.Globalization.CultureInfo>代表其格式设置约定才会反映在返回的字符串的区域性的对象。 <xref:System.Globalization.DateTimeFormatInfo>返回对象<xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType>属性定义返回字符串的格式。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>定义的日期和时间数据格式的对象。  
  
-   实现一个自定义对象<xref:System.IFormatProvider>接口。 其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.DateTimeFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`、<xref:System.Globalization.DateTimeFormatInfo>使用与当前区域性关联的对象。 有关详情，请参阅<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例显示的字符串表示形式的日期和时间使用<xref:System.Globalization.CultureInfo>表示五种不同区域性的对象。  
  
 [!code-csharp[System.DateTime.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/ToString4.cs#3)]
 [!code-vb[System.DateTime.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/ToString4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">日期和时间处于由 <paramref name="provider" /> 使用的日历支持的日期范围之外。</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTime.ToString(System.IFormatProvider)" />方法代表的区域性所使用的日历中返回的字符串表示形式的日期和时间<paramref name="provider" />参数。 由定义其日历<see cref="P:System.Globalization.DateTimeFormatInfo.Calendar" />属性。 如果当前的值<see cref="T:System.DateTime" />实例是早于<see cref="P:System.Globalization.Calendar.MinSupportedDateTime" />或晚于<see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />，该方法将引发<see cref="T:System.ArgumentOutOfRangeException" />。 下面的示例进行了这方面的演示。 它会尝试设置日期超出范围的格式<see cref="T:System.Globalization.JapaneseCalendar" />类。  
  
 [!code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception1.cs#1)]
 [!code-vb[System.DateTime.ToString.ArgumentOutOfRangeException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/datetime.tostring.argumentoutofrangeexception1.vb#1)]</para>
        </block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">标准或自定义日期和时间格式字符串。</param>
        <summary>使用指定的格式和当前区域性的格式约定将当前 <see cref="T:System.DateTime" /> 对象的值转换为它的等效字符串表示形式。</summary>
        <returns>由 <see cref="T:System.DateTime" /> 指定的当前 <paramref name="format" /> 对象的值的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.ToString%28System.String%29>方法返回的字符串表示形式的日期和时间值以使用当前区域性; 有关详细信息的格式设置约定的特定格式中，请参阅<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>。  
  
 `format`参数应包含单个格式说明符 (请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)) 或自定义格式模式 (请参阅[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md))，它定义返回字符串的格式。 如果`format`是`null`或空字符串，使用常规格式说明符，G，则使用。  
  
 此方法的一些用途包括：  
  
-   获取一个字符串在当前区域性的短日期和时间格式显示日期和时间。 若要执行此操作，你可以使用"G"格式说明符。  
  
-   获取一个字符串包含仅在月份和年份。 若要执行此操作，你可以使用"MM/yyyy"格式字符串。 格式字符串使用当前区域性的日期分隔符。  
  
-   获取一个字符串包含的日期和时间以特定的格式。 例如，"MM/dd/yyyyHH:mm"格式字符串以固定格式显示日期和时间字符串如"19 的 / 03 / / 2013年 18:06"。 格式字符串使用"/"作为固定的日期分隔符，而不考虑特定于区域性的设置。  
  
-   可用于序列化的日期字符串获取压缩格式的日期。 例如，"yyyyMMdd"格式字符串显示两位数月份和两位数日期跟带没有日期分隔符的四位数年份。  
  
 下面的示例使用这三个格式字符串来显示日期和时间值，通过使用 EN-US 和 FR-FR 区域性的约定。  
  
 [!code-csharp[System.DateTime.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/tostring5.cs#5)]
 [!code-vb[System.DateTime.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/tostring5.vb#5)]  
  
   
  
## Examples  
 下面的示例使用每个标准日期和时间格式字符串和选定的自定义日期和时间格式字符串来显示的字符串表示形式<xref:System.DateTime>值。 例如当前区域性为 EN-US。  
  
 [!code-csharp[System.DateTime.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/ToString2.cs#2)]
 [!code-vb[System.DateTime.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/ToString2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 的长度是 1，并且它不是为 <see cref="T:System.Globalization.DateTimeFormatInfo" /> 定义的格式说明符之一。  
  
 或  
  
 <paramref name="format" /> 中不包含有效的自定义格式模式。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">此日期和时间超出了当前区域性所用日历支持的日期范围。</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTime.ToString(System.String)" />方法使用当前区域性的日历中返回的字符串表示形式的日期和时间。 如果当前的值<see cref="T:System.DateTime" />实例是早于<see cref="P:System.Globalization.Calendar.MinSupportedDateTime" />或晚于<see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />，该方法将引发<see cref="T:System.ArgumentOutOfRangeException" />。 下面的示例进行了这方面的演示。 它会尝试设置日期超出范围的格式<see cref="T:System.Globalization.HebrewCalendar" />类的当前区域性时希伯来语 （以色列）。  
  
 [!code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception3.cs#3)]
 [!code-vb[System.DateTime.ToString.ArgumentOutOfRangeException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/datetime.tostring.argumentoutofrangeexception3.vb#3)]</para>
        </block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">标准或自定义日期和时间格式字符串。</param>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <summary>使用指定的格式和区域性特定格式信息将当前 <see cref="T:System.DateTime" /> 对象的值转换为它的等效字符串表示形式。</summary>
        <returns>由 <see cref="T:System.DateTime" /> 和 <paramref name="format" /> 指定的当前 <paramref name="provider" /> 对象的值的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `format`参数可以包含单个格式说明符 (请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)) 或自定义格式模式 (请参阅[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md))。 如果`format`是`null`或空字符串 ("")，使用标准格式说明符，"G"。  
  
 `provider`参数定义的标准格式说明符，以及符号和日期和时间的组件的名称相对应的模式。 `provider`参数可以是任何以下：  
  
-   A<xref:System.Globalization.CultureInfo>代表其格式设置约定才会反映在返回的字符串的区域性的对象。 <xref:System.Globalization.DateTimeFormatInfo>返回对象<xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType>属性定义返回字符串的格式。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>定义的日期和时间数据格式的对象。  
  
-   实现一个自定义对象<xref:System.IFormatProvider>接口。 其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.DateTimeFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`、<xref:System.Globalization.DateTimeFormatInfo>关联与当前使用区域性。 有关详情，请参阅<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 以下示例使用每个标准日期时间格式字符串来显示的字符串表示形式的日期和时间为四个不同的区域性。  
  
 [!code-csharp[System.DateTime.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.ToString/cs/tostring3.cs#4)]
 [!code-vb[System.DateTime.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.ToString/vb/tostring3.vb#4)]  
  
 下面的示例演示的格式设置的不同方式<xref:System.DateTime>值使用固定<xref:System.Globalization.DateTimeFormatInfo>。  
  
 [!code-cpp[Classic DateTime.ToString2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic DateTime.ToString2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DateTime.ToString2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic DateTime.ToString2 Example/CS/source.cs#1)]
 [!code-vb[Classic DateTime.ToString2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic DateTime.ToString2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 的长度是 1，并且它不是为 <see cref="T:System.Globalization.DateTimeFormatInfo" /> 定义的格式说明符之一。  
  
 或  
  
 <paramref name="format" /> 中不包含有效的自定义格式模式。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">日期和时间处于由 <paramref name="provider" /> 使用的日历支持的日期范围之外。</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTime.ToString(System.String,System.IFormatProvider)" />方法返回的字符串表示形式的日期和时间中使用的日历<paramref name="provider" />参数。 由定义其日历<see cref="P:System.Globalization.DateTimeFormatInfo.Calendar" />属性。 如果当前的值<see cref="T:System.DateTime" />实例是早于<see cref="P:System.Globalization.Calendar.MinSupportedDateTime" />或晚于<see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />，该方法将引发<see cref="T:System.ArgumentOutOfRangeException" />。 下面的示例进行了这方面的演示。 它会尝试设置日期超出范围的格式<see cref="T:System.Globalization.UmAlQuraCalendar" />类。  
  
 [!code-csharp[System.DateTime.ToString.ArgumentOutOfRangeException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/cs/datetime.tostring.argumentoutofrangeexception4.cs#4)]
 [!code-vb[System.DateTime.ToString.ArgumentOutOfRangeException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.tostring.argumentoutofrangeexception/vb/datetime.tostring.argumentoutofrangeexception4.vb#4)]</para>
        </block>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="ToUniversalTime">
      <MemberSignature Language="C#" Value="public DateTime ToUniversalTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime ToUniversalTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.ToUniversalTime" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUniversalTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime ToUniversalTime();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前 <see cref="T:System.DateTime" /> 对象的值转换为协调世界时 (UTC)。</summary>
        <returns>一个对象，其 <see cref="P:System.DateTime.Kind" /> 属性为 <see cref="F:System.DateTimeKind.Utc" />，并且其值为等效于当前 <see cref="T:System.DateTime" /> 对象的值的 UTC；如果经转换的值过大以至于不能由 <see cref="F:System.DateTime.MaxValue" /> 对象表示，则为 <see cref="T:System.DateTime" />，或者，如果经转换的值过小以至于不能表示为 <see cref="F:System.DateTime.MinValue" /> 对象，则为 <see cref="T:System.DateTime" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 协调世界时 (UTC) 等于在本地时间的 UTC 偏移量。 有关的 UTC 偏移量的详细信息，请参阅<xref:System.TimeZone.GetUtcOffset%2A?displayProperty=nameWithType>。 转换还会考虑夏时制规则适用于由当前所表示的时间<xref:System.DateTime>对象。  
  
> [!IMPORTANT]
>  上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统，<xref:System.DateTime.ToUniversalTime%2A>方法识别只将当前的调整规则时将从本地时间转换为 UTC。 因此，当前的调整规则生效之前的转换可能不准确地反映 UTC 和当地时间之间的差异。  
  
 从.NET Framework 2.0 版中，返回的值开始<xref:System.DateTime.ToUniversalTime%2A>方法通过确定<xref:System.DateTime.Kind%2A>属性的当前<xref:System.DateTime>对象。 下表描述了可能的结果。  
  
|类型|结果|  
|----------|-------------|  
|<xref:System.DateTimeKind.Utc>|不执行任何转换。|  
|<xref:System.DateTimeKind.Local>|当前<xref:System.DateTime>对象转换为 UTC。|  
|<xref:System.DateTimeKind.Unspecified>|当前<xref:System.DateTime>对象被假定为本地时间，并执行转换就像<xref:System.DateTime.Kind%2A>已<xref:System.DateTimeKind.Local>。|  
  
> [!NOTE]
>  <xref:System.DateTime.ToUniversalTime%2A>方法将<xref:System.DateTime>从本地时间到 UTC 的值。 若要将时间转换为 UTC 非本地时间区域中，使用<xref:System.TimeZoneInfo.ConvertTimeToUtc%28System.DateTime%2CSystem.TimeZoneInfo%29?displayProperty=nameWithType>方法。 若要转换已知其相对于 UTC 的偏移量的时间，使用<xref:System.DateTimeOffset.ToUniversalTime%2A>方法。  
  
 日期和时间实例值是否不明确的时间，此方法假定它是标准时间。 （不明确的时间是指可以映射到标准时间或在本地时区的夏时制）如果日期和时间实例值是无效时间，则此方法只中减去从本地时区的 UTC 偏移量返回 UTC 本地时间。 （一个无效的时间是指不存在由于夏时制调整规则的应用程序。）  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.ToUniversalTime%2A>方法。  
  
 [!code-cpp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/cpp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CPP/class1.cpp#1)]
 [!code-csharp[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/CS/class1.cs#1)]
 [!code-vb[DateTime.ToLocalTime ToUniversalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.ToLocalTime ToUniversalTime/VB/class1.vb#1)]  
  
 下面的示例使用<xref:System.DateTime.SpecifyKind%2A>方法演示如何<xref:System.DateTime.Kind%2A>属性影响<xref:System.DateTime.ToLocalTime%2A>和<xref:System.DateTime.ToUniversalTime%2A>转换方法。  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTime.ToUniversalTime" />方法有时用来将本地时间转换为 UTC。 <see cref="M:System.DateTime.ToLocalTime" />然后调用方法来还原原始的本地时间。 但是，如果使用原始时间表示本地时区的时间无效，则两个本地时间值将不相等。 有关其他信息和示例，请参阅<see cref="M:System.DateTime.ToLocalTime" />方法。  
  
 上[!INCLUDE[winxp](~/includes/winxp-md.md)]系统，<see cref="M:System.DateTime.ToUniversalTime" />方法只会识别当前调整规则的本地时区，并将其应用于所有日期，包括低级别日期 （即日期早于当前调整的开始日期规则）。 在上运行的应用程序[!INCLUDE[winxp](~/includes/winxp-md.md)]它要求从历史上看准确的本地日期和时间计算必须要解决此行为，通过使用<see cref="M:System.TimeZoneInfo.FindSystemTimeZoneById(System.String)" />方法来检索<see cref="T:System.TimeZoneInfo" />对象，它对应于本地时区，并调用其<see cref="M:System.TimeZoneInfo.ConvertTimeToUtc(System.DateTime,System.TimeZoneInfo)" />方法。  
  
 下面的示例演示之间的差异<see cref="M:System.DateTime.ToUniversalTime" />和<see cref="M:System.TimeZoneInfo.ConvertTimeToUtc(System.DateTime,System.TimeZoneInfo)" />方法[!INCLUDE[winxp](~/includes/winxp-md.md)]在美国的系统。 第一个的两个方法调用适用于 2006 年的日期的当前时区调整规则 （2007 年开始生效）。 当前的调整规则提供转换为夏时制的年 3 月; 第二个星期日上一个规则，实际上已在 2006 年，提供有关转换为夏时制在年 4 月的第一个星期日发生。 仅在第三个方法调用准确地执行此历史日期和时间转换。  
  
 [!code-csharp[System.DateTime.ToUniversalTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetime.touniversaltime/cs/touniversaltime.cs#1)]
 [!code-vb[System.DateTime.ToUniversalTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetime.touniversaltime/vb/touniversaltime.vb#1)]</para>
        </block>
        <altmember cref="M:System.DateTime.ToLocalTime" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将日期和时间的指定字符串表示形式转换为其 <see cref="T:System.DateTime" /> 等效项，并返回一个指示转换是否成功的值。</summary>
        <altmember cref="Overload:System.DateTime.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.ReadOnlySpan{System.Char},System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.String,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。</param>
        <param name="result">当此方法返回时，如果转换成功，则包含与 <c>s</c> 中包含的日期和时间等效的 <see cref="T:System.DateTime" /> 值；如果转换失败，则为 <see cref="F:System.DateTime.MinValue" />。 如果 <c>s</c> 参数为 <see langword="null" />，是空字符串 ("") 或者不包含日期和时间的有效字符串表示形式，则转换失败。 此参数未经初始化即被传递。</param>
        <summary>将日期和时间的指定字符串表示形式转换为其 <see cref="T:System.DateTime" /> 等效项，并返回一个指示转换是否成功的值。</summary>
        <returns>
          如果 <paramref name="s" /> 参数成功转换，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法类似于是<xref:System.DateTime.Parse%28System.String%29?displayProperty=nameWithType>方法，只不过<xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29>方法不会引发异常，如果转换失败。  
  
 字符串`s`分析在当前使用的格式设置信息<xref:System.Globalization.DateTimeFormatInfo>对象，它由当前线程区域性隐式提供。  
  
 如果可能，此方法尝试忽略无法识别的数据，并填写缺少的月、 日和年信息与当前日期。 如果`s`包含仅日期而没有时间，此方法假设时间为午夜 12:00。 如果`s`包括日期部分的两位数年份，它将转换为基于值的当前区域性的当前日历中每一年<xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType>属性。 任何前导、 内部或尾随空格字符中的`s`将被忽略。 日期和时间可以使用一对前导空格和尾随数字标记字符 （#，U + 0023），括起来，并可以尾随一个或多个 NULL 字符 (U + 0000)。  
  
 因为<xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法尝试分析的字符串表示形式的日期和时间使用当前区域性，尝试跨不同区域性中分析特定字符串的格式设置规则可失败或返回不同的结果。 如果要跨不同的区域设置分析特定日期和时间格式，使用<xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法或的重载之一<xref:System.DateTime.TryParseExact%2A>方法并提供的格式说明符。  
  
 如果`s`是闰日闰年中当前日历，方法分析中的字符串表示`s`成功。 如果`s`的字符串表示形式闰日中非-闰年中当前区域性的当前日历，分析操作将失败，该方法返回`false`。  
  
 如果`s`不包含任何时区信息，`result`包含<xref:System.DateTime>值其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>方法返回时。 如果要分析的字符串包含时区信息`result`包含<xref:System.DateTime>值其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>方法返回时。  
  
   
  
## Examples  
 下面的示例传入大量的日期和时间字符串转换为<xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法。  
  
 [!code-cpp[System.DateTime.TryParse#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.TryParse/cpp/datetime.tryparse1.cpp#1)]
 [!code-csharp[System.DateTime.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParse/cs/TryParse1.cs#1)]
 [!code-vb[System.DateTime.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParse/vb/TryParse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>格式化受当前的属性<see cref="T:System.Globalization.DateTimeFormatInfo" />对象，它们的默认值派生自**区域和语言选项**控制面板中的项。 <see cref="Overload:System.DateTime.TryParse" />方法可以意外失败，返回<see langword="False" />如果当前<see cref="P:System.Globalization.DateTimeFormatInfo.DateSeparator" />和<see cref="P:System.Globalization.DateTimeFormatInfo.TimeSeparator" />属性设置为相同的值。</para>
        </block>
        <altmember cref="Overload:System.DateTime.Parse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, IFormatProvider provider, System.Globalization.DateTimeStyles styles, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), provider As IFormatProvider, styles As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider, System::Globalization::DateTimeStyles styles, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="styles">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, IFormatProvider provider, System.Globalization.DateTimeStyles styles, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles styles, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, provider As IFormatProvider, styles As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, IFormatProvider ^ provider, System::Globalization::DateTimeStyles styles, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。</param>
        <param name="provider">一个对象，提供有关 <c>s</c> 的区域性特定格式设置信息。</param>
        <param name="styles">枚举值的按位组合，该组合定义如何根据当前时区或当前日期解释已分析日期。 要指定的一个典型值为 <see cref="F:System.Globalization.DateTimeStyles.None" />。</param>
        <param name="result">当此方法返回时，如果转换成功，则包含与 <c>s</c> 中包含的日期和时间等效的 <see cref="T:System.DateTime" /> 值；如果转换失败，则为 <see cref="F:System.DateTime.MinValue" />。 如果 <c>s</c> 参数为 <see langword="null" />，是空字符串 ("") 或者不包含日期和时间的有效字符串表示形式，则转换失败。 此参数未经初始化即被传递。</param>
        <summary>使用指定的区域性特定格式信息和格式设置样式，将日期和时间的指定字符串表示形式转换为其 <see cref="T:System.DateTime" /> 等效项，并返回一个指示转换是否成功的值。</summary>
        <returns>
          如果 <paramref name="s" /> 参数成功转换，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法分析字符串可包含日期、 时间和时区信息。 它是类似于<xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法，只不过<xref:System.DateTime.TryParse%28System.String%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法不会引发异常，如果转换失败。  
  
 此方法尝试忽略无法识别的数据和分析`s`完全。 如果`s`包含一次，但没有日期，则该方法通过默认的替换当前的日期或者，如果`styles`包括<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>标志，它将替换`DateTime.Date.MinValue`。 如果`s`包含日期而没有时间，12:00 午夜用作默认时间。 如果某个日期是否存在，但其年份部分包含仅有两个数字，该程序转换为由一年`provider`参数的当前日历的值基于<xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType>属性。 任何前导、 内部或尾随空格字符中的`s`将被忽略。 日期和时间可以使用一对前导空格和尾随数字标记字符 （#，U + 0023），括起来，并可以尾随一个或多个 NULL 字符 (U + 0000)。  
  
 由定义特定的日期和时间元素，以及名称以及日期和时间中, 使用的符号的有效格式`provider`可以为任何以下参数：  
  
-   A<xref:System.Globalization.CultureInfo>表示的格式设置中使用的区域性的对象`s`参数。 <xref:System.Globalization.DateTimeFormatInfo>返回对象<xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType>属性定义中使用的格式`s`。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>对象，用于定义中使用的格式`s`。  
  
-   一个自定义 <xref:System.IFormatProvider> 实现。 其<xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>方法返回<xref:System.Globalization.DateTimeFormatInfo>对象，用于定义中使用的格式`s`。  
  
 如果 `provider` 为 `null`，则使用当前区域性。  
  
 如果`s`是闰日闰年中当前日历，方法分析中的字符串表示`s`成功。 如果`s`是闰日中非-闰年中的当前日历的字符串表示`provider`，分析操作将失败，该方法返回`false`。  
  
 `styles`参数定义的分析的字符串和分析操作应如何处理它的确切解释。 它可以是的一个或多个成员<xref:System.Globalization.DateTimeStyles>枚举下, 表中所述。  
  
|DateTimeStyles 成员|描述|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|分析`s`并且，如果有必要，请将其转换为 UTC。 如果`s`包括时区偏移量，或者如果`s`不包含任何时区信息但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，该方法分析字符串，调用<xref:System.DateTime.ToUniversalTime%2A>要转换返回<xref:System.DateTime>为 UTC 值并将设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果`s`指示它表示 UTC，或如果`s`不包含时区信息但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>标志，该方法分析字符串，对返回执行任何时区转换<xref:System.DateTime>值，并设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 在所有其他情况下，标记有任何影响。|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|虽然有效，但将忽略此值。 允许的日期和时间元素中存在内部空白`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|虽然有效，但将忽略此值。 中的日期和时间元素允许前导空白字符`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|虽然有效，但将忽略此值。 允许的日期和时间元素中存在尾随空格`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|指定`s`可能包含前导、 内部和尾随空格。 这是默认行为。 不能重写通过提供限制性更强<xref:System.Globalization.DateTimeStyles>枚举值，如<xref:System.Globalization.DateTimeStyles.None?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|指定，如果`s`缺少的任何时区信息，则假定它表示本地时间。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志位于<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>值设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|指定，如果`s`缺少的任何时区信息，则假定它表示 UTC。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志存在，该方法将返回<xref:System.DateTime>于 UTC 的值为本地时间和设置其<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.None>|虽然有效，但将忽略此值。|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|对于包含时区信息的字符串，尝试阻止的日期和时间字符串的转换<xref:System.DateTime>值与其<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 通常情况下，通过调用创建此类字符串<xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType>方法使用"o"、"r"或"u"标准格式说明符。|  
  
 如果`s`不包含任何时区信息，<xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法返回<xref:System.DateTime>值其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>除非`styles`标志指示成功。 如果`s`时区偏移量的信息，包括<xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法执行任何必要的时间转换，并返回下列项之一：  
  
-   A<xref:System.DateTime>其日期和时间反映本地时间并且其值<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。  
  
-   或者，如果`styles`包括<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>标志，<xref:System.DateTime>其日期和时间反映 UTC 并且其值<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。  
  
 可以通过重写此行为<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>标志。  
  
## <a name="parsing-custom-cultures"></a>分析自定义区域性  
 如果您要分析生成的自定义区域性的日期和时间字符串，使用<xref:System.DateTime.TryParseExact%2A>方法而不是<xref:System.DateTime.TryParse%2A>方法以提高分析操作将成功的可能性。 自定义区域性日期和时间字符串可以很复杂且难以进行分析。 <xref:System.DateTime.TryParse%2A>方法尝试分析字符串，使用多个隐式分析模式，它们都可能会失败。 与此相反，<xref:System.DateTime.TryParseExact%2A>方法要求你显式指定一个或多个可能会成功的确切的分析模式。  
  
 有关自定义区域性的详细信息，请参阅<xref:System.Globalization.CultureAndRegionInfoBuilder?displayProperty=nameWithType>类。  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法。  
  
 [!code-csharp[System.DateTime.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParse/cs/tryparse2.cs#2)]
 [!code-vb[System.DateTime.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParse/vb/tryparse2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="styles" /> 不是有效的 <see cref="T:System.Globalization.DateTimeStyles" /> 值。  
  
 或  
  
 <paramref name="styles" /> 包含 <see cref="T:System.Globalization.DateTimeStyles" /> 值的无效组合（例如，<see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> 和 <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />）。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="provider" /> 是一个非特定区域性并且无法在分析操作中使用。</exception>
        <block subset="none" type="usage">
          <para>格式化受当前的属性<see cref="T:System.Globalization.DateTimeFormatInfo" />对象，它提供由<paramref name="provider" />参数。 <see cref="Overload:System.DateTime.TryParse" />方法可以意外失败，返回<see langword="False" />如果当前<see cref="P:System.Globalization.DateTimeFormatInfo.DateSeparator" />和<see cref="P:System.Globalization.DateTimeFormatInfo.TimeSeparator" />属性设置为相同的值。</para>
        </block>
        <altmember cref="Overload:System.DateTime.Parse" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParseExact">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将日期和时间的指定字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。 字符串表示形式的格式必须与指定的格式完全匹配。 该方法返回一个指示转换是否成功的值。</summary>
        <altmember cref="Overload:System.DateTime.ParseExact" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As ReadOnlySpan(Of Char), format As ReadOnlySpan(Of Char), provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, ReadOnlySpan&lt;char&gt; format, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (ReadOnlySpan&lt;char&gt; s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.ReadOnlySpan{System.Char},System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As ReadOnlySpan(Of Char), formats As String(), provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(ReadOnlySpan&lt;char&gt; s, cli::array &lt;System::String ^&gt; ^ formats, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="formats">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="style">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (string s, string format, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(string s, string format, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.String,System.String,System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As String, format As String, provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(System::String ^ s, System::String ^ format, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。</param>
        <param name="format">所需的 <c>s</c> 格式。</param>
        <param name="provider">一个对象，提供有关 <c>s</c> 的区域性特定格式设置信息。</param>
        <param name="style">一个或多个枚举值的按位组合，指示 <c>s</c> 允许使用的格式。</param>
        <param name="result">当此方法返回时，如果转换成功，则包含与 <c>s</c> 中包含的日期和时间等效的 <see cref="T:System.DateTime" /> 值；如果转换失败，则为 <see cref="F:System.DateTime.MinValue" />。 如果 <c>s</c> 或 <c>format</c> 参数为 <see langword="null" />，或者为空字符串，或者未包含对应于 <c>format</c> 中指定的模式的日期和时间，则转换失败。 此参数未经初始化即被传递。</param>
        <summary>使用指定的格式、区域性特定的格式信息和样式将日期和时间的指定字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。 字符串表示形式的格式必须与指定的格式完全匹配。 该方法返回一个指示转换是否成功的值。</summary>
        <returns>
          如果 <see langword="true" /> 成功转换，则为 <paramref name="s" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法分析的字符串表示形式必须是定义的格式的日期`format`参数。 它是类似于<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法，只不过<xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29>方法不会引发异常，如果转换失败。  
  
 `s`参数包含要分析的日期和时间，而且必须是定义的格式`format`参数。 如果日期、 时间和时区元素同时存在于`s`，它们必须也显示在指定的顺序`format`。 如果`format`定义的日期与没有时间元素和分析操作成功，则生成<xref:System.DateTime>值必须在时间内的午夜 (00: 00:00)。 如果`format`定义的时间与没有日期元素，并且分析操作成功，则生成<xref:System.DateTime>默认情况下的值具有日期`DateTime.Now.Date`，它具有的日期或`DateTime.MinValue.Date`如果`styles`包括<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType>标志。 `style`参数确定是否`s`参数可以包含前导、 内部或尾随空格字符。  
  
 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 可以使用更改此行为<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>，或通过使用<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>和<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果 s 包含时区信息，时间转换为本地时间，如有必要，和<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 可以使用更改此行为<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>标志以不将协调世界时 (UTC) 转换为本地时间和将设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。  
  
 `format`参数包含对应于预期的格式模式`s`参数。 中的模式`format`参数从的一个或多个自定义格式说明符组成[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)表或用于标识预定义的模式，从单个标准格式说明符[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)表。  
  
 如果你不使用自定义格式模式中的日期或时间分隔符，使用固定区域性的`provider`参数以及提供给最大形式的每个自定义格式说明符。 例如，如果你想要指定模式中的小时数，请指定较宽的形式"HH"，而不是较窄的形式，"H"。  
  
> [!NOTE]
>  而不是要求`s`符合使分析操作成功的一种格式，您可以调用<xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法并指定多种允许的格式。 这使得更可能会成功分析操作。  
  
 特定日期和时间符号和字符串 （例如，由特定语言星期几的名称） 中使用`s`由定义`provider`参数，则精确格式`s`如果`format`是标准的格式说明符字符串。 `provider`参数可以是任何以下：  
  
-   A<xref:System.Globalization.CultureInfo>对象，表示用于解释的区域性`s`。 <xref:System.Globalization.DateTimeFormatInfo>对象由其<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性定义的符号和中的格式设置`s`。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>定义的日期和时间数据格式的对象。  
  
-   自定义<xref:System.IFormatProvider>实现其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.CultureInfo>对象或<xref:System.Globalization.DateTimeFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`、<xref:System.Globalization.CultureInfo>使用对应于当前区域性的对象。  
  
 `styles`参数包含一个或多个成员的<xref:System.Globalization.DateTimeStyles>确定是否以及在何处的空白区域未定义的枚举`format`可以出现在`s`和控制分析操作的确切行为。 下表描述了每个成员的<xref:System.Globalization.DateTimeStyles>枚举会影响的操作<xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29>方法。  
  
|DateTimeStyles 成员|描述|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|分析`s`并且，如果有必要，请将其转换为 UTC。 如果`s`包括时区偏移量，或者如果`s`不包含任何时区信息但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，该方法分析字符串，调用<xref:System.DateTime.ToUniversalTime%2A>要转换返回<xref:System.DateTime>为 UTC 值并将设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果`s`指示它表示 UTC，或如果`s`不包含时区信息但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>标志，该方法分析字符串，对返回执行任何时区转换<xref:System.DateTime>值，并设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 在所有其他情况下，标记有任何影响。|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|指定未定义的空白`format`可以出现在任何单个的日期或时间元素之间。|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|指定未定义的空白`format`可以出现的开始处`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|指定未定义的空白`format`可以出现在结尾处`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|指定`s`可能包含前导、 内部和尾随空格未定义的`format`。|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|指定，如果`s`缺少的任何时区信息，则假定它表示本地时间。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志位于<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>值设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|指定，如果`s`缺少的任何时区信息，则假定它表示 UTC。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志存在，该方法将返回<xref:System.DateTime>于 UTC 的值为本地时间和设置其<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|如果`s`包含时间不包含日期信息的返回值的日期设置为`DateTime.MinValue.Date`。|  
|<xref:System.Globalization.DateTimeStyles.None>|`s`使用默认值分析参数。 没有空格，而不是中提供的`format`允许。 如果`s`缺少返回日期的日期部分，<xref:System.DateTime>值设置为 0001 年 1 月 1 日。 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 如果时区信息位于`s`，将时间转换为本地时间和<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|对于包含时区信息的字符串，尝试阻止转换为<xref:System.DateTime>值与其<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 此标志主要是阻止将本地时间到 UTC 时间的转换。|  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法。 请注意，字符串"5/01/2009年上午 8:30"无法成功分析时`styles`参数等于<xref:System.Globalization.DateTimeStyles.None?displayProperty=nameWithType>因为通过不允许有前导空格`format`。 此外，字符串"5/01/2009年 09:00"不能与成功分析`format`的"MM/dd/yyyyhh:mm"因为日期字符串前面不带前导零的月份数作为`format`要求。  
  
 [!code-csharp[System.DateTime.TryParseExact#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParseExact/cs/TryParseExact1.cs#1)]
 [!code-vb[System.DateTime.TryParseExact#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParseExact/vb/TryParseExact1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="styles" /> 不是有效的 <see cref="T:System.Globalization.DateTimeStyles" /> 值。  
  
 或  
  
 <paramref name="styles" /> 包含 <see cref="T:System.Globalization.DateTimeStyles" /> 值的无效组合（例如，<see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> 和 <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />）。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、<see cref="Overload:System.DateTime.TryParseExact" />方法返回<see langword="false" />如果要分析的字符串包含小时组成部分和 AM/PM 指示符，并不一致。 在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和早期版本中，AM/PM 指示符将被忽略。</para>
        </block>
        <altmember cref="Overload:System.DateTime.ParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (string s, string[] formats, IFormatProvider provider, System.Globalization.DateTimeStyles style, out DateTime result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(string s, string[] formats, class System.IFormatProvider provider, valuetype System.Globalization.DateTimeStyles style, [out] valuetype System.DateTime&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTime.TryParseExact(System.String,System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (s As String, formats As String(), provider As IFormatProvider, style As DateTimeStyles, ByRef result As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(System::String ^ s, cli::array &lt;System::String ^&gt; ^ formats, IFormatProvider ^ provider, System::Globalization::DateTimeStyles style, [Runtime::InteropServices::Out] DateTime % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="style" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTime&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">包含要转换的日期和时间的字符串。</param>
        <param name="formats">
          <c>s</c> 的允许格式的数组。</param>
        <param name="provider">一个对象，提供有关 <c>s</c> 的区域性特定格式信息。</param>
        <param name="style">枚举值的按位组合，指示 <c>s</c> 允许使用的格式。 要指定的一个典型值为 <see cref="F:System.Globalization.DateTimeStyles.None" />。</param>
        <param name="result">当此方法返回时，如果转换成功，则包含与 <c>s</c> 中包含的日期和时间等效的 <see cref="T:System.DateTime" /> 值；如果转换失败，则为 <see cref="F:System.DateTime.MinValue" />。 如果 <c>s</c> 或 <c>formats</c> 为 <see langword="null" />，<c>s</c> 或 <c>formats</c> 的某个元素为空字符串，或者 <c>s</c> 的格式与 <c>formats</c> 中的格式模式所指定的格式都不完全匹配，则转换失败。 此参数未经初始化即被传递。</param>
        <summary>使用指定的格式数组、区域性特定格式信息和样式，将日期和时间的指定字符串表示形式转换为其等效的 <see cref="T:System.DateTime" />。 字符串表示形式的格式必须至少与指定的格式之一完全匹配。 该方法返回一个指示转换是否成功的值。</summary>
        <returns>
          如果 <paramref name="s" /> 参数成功转换，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法分析的字符串表示形式符合任一分配到的模式的日期`formats`参数。 此操作就如同<xref:System.DateTime.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType>方法，除了<xref:System.DateTime.TryParseExact%2A>方法不会引发异常，如果转换失败。  
  
 `s`参数包含要分析的日期和时间。 如果`s`参数包含仅在时间，并没有日期，当前日期用于除非`style`参数包含<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType>标志，在这种情况下的默认日期 (`DateTime.Date.MinValue`) 使用。 如果`s`参数包含仅的日期和没有时间、 午夜 (00: 00:00) 使用。 `style`参数还确定是否`s`参数可以包含前导、 内部或尾随空格字符其他比允许的格式字符串在之一`formats`。  
  
 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象是<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 可以使用更改此行为<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Local?displayProperty=nameWithType>，或通过使用<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>和<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志，它将返回<xref:System.DateTime>值其<xref:System.DateTime.Kind%2A>属性是<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果 s 包含时区信息，时间转换为本地时间，如有必要，和<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 可以使用更改此行为<xref:System.Globalization.DateTimeStyles.RoundtripKind?displayProperty=nameWithType>标志以不将协调世界时 (UTC) 转换为本地时间和将设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。  
  
 `formats`参数包含数组的模式，其中`s`必须完全匹配分析操作成功。 中的模式`formats`参数由一个或多个自定义格式说明符组成从[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)表或用于标识预定义的模式，从单个标准格式说明符[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)表。  
  
 如果你不使用自定义格式模式中的日期或时间分隔符，使用固定区域性的`provider`参数以及提供给最大形式的每个自定义格式说明符。 例如，如果你想要指定模式中的小时数，请指定较宽的形式"HH"，而不是较窄的形式，"H"。  
  
 特定日期和时间符号和字符串 （例如，由特定语言星期几的名称） 中使用`s`由定义`provider`参数，则精确格式`s`如果`format`是标准的格式说明符字符串。 `provider`参数可以是任何以下：  
  
-   A<xref:System.Globalization.CultureInfo>对象，表示用于解释的区域性`s`。 <xref:System.Globalization.DateTimeFormatInfo>对象由其<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>属性定义的符号和中的格式设置`s`。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>定义的日期和时间数据格式的对象。  
  
-   自定义<xref:System.IFormatProvider>实现其<xref:System.IFormatProvider.GetFormat%2A>方法返回<xref:System.Globalization.CultureInfo>对象或<xref:System.Globalization.DateTimeFormatInfo>提供格式设置信息的对象。  
  
 如果`provider`是`null`、<xref:System.Globalization.CultureInfo>使用对应于当前区域性的对象。  
  
 `styles`参数包含一个或多个成员的<xref:System.Globalization.DateTimeStyles>确定是否以及在何处的空白区域未定义的枚举`format`可以出现在`s`和控制分析操作的确切行为。 下表描述了每个成员的<xref:System.Globalization.DateTimeStyles>枚举会影响的操作<xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29>方法。  
  
|DateTimeStyles 成员|描述|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|分析`s`并且，如果有必要，请将其转换为 UTC。 如果`s`包括时区偏移量，或者如果`s`不包含任何时区信息但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>标志，该方法分析字符串，调用<xref:System.DateTime.ToUniversalTime%2A>要转换返回<xref:System.DateTime>为 UTC 值并将设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 如果`s`指示它表示 UTC，或如果`s`不包含时区信息但`styles`包括<xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>标志，该方法分析字符串，对返回执行任何时区转换<xref:System.DateTime>值，并设置<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。 在所有其他情况下，标记有任何影响。|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|指定未定义的空白`format`可以出现在任何单个的日期或时间元素之间。|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|指定未定义的空白`format`可以出现的开始处`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|指定未定义的空白`format`可以出现在结尾处`s`。|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|指定`s`可能包含前导、 内部和尾随空格未定义的`format`。|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|指定，如果`s`缺少的任何时区信息，则假定它表示本地时间。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志位于<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>值设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|指定，如果`s`缺少的任何时区信息，则假定它表示 UTC。 除非<xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType>标志存在，该方法将返回<xref:System.DateTime>于 UTC 的值为本地时间和设置其<xref:System.DateTime.Kind%2A>属性<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>|如果`s`包含时间不包含日期信息的返回值的日期设置为`DateTime.MinValue.Date`。|  
|<xref:System.Globalization.DateTimeStyles.None>|`s`使用默认值分析参数。 没有空格，而不是中提供的`format`允许。 如果`s`缺少返回日期的日期部分，<xref:System.DateTime>值设置为 0001 年 1 月 1 日。 如果`s`不包含任何时区信息，<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 如果时区信息位于`s`，将时间转换为本地时间和<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTime>对象设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|对于包含时区信息的字符串，尝试阻止转换为<xref:System.DateTime>值与其<xref:System.DateTime.Kind%2A>属性设置为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>。 此标志主要是阻止将本地时间到 UTC 时间的转换。|  
  
   
  
## Examples  
 下面的示例使用<xref:System.DateTime.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTime%40%29?displayProperty=nameWithType>方法，以确保可以成功分析中大量的可能格式的字符串。  
  
 [!code-csharp[System.Datetime.TryParseExact#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.TryParseExact/cs/TryParseExact2.cs#2)]
 [!code-vb[System.Datetime.TryParseExact#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.TryParseExact/vb/TryParseExact2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="styles" /> 不是有效的 <see cref="T:System.Globalization.DateTimeStyles" /> 值。  
  
 或  
  
 <paramref name="styles" /> 包含 <see cref="T:System.Globalization.DateTimeStyles" /> 值的无效组合（例如，<see cref="F:System.Globalization.DateTimeStyles.AssumeLocal" /> 和 <see cref="F:System.Globalization.DateTimeStyles.AssumeUniversal" />）。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、<see cref="Overload:System.DateTime.TryParseExact" />方法返回<see langword="false" />如果要分析的字符串包含小时组成部分和 AM/PM 指示符，并不一致。 在[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]和早期版本中，AM/PM 指示符将被忽略。</para>
        </block>
        <altmember cref="Overload:System.DateTime.ParseExact" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnixEpoch">
      <MemberSignature Language="C#" Value="public static readonly DateTime UnixEpoch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTime UnixEpoch" />
      <MemberSignature Language="DocId" Value="F:System.DateTime.UnixEpoch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnixEpoch As DateTime " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTime UnixEpoch;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UtcNow">
      <MemberSignature Language="C#" Value="public static DateTime UtcNow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.DateTime UtcNow" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.UtcNow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UtcNow As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property DateTime UtcNow { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.DateTime" /> 对象，该对象设置为此计算机上的当前日期和时间，表示为协调通用时间 (UTC)。</summary>
        <value>其值为当前 UTC 日期和时间的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的解决方法取决于系统计时器，具体取决于基础操作系统。 它往往是之间 0.5 和 15 毫秒。

 从.NET Framework 2.0 版开始，则返回值是<xref:System.DateTime>其<xref:System.DateTime.Kind%2A>属性返回<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>。

 除了使用<xref:System.DateTime.UtcNow%2A>是<xref:System.DateTimeOffset.UtcNow%2A?displayProperty=nameWithType>。 而前者表示的日期和时间值通过分配为协调世界时 (UTC)<xref:System.DateTimeKind.Utc?displayProperty=nameWithType>到其<xref:System.DateTime.Kind%2A>属性，后者将分配日期和时间值的 UTC 时间的偏移量 (等于<xref:System.TimeSpan.Zero?displayProperty=nameWithType>)。
  
## Examples  
 下面的示例使用<xref:System.DateTime.SpecifyKind%2A>方法演示如何<xref:System.DateTime.Kind%2A>属性影响<xref:System.DateTime.ToLocalTime%2A>和<xref:System.DateTime.ToUniversalTime%2A>转换方法。  
  
 [!code-csharp[DateTime.Kind_Suite#1](~/samples/snippets/csharp/VS_Snippets_CLR/DateTime.Kind_Suite/cs/ks.cs#1)]
 [!code-vb[DateTime.Kind_Suite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DateTime.Kind_Suite/vb/ks.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTimeOffset.UtcNow" />
        <altmember cref="M:System.TimeZone.GetUtcOffset(System.DateTime)" />
      </Docs>
    </Member>
    <Member MemberName="Year">
      <MemberSignature Language="C#" Value="public int Year { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Year" />
      <MemberSignature Language="DocId" Value="P:System.DateTime.Year" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Year As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Year { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所表示日期的年份部分。</summary>
        <value>年份（介于 1 和 9999 之间）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTime.Year%2A>属性返回公历日历中的当前实例的年份。 它不返回使用当前区域性的默认日历年。 若要检索特定日历的年份，可以调用该日历`GetYear`方法，如以下代码所示。  
  
 [!code-csharp[System.DateTime.Year#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Year/cs/Year.cs#1)]
 [!code-vb[System.DateTime.Year#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Year/vb/Year.vb#1)]  
  
   
  
## Examples  
 下面的示例演示<xref:System.DateTime.Year%2A>属性。  
  
 [!code-cpp[System.DateTime.Minute etc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CPP/class1.cpp#1)]
 [!code-csharp[System.DateTime.Minute etc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTime.Minute etc/CS/class1.cs#1)]
 [!code-vb[System.DateTime.Minute etc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTime.Minute etc/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.Calendar" />
      </Docs>
    </Member>
  </Members>
</Type>