<Type Name="Array" FullName="System.Array">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1f1e5542ce17228b81ac98e22af0444d4203ab07" />
    <Meta Name="ms.sourcegitcommit" Value="ad09e88f48ca55b181e8d272cfc3742eadc3f939" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/08/2018" />
    <Meta Name="ms.locfileid" Value="35231185" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供一些方法，用于创建、处理、搜索数组并对数组进行排序，从而充当公共语言运行时中所有数组的基类。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>类不是属于<xref:System.Collections>命名空间。 但是，仍将其视为集合因为它基于<xref:System.Collections.IList>接口。  
  
 <xref:System.Array>类是支持数组的语言实现的基类。 但是，只有系统和编译器可以从显式派生<xref:System.Array>类。 用户应采用由语言提供的数组构造。  
  
 元素是中的值<xref:System.Array>。 长度<xref:System.Array>是它可以包含的元素总数。 下限为<xref:System.Array>是其第一个元素的索引。 <xref:System.Array>可以有任何下限，但该下限为零，默认情况下。 创建的实例时，可以定义不同的下限<xref:System.Array>类使用<xref:System.Array.CreateInstance%2A>。多维<xref:System.Array>可以为每个维度的下限。 32 维数的最多可以有一个数组。  
  
 与中的类不同<xref:System.Collections>命名空间，<xref:System.Array>具有固定的容量。 若要增加容量，你必须创建一个新<xref:System.Array>对象具有所需容量，旧中的元素复制<xref:System.Array>到新对象，并删除旧<xref:System.Array>。  
  
 默认情况下的最大大小<xref:System.Array>是 2 千兆字节 (GB)。 在 64 位环境中，你可以通过设置来避免大小限制`enabled`属性[gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)到的配置元素`true`在运行时环境中。 但是，数组仍将仅限于总数 40 亿个元素，以及 0X7FEFFFFF 的任何给定维度 (0X7FFFFFC7 字节数组和单字节结构的数组) 中的最大索引。  
  
 一维数组实现<xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>， <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>， <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>，<xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType>和<xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType>泛型接口。 在运行时，实现提供给数组和泛型接口结果是，不显示在的声明语法<xref:System.Array>类。 此外，还有只能通过强制转换为泛型接口类型 （显式接口实现） 的数组是可访问的接口成员没有参考主题。 关键的一点需要注意的当强制转换到这些接口之一的数组是成员将其添加，插入或删除元素 throw <xref:System.NotSupportedException>。  
  
 <xref:System.Type> 对象提供有关数组类型声明的信息。 <xref:System.Array> 使用相同的数组类型的对象共享相同<xref:System.Type>对象。  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> 和<xref:System.Type.GetElementType%2A?displayProperty=nameWithType>可能不返回预期的结果与<xref:System.Array>因为如果数组被强制转换为类型<xref:System.Array>，结果是一个对象，不是数组。 也就是说，`typeof(System.Array).IsArray`返回`false`，和`typeof(System.Array).GetElementType`返回`null`。  
  
 <xref:System.Array.Copy%2A?displayProperty=nameWithType>方法复制不仅之间相同类型的数组，但还的不同类型的标准阵列之间的元素; 它处理自动强制转换的类型。  
  
 某些方法，如<xref:System.Array.CreateInstance%2A>， <xref:System.Array.Copy%2A>， <xref:System.Array.CopyTo%2A>， <xref:System.Array.GetValue%2A>，和<xref:System.Array.SetValue%2A>，提供重载，以适应大容量数组作为参数接受 64 位整数。 <xref:System.Array.LongLength%2A> 和<xref:System.Array.GetLongLength%2A>返回 64 位整数，表示数组的长度。  
  
 <xref:System.Array>不一定进行排序。  您必须对进行排序<xref:System.Array>之前执行操作 (如<xref:System.Array.BinarySearch%2A>) 需要<xref:System.Array>进行排序。  
  
 使用<xref:System.Array>的本机代码中的指针的对象不受支持，将引发<xref:System.NotSupportedException>对几种方法。  
  
   
  
## Examples  
 下面的代码示例演示如何<xref:System.Array.Copy%2A?displayProperty=nameWithType>之间的整数类型的数组和类型的数组的元素复制<xref:System.Object>。  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 下面的代码示例创建并初始化<xref:System.Array>并显示其属性和它的元素。  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>公共静态 (<see langword="Shared" />在 Visual Basic 中) 的此类型的成员都是线程安全。 但不保证所有实例成员都是线程安全的。  此实现不提供同步 （线程安全） 包装器<see cref="T:System.Array" />; 但是，.NET Framework 类基于<see cref="T:System.Array" />提供其自己的同步的版本的集合使用<see cref="P:System.Array.SyncRoot" />属性。  枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要包装在只读 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 包装器中的从零开始的一维数组。</param>
        <summary>返回指定数组的只读包装。</summary>
        <returns>指定数组的只读 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止对数组进行任何修改，公开只通过此包装器数组。  
  
 集合是只读的是只是一个集合与防止集合; 进行修改的包装因此，如果对基础集合进行更改，只读集合将反映这些更改。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的示例将数组包装在只读的<xref:System.Collections.ObjectModel.ReadOnlyCollection%601>。  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用二进制搜索算法在一维的排序 <see cref="T:System.Array" /> 中搜索值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的排序一维 <see cref="T:System.Array" />。</param>
        <param name="value">要搜索的对象。</param>
        <summary>使用由数组中每个元素和指定对象实现的 <see cref="T:System.IComparable" /> 接口，在整个一维排序数组中搜索特定元素。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持包含负索引的搜索数组。 `array` 必须调用此方法之前进行排序。  
  
 如果<xref:System.Array>不包含指定的值，该方法返回负整数。 你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。 如果此索引是一种大于上限的数组，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 请`value`或的每个元素`array`必须实现<xref:System.IComparable>接口，用于比较。 元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。  
  
> [!NOTE]
>  如果`value`不实现<xref:System.IComparable>接口的元素`array`未测试的<xref:System.IComparable>开始执行搜索之前。 如果搜索遇到不实现的元素将引发异常<xref:System.IComparable>。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。  
  
 `null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`不生成异常。  
  
> [!NOTE]
>  为测试，每个元素`value`传递给相应<xref:System.IComparable>实现，即使`value`是`null`。 也就是说，<xref:System.IComparable>实现确定给定的元素如何比较到`null`。  
  
 此方法为 O (日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Array.BinarySearch%2A>查找中的特定对象<xref:System.Array>。  
  
> [!NOTE]
>  创建数组时，其元素以升序排序。 <xref:System.Array.BinarySearch%2A>方法要求要以升序排序的数组。  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的排序一维 <see cref="T:System.Array" />。</param>
        <param name="value">要搜索的对象。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  -或-  若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定 <see cref="T:System.Collections.IComparer" /> 接口，在整个一维排序数组中搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持包含负索引的搜索数组。 `array` 必须调用此方法之前进行排序。  
  
 如果<xref:System.Array>不包含指定的值，该方法返回负整数。 你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。 如果此索引是一种大于上限的数组，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 比较器自定义如何比较元素。 例如，你可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>作为要执行不区分大小写的字符串搜索的比较器。  
  
 如果`comparer`不`null`的元素`array`与使用指定的指定值进行比较<xref:System.Collections.IComparer>实现。 元素`array`必须已在增加根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。  
  
 如果`comparer`是`null`，完成比较使用<xref:System.IComparable>通过自身的元素或指定的值提供的实现。 元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。  
  
> [!NOTE]
>  如果`comparer`是`null`和`value`不实现<xref:System.IComparable>接口的元素`array`未测试的<xref:System.IComparable>开始执行搜索之前。 如果搜索遇到不实现的元素将引发异常<xref:System.IComparable>。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。  
  
 `null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`不生成异常。  
  
> [!NOTE]
>  为测试，每个元素`value`传递给相应<xref:System.IComparable>实现，即使`value`是`null`。 也就是说，<xref:System.IComparable>实现确定给定的元素如何比较到`null`。  
  
 此方法为 O (日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，<paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的排序一维 <see cref="T:System.Array" />。</param>
        <param name="index">要搜索的范围的起始索引。</param>
        <param name="length">要搜索的范围的长度。</param>
        <param name="value">要搜索的对象。</param>
        <summary>使用由一维排序数组中每个元素和指定的值实现的 <see cref="T:System.IComparable" /> 接口，在该数组的一个元素范围内搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持包含负索引的搜索数组。 `array` 必须调用此方法之前进行排序。  
  
 如果<xref:System.Array>不包含指定的值，该方法返回负整数。 你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。 如果此索引是一种大于上限的数组，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 请`value`或的每个元素`array`必须实现<xref:System.IComparable>接口，用于比较。 元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。  
  
> [!NOTE]
>  如果`value`不实现<xref:System.IComparable>接口的元素`array`未测试的<xref:System.IComparable>开始执行搜索之前。 如果搜索遇到不实现的元素将引发异常<xref:System.IComparable>。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。  
  
 `null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`不生成异常。  
  
> [!NOTE]
>  为测试，每个元素`value`传递给相应<xref:System.IComparable>实现，即使`value`是`null`。 也就是说，<xref:System.IComparable>实现确定给定的元素如何比较到`null`。  
  
 此方法为 O (日志`n`) 操作，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  -或-  <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的排序一维 <see cref="T:System.Array" />。</param>
        <param name="index">要搜索的范围的起始索引。</param>
        <param name="length">要搜索的范围的长度。</param>
        <param name="value">要搜索的对象。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  -或-  若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定 <see cref="T:System.Collections.IComparer" /> 接口，在一维排序数组的某个元素范围中搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持包含负索引的搜索数组。 `array` 必须调用此方法之前进行排序。  
  
 如果<xref:System.Array>不包含指定的值，该方法返回负整数。 你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。 如果此索引是一种大于上限的数组，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 比较器自定义如何比较元素。 例如，你可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>作为要执行不区分大小写的字符串搜索的比较器。  
  
 如果`comparer`不`null`的元素`array`与使用指定的指定值进行比较<xref:System.Collections.IComparer>实现。 元素`array`必须已在增加根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。  
  
 如果`comparer`是`null`，完成比较使用<xref:System.IComparable>通过自身的元素或指定的值提供的实现。 元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。  
  
> [!NOTE]
>  如果`comparer`是`null`和`value`不实现<xref:System.IComparable>接口的元素`array`未测试的<xref:System.IComparable>开始执行搜索之前。 如果搜索遇到不实现的元素将引发异常<xref:System.IComparable>。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。  
  
 `null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`使用时不生成异常<xref:System.IComparable>。  
  
> [!NOTE]
>  为测试，每个元素`value`传递给相应<xref:System.IComparable>实现，即使`value`是`null`。 也就是说，<xref:System.IComparable>实现确定给定的元素如何比较到`null`。  
  
 此方法为 O (日志`n`) 操作，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  -或-  <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，<paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</param>
        <param name="value">要搜索的对象。</param>
        <summary>使用由 <see cref="T:System.Array" /> 中每个元素和指定对象实现的 <see cref="T:System.IComparable`1" /> 泛型接口，在整个一维排序数组中搜索特定元素。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持包含负索引的搜索数组。 `array` 必须调用此方法之前进行排序。  
  
 如果`array`不包含指定的值，该方法返回负整数。 你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。 如果此索引等于数组的大小，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 `T` 必须实现<xref:System.IComparable%601>泛型接口，用于比较。 元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable%601>实现; 否则，结果可能不正确。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。  
  
 `null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`不生成异常。  
  
> [!NOTE]
>  为测试，每个元素`value`传递给相应<xref:System.IComparable%601>实现，即使`value`是`null`。 也就是说，<xref:System.IComparable%601>实现确定给定的元素如何比较到`null`。  
  
 此方法为 O (日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>泛型方法重载与<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>泛型方法重载。 创建一个字符串数组，顺序不分先后。  
  
 数组是显示、 排序，并且再次显示。 数组必须进行排序以便使用<xref:System.Array.BinarySearch%2A>方法。  
  
> [!NOTE]
>  对调用<xref:System.Array.Sort%2A>和<xref:System.Array.BinarySearch%2A>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。 如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>泛型方法重载然后用于两个字符串搜索，另一个不在使用数组和一个，是。 数组和返回值的<xref:System.Array.BinarySearch%2A>方法传递给`ShowWhere`泛型方法，如果找到该字符串，而且否则元素的搜索字符串将介于像它是数组中显示的索引值。 索引为负如果字符串不是在数组中，因此`ShowWhere`方法采用的按位求补 (~ 中 C# 和 Visual c + + 中，运算符`Xor`在 Visual Basic 中的为-1) 若要获取大于搜索列表中的第一个元素的索引 str运算结果。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</param>
        <param name="value">要搜索的对象。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现。  -或-  若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 实现。</param>
        <summary>使用指定 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，在整个一维排序数组中搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持包含负索引的搜索数组。 `array` 必须调用此方法之前进行排序。  
  
 如果<xref:System.Array>不包含指定的值，该方法返回负整数。 你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。 如果此索引等于数组的大小，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 比较器自定义如何比较元素。 例如，你可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>作为要执行不区分大小写的字符串搜索的比较器。  
  
 如果`comparer`不`null`的元素`array`与使用指定的指定值进行比较<xref:System.Collections.Generic.IComparer%601>泛型接口实现。 元素`array`必须已在增加根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。  
  
 如果`comparer`是`null`，完成比较使用<xref:System.IComparable%601>由提供的泛型接口实现`T`。 元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable%601>实现; 否则，结果可能不正确。  
  
> [!NOTE]
>  如果`comparer`是`null`和`value`不实现<xref:System.IComparable%601>泛型接口的元素`array`未测试的<xref:System.IComparable%601>开始执行搜索之前。 如果搜索遇到不实现的元素将引发异常<xref:System.IComparable%601>。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。  
  
 `null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`不生成异常。  
  
> [!NOTE]
>  为测试，每个元素`value`传递给相应<xref:System.IComparable%601>实现，即使`value`是`null`。 也就是说，<xref:System.IComparable%601>实现确定给定的元素如何比较到`null`。  
  
 此方法为 O (日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载与<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载。  
  
 代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。  
  
 数组是显示、 排序，并且再次显示。 数组必须进行排序以便使用<xref:System.Array.BinarySearch%2A>方法。  
  
> [!NOTE]
>  对调用<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。 如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载然后用于两个字符串搜索，另一个不在使用数组和一个，是。 数组和返回值的<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>方法传递给`ShowWhere`泛型方法，如果找到该字符串，而且否则元素的搜索字符串将介于像它是数组中显示的索引值。 索引是如果字符串不是 n 负数组，因此`ShowWhere`方法采用的按位求补 (~ 中 C# 和 Visual c + + 中，运算符`Xor`在 Visual Basic 中的为-1) 若要获取大于搜索 stri 列表中的第一个元素的索引ng。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</param>
        <param name="index">要搜索的范围的起始索引。</param>
        <param name="length">要搜索的范围的长度。</param>
        <param name="value">要搜索的对象。</param>
        <summary>使用由 <see cref="T:System.Array" /> 中每个元素和指定值实现的 <see cref="T:System.IComparable`1" /> 泛型接口，在一维排序数组的某个元素范围中搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持包含负索引的搜索数组。 `array` 必须调用此方法之前进行排序。  
  
 如果数组不包含指定的值，此方法将返回负整数。 你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。 如果此索引等于数组的大小，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 `T` 必须实现<xref:System.IComparable%601>泛型接口，用于比较。 元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable%601>实现; 否则，结果可能不正确。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。  
  
 `null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`不生成异常。  
  
> [!NOTE]
>  为测试，每个元素`value`传递给相应<xref:System.IComparable%601>实现，即使`value`是`null`。 也就是说，<xref:System.IComparable%601>实现确定给定的元素如何比较到`null`。  
  
 此方法为 O (日志`n`) 操作，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  -或-  <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</param>
        <param name="index">要搜索的范围的起始索引。</param>
        <param name="length">要搜索的范围的长度。</param>
        <param name="value">要搜索的对象。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现。  -或-  若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 实现。</param>
        <summary>使用指定 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，在一维排序数组的某个元素范围中搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持包含负索引的搜索数组。 `array` 必须调用此方法之前进行排序。  
  
 如果数组不包含指定的值，此方法将返回负整数。 你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。 如果此索引等于数组的大小，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 比较器自定义如何比较元素。 例如，你可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>作为要执行不区分大小写的字符串搜索的比较器。  
  
 如果`comparer`不`null`的元素`array`与使用指定的指定值进行比较<xref:System.Collections.Generic.IComparer%601>泛型接口实现。 元素`array`必须已在增加根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。  
  
 如果`comparer`是`null`，完成比较使用<xref:System.IComparable%601>为类型提供的泛型接口实现`T`。 元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable%601>实现; 否则，结果可能不正确。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。  
  
 `null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`使用时不生成异常<xref:System.IComparable%601>。  
  
> [!NOTE]
>  为测试，每个元素`value`传递给相应<xref:System.IComparable%601>实现，即使`value`是`null`。 也就是说，<xref:System.IComparable%601>实现确定给定的元素如何比较到`null`。  
  
 此方法为 O (日志`n`) 操作，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  -或-  <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">需要清除其元素的数组。</param>
        <param name="index">要清除的一系列元素的起始索引。</param>
        <param name="length">要清除的元素数。</param>
        <summary>将数组中的某个范围的元素设置为每个元素类型的默认值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将在数组中的每个元素重置为元素类型的默认值。 它设置每个元素的引用类型 (包括<xref:System.String>元素) 到`null`，并将值类型的元素设置为下表中显示的默认值。  
  
|类型|“值”|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|所有整型和浮点数字类型|0 （零）|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|其他值类型|该类型的字段的默认值|  
  
 范围清除元素换行从行至行多维数组中。  
  
 此方法仅清除元素; 的值它不会删除元素本身。 数组具有固定的大小，则因此，不能添加或删除元素。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Array.Clear%2A>方法来重置一维、 二维和三维数组中的整数值。  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 下面的示例定义`TimeZoneTime`结构，其中包含<xref:System.TimeZoneInfo>字段和<xref:System.DateTimeOffset>字段。 然后，它调用<xref:System.Array.Clear%2A>方法清除在两个元素数组中的一个元素`TimeZoneTime`值。 该方法将清除元素的值设置的默认值为<xref:System.TimeZoneInfo>对象，它是`null`，和的默认值<xref:System.DateTimeOffset>对象，它是<xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> 小于 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小于零。  -或-  <paramref name="index" /> 与 <paramref name="length" /> 之和大于 <paramref name="array" /> 的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建 <see cref="T:System.Array" /> 的浅表副本。</summary>
        <returns>
          <see cref="T:System.Array" /> 的浅表副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浅表复制<xref:System.Array>的元素复制<xref:System.Array>，无论它们是引用类型还是值类型，但它不会复制引用所引用的对象。 在新的引用<xref:System.Array>指向相同对象的原始中的引用<xref:System.Array>指向。  
  
 与此相反的深层副本<xref:System.Array>将复制的元素，并直接或间接引用的元素的所有内容。  
  
 克隆属于相同<xref:System.Type>与原始<xref:System.Array>。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>。  
  
   
  
## Examples  
 下面的代码示例克隆<xref:System.Globalization.CultureInfo?displayProperty=nameWithType>数组和演示的浅表副本的行为。  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要复制的数据的 <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">一个 32 位整数，它表示 <c>sourceArray</c> 中复制开始处的索引。</param>
        <param name="destinationArray">接收数据的 <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">一个 32 位整数，它表示 <c>destinationArray</c> 中存储开始处的索引。</param>
        <param name="length">一个 32 位整数，它表示要复制的元素数目。</param>
        <summary>复制 <see cref="T:System.Array" /> 中的一系列元素（从指定的源索引开始），并将它们粘贴到另一 <see cref="T:System.Array" /> 中（从指定的目标索引开始）。  保证在复制未成功完成的情况下撤消所有更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`和`destinationArray`参数必须具有相同数量的维度。  `sourceArray`类型必须相同或派生自`destinationArray`类型; 否则为<xref:System.ArrayTypeMismatchException>引发。  与不同<xref:System.Array.Copy%2A>，<xref:System.Array.ConstrainedCopy%2A>在执行任何操作之前验证数组类型的兼容性。  
  
 在多维阵列之间复制时，该数组表现得像是长时间一维数组，其中的行 （或多个列） 从概念上讲列出了端到端。 例如，如果数组有三个行 （列） 带有四个元素从数组的开头的每个，复制的六个元素会将复制所有四个元素的第一行 （或列） 和第二个行 （或列） 的前两个元素。 第三个行 （或列），第二个元素从其开始复制`sourceIndex`必须是第一个行 （或列） 的上限加上的第二个行 （或列） 的长度值，再加上 2。  
  
 如果`sourceArray`和`destinationArray`重叠，此方法的行为就像的原始值`sourceArray`在临时位置之前保留`destinationArray`将被覆盖。  
  
 [C++]  
  
 此方法相当于标准的 C/c + + 函数`memmove`，而不`memcpy`。  
  
 数组可以是引用类型的数组或值类型数组。  如果`sourceArray`和`destinationArray`两个引用类型数组或类型的两个数组<xref:System.Object>，执行的浅表副本。 浅表复制<xref:System.Array>是一种新<xref:System.Array>包含对原始与相同的元素的引用<xref:System.Array>。 元素本身或任何引用的元素不会复制。 与此相反的深层副本<xref:System.Array>将复制的元素，并直接或间接引用的元素的所有内容。  
  
 如果此方法将引发时复制时，出现异常`destinationArray`保持不变; 因此，<xref:System.Array.ConstrainedCopy%2A>可以受约束的执行区域内使用 (<xref:System.Runtime.ConstrainedExecution.Cer>)。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> 为 <see langword="null" />。  -或-  <paramref name="destinationArray" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> 类型与 <paramref name="destinationArray" /> 类型不同，且不派生自后者。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> 少于 <paramref name="sourceArray" /> 的第一个维度的下限。  -或-  <paramref name="destinationIndex" /> 少于 <paramref name="destinationArray" /> 的第一个维度的下限。  -或-  <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> 大于从 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 末尾的元素数。  -或-  <paramref name="length" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 末尾之间的元素数。</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">源数组元素的类型。</typeparam>
        <typeparam name="TOutput">目标数组元素的类型。</typeparam>
        <param name="array">要转换为目标类型的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="converter">用于将每个元素从一种类型转换为另一种类型的 <see cref="T:System.Converter`2" />。</param>
        <summary>将一种类型的数组转换为另一种类型的数组。</summary>
        <returns>目标类型的数组，包含从源数组转换而来的元素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602>是将对象转换为目标类型的方法的委托。  元素`array`单独传递给<xref:System.Converter%602>，和转换后的元素保存在新的数组。  
  
 源`array`保持不变。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例定义一个名为方法`PointFToPoint`，用于将转换<xref:System.Drawing.PointF>结构<xref:System.Drawing.Point>结构。 然后，示例创建的数组<xref:System.Drawing.PointF>结构，创建`Converter<PointF, Point>`委托 (`Converter(Of PointF, Point)`在 Visual Basic 中) 来表示`PointFToPoint`方法，并将传递到委托<xref:System.Array.ConvertAll%2A>方法。 <xref:System.Array.ConvertAll%2A>方法将传递到输入列表的每个元素`PointFToPoint`方法并将转换后的元素放入一个新的列表<xref:System.Drawing.Point>结构。 显示这两个列表。  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。  -或-  <paramref name="converter" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将一个 <see cref="T:System.Array" /> 的一部分元素复制到另一个 <see cref="T:System.Array" /> 中，并根据需要执行类型强制转换和装箱。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要复制的数据的 <see cref="T:System.Array" />。</param>
        <param name="destinationArray">接收数据的 <see cref="T:System.Array" />。</param>
        <param name="length">一个 32 位整数，它表示要复制的元素数目。</param>
        <summary>从第一个元素开始复制 <see cref="T:System.Array" /> 中的一系列元素，将它们粘贴到另一 <see cref="T:System.Array" /> 中（从第一个元素开始）。 长度指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`和`destinationArray`参数必须具有相同数量的维度。 此外，`destinationArray`必须已具有已指定维度，并且必须具有足够数量的元素，以容纳所复制的数据。  
  
 在多维阵列之间复制时，数组表现得像是长时间一维数组，其中的行 （或多个列） 从概念上讲首尾相连。 例如，如果数组有三个行 （列） 带有四个元素从数组的开头的每个，复制的六个元素会将复制所有四个元素的第一行 （或列） 和第二个行 （或列） 的前两个元素。  
  
 如果`sourceArray`和`destinationArray`重叠，此方法的行为就像的原始值`sourceArray`在临时位置之前保留`destinationArray`将被覆盖。  
  
 [C++]  
  
 此方法相当于标准的 C/c + + 函数`memmove`，而不`memcpy`。  
  
 数组可以是引用类型的数组或值类型数组。 执行类型转换，则所需的方式。  
  
-   当从引用类型的数组复制到值类型的数组，每个元素是取消装箱，然后将其复制。 当从值类型数组复制到引用类型的数组，每个元素被装箱，然后将其复制。  
  
-   在复制到一个引用类型或值类型数组中<xref:System.Object>数组，<xref:System.Object>然后复制并创建来保存每个值或引用。 当从复制<xref:System.Object>到引用类型或值类型数组和分配的数组不能，<xref:System.InvalidCastException>引发。  
  
-   如果`sourceArray`和`destinationArray`两个引用类型数组或类型的两个数组<xref:System.Object>，执行的浅表副本。 浅表复制<xref:System.Array>是一种新<xref:System.Array>包含对原始与相同的元素的引用<xref:System.Array>。 元素本身或任何引用的元素不会复制。 与此相反的深层副本<xref:System.Array>将复制的元素，并直接或间接引用的元素的所有内容。  
  
 <xref:System.ArrayTypeMismatchException>引发如果数组的不可兼容类型。 类型兼容性定义如下：  
  
-   一种类型适用于本身。  
  
-   值类型适用于<xref:System.Object>和与该值类型实现的接口类型。 值类型被视为连接的接口，仅当它直接实现该接口。 断开连接的类型不兼容。  
  
-   两个内部函数 （预定义） 的值类型相兼容。 如果将源类型从复制到目标类型是一个的扩大转换。 扩大转换永远不会丢失信息，而收缩转换可能会丢失信息。 例如，将一个 32 位带符号的整数转换为 64 位有符号整数是扩大转换，并将一个 64 位带符号的整数转换为 32 位有符号整数都是收缩转换。 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
-   内部 （用户定义） 的值类型是只与其本身兼容。  
  
-   枚举具有隐式转换为<xref:System.Enum>和为其基础类型。  
  
 如果在每个元素`sourceArray`需要向下转换 （例如，从派生类的基类或接口的对象） 和一个或多个元素不能强制转换为中的对应类型`destinationArray`、<xref:System.InvalidCastException>引发。  
  
 如果此方法将引发异常时复制的状态`destinationArray`是不确定的。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> 为 <see langword="null" />。  -或-  <paramref name="destinationArray" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> 大于 <paramref name="sourceArray" /> 中的元素数。  -或-  <paramref name="length" /> 大于 <paramref name="destinationArray" /> 中的元素数。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要复制的数据的 <see cref="T:System.Array" />。</param>
        <param name="destinationArray">接收数据的 <see cref="T:System.Array" />。</param>
        <param name="length">一个 64 位整数，它表示要复制的元素数目。 该整数必须介于零和 <see cref="F:System.Int32.MaxValue" /> 之间（包括这两个值）。</param>
        <summary>从第一个元素开始复制 <see cref="T:System.Array" /> 中的一系列元素，将它们粘贴到另一 <see cref="T:System.Array" /> 中（从第一个元素开始）。 长度指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`和`destinationArray`参数必须具有相同数量的维度。 此外，`destinationArray`必须已具有已指定维度，并且必须具有足够数量的元素，以容纳所复制的数据。  
  
 在多维阵列之间复制时，数组表现得像是长时间一维数组，其中的行 （或多个列） 从概念上讲首尾相连。 例如，如果数组有三个行 （列） 带有四个元素从数组的开头的每个，复制的六个元素会将复制所有四个元素的第一行 （或列） 和第二个行 （或列） 的前两个元素。  
  
 如果`sourceArray`和`destinationArray`重叠，此方法的行为就像的原始值`sourceArray`在临时位置之前保留`destinationArray`将被覆盖。  
  
 [C++]  
  
 此方法相当于标准的 C/c + + 函数`memmove`，而不`memcpy`。  
  
 数组可以是引用类型的数组或值类型数组。 执行类型转换，则所需的方式。  
  
-   当从引用类型的数组复制到值类型的数组，每个元素是取消装箱，然后将其复制。 当从值类型数组复制到引用类型的数组，每个元素被装箱，然后将其复制。  
  
-   在复制到一个引用类型或值类型数组中<xref:System.Object>数组，<xref:System.Object>然后复制并创建来保存每个值或引用。 当从复制<xref:System.Object>到引用类型或值类型数组和分配的数组不能，<xref:System.InvalidCastException>引发。  
  
-   如果`sourceArray`和`destinationArray`两个引用类型数组或类型的两个数组<xref:System.Object>，执行的浅表副本。 浅表复制<xref:System.Array>是一种新<xref:System.Array>包含对原始与相同的元素的引用<xref:System.Array>。 元素本身或任何引用的元素不会复制。 与此相反的深层副本<xref:System.Array>将复制的元素，并直接或间接引用的元素的所有内容。  
  
 <xref:System.ArrayTypeMismatchException>引发如果数组的不可兼容类型。 类型兼容性定义如下：  
  
-   一种类型适用于本身。  
  
-   值类型适用于<xref:System.Object>和与该值类型实现的接口类型。 值类型被视为连接的接口，仅当它直接实现该接口。 断开连接的类型不兼容。  
  
-   两个内部函数 （预定义） 的值类型相兼容。 如果将源类型从复制到目标类型是一个的扩大转换。 扩大转换永远不会丢失信息，而收缩转换可能会丢失信息。 例如，将一个 32 位带符号的整数转换为 64 位有符号整数是扩大转换，并将一个 64 位带符号的整数转换为 32 位有符号整数都是收缩转换。 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
-   内部 （用户定义） 的值类型是只与其本身兼容。  
  
-   枚举具有隐式转换为<xref:System.Enum>和为其基础类型。  
  
 如果在每个元素`sourceArray`需要向下转换 （例如，从派生类的基类或接口的对象） 和一个或多个元素不能强制转换为中的对应类型`destinationArray`、<xref:System.InvalidCastException>引发。  
  
 如果此方法将引发异常时复制的状态`destinationArray`是不确定的。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> 为 <see langword="null" />。  -或-  <paramref name="destinationArray" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> 小于 0 或大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> 大于 <paramref name="sourceArray" /> 中的元素数。  -或-  <paramref name="length" /> 大于 <paramref name="destinationArray" /> 中的元素数。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要复制的数据的 <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">一个 32 位整数，它表示 <c>sourceArray</c> 中复制开始处的索引。</param>
        <param name="destinationArray">接收数据的 <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">一个 32 位整数，它表示 <c>destinationArray</c> 中存储开始处的索引。</param>
        <param name="length">一个 32 位整数，它表示要复制的元素数目。</param>
        <summary>复制 <see cref="T:System.Array" /> 中的一系列元素（从指定的源索引开始），并将它们粘贴到另一 <see cref="T:System.Array" /> 中（从指定的目标索引开始）。 长度和索引指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`和`destinationArray`参数必须具有相同数量的维度。 此外，`destinationArray`必须已具有已指定维度，并且必须具有足够数量的元素从开始`destinationIndex`以容纳所复制的数据的位置。  
  
 在多维阵列之间复制时，该数组表现得像是长时间一维数组，其中的行 （或多个列） 从概念上讲列出了端到端。 例如，如果数组有三个行 （列） 带有四个元素从数组的开头的每个，复制的六个元素会将复制所有四个元素的第一行 （或列） 和第二个行 （或列） 的前两个元素。 第三个行 （或列），第二个元素从其开始复制`sourceIndex`必须是第一个行 （或列） 的上限加上的第二个行 （或列） 的长度值，再加上 2。  
  
 如果`sourceArray`和`destinationArray`重叠，此方法的行为就像的原始值`sourceArray`在临时位置之前保留`destinationArray`将被覆盖。  
  
 [C++]  
  
 此方法相当于标准的 C/c + + 函数`memmove`，而不`memcpy`。  
  
 数组可以是引用类型的数组或值类型数组。 执行类型转换，则所需的方式。  
  
-   当从引用类型的数组复制到值类型的数组，每个元素是取消装箱，然后将其复制。 当从值类型数组复制到引用类型的数组，每个元素被装箱，然后将其复制。  
  
-   在复制到一个引用类型或值类型数组中<xref:System.Object>数组，<xref:System.Object>然后复制并创建来保存每个值或引用。 当从复制<xref:System.Object>到引用类型或值类型数组和分配的数组不能，<xref:System.InvalidCastException>引发。  
  
-   如果`sourceArray`和`destinationArray`两个引用类型数组或类型的两个数组<xref:System.Object>，执行的浅表副本。 浅表复制<xref:System.Array>是一种新<xref:System.Array>包含对原始与相同的元素的引用<xref:System.Array>。 元素本身或任何引用的元素不会复制。 与此相反的深层副本<xref:System.Array>将复制的元素，并直接或间接引用的元素的所有内容。  
  
 <xref:System.ArrayTypeMismatchException>引发如果数组的不可兼容类型。 类型兼容性定义如下：  
  
-   一种类型适用于本身。  
  
-   值类型适用于<xref:System.Object>和与该值类型实现的接口类型。 值类型被视为连接的接口，仅当它直接实现该接口。 断开连接的类型不兼容。  
  
-   两个内部函数 （预定义） 的值类型相兼容。 如果将源类型从复制到目标类型是一个的扩大转换。 扩大转换永远不会丢失信息，而收缩转换可能会丢失信息。 例如，将一个 32 位带符号的整数转换为 64 位有符号整数是扩大转换，并将一个 64 位带符号的整数转换为 32 位有符号整数都是收缩转换。 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
-   内部 （用户定义） 的值类型是只与其本身兼容。  
  
-   枚举具有隐式转换为<xref:System.Enum>和为其基础类型。  
  
 如果在每个元素`sourceArray`需要向下转换 （例如，从派生类的基类或接口的对象） 和一个或多个元素不能强制转换为中的对应类型`destinationArray`、<xref:System.InvalidCastException>引发。  
  
 如果此方法将引发异常时复制的状态`destinationArray`是不确定的。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何从某个复制<xref:System.Array>类型的<xref:System.Object>到另一个<xref:System.Array>的整数类型。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> 为 <see langword="null" />。  -或-  <paramref name="destinationArray" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> 少于 <paramref name="sourceArray" /> 的第一个维度的下限。  -或-  <paramref name="destinationIndex" /> 少于 <paramref name="destinationArray" /> 的第一个维度的下限。  -或-  <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> 大于从 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 末尾的元素数。  -或-  <paramref name="length" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 末尾之间的元素数。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要复制的数据的 <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">一个 64 位整数，它表示 <c>sourceArray</c> 中复制开始处的索引。</param>
        <param name="destinationArray">接收数据的 <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">一个 64 位整数，它表示 <c>destinationArray</c> 中存储开始处的索引。</param>
        <param name="length">一个 64 位整数，它表示要复制的元素数目。 该整数必须介于零和 <see cref="F:System.Int32.MaxValue" /> 之间（包括这两个值）。</param>
        <summary>复制 <see cref="T:System.Array" /> 中的一系列元素（从指定的源索引开始），并将它们粘贴到另一 <see cref="T:System.Array" /> 中（从指定的目标索引开始）。 长度和索引指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`和`destinationArray`参数必须具有相同数量的维度。 此外，`destinationArray`必须已具有已指定维度，并且必须具有足够数量的元素从开始`destinationIndex`以容纳所复制的数据的位置。  
  
 在多维阵列之间复制时，该数组表现得像是长时间一维数组，其中的行 （或多个列） 从概念上讲列出了端到端。 例如，如果数组有三个行 （列） 带有四个元素从数组的开头的每个，复制的六个元素会将复制所有四个元素的第一行 （或列） 和第二个行 （或列） 的前两个元素。 第三个行 （或列），第二个元素从其开始复制`sourceIndex`必须是第一个行 （或列） 的上限加上的第二个行 （或列） 的长度值，再加上 2。  
  
 如果`sourceArray`和`destinationArray`重叠，此方法的行为就像的原始值`sourceArray`在临时位置之前保留`destinationArray`将被覆盖。  
  
 [C++]  
  
 此方法相当于标准的 C/c + + 函数`memmove`，而不`memcpy`。  
  
 数组可以是引用类型的数组或值类型数组。 执行类型转换，则所需的方式。  
  
-   当从引用类型的数组复制到值类型的数组，每个元素是取消装箱，然后将其复制。 当从值类型数组复制到引用类型的数组，每个元素被装箱，然后将其复制。  
  
-   在复制到一个引用类型或值类型数组中<xref:System.Object>数组，<xref:System.Object>然后复制并创建来保存每个值或引用。 当从复制<xref:System.Object>到引用类型或值类型数组和分配的数组不能，<xref:System.InvalidCastException>引发。  
  
-   如果`sourceArray`和`destinationArray`两个引用类型数组或类型的两个数组<xref:System.Object>，执行的浅表副本。 浅表复制<xref:System.Array>是一种新<xref:System.Array>包含对原始与相同的元素的引用<xref:System.Array>。 元素本身或任何引用的元素不会复制。 与此相反的深层副本<xref:System.Array>将复制的元素，并直接或间接引用的元素的所有内容。  
  
 <xref:System.ArrayTypeMismatchException>引发如果数组的不可兼容类型。 类型兼容性定义如下：  
  
-   一种类型适用于本身。  
  
-   值类型适用于<xref:System.Object>和与该值类型实现的接口类型。 值类型被视为连接的接口，仅当它直接实现该接口。 断开连接的类型不兼容。  
  
-   两个内部函数 （预定义） 的值类型相兼容。 如果将源类型从复制到目标类型是一个的扩大转换。 扩大转换永远不会丢失信息，而收缩转换可能会丢失信息。 例如，将一个 32 位带符号的整数转换为 64 位有符号整数是扩大转换，并将一个 64 位带符号的整数转换为 32 位有符号整数都是收缩转换。 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
-   内部 （用户定义） 的值类型是只与其本身兼容。  
  
-   枚举具有隐式转换为<xref:System.Enum>和为其基础类型。  
  
 如果在每个元素`sourceArray`需要向下转换 （例如，从派生类的基类或接口的对象） 和一个或多个元素不能强制转换为中的对应类型`destinationArray`、<xref:System.InvalidCastException>引发。  
  
 如果此方法将引发异常时复制的状态`destinationArray`是不确定的。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何从某个复制<xref:System.Array>类型的<xref:System.Object>到另一个<xref:System.Array>的整数类型。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> 为 <see langword="null" />。  -或-  <paramref name="destinationArray" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> 超出了 <paramref name="sourceArray" /> 的有效索引范围。  -或-  <paramref name="destinationIndex" /> 超出了 <paramref name="destinationArray" /> 的有效索引范围。  -或-  <paramref name="length" /> 小于 0 或大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> 大于从 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 末尾的元素数。  -或-  <paramref name="length" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 末尾之间的元素数。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将当前一维数组的所有元素复制到指定的一维数组中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一维数组，它是从当前数组复制的元素的目标。</param>
        <param name="index">一个 32 位整数，它表示 <c>array</c> 中复制开始处的索引。</param>
        <summary>从指定的目标数组索引处开始，将当前一维数组的所有元素复制到指定的一维数组中。 索引指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法会复制到当前数组实例的所有元素`array`目标数组索引处开始`index`。 `array`目标数组必须已具有已指定维度，并且必须具有足够数量的元素，以适应复制的元素。 否则，该方法将引发异常。  
  
 此方法支持<xref:System.Collections.ICollection?displayProperty=nameWithType>接口。 如果实现<xref:System.Collections.ICollection?displayProperty=nameWithType>是不明确要求，使用<xref:System.Array.Copy%2A>以避免额外间接寻址。  
  
 如果此方法将引发异常时复制的状态`array`是不确定的。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>。它执行的浅表副本。  
  
   
  
## Examples  
 下面的代码示例演示如何复制<xref:System.Array>到另一个<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 下面的代码示例演示如何复制<xref:System.Array>到另一个<xref:System.Array>、 非零的下限。 请注意，整个源<xref:System.Array>包括覆盖目标中的现有元素的空元素的复制<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 <paramref name="array" /> 的下限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> 是多维的。  -或-  源数组中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 的末尾之间的可用元素数。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">无法自动将源 <see cref="T:System.Array" /> 的类型转换为目标 <paramref name="array" /> 的类型。</exception>
        <exception cref="T:System.RankException">源数组是多维数组。</exception>
        <exception cref="T:System.InvalidCastException">源 <see cref="T:System.Array" /> 中至少有一个元素无法转换为目标 <paramref name="array" /> 的类型。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">一维数组，它是从当前数组复制的元素的目标。</param>
        <param name="index">一个 64 位整数，它表示 <c>array</c> 中复制开始处的索引。</param>
        <summary>从指定的目标数组索引处开始，将当前一维数组的所有元素复制到指定的一维数组中。 索引指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法会复制到当前数组实例的所有元素`array`目标数组索引处开始`index`。 `array`目标数组必须已具有已指定维度，并且必须具有足够数量的元素，以适应复制的元素。 否则，该方法将引发异常。  
  
 此方法支持<xref:System.Collections.ICollection?displayProperty=nameWithType>接口。 如果实现<xref:System.Collections.ICollection?displayProperty=nameWithType>是不明确要求，使用<xref:System.Array.Copy%2A>以避免额外间接寻址。  
  
 如果此方法将引发异常时复制的状态`array`是不确定的。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>。它执行的浅表副本。  
  
   
  
## Examples  
 下面的代码示例演示如何复制<xref:System.Array>到另一个<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 下面的代码示例演示如何复制<xref:System.Array>到另一个<xref:System.Array>、 非零的下限。 请注意，整个源<xref:System.Array>包括覆盖目标中的现有元素的空元素的复制<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> 是多维的。  -或-  源数组中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 的末尾之间的可用元素数。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">无法自动将源 <see cref="T:System.Array" /> 的类型转换为目标 <paramref name="array" /> 的类型。</exception>
        <exception cref="T:System.RankException">源 <see cref="T:System.Array" /> 是多维的。</exception>
        <exception cref="T:System.InvalidCastException">源 <see cref="T:System.Array" /> 中至少有一个元素无法转换为目标 <paramref name="array" /> 的类型。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Array" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="length">要创建的 <see cref="T:System.Array" /> 的大小。</param>
        <summary>创建使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和长度的一维 <see cref="T:System.Array" />。</summary>
        <returns>使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和长度的新的一维 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与大多数类时，不同<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许后期绑定访问。  
  
 引用类型元素将初始化为`null`。 值类型的元素将初始化为零。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化一维<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  -或-  <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="lengths">一个 32 位整数数组，它表示要创建的 <see cref="T:System.Array" /> 中每个维度的大小。</param>
        <summary>创建索引从零开始、具有指定 <see cref="T:System.Type" /> 和维长的多维 <see cref="T:System.Array" />。 维的长度在一个 32 位整数数组中指定。</summary>
        <returns>指定 <see cref="T:System.Type" /> 的新多维 <see cref="T:System.Array" />，该数组每个维具有指定长度，且使用从零开始的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与大多数类时，不同<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许后期绑定访问。  
  
 中的元素数`lengths`数组必须等于在新的维度数<xref:System.Array>。 每个元素`lengths`数组必须在新中指定的相应维度的长度<xref:System.Array>。  
  
 引用类型元素将初始化为`null`。 值类型的元素将初始化为零。  
  
 此方法为 O (`n`) 操作，其中`n`是中的所有值的乘积`lengths`。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化的多维<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> 为 <see langword="null" />。  -或-  <paramref name="lengths" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。  -或-  <paramref name="lengths" /> 数组包含的元素少于一个。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  -或-  <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lengths" /> 中的任何值都小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="lengths">一个 64 位整数数组，它表示要创建的 <see cref="T:System.Array" /> 中每个维度的大小。 数组中的每个整数都必须介于零和 <see cref="F:System.Int32.MaxValue" /> 之间，（包括零和 System.Int32.MaxValue）。</param>
        <summary>创建索引从零开始、具有指定 <see cref="T:System.Type" /> 和维长的多维 <see cref="T:System.Array" />。 维的长度在一个 64 位整数数组中指定。</summary>
        <returns>指定 <see cref="T:System.Type" /> 的新多维 <see cref="T:System.Array" />，该数组每个维具有指定长度，且使用从零开始的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与大多数类时，不同<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许后期绑定访问。  
  
 中的元素数`lengths`数组必须等于在新的维度数<xref:System.Array>。 每个元素`lengths`数组必须在新中指定的相应维度的长度<xref:System.Array>。  
  
 引用类型元素将初始化为`null`。 值类型的元素将初始化为零。  
  
 此方法为 O (`n`) 操作，其中`n`是中的所有值的乘积`lengths`。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化的多维<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> 为 <see langword="null" />。  -或-  <paramref name="lengths" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。  -或-  <paramref name="lengths" /> 数组包含的元素少于一个。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  -或-  <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lengths" /> 中的所有值都小于零或大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="length1">要创建的 <see cref="T:System.Array" /> 的第一维的大小。</param>
        <param name="length2">要创建的 <see cref="T:System.Array" /> 的第二维的大小。</param>
        <summary>创建使用从零开始的索引、具有指定 <see cref="T:System.Array" /> 和维长的二维 <see cref="T:System.Type" />。</summary>
        <returns>使用从零开始的索引、具有指定 <see cref="T:System.Array" /> 的新的二维 <see cref="T:System.Type" />，其每个维度都为指定的长度。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与大多数类时，不同<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许后期绑定访问。  
  
 引用类型元素将初始化为`null`。 值类型的元素将初始化为零。  
  
 此方法为 O (`n`) 操作，其中`n`是产品`length1`和`length2`。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化的二维<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  -或-  <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> 小于零。  -或-  <paramref name="length2" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="lengths">一维数组，它包含要创建的 <see cref="T:System.Array" /> 的每个维度的大小。</param>
        <param name="lowerBounds">一维数组，它包含要创建的 <see cref="T:System.Array" /> 的每个维度的下限（起始索引）。</param>
        <summary>创建具有指定下限、指定 <see cref="T:System.Array" /> 和维长的多维 <see cref="T:System.Type" />。</summary>
        <returns>新的指定 <see cref="T:System.Array" /> 的多维 <see cref="T:System.Type" />，每个维度都有指定的长度和下限。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与大多数类时，不同<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许后期绑定访问。  
  
 `lengths`和`lowerBounds`数组必须具有相同数量的元素。 中的元素数`lengths`数组必须等于在新的维度数<xref:System.Array>。  
  
 每个元素`lengths`数组必须在新中指定的相应维度的长度<xref:System.Array>。  
  
 每个元素`lowerBounds`数组必须在新中指定的相应维度的下限<xref:System.Array>。 通常情况下，.NET Framework 类库和许多编程语言不处理非零下限。  
  
 引用类型元素将初始化为`null`。 值类型的元素将初始化为零。  
  
 此方法为 O (`n`) 操作，其中`n`是中的所有值的乘积`lengths`。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化的多维<xref:System.Array>具有指定的下限。  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> 为 <see langword="null" />。  -或-  <paramref name="lengths" /> 为 <see langword="null" />。  -或-  <paramref name="lowerBounds" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。  -或-  <paramref name="lengths" /> 数组包含的元素少于一个。  -或-  <paramref name="lengths" /> 和 <paramref name="lowerBounds" /> 数组包含的元素数不同。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  -或-  <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lengths" /> 中的任何值都小于零。  -或-  <paramref name="lowerBounds" /> 中的任意一个值都很大，因此，维的下限和长度的和大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="length1">要创建的 <see cref="T:System.Array" /> 的第一维的大小。</param>
        <param name="length2">要创建的 <see cref="T:System.Array" /> 的第二维的大小。</param>
        <param name="length3">要创建的 <see cref="T:System.Array" /> 的第三维的大小。</param>
        <summary>创建使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和维长的三维 <see cref="T:System.Array" />。</summary>
        <returns>每个维具有指定长度、使用从零开始的索引的指定 <see cref="T:System.Type" /> 的新三维 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与大多数类时，不同<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许后期绑定访问。  
  
 引用类型元素将初始化为`null`。 值类型的元素将初始化为零。  
  
 此方法为 O (`n`) 操作，其中`n`是产品`length1`， `length2`，和`length3`。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化三维<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  -或-  <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> 小于零。  -或-  <paramref name="length2" /> 小于零。  -或-  <paramref name="length3" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <summary>返回一个空数组。</summary>
        <returns>返回一个空 <see cref="T:System.Array" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match">
          <see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>确定指定数组包含的元素是否与指定谓词定义的条件匹配。</summary>
        <returns>如果 <paramref name="array" /> 包含一个或多个与指定谓词所定义的条件相匹配的元素，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`单独传递给<xref:System.Predicate%601>，并且当找到匹配项时停止处理。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建<xref:System.Predicate%601>显式委托。 这些语言推断从上下文正确的委托，并自动创建。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例指定的匹配条件<xref:System.Array.Exists%2A>方法 usinglambda 表达式来检查是否世界各地给定的字母开头，或是否在世界各地找到上给定数组。  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 下面的示例使用<xref:System.Array.Exists%2A>方法，以指示是否使用指定的字符开始的字符串数组中的任何名称。 该示例实例化`StringSearcher`通过传递给其类构造函数搜索的字符串对象。 `StringSearcher.StartsWith`方法具有相同的签名<xref:System.Predicate%601>委托。 当<xref:System.Array.Exists%2A>方法调用，该数组的每个成员传递给委托，直到它返回`true`或循环访问数组中的所有元素。  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 可以还使用 lambda 表达式，而不是显式定义其签名相对应的方法的委托。 下面的示例替换`StringSearcher`类并将其`StartsWith`使用 lambda 表达式的方法。  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。  -或-  <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维数组。</param>
        <param name="match">用于定义要搜索的元素的条件的谓词。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中的第一个匹配元素。</summary>
        <returns>如果找到与指定谓词定义的条件匹配的第一个元素，则为该元素；否则为类型 <paramref name="T" /> 的默认值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是对的方法或 lambda 表达式返回一个委托`true`如果该对象传递给委托或 lambda 表达式中定义的条件匹配。  元素`array`单独传递给<xref:System.Predicate%601>，从第一个元素开始和结束的最后一个元素。  找到匹配项，已停止处理。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Predicate%601>委托以及<xref:System.Array.Find%2A>泛型方法搜索的数组<xref:System.Drawing.Point>结构。 表示委托，该方法`ProductGT10`，返回`true`是否大于 100,000 的 X 和 Y 字段的产品。 <xref:System.Array.Find%2A>方法返回满足测试条件的第一个点的数组的每个元素调用委托。  
  
> [!NOTE]
>  Visual Basic 和 C# 用户不需要显式创建委托，或者指定泛型方法的类型自变量。 编译器确定必需你提供的方法自变量的类型。  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 而不是显式定义具有必要的签名的方法实例化<xref:System.Predicate%601>委托，并将传递到委托<xref:System.Array.Find%2A>方法，它是通常使用 lambda 表达式。 下面的示例是上一，相同，但它使用 lambda 表达式作为`match`自变量。  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。  -或-  <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match">
          <see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>检索与指定谓词定义的条件匹配的所有元素。</summary>
        <returns>如果找到一个其中所有元素均与指定谓词定义的条件匹配的 <see cref="T:System.Array" />，则为该数组；否则为一个空 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`单独传递给<xref:System.Predicate%601>，和的条件相匹配的元素保存在返回的数组。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例使用范围可以从 0 到 1000 的值创建 50 的随机数的数组。 然后，它调用<xref:System.Array.FindAll%2A>方法返回的值，范围从 300 为 600 的 lambda 表达式。 请注意，lambda 表达式将传递一个名为参数`x`; 这表示传递给单个数组成员<xref:System.Predicate%601>。 另请注意，本地`lBound`和`uBound`变量是在 lambda 表达式中访问。  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 下面的代码示例演示<xref:System.Array.Find%2A>， <xref:System.Array.FindLast%2A>，和<xref:System.Array.FindAll%2A>泛型方法。 创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.Find%2A>泛型方法的开头，将每个元素传递给反过来遍历数组`EndsWithSaurus`方法。 搜索将停止时`EndsWithSaurus`方法返回`true`元素"Amargasaurus"。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindLast%2A>泛型方法用于搜索向后结尾的数组。 它找到的元素"Dilophosaurus"在位置 5。 <xref:System.Array.FindAll%2A>泛型方法用于返回数组，其中包含以"saurus"结尾的所有元素。 元素的显示。  
  
 代码示例还演示<xref:System.Array.Exists%2A>和<xref:System.Array.TrueForAll%2A>泛型方法。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。  -或-  <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜索与指定谓词定义的条件匹配的元素，然后返回 <see cref="T:System.Array" /> 或其某个部分中第一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match">
          <see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中第一个匹配元素的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>搜索向前从第一个元素开始和结束时间的最后一个元素。  
  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`单独传递给<xref:System.Predicate%601>。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个重载<xref:System.Array.FindIndex%2A>泛型方法。 创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从开始时，将每个元素传递给反过来遍历数组`EndsWithSaurus`方法。 搜索将停止时`EndsWithSaurus`方法返回`true`位于位置 1 处的元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索位置 2 处开始并一直到数组末尾的数组。 它找到位置 5 处的元素。 最后，<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的位置 2 处开始的三个元素的范围。 它返回 – 1，因为没有在该范围内不复存在名以"saurus"结尾。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。  -或-  <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="match">
          <see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Array" /> 中从指定索引到最后一个元素的元素范围内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>处开始向前搜索`startIndex`和结束时间的最后一个元素。  
  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`单独传递给<xref:System.Predicate%601>。  
  
 此方法为 O (`n`) 操作，其中`n`是中的元素数`startIndex`到末尾`array`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个重载<xref:System.Array.FindIndex%2A>泛型方法。 创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从开始时，将每个元素传递给反过来遍历数组`EndsWithSaurus`方法。 搜索将停止时`EndsWithSaurus`方法返回`true`位于位置 1 处的元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索位置 2 处开始并一直到数组末尾的数组。 它找到位置 5 处的元素。 最后，<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的位置 2 处开始的三个元素的范围。 它返回 – 1，因为没有在该范围内不复存在名以"saurus"结尾。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。  -或-  <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="match">
          <see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的一个元素，并返回 <see cref="T:System.Array" /> 中从指定的索引开始、包含指定元素个数的元素范围内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>处开始向前搜索`startIndex`结束`startIndex`加上`count`减 1，如果`count`大于 0。  
  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`单独传递给<xref:System.Predicate%601>。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个重载<xref:System.Array.FindIndex%2A>泛型方法。 创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从开始时，将每个元素传递给反过来遍历数组`EndsWithSaurus`方法。 搜索将停止时`EndsWithSaurus`方法返回`true`位于位置 1 处的元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索位置 2 处开始并一直到数组末尾的数组。 它找到位置 5 处的元素。 最后，<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的位置 2 处开始的三个元素的范围。 它返回 – 1，因为没有在该范围内不复存在名以"saurus"结尾。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。  -或-  <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  -或-  <paramref name="count" /> 小于零。  -或-  <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match">
          <see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中的最后一个匹配元素。</summary>
        <returns>如果找到，则为与指定谓词所定义的条件相匹配的最后一个元素；否则为类型 <paramref name="T" /> 的默认值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`单独传递给<xref:System.Predicate%601>、 移动中向后<xref:System.Array>，从最后一个元素开始和结束的第一个元素。  找到匹配项，已停止处理。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Find%2A>， <xref:System.Array.FindLast%2A>，和<xref:System.Array.FindAll%2A>泛型方法。 创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.Find%2A>泛型方法的开头，将每个元素传递给反过来遍历数组`EndsWithSaurus`方法。 搜索将停止时`EndsWithSaurus`方法返回`true`元素"Amargasaurus"。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindLast%2A>泛型方法用于搜索向后结尾的数组。 它找到的元素"Dilophosaurus"在位置 5。 <xref:System.Array.FindAll%2A>泛型方法用于返回数组，其中包含以"saurus"结尾的所有元素。 元素的显示。  
  
 代码示例还演示<xref:System.Array.Exists%2A>和<xref:System.Array.TrueForAll%2A>泛型方法。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。  -或-  <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜索与指定谓词定义的条件匹配的元素，然后返回 <see cref="T:System.Array" /> 或其某个部分中最后一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match">
          <see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中最后一个匹配元素的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>向后搜索的最后一个元素开始，在第一个元素结束。  
  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`单独传递给<xref:System.Predicate%601>。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个重载<xref:System.Array.FindLastIndex%2A>泛型方法。 创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从结束时，将每个元素传递给反过来遍历数组向后`EndsWithSaurus`方法。 搜索将停止时`EndsWithSaurus`方法返回`true`位于位置 5 处的元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索数组开始位置 4 并向数组的开头后继续。 它找到位置 1 处的元素。 最后，<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的三个元素从位置 4 开始，向回查找 （即，元素 4、 3 和 2） 的范围。 它返回 – 1，因为没有在该范围内不复存在名以"saurus"结尾。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。  -或-  <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="match">
          <see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与由指定谓词定义的条件相匹配的元素，并返回 <see cref="T:System.Array" /> 中从第一个元素到指定索引的元素范围内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>是搜索向后开始`startIndex`和结束的第一个元素。  
  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`单独传递给<xref:System.Predicate%601>。  
  
 此方法为 O (`n`) 操作，其中`n`是从开始处的元素数目`array`到`startIndex`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个重载<xref:System.Array.FindLastIndex%2A>泛型方法。 创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从结束时，将每个元素传递给反过来遍历数组向后`EndsWithSaurus`方法。 搜索将停止时`EndsWithSaurus`方法返回`true`位于位置 5 处的元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索数组开始位置 4 并向数组的开头后继续。 它找到位置 1 处的元素。 最后，<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的三个元素从位置 4 开始，向回查找 （即，元素 4、 3 和 2） 的范围。 它返回 – 1，因为没有在该范围内不复存在名以"saurus"结尾。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。  -或-  <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="match">
          <see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Array" /> 中包含指定元素个数、到指定索引结束的元素范围内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>是搜索向后开始`startIndex`结束`startIndex`减`count`加上 1，如果`count`大于 0。  
  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`单独传递给<xref:System.Predicate%601>。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个重载<xref:System.Array.FindLastIndex%2A>泛型方法。 创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从结束时，将每个元素传递给反过来遍历数组向后`EndsWithSaurus`方法。 搜索将停止时`EndsWithSaurus`方法返回`true`位于位置 5 处的元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索数组开始位置 4 并向数组的开头后继续。 它找到位置 1 处的元素。 最后，<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的三个元素从位置 4 开始，向回查找 （即，元素 4、 3 和 2） 的范围。 它返回 – 1，因为没有在该范围内不复存在名以"saurus"结尾。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。  -或-  <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  -或-  <paramref name="count" /> 小于零。  -或-  <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">从零开始的一维 <see cref="T:System.Array" />，要对其元素执行操作。</param>
        <param name="action">要对 <c>array</c> 的每个元素执行的 <see cref="T:System.Action`1" />。</param>
        <summary>对指定数组的每个元素执行指定操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601>向其传递对对象执行的操作方法的委托。  元素`array`单独传递给<xref:System.Action%601>。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Array.ForEach%2A>要在整数数组中显示的每个元素的平方。  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。  -或-  <paramref name="action" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Collections.IEnumerator" /> 的 <see cref="T:System.Array" />。</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> 的一个 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic、 C#]  
  
 `foreach` C# 语言的语句 (`for each` c + + 中`For Each`在 Visual Basic 中) 隐藏了枚举数的复杂性。 因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 <xref:System.Collections.IEnumerator.Reset%2A> 也会将枚举器放回此位置。  在此位置上，未定义 <xref:System.Collections.IEnumerator.Current%2A>。 因此，在读取 <xref:System.Collections.IEnumerator.MoveNext%2A> 的值之前，必须调用 <xref:System.Collections.IEnumerator.Current%2A> 将枚举器向前移动到集合的第一个元素。  
  
 在调用 <xref:System.Collections.IEnumerator.Current%2A> 或 <xref:System.Collections.IEnumerator.MoveNext%2A> 之前，<xref:System.Collections.IEnumerator.Reset%2A> 返回同一对象。 <xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.IEnumerator.Current%2A> 设置为下一个元素。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过的末尾的集合，枚举数定位在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。 当枚举器位于此位置上，后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。 若要再次将 <xref:System.Collections.IEnumerator.Current%2A> 设置为集合的第一个元素，可以调用 <xref:System.Collections.IEnumerator.Reset%2A> 并接着调用 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合保持不变，枚举数就保持有效。 如果对集合进行更改（如添加、修改或删除元素），则枚举数将失效且不可恢复，而且其行为是不确定的。  
  
 该枚举数不具有独占访问集合的权限；因此，枚举整个集合本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Array.GetEnumerator%2A>列出数组的元素。  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">
          <see cref="T:System.Array" /> 的从零开始的维度，其长度需要确定。</param>
        <summary>获取一个 32 位整数，该整数表示 <see cref="T:System.Array" /> 的指定维中的元素数。</summary>
        <returns>一个 32 位整数，它表示指定维中的元素数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个示例<xref:System.Array.GetLength%2A>是`GetLength(0)`，其返回的第一个维度中的元素数<xref:System.Array>。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Array.GetLength%2A>以显示两个具有不同的秩的数组的维度。  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> 小于零。  -或-  <paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">
          <see cref="T:System.Array" /> 的从零开始的维度，其长度需要确定。</param>
        <summary>获取一个 64 位整数，该整数表示 <see cref="T:System.Array" /> 的指定维中的元素数。</summary>
        <returns>一个 64 位整数，它表示指定维中的元素数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个示例<xref:System.Array.GetLongLength%2A>是`GetLongLength(0)`，其返回的第一个维度中的元素数<xref:System.Array>。  
  
 此方法为 o （1） 运算。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> 小于零。  -或-  <paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">数组的从零开始的维度，其起始索引需要确定。</param>
        <summary>获取数组中指定维度第一个元素的索引。</summary>
        <returns>数组中指定维度第一个元素的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` 返回数组的第一个维度的起始索引和`GetLowerBound(Rank - 1)`返回数组的最后一个维度的起始索引。  
  
 <xref:System.Array.GetLowerBound%2A>方法始终返回一个值，指示该数组的下限的索引，即使数组为空。  
  
 请注意，虽然大多数.NET Framework 中的数组是从零开始 (即，<xref:System.Array.GetLowerBound%2A>方法将返回每个维度的数组的 0)，.NET Framework 支持不从零开始的数组。 可用于创建此类阵列<xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29>方法，并还可以从非托管代码返回。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法以显示一维数组与二维数组的边界并显示其数组元素的值。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> 小于零。  -或-  <paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">数组的从零开始的维度，其上限需要确定。</param>
        <summary>获取数组中指定维度最后一个元素的索引。</summary>
        <returns>数组中指定维度最后一个元素的索引，或 -1（如果指定维度为空）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` 返回数组的第一个维度中的最后一个索引和`GetUpperBound(Rank - 1)`返回数组的最后一个维度的最后一个索引。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法以显示一维数组与二维数组的边界并显示其数组元素的值。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> 小于零。  -或-  <paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Array" /> 中指定元素的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>获取一维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 32 位整数。</summary>
        <returns>一维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定是否的值`index`超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有一维。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> 超出当前 <see cref="T:System.Array" /> 的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">32 位整数的一维数组，它表示用于指定要获取的 <see cref="T:System.Array" /> 元素的位置的索引。</param>
        <summary>获取多维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为一个 32 位整数数组。</summary>
        <returns>多维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的元素数`indices`必须等于的中的维数<xref:System.Array>。 中的所有元素`indices`数组必须共同指定所需元素的位置，在多维<xref:System.Array>。  
  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="indices" /> 中的任何元素都超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>获取一维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 64 位整数。</summary>
        <returns>一维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定是否的值`index`超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有一维。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 超出当前 <see cref="T:System.Array" /> 的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">一个 64 位整数的一维数组，它表示指定要获取的 <see cref="T:System.Array" /> 元素的位置的索引。</param>
        <summary>获取多维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为一个 64 位整数数组。</summary>
        <returns>多维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的元素数`indices`必须等于的中的维数<xref:System.Array>。 中的所有元素`indices`数组必须共同指定所需元素的位置，在多维<xref:System.Array>。  
  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indices" /> 中的任何元素都超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <summary>获取二维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 32 位整数。</summary>
        <returns>二维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有两维。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <summary>获取二维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 64 位整数。</summary>
        <returns>二维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有两维。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <param name="index3">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第三维索引。</param>
        <summary>获取三维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 32 位整数。</summary>
        <returns>三维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有三维。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <param name="index3">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第三维索引。</param>
        <summary>获取三维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 64 位整数。</summary>
        <returns>三维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有三维。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在一个一维数组或该数组的一系列元素中搜索指定对象，并返回其首个匹配项的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维数组。</param>
        <param name="value">要在 <c>array</c> 中查找的对象。</param>
        <summary>在一个一维数组中搜索指定对象，并返回其首个匹配项的索引。</summary>
        <returns>如果找到，则为 <paramref name="array" /> 中 <paramref name="value" /> 的第一个匹配项的索引；否则为该数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法搜索的一维 arrayfor 的所有元素`value`。 若要确定是否`value`中存在`array`，该方法通过调用每个元素执行的相等比较`Equals`方法，直到它找到的匹配项。 这意味着，如果元素会替代<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，重写方法调用。  
  
 因为大多数数组具有下限为零，此方法通常返回 – 1 如果`value`找不到。 数组的下限是等于的罕见情况<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) 和`value`找不到，此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF)。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 该示例将调用以下三个重载的<xref:System.Array.IndexOf%2A>方法以字符串数组中查找的字符串的索引：  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>以确定第一个匹配项的字符串"the"中的字符串数组。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>以确定第一个匹配项的字符串"the"中的字符串数组的最后一个元素的第四个。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>以确定第一个匹配项的字符串"the"在一个字符串数组之后到数组末尾之间的最后一个成功匹配的元素。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维数组。</param>
        <param name="value">要在 <c>array</c> 中查找的对象。</param>
        <param name="startIndex">搜索的起始索引。 空数组中 0（零）为有效值。</param>
        <summary>在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。 该元素系列的范围为从指定索引到该数组结尾。</summary>
        <returns>如果在从 <paramref name="startIndex" /> 到最后一个元素的 <paramref name="array" /> 中的元素范围中找到了 <paramref name="value" /> 的第一个匹配项的索引，则为该索引；否则为数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法搜索索引处的元素从一维数组`startIndex`中最后一个元素。 若要确定是否`value`中存在`array`，该方法通过调用执行的相等比较`Equals`的每个元素，直到它找到的匹配项的方法。 这意味着，如果元素会替代<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，重写方法调用。  
  
 因为大多数数组具有下限为零，此方法通常返回 – 1 如果`value`找不到。 数组的下限是等于的罕见情况<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) 和`value`找不到，此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF)。  
  
 如果`startIndex`等于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法返回-1。 如果`startIndex`大于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法将引发<xref:System.ArgumentOutOfRangeException>。  
  
 此方法为 O (`n`) 操作，其中`n`是中的元素数`startIndex`到末尾`array`。  
  
   
  
## Examples  
 该示例将调用以下三个重载的<xref:System.Array.IndexOf%2A>方法以字符串数组中查找的字符串的索引：  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>以确定第一个匹配项的字符串"the"中的字符串数组。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>以确定第一个匹配项的字符串"the"中的字符串数组的最后一个元素的第四个。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>以确定第一个匹配项的字符串"the"在一个字符串数组之后到数组末尾之间的最后一个成功匹配的元素。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维数组。</param>
        <param name="value">要在 <c>array</c> 中查找的对象。</param>
        <param name="startIndex">搜索的起始索引。 空数组中 0（零）为有效值。</param>
        <param name="count">要搜索的元素数。</param>
        <summary>在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。 该元素系列的范围从指定数量的元素的指定索引开始。</summary>
        <returns>如果在从索引 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> - 1 的 <paramref name="array" /> 中找到了 <paramref name="value" /> 的第一个匹配项的索引，则为该索引；否则为该数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法搜索的一维 arrayfrom 元素`startIndex`到`startIndex`加上`count`减 1，如果`count`大于 0。 若要确定是否`value`中存在`array`，该方法通过调用执行的相等比较`Equals`的每个元素，直到它找到的匹配项的方法。 这意味着，如果元素会替代<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法，重写方法调用。  
  
 Becausemost 数组具有下限为零，则此方法通常返回 – 1 在`value`找不到。 数组的下限是等于的罕见情况<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) 和`value`找不到，此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF)。  
  
 如果`startindex`等于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法返回-1。 如果`startIndex`大于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法将引发<xref:System.ArgumentOutOfRangeException>。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 该示例将调用以下三个重载的<xref:System.Array.IndexOf%2A>方法以字符串数组中查找的字符串的索引：  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>以确定第一个匹配项的字符串"the"中的字符串数组。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>以确定第一个匹配项的字符串"the"中的字符串数组的最后一个元素的第四个。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>以确定第一个匹配项的字符串"the"在一个字符串数组之后到数组末尾之间的最后一个成功匹配的元素。 若要确定其值的`count`自变量，它减去从的起始索引数组的上限，并添加一个。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  -或-  <paramref name="count" /> 小于零。  -或-  <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维数组。</param>
        <param name="value">要在 <c>array</c> 中查找的对象。</param>
        <summary>在一个一维数组中搜索指定对象，并返回其首个匹配项的索引。</summary>
        <returns>如果在整个 <paramref name="array" /> 中找到 <paramref name="value" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法搜索的一维数组的所有元素`value`。 若要确定是否`value`中存在`array`，该方法通过调用执行的相等比较`T.Equals`对每个元素的方法。 这意味着，如果`T`重写<xref:System.Object.Equals%2A>方法，重写方法调用。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例演示的所有三个泛型重载<xref:System.Array.IndexOf%2A>方法。 创建一个字符串数组，其中有一项显示两次，在索引位置 0 和索引位置 5。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从开始，数组中搜索并查找字符串的第一个匹配项。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载可用于搜索索引位置 3 开头的数组，直至到数组末尾之间的并查找字符串的第二个匹配项。 最后，<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置两处开头的两个条目范围; 它将返回 – 1，因为没有在该范围内的搜索字符串的实例。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维数组。</param>
        <param name="value">要在 <c>array</c> 中查找的对象。</param>
        <param name="startIndex">从零开始的搜索的起始索引。 空数组中 0（零）为有效值。</param>
        <summary>在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。 该元素系列的范围为从指定索引到该数组结尾。</summary>
        <returns>如果在 <paramref name="value" /> 中从 <paramref name="array" /> 到最后一个元素这部分元素中找到 <paramref name="startIndex" /> 的匹配项，则为第一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法搜索处的元素从一维数组`startIndex`到数组末尾。 若要确定是否`value`中存在`array`，该方法通过调用执行的相等比较`T.Equals`对每个元素的方法。 这意味着，如果`T`重写<xref:System.Object.Equals%2A>方法，重写方法调用。  
  
 如果`startIndex`等于<xref:System.Array.Length%2A>，该方法返回-1.If`startIndex`大于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法将引发<xref:System.ArgumentOutOfRangeException>。  
  
 此方法为 O (`n`) 操作，其中`n`是中的元素数`startIndex`到末尾`array`。  
  
   
  
## Examples  
 下面的示例演示的所有三个泛型重载<xref:System.Array.IndexOf%2A>方法。 创建一个字符串数组，其中有一项显示两次，在索引位置 0 和索引位置 5。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从开始，数组中搜索并查找字符串的第一个匹配项。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载可用于搜索索引位置 3 开头的数组，直至到数组末尾之间的并查找字符串的第二个匹配项。 最后，<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置两处开头的两个条目范围; 它将返回 – 1，因为没有在该范围内的搜索字符串的实例。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维数组。</param>
        <param name="value">要在 <c>array</c> 中查找的对象。</param>
        <param name="startIndex">从零开始的搜索的起始索引。 空数组中 0（零）为有效值。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。 该元素系列的范围从指定数量的元素的指定索引开始。</summary>
        <returns>如果在 <paramref name="value" /> 中从 <paramref name="array" /> 开始、包含 <paramref name="startIndex" /> 所指定的元素个数的这部分元素中，找到 <paramref name="count" /> 的匹配项，则为第一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法 searchesthe 元素从一维数组的`startIndex`到`startIndex`加上`count`减 1，如果`count`大于 0。 若要确定是否`value`中存在`array`，该方法通过调用执行的相等比较`T.Equals`对每个元素的方法。 这意味着，如果`T`重写<xref:System.Object.Equals%2A>方法，重写方法调用。  
  
 如果`startIndex`等于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法返回-1。  如果`startIndex`大于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法将引发<xref:System.ArgumentOutOfRangeException>。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 下面的示例演示的所有三个泛型重载<xref:System.Array.IndexOf%2A>方法。 创建一个字符串数组，其中有一项显示两次，在索引位置 0 和索引位置 5。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从开始，数组中搜索并查找字符串的第一个匹配项。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载可用于搜索索引位置 3 开头的数组，直至到数组末尾之间的并查找字符串的第二个匹配项。 最后，<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置两处开头的两个条目范围; 它将返回 – 1，因为没有在该范围内的搜索字符串的实例。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  -或-  <paramref name="count" /> 小于零。  -或-  <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通过调用值类型的默认构造函数，初始化值类型 <see cref="T:System.Array" /> 的每一个元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法旨在帮助编译器支持值类型数组;大多数用户不需要使用此方法。 它必须不使用引用类型数组中。  
  
 如果<xref:System.Array>不是值类型<xref:System.Array>或值类型不具有默认构造函数，如果<xref:System.Array>则不会修改。  
  
 值类型<xref:System.Array>可以具有任何下限和任意数量的维度。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>。  
  
> [!CAUTION]
>  你可以仅在具有构造函数; 的值类型上使用此方法但是，值类型都向 C# 本机没有构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Array" /> 是否具有固定大小。</summary>
        <value>此属性对于所有数组总是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 实现<xref:System.Array.IsFixedSize%2A>属性因为它必需的<xref:System.Collections.IList?displayProperty=nameWithType>接口。  
  
 具有固定大小的数组不允许添加或移除元素，该数组在创建之后，且它允许修改现有元素。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Array" /> 是否为只读。</summary>
        <value>此属性对于所有数组总是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 实现<xref:System.Array.IsReadOnly%2A>属性因为它必需的<xref:System.Collections.IList?displayProperty=nameWithType>接口。 数组类型的值是只读的不允许添加、 移除或修改元素，创建数组后。  
  
 如果你需要只读集合，使用<xref:System.Collections>类，该类实现<xref:System.Collections.IList?displayProperty=nameWithType>接口。  
  
 如果强制转换或转换到的数组<xref:System.Collections.IList>接口对象<xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType>属性返回`false`。 但是，如果强制转换或转换到的数组<xref:System.Collections.Generic.IList%601>接口，`IsReadOnly`属性返回`true`。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否同步对 <see cref="T:System.Array" /> 的访问（线程安全）。</summary>
        <value>此属性对于所有数组总是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 实现<xref:System.Array.IsSynchronized%2A>属性因为它必需的<xref:System.Collections.ICollection?displayProperty=nameWithType>接口。  
  
 .NET framework 类基于<xref:System.Array>提供其自己的同步的版本的集合使用<xref:System.Array.SyncRoot%2A>属性。  
  
 使用数组的类还可以实现自己的同步使用<xref:System.Array.SyncRoot%2A>属性。 同步代码必须在执行操作`SyncRoot`不是直接对集合的集合。 这样可确保对从其他对象派生的集合正确地执行操作。 具体地说，这样可保持正确的同步，与可能同时修改集合的其他线程。 请注意，某些实现的<xref:System.Array.SyncRoot%2A>可能会返回<xref:System.Array>本身。  
  
 枚举整个集合本质上不是线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的代码示例演示如何通过使用在整个枚举过程中锁定数组<xref:System.Array.SyncRoot%2A>属性。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一维 <see cref="T:System.Array" /> 或部分 <see cref="T:System.Array" /> 中某个值的最后一个匹配项的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <c>array</c> 中查找的对象。</param>
        <summary>搜索指定的对象，并返回整个一维 <see cref="T:System.Array" /> 中最后一个匹配项的索引。</summary>
        <returns>如果在整个 <paramref name="value" /> 中找到 <paramref name="array" /> 的匹配项，则为最后一个匹配项的索引；否则为该数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一维<xref:System.Array>向后搜索的最后一个元素开始，在第一个元素结束。  
  
 对元素进行比较到指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果元素类型是内部的 （用户定义的） 类型，`Equals`使用该类型的实现。  
  
 由于大多数数组将具有下限为零，因此此方法通常将返回 – 1 在`value`找不到。 数组的下限是等于的罕见情况<xref:System.Int32.MinValue?displayProperty=nameWithType>和`value`未找到，则此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>，即`System.Int32.MinValue - 1`。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
 在.NET Framework 2.0 版中，此方法使用<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法<xref:System.Array>以确定是否<xref:System.Object>指定的`value`参数存在。 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`value`<xref:System.Object>本身。  
  
 <xref:System.IComparable.CompareTo%2A> 方法的`item`参数的集合中的对象。  
  
   
  
## Examples  
 下面的代码示例演示如何确定数组中指定的元素的最后一个匹配项的索引。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <c>array</c> 中查找的对象。</param>
        <param name="startIndex">向后搜索的起始索引。</param>
        <summary>搜索指定的对象，并返回一维 <see cref="T:System.Array" /> 中从第一个元素到指定索引这部分元素中最后一个匹配项的索引。</summary>
        <returns>如果在 <paramref name="value" /> 中从第一个元素到 <paramref name="array" /> 这部分元素中找到 <paramref name="startIndex" /> 的匹配项，则为最后一个匹配项的索引；否则为该数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一维<xref:System.Array>是搜索向后开始`startIndex`和结束的第一个元素。  
  
 对元素进行比较到指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果元素类型是内部的 （用户定义的） 类型，`Equals`使用该类型的实现。  
  
 由于大多数数组将具有下限为零，因此此方法通常将返回 – 1 在`value`找不到。 数组的下限是等于的罕见情况<xref:System.Int32.MinValue?displayProperty=nameWithType>和`value`未找到，则此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>，即`System.Int32.MinValue - 1`。  
  
 此方法为 O (`n`) 操作，其中`n`是从开始处的元素数目`array`到`startIndex`。  
  
 在.NET Framework 2.0 版中，此方法使用<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法<xref:System.Array>以确定是否<xref:System.Object>指定的`value`参数存在。 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`value`<xref:System.Object>本身。  
  
   
  
## Examples  
 下面的代码示例演示如何确定数组中指定的元素的最后一个匹配项的索引。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <c>array</c> 中查找的对象。</param>
        <param name="startIndex">向后搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的对象，并返回一维 <see cref="T:System.Array" /> 中到指定索引为止包含指定个元素的这部分元素中最后一个匹配项的索引。</summary>
        <returns>如果在 <paramref name="value" /> 中到 <paramref name="array" /> 为止并且包含的元素个数为在 <paramref name="count" /> 中指定的个数的这部分元素中找到 <paramref name="startIndex" /> 的匹配项，则为最后一个匹配项的索引；否则为该数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一维<xref:System.Array>是搜索向后开始`startIndex`结束`startIndex`减`count`加上 1，如果`count`大于 0。  
  
 对元素进行比较到指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果元素类型是内部的 （用户定义的） 类型，`Equals`使用该类型的实现。  
  
 由于大多数数组将具有下限为零，因此此方法通常将返回 – 1 在`value`找不到。 数组的下限是等于的罕见情况<xref:System.Int32.MinValue?displayProperty=nameWithType>和`value`未找到，则此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>，即`System.Int32.MinValue - 1`。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
 在.NET Framework 2.0 版中，此方法使用<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法<xref:System.Array>以确定是否<xref:System.Object>指定的`value`参数存在。 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`value`<xref:System.Object>本身。  
  
   
  
## Examples  
 下面的代码示例演示如何确定数组中指定的元素的最后一个匹配项的索引。 请注意，<xref:System.Array.LastIndexOf%2A>方法是向后搜索; 因此，`count`必须小于或等于 (`startIndex`减零下限的数组加 1)。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  -或-  <paramref name="count" /> 小于零。  -或-  <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <c>array</c> 中查找的对象。</param>
        <summary>搜索指定的对象，并返回整个 <see cref="T:System.Array" /> 中最后一个匹配项的索引。</summary>
        <returns>如果在整个 <paramref name="value" /> 中找到 <paramref name="array" /> 的匹配项，则为最后一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>向后搜索的最后一个元素开始，在第一个元素结束。  
  
 对元素进行比较到指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果元素类型是内部的 （用户定义的） 类型，`Equals`使用该类型的实现。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个泛型重载<xref:System.Array.LastIndexOf%2A>方法。 创建一个字符串数组，其中有一项显示两次，在索引位置 0 和索引位置 5。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从结束时，整个数组中搜索并查找字符串的第二个匹配项。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载可用于搜索数组向后开头的索引位置 3，直至到该数组的开头，并查找字符串的第一个匹配项。 最后，<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置 4 处开始并扩展向后的四个条目范围 （即，搜索位置 4、 3、 2 和 1 处的项）; 此搜索返回 – 1，因为没有的搜索的实例在该范围内的字符串。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <c>array</c> 中查找的对象。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <summary>搜索指定的对象，并返回 <see cref="T:System.Array" /> 中从第一个元素到指定索引这部分元素中最后一个匹配项的索引。</summary>
        <returns>如果在 <paramref name="value" /> 中从第一个元素到 <paramref name="array" /> 这部分元素中找到 <paramref name="startIndex" /> 的匹配项，则为最后一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>是搜索向后开始`startIndex`和结束的第一个元素。  
  
 对元素进行比较到指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果元素类型是内部的 （用户定义的） 类型，`Equals`使用该类型的实现。  
  
 此方法为 O (`n`) 操作，其中`n`是从开始处的元素数目`array`到`startIndex`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个泛型重载<xref:System.Array.LastIndexOf%2A>方法。 创建一个字符串数组，其中有一项显示两次，在索引位置 0 和索引位置 5。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从结束时，整个数组中搜索并查找字符串的第二个匹配项。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载可用于搜索数组向后开头的索引位置 3，直至到该数组的开头，并查找字符串的第一个匹配项。 最后，<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置 4 处开始并扩展向后的四个条目范围 （即，搜索位置 4、 3、 2 和 1 处的项）; 此搜索返回 – 1，因为没有的搜索的实例在该范围内的字符串。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <c>array</c> 中查找的对象。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的对象，并返回 <see cref="T:System.Array" /> 中到指定索引为止包含指定个元素的这部分元素中最后一个匹配项的索引。</summary>
        <returns>如果在 <paramref name="value" /> 中到 <paramref name="array" /> 为止、包含 <paramref name="count" /> 所指定的元素个数的这部分元素中，找到 <paramref name="startIndex" /> 的匹配项，则为最后一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>是搜索向后开始`startIndex`结束`startIndex`减`count`加上 1，如果`count`大于 0。  
  
 对元素进行比较到指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果元素类型是内部的 （用户定义的） 类型，`Equals`使用该类型的实现。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个泛型重载<xref:System.Array.LastIndexOf%2A>方法。 创建一个字符串数组，其中有一项显示两次，在索引位置 0 和索引位置 5。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从结束时，整个数组中搜索并查找字符串的第二个匹配项。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载可用于搜索数组向后开头的索引位置 3，直至到该数组的开头，并查找字符串的第一个匹配项。 最后，<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置 4 处开始并扩展向后的四个条目范围 （即，搜索位置 4、 3、 2 和 1 处的项）; 此搜索返回 – 1，因为没有的搜索的实例在该范围内的字符串。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  -或-  <paramref name="count" /> 小于零。  -或-  <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Array" /> 的所有维度中的元素总数。</summary>
        <value>所有维数中元素的总数<see cref="T:System.Array" />; 零如果数组中没有的元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Array.Length%2A>属性来获取数组中的元素总数。 它还使用<xref:System.Array.GetUpperBound%2A>方法来确定每个维度的多维数组中的元素数。  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">数组是多维的，并且包括多于 <see cref="F:System.Int32.MaxValue" /> 个元素。</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 64 位整数，该整数表示 <see cref="T:System.Array" /> 的所有维数中元素的总数。</summary>
        <value>一个 64 位整数，表示 <see cref="T:System.Array" /> 的所有维数中元素的总数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Array" /> 的秩（维数）。 例如，一维数组返回 1，二维数组返回 2，依次类推。</summary>
        <value>该 <see cref="T:System.Array" /> 的秩（维数）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，Visual Basic 代码  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 和 C# 代码  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 创建一个具有三个维度的数组<xref:System.Array.Rank%2A>其值为 3 的属性。  
  
 交错的数组 （由数组的数组） 是一维数组中;值其<xref:System.Array.Rank%2A>属性为 1。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的示例将初始化一个一维数组、 一个二维数组和交错的数组，并检索<xref:System.Array.Rank%2A>每个属性。  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]&amp;" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要调整大小的一维数组，该数组从零开始；如果为 <see langword="null" />，则新建具有指定大小的数组。</param>
        <param name="newSize">新数组的大小。</param>
        <summary>将一维数组的元素数更改为指定的新大小。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法分配指定大小的新数组，将元素从旧的数组复制到新，然后使用新替换旧的数组。 `array` 必须是一个一维数组。  
  
 如果`array`是`null`，此方法具有指定大小创建一个新数组。  
  
 如果`newSize`大于<xref:System.Array.Length%2A>的旧的数组中，分配一个新数组，且所有元素从旧的数组都复制到新。  如果`newSize`是小于<xref:System.Array.Length%2A>的旧的数组中，分配一个新数组和元素从旧数组复制到新直到填充新的; 旧的数组中的元素的其余部分将被忽略。  如果`newSize`等同于<xref:System.Array.Length%2A>的旧的数组，此方法不执行任何操作。  
  
 此方法为 O (`n`) 操作，其中`n`是`newSize`。  
  
 <xref:System.Array.Resize%2A>方法调整大小的一维数组。 <xref:System.Array>类不包括用于调整大小多维数组的方法。 若要执行此操作，你必须提供您自己的代码或调用的第三方库中的特殊用途方法。 下面的代码演示调整大小的数组的方法的一种可能实现*n*维度。  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 下面的示例演示如何调整大小影响数组。  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newSize" /> 小于零。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>反转一维 <see cref="T:System.Array" /> 或部分 <see cref="T:System.Array" /> 中元素的顺序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">要反转的一维 <see cref="T:System.Array" />。</param>
        <summary>反转整个一维 <see cref="T:System.Array" /> 中元素的顺序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在这种方法，处的元素调用`myArray[i]`，其中`i`是数组中的任何索引，将移动到`myArray[j]`，其中`j`等于`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
 如下面的示例所示，<xref:System.Array.Reverse%2A>方法可以用于反向交错的数组。 它将初始化为当前区域性的日历中的当前年份的每个月交错的数组包含一个元素。 每个元素包含与该月有天数的所有元素的数组。 该示例显示数组，调用的内容<xref:System.Array.Reverse%2A>方法，然后显示反向数组的内容。  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 下面的代码示例演示如何反向中的值排序<xref:System.Array>。  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要反转的一维 <see cref="T:System.Array" />。</param>
        <param name="index">要反转的部分的起始索引。</param>
        <param name="length">要反转的部分中的元素数。</param>
        <summary>反转一维 <see cref="T:System.Array" /> 中某部分元素的元素顺序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在这种方法，处的元素调用`myArray[i]`，其中`i`是数组中的任何索引，将移动到`myArray[j]`，其中`j`等于`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`。  
  
 <xref:System.Array.Reverse%2A>方法可以用于反向交错的数组。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何反向中的元素范围中的值的排序<xref:System.Array>。  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将当前 <see cref="T:System.Array" /> 中的指定元素设置为指定值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>将某值设置给一维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定是否的值`index`超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。 元素的值不是 null 引用，并无法找到所搜索的 null 引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有一维。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> 超出当前 <see cref="T:System.Array" /> 的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="indices">32 位整数的一维数组，它表示用于指定要设置的元素的位置的索引。</param>
        <summary>将某值设置给多维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为一个 32 位整数数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的元素数`indices`必须等于的中的维数<xref:System.Array>。 中的所有元素`indices`数组必须共同指定所需元素的位置，在多维<xref:System.Array>。  
  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定是否有任何中的值`indices`数组是超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。 元素的值不是 null 引用，并无法找到所搜索的 null 引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="indices" /> 中的任何元素都超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>将某值设置给一维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定是否的值`index`超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。 元素的值不是 null 引用，并无法找到所搜索的 null 引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有一维。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 超出当前 <see cref="T:System.Array" /> 的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="indices">64 位整数的一维数组，它表示用于指定要设置的元素的位置的索引。</param>
        <summary>将某值设置给多维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为一个 64 位整数数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的元素数`indices`必须等于的中的维数<xref:System.Array>。 中的所有元素`indices`数组必须共同指定所需元素的位置，在多维<xref:System.Array>。  
  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定是否有任何中的值`indices`数组是超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。 元素的值不是 null 引用，并无法找到所搜索的 null 引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indices" /> 中的任何元素都超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index1">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <summary>将某值设置给二维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。 元素的值不是 null 引用，并无法找到所搜索的 null 引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有两维。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index1">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <summary>将某值设置给二维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。 元素的值不是 null 引用，并无法找到所搜索的 null 引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有两维。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index1">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <param name="index3">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第三维索引。</param>
        <summary>将某值设置给三维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。 元素的值不是 null 引用，并无法找到所搜索的 null 引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有三维。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index1">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <param name="index3">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第三维索引。</param>
        <summary>将某值设置给三维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。 元素的值不是 null 引用，并无法找到所搜索的 null 引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有三维。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>对一维数组中的元素进行排序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一维 <see cref="T:System.Array" />。</param>
        <summary>使用 <see cref="T:System.Array" /> 中每个元素的 <see cref="T:System.IComparable" /> 实现，对整个一维 <see cref="T:System.Array" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个元素`array`必须实现<xref:System.IComparable>接口，才能与中的每个其他元素的比较`array`。  
  
 如果未成功完成排序，结果不确定。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示如何进行排序中的值<xref:System.Array>使用默认比较器和将反转排序顺序的自定义比较器。 请注意，结果可能有所不同具体取决于当前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c><see cref="T:System.Array" /> 中每个关键字对应的项。  -或-  如果为 <see langword="null" />，则只对 <c>keys</c><see cref="T:System.Array" /> 进行排序。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.Array" /> 实现，对两个一维 <see cref="T:System.IComparable" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。  
  
 在每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable>接口，才能与每个其他键的比较。  
  
 如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。 如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。  
  
 如果未成功完成排序，结果不确定。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`keys`。  
  
   
  
## Examples  
 下面的示例演示如何对两个关联的数组的第一个数组包含的键，其中第二个数组包含的值进行排序。 完成排序使用的默认比较器和将反转排序顺序的自定义比较器。 请注意，结果可能有所不同具体取决于当前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 是多维的。  -或-  <paramref name="items" /><see cref="T:System.Array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一维数组。</param>
        <param name="comparer">比较元素时要使用的实现。  -或-  若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定的 <see cref="T:System.Array" />，对一维 <see cref="T:System.Collections.IComparer" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`是`null`的每个元素`array`必须实现<xref:System.IComparable>接口，才能与中的每个其他元素的比较`array`。  
  
 如果未成功完成排序，结果不确定。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
 .NET Framework 包括预定义<xref:System.Collections.IComparer>下表中列出的实现。  
  
|实现|描述|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比较任意两个对象，但执行不区分大小写的字符串比较。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用当前区域性的排序约定比较任意两个对象。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|使用固定区域性的排序约定比较任意两个对象。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|比较两个对象类型的`T`通过使用该类型的默认排序顺序。|  
  
 此外可以通过提供你自己的实例来支持自定义比较<xref:System.Collections.IComparer>实现`comparer`参数。 该示例执行这通过定义`ReverseComparer`反转的默认排序顺序的类类型的实例和执行不区分大小写的字符串比较。  
  
   
  
## Examples  
 下面的示例对使用默认比较器字符串 arrayby 中的值进行排序。 它还定义一个自定义<xref:System.Collections.IComparer>实现名为`ReverseComparer`，反转同时执行不区分大小写的字符串比较的对象的默认排序顺序。 请注意，输出根据当前区域性可能有所不同。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，<paramref name="array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和更早版本使用仅快速排序算法。快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。从 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能会引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。大多数情况下，这适用于具有少于 16 个元素的数组。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c><see cref="T:System.Array" /> 中每个关键字对应的项。  -或-  如果为 <see langword="null" />，则只对 <c>keys</c><see cref="T:System.Array" /> 进行排序。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  -或-  若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Array" />，对两个一维 <see cref="T:System.Collections.IComparer" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。  
  
 如果`comparer`是`null`，每个密钥中`keys`<xref:System.Array>必须实现<xref:System.IComparable>接口，才能与每个其他键的比较。  
  
 如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。 如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。  
  
 如果未成功完成排序，结果不确定。  
  
 .NET Framework 包括预定义<xref:System.Collections.IComparer>下表中列出的实现。  
  
|实现|描述|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比较任意两个对象，但执行不区分大小写的字符串比较。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用当前区域性的排序约定比较任意两个对象。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|使用固定区域性的排序约定比较任意两个对象。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|比较两个对象类型的`T`通过使用该类型的默认排序顺序。|  
  
 此外可以通过提供你自己的实例来支持自定义比较<xref:System.Collections.IComparer>实现`comparer`参数。 该示例执行这通过定义<xref:System.Collections.IComparer>反转默认的排序顺序和执行不区分大小写的字符串比较的实现。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`keys`。  
  
   
  
## Examples  
 下面的示例演示如何对两个关联的数组的第一个数组包含的键，其中第二个数组包含的值进行排序。 完成排序使用的默认比较器和将反转排序顺序的自定义比较器。 请注意，结果可能有所不同具体取决于当前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 是多维的。  -或-  <paramref name="items" /><see cref="T:System.Array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  -或-  <paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和更早版本使用仅快速排序算法。快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。从 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，它是可能的排序操作该 previouslythrew<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。大多数情况下，这适用于具有少于 16 个元素的数组。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一维 <see cref="T:System.Array" />。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <summary>使用 <see cref="T:System.Array" /> 中每个元素的 <see cref="T:System.IComparable" /> 实现，对一维 <see cref="T:System.Array" /> 中某部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定范围中的元素内的每个元素`array`必须实现<xref:System.IComparable>接口，才能与中的每个其他元素的比较`array`。  
  
 如果未成功完成排序，结果不确定。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何进行排序中的值<xref:System.Array>使用默认比较器和将反转排序顺序的自定义比较器。 请注意，结果可能有所不同具体取决于当前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c><see cref="T:System.Array" /> 中每个关键字对应的项。  -或-  如果为 <see langword="null" />，则只对 <c>keys</c><see cref="T:System.Array" /> 进行排序。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.Array" /> 实现，对两个一维 <see cref="T:System.IComparable" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。  
  
 指定范围中的元素内的每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable>接口，才能与每个其他键的比较。  
  
 如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。 如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。  
  
 如果未成功完成排序，结果不确定。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何对两个关联的数组的第一个数组包含的键，其中第二个数组包含的值进行排序。 完成排序使用的默认比较器和将反转排序顺序的自定义比较器。 请注意，结果可能有所不同具体取决于当前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 是多维的。  -或-  <paramref name="items" /><see cref="T:System.Array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 <paramref name="keys" /> 的下限。  -或-  <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  -或-  <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。  -或-  <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一维 <see cref="T:System.Array" />。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  -或-  若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定的 <see cref="T:System.Array" />，对一维 <see cref="T:System.Collections.IComparer" /> 的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`是`null`，每个元素中的元素指定的范围内`array`必须实现<xref:System.IComparable>接口，才能与中的每个其他元素的比较`array`。  
  
 如果未成功完成排序，结果不确定。  
  
 .NET Framework 包括预定义<xref:System.Collections.IComparer>下表中列出的实现。  
  
|实现|描述|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比较任意两个对象，但执行不区分大小写的字符串比较。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用当前区域性的排序约定比较任意两个对象。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|使用固定区域性的排序约定比较任意两个对象。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|比较两个对象类型的`T`通过使用该类型的默认排序顺序。|  
  
 此外可以通过提供你自己的实例来支持自定义比较<xref:System.Collections.IComparer>实现`comparer`参数。 该示例执行这通过定义`ReverseComparer`反转的默认排序顺序的类类型的实例和执行不区分大小写的字符串比较。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何进行排序中的值<xref:System.Array>使用默认比较器和将反转排序顺序的自定义比较器。 请注意，结果可能有所不同具体取决于当前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  -或-  <paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，<paramref name="array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和更早版本使用仅快速排序算法。快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。从 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能会引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。大多数情况下，这适用于具有少于 16 个元素的数组。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c><see cref="T:System.Array" /> 中每个关键字对应的项。  -或-  如果为 <see langword="null" />，则只对 <c>keys</c><see cref="T:System.Array" /> 进行排序。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  -或-  若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Array" />，对两个一维 <see cref="T:System.Collections.IComparer" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。  
  
 如果`comparer`是`null`中的元素指定的范围内的每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable>接口，才能与每个其他键的比较。  
  
 如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。 如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。  
  
 如果未成功完成排序，结果不确定。  
  
 .NET Framework 包括预定义<xref:System.Collections.IComparer>下表中列出的实现。  
  
|实现|描述|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比较任意两个对象，但执行不区分大小写的字符串比较。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用当前区域性的排序约定比较任意两个对象。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|使用固定区域性的排序约定比较任意两个对象。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|比较两个对象类型的`T`通过使用该类型的默认排序顺序。|  
  
 此外可以通过提供你自己的实例来支持自定义比较<xref:System.Collections.IComparer>实现`comparer`参数。 该示例执行这通过定义一个自定义<xref:System.Collections.IComparer>反转默认的排序顺序和执行不区分大小写的字符串比较的实现。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何对两个关联的数组的第一个数组包含的键，其中第二个数组包含的值进行排序。 完成排序使用的默认比较器和将反转排序顺序的自定义比较器。 请注意，结果可能有所不同具体取决于当前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 是多维的。  -或-  <paramref name="items" /><see cref="T:System.Array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 <paramref name="keys" /> 的下限。  -或-  <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。  -或-  <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  -或-  <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。  -或-  <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。  -或-  <paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和更早版本使用仅快速排序算法。快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。从 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能会引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。大多数情况下，这适用于具有少于 16 个元素的数组。</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要排序的从零开始的一维 <see cref="T:System.Array" />。</param>
        <summary>使用 <see cref="T:System.Array" /> 的每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现，对整个 <see cref="T:System.Array" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个元素`array`必须实现<xref:System.IComparable%601>泛型接口，才能与中的每个其他元素的比较`array`。  
  
 如果未成功完成排序，结果不确定。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>泛型方法重载与<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>泛型方法重载。 创建一个字符串数组，顺序不分先后。  
  
 数组是显示、 排序，并且再次显示。  
  
> [!NOTE]
>  对调用<xref:System.Array.Sort%2A>和<xref:System.Array.BinarySearch%2A>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。 如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>泛型方法重载然后用于两个字符串搜索，另一个不在使用数组和一个，是。 数组和返回值的<xref:System.Array.BinarySearch%2A>方法传递给`ShowWhere`泛型方法，如果找到该字符串，而且否则元素的搜索字符串将介于像它是数组中显示的索引值。 索引是如果字符串不是 n 负数组，因此`ShowWhere`方法采用的按位求补 (~ 中 C# 和 Visual c + + 中，运算符`Xor`在 Visual Basic 中的为-1) 若要获取大于搜索 stri 列表中的第一个元素的索引ng。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要排序的从零开始的一维 <see cref="T:System.Array" /></param>
        <param name="comparer">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</param>
        <summary>使用指定的 <see cref="T:System.Array" /> 泛型接口，对 <see cref="T:System.Collections.Generic.IComparer`1" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`是`null`的每个元素`array`必须实现<xref:System.IComparable%601>泛型接口，才能与中的每个其他元素的比较`array`。  
  
 如果未成功完成排序，结果不确定。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载与<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载。  
  
 代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。  
  
 数组是显示、 排序，并且再次显示。 数组必须进行排序以便使用<xref:System.Array.BinarySearch%2A>方法。  
  
> [!NOTE]
>  对调用<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。 如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载然后用于两个字符串搜索，另一个不在使用数组和一个，是。 数组和返回值的<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>方法传递给`ShowWhere`泛型方法，如果找到该字符串，而且否则元素的搜索字符串将介于像它是数组中显示的索引值。 索引是如果字符串不是 n 负数组，因此`ShowWhere`方法采用的按位求补 (~ 中 C# 和 Visual c + + 中，运算符`Xor`在 Visual Basic 中的为-1) 若要获取大于搜索 stri 列表中的第一个元素的索引ng。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和更早版本使用仅快速排序算法。快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。从 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能会引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。大多数情况下，这适用于具有少于 16 个元素的数组。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要排序的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="comparison">比较元素时要使用的 <see cref="T:System.Comparison`1" />。</param>
        <summary>使用指定的 <see cref="T:System.Array" /> 对 <see cref="T:System.Comparison`1" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果未成功完成排序，结果不确定。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>方法重载。  
  
 代码示例定义了命名的字符串替换比较方法`CompareDinosByLength`。 此方法的工作方式如下： 首先，comparandsare 测试为`null`，并为空引用被视为小于非空。 其次，比较字符串的长度，和较长的字符串被认为更高版本。 第三，如果长度相等，则使用普通字符串比较。  
  
 创建并填充了四个字符串，顺序不分先后字符串的数组。 列表还包括一个空字符串和 null 引用。 显示的列表，使用排序<xref:System.Comparison%601>泛型委托表示`CompareDinosByLength`方法，然后再次显示。  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。  -或-  <paramref name="comparison" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparison" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparison" /> 可能不返回 0。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和更早版本使用仅快速排序算法。快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。从 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能会引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。大多数情况下，这适用于具有少于 16 个元素的数组。</para>
        </block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要排序的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <summary>使用 <see cref="T:System.Array" /> 的每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现，对 <see cref="T:System.Array" /> 中某个元素范围内的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定范围中的元素内的每个元素`array`必须实现<xref:System.IComparable%601>泛型接口，才能与中的每个其他元素的比较`array`。  
  
 如果未成功完成排序，结果不确定。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>泛型方法重载与<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>数组中的范围进行排序的泛型方法重载。  
  
 代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。  
  
 下面的代码示例创建并显示不复存在名称，三个草食跟三个食肉恐龙 (tyrannosaurids，使之精确) 所组成的数组。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用泛型方法重载的数组，随后显示的最后三个元素进行排序。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>与使用泛型方法重载`ReverseCompare`以按相反顺序进行排序的最后三个元素。 全面混淆历史舞台再次显示。  
  
> [!NOTE]
>  对调用<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。 如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要排序的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <param name="comparer">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</param>
        <summary>使用指定的 <see cref="T:System.Array" /> 泛型接口，对 <see cref="T:System.Collections.Generic.IComparer`1" /> 中某个元素范围内的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`是`null`，每个元素中的元素指定的范围内`array`必须实现<xref:System.IComparable%601>泛型接口，才能与中的每个其他元素的比较`array`。  
  
 如果未成功完成排序，结果不确定。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>泛型方法重载与<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>数组中的范围进行排序的泛型方法重载。  
  
 代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。  
  
 下面的代码示例创建并显示不复存在名称，三个草食跟三个食肉恐龙 (tyrannosaurids，使之精确) 所组成的数组。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用泛型方法重载的数组，随后显示的最后三个元素进行排序。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>与使用泛型方法重载`ReverseCompare`以按相反顺序进行排序的最后三个元素。 全面混淆历史舞台再次显示。  
  
> [!NOTE]
>  对调用<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。 如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 <paramref name="array" /> 的下限。  -或-  <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  -或-  <paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和更早版本使用仅快速排序算法。快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。从 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能会引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。大多数情况下，这适用于具有少于 16 个元素的数组。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">关键字数组元素的类型。</typeparam>
        <typeparam name="TValue">项数组元素的类型。</typeparam>
        <param name="keys">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <c>keys</c> 进行排序。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.Array" /> 泛型接口实现，对两个 <see cref="T:System.IComparable`1" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。  
  
 在每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable%601>泛型接口，才能与每个其他键的比较。  
  
 如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。 如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。  
  
 如果未成功完成排序，结果不确定。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>，和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的重载，对表示键和值的数组进行排序。  
  
 代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。  
  
 下面的代码示例创建并显示不复存在头名 （关键字） 的数组和数组表示每个不复存在以米为单位 （值） 的最大长度的整数。 然后，数组进行排序和显示几次：  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于对这两个数组中的第一个数组中的不复存在名称顺序进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载与实例`ReverseCompare`用于反转排序顺序的成对的数组。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用重载的两个数组的最后三个元素进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载用于按相反顺序进行排序的两个数组的最后三个元素。  
  
> [!NOTE]
>  因为 Visual Basic、 C# 和 c + + 来推断与前两个参数的类型的泛型类型参数的类型对泛型方法的调用不查找从其非泛型对应项，对调用任何不同。 如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。  -或-  <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">关键字数组元素的类型。</typeparam>
        <typeparam name="TValue">项数组元素的类型。</typeparam>
        <param name="keys">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <c>keys</c> 进行排序。</param>
        <param name="comparer">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Array" /> 泛型接口，对两个 <see cref="T:System.Collections.Generic.IComparer`1" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。  
  
 如果`comparer`是`null`，每个密钥中`keys`<xref:System.Array>必须实现<xref:System.IComparable%601>泛型接口，才能与每个其他键的比较。  
  
 如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。 如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。  
  
 如果未成功完成排序，结果不确定。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>，[\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >，<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>，和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的重载，对表示键和值的数组进行排序。  
  
 代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。  
  
 下面的代码示例创建并显示不复存在头名 （关键字） 的数组和数组表示每个不复存在以米为单位 （值） 的最大长度的整数。 然后，数组进行排序和显示几次：  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于对这两个数组中的第一个数组中的不复存在名称顺序进行排序。  
  
-   [\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > 重载与实例`ReverseCompare`用于反转排序顺序成对的数组。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用重载的两个数组的最后三个元素进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载用于按相反顺序进行排序的两个数组的最后三个元素。  
  
> [!NOTE]
>  因为 Visual Basic、 C# 和 c + + 来推断与前两个参数的类型的泛型类型参数的类型对泛型方法的调用不查找从其非泛型对应项，对调用任何不同。 如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。  -或-  <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  -或-  <paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和更早版本使用仅快速排序算法。快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。从 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能会引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。大多数情况下，这适用于具有少于 16 个元素的数组。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">关键字数组元素的类型。</typeparam>
        <typeparam name="TValue">项数组元素的类型。</typeparam>
        <param name="keys">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <c>keys</c> 进行排序。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.Array" /> 泛型接口实现，对两个 <see cref="T:System.IComparable`1" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。  
  
 指定范围中的元素内的每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable%601>泛型接口，才能与每个其他键的比较。  
  
 如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。 如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。  
  
 如果未成功完成排序，结果不确定。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>，[\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >，和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载，对表示键和值的数组进行排序。  
  
 代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。  
  
 下面的代码示例创建并显示不复存在头名 （关键字） 的数组和数组表示每个不复存在以米为单位 （值） 的最大长度的整数。 然后，数组进行排序和显示几次：  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于对这两个数组中的第一个数组中的不复存在名称顺序进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载与实例`ReverseCompare`用于反转排序顺序的成对的数组。  
  
-   [\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > 使用重载的两个数组的最后三个元素进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载用于按相反顺序进行排序的两个数组的最后三个元素。  
  
> [!NOTE]
>  因为 Visual Basic、 C# 和 c + + 来推断与前两个参数的类型的泛型类型参数的类型对泛型方法的调用不查找从其非泛型对应项，对调用任何不同。 如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 <paramref name="keys" /> 的下限。  -或-  <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。  -或-  <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  -或-  <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。  -或-  <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">关键字数组元素的类型。</typeparam>
        <typeparam name="TValue">项数组元素的类型。</typeparam>
        <param name="keys">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <c>keys</c> 进行排序。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <param name="comparer">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Array" /> 泛型接口，对两个 <see cref="T:System.Collections.Generic.IComparer`1" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。  
  
 如果`comparer`是`null`中的元素指定的范围内的每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable%601>泛型接口，才能与每个其他键的比较。  
  
 如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。 如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。  
  
 如果未成功完成排序，结果不确定。  
  
 此方法使用反省排序 (introsort) 算法，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>，和 [\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > 泛型方法的重载，对表示键和值的数组进行排序。  
  
 代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。  
  
 下面的代码示例创建并显示不复存在头名 （关键字） 的数组和数组表示每个不复存在以米为单位 （值） 的最大长度的整数。 然后，数组进行排序和显示几次：  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于对这两个数组中的第一个数组中的不复存在名称顺序进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载与实例`ReverseCompare`用于反转排序顺序的成对的数组。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用重载的两个数组的最后三个元素进行排序。  
  
-   [\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > 使用重载进行排序最后三个这两个元素的数组按相反的顺序。  
  
> [!NOTE]
>  因为 Visual Basic、 C# 和 c + + 来推断与前两个参数的类型的泛型类型参数的类型对泛型方法的调用不查找从其非泛型对应项，对调用任何不同。 如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 <paramref name="keys" /> 的下限。  -或-  <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。  -或-  <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  -或-  <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。  -或-  <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。  -或-  <paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 和更早版本使用仅快速排序算法。快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。从 [！INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能会引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。大多数情况下，这适用于具有少于 16 个元素的数组。</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</summary>
        <value>可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性实现<xref:System.Collections.ICollection?displayProperty=nameWithType>接口。  
  
 .NET framework 类基于<xref:System.Array>提供其自己的同步的版本的集合使用<xref:System.Array.SyncRoot%2A>属性。  
  
 使用数组的类还可以实现自己的同步使用<xref:System.Array.SyncRoot%2A>属性。 同步代码必须在执行操作`SyncRoot`不是直接对集合的集合。 这样可确保对从其他对象派生的集合正确地执行操作。 具体地说，这样可保持正确的同步，与可能同时修改集合的其他线程。 请注意，某些实现的<xref:System.Array.SyncRoot%2A>可能会返回<xref:System.Array>本身。  
  
 枚举整个集合本质上不是线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的代码示例演示如何通过使用在整个枚举过程中锁定数组<xref:System.Array.SyncRoot%2A>属性。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System.Collections.ICollection.Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Array" /> 中包含的元素数。</summary>
        <value>集合中包含的元素数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.ICollection> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要添加到 <see cref="T:System.Collections.IList" /> 的对象。</param>
        <summary>调用此方法始终会引发 <see cref="T:System.NotSupportedException" /> 异常。</summary>
        <returns>不支持向数组添加值。 不返回任何值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常，<xref:System.Collections.IList.Add%2A?displayProperty=nameWithType>实现将成员添加到集合。 但是，因为数组具有固定的大小 (<xref:System.Array.IsFixedSize%2A>属性始终返回`true`)，此方法始终引发<xref:System.NotSupportedException>异常。  
  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从 <see cref="T:System.Collections.IList" /> 中移除所有项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> 为只读。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在当前列表中定位的对象。 要定位的元素对于引用类型可以是 <see langword="null" />。</param>
        <summary>确定某元素是否在 <see cref="T:System.Collections.IList" /> 中。</summary>
        <returns>如果在 <see langword="true" /> 中找到 <paramref name="value" />，则为 <see cref="T:System.Collections.IList" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在当前列表中定位的对象。</param>
        <summary>确定 <see cref="T:System.Collections.IList" /> 中特定项的索引。</summary>
        <returns>如果在列表中找到，则为值的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">应插入 <c>value</c> 的索引位置。</param>
        <param name="value">要插入的对象。</param>
        <summary>在 <see cref="T:System.Collections.IList" /> 中的指定索引处插入一个项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> 为只读。  -或-  <see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> 在 <see cref="T:System.Collections.IList" /> 中是 null 引用。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要获取或设置的元素的索引。</param>
        <summary>获取或设置指定索引处的元素。</summary>
        <value>指定索引处的元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零。  -或-  <paramref name="index" /> 等于或大于 <see cref="P:System.Collections.ICollection.Count" />。</exception>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有一维。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要从 <see cref="T:System.Collections.IList" /> 中删除的对象。</param>
        <summary>从 <see cref="T:System.Collections.IList" /> 中移除特定对象的第一个匹配项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> 为只读。  -或-  <see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的元素的索引。</param>
        <summary>移除位于指定索引处的 <see cref="T:System.Collections.IList" /> 项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">索引不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> 为只读。  -或-  <see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">要与当前实例进行比较的对象。</param>
        <param name="comparer">一个将当前对象与 <c>other</c> 进行比较的对象。</param>
        <summary>确定当前集合对象在排序顺序中的位置是位于另一个对象之前、之后还是与其位置相同。</summary>
        <returns>一个指示当前集合对象与其他对象的关系的整数，如下表所示。  
  
 <list type="table"><listheader><term> 返回值  </term><description> 描述  </description></listheader><item><term> -1  </term><description> 当前实例位于 <paramref name="other" /> 之前。</description></item><item><term> 0  </term><description> 当前实例和 <paramref name="other" /> 相等。</description></item><item><term> 1  </term><description> 当前实例位于 <paramref name="other" /> 之后。  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IStructuralComparable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">要与当前实例进行比较的对象。</param>
        <param name="comparer">一个可确定当前实例与 <c>other</c> 是否相等的对象。</param>
        <summary>确定某个对象与当前实例是否相等。</summary>
        <returns>如果两个对象相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IStructuralEquatable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">一个计算当前对象的哈希代码的对象。</param>
        <summary>返回当前实例的哈希代码。</summary>
        <returns>当前实例的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IStructuralEquatable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要对照条件进行检查的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match">用于定义检查元素时要对照的条件的谓词。</param>
        <summary>确定数组中的每个元素是否都与指定谓词定义的条件匹配。</summary>
        <returns>如果 <paramref name="array" /> 中的每个元素都与指定谓词定义的条件匹配，则为 <see langword="true" />；否则为 <see langword="false" />。 如果数组中没有元素，则返回值为 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`单独传递给<xref:System.Predicate%601>，并且在委托返回时停止处理`false`任何元素。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例确定字符串数组中每个元素的最后一个字符是否是一个数字。 它将创建两个字符串数组。 第一个 arrayincludes 同时字符串结尾字母字符和字符串以数字字符结尾。第二个数组只能包含数字字符结尾的字符串。 该示例还定义`EndWithANumber`其签名与匹配的方法<xref:System.Predicate%601>委托。 该示例将传递到每个数组<xref:System.Array.TrueForAll%2A>方法以及一个委托，表示`EndsWithANumber`方法。  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 下面的示例是类似于第一个，只不过它将传递到的字符串数组<xref:System.Array.TrueForAll%2A>方法以及确定是否将特定的数组元素结尾的数字的字符串表示的 lambda 表达式。  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 在这两种情况下，<xref:System.Array.TrueForAll%2A>方法返回`false`只要它遇到第一个不是一个数字以结尾的数组元素。 否则，它将返回`true`后循环访问数组中的所有元素。  
  
> [!NOTE]
>  这两个示例所示，在 C# 和 Visual Basic 中，不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。  -或-  <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>