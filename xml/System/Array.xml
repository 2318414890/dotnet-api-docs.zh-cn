<Type Name="Array" FullName="System.Array">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f64347ff86c34f6c5aa7fc81f1476e587a8b0d4f" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55423974" /></Metadata><TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供一些方法，用于创建、处理、搜索数组并对数组进行排序，从而充当公共语言运行时中所有数组的基类。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>类不是属于<xref:System.Collections>命名空间。 但是，它仍被视为集合因为它基于<xref:System.Collections.IList>接口。  
  
 <xref:System.Array>类是支持数组的语言实现的基类。 但是，只有系统和编译器可以派生自显式<xref:System.Array>类。 用户应使用语言提供的数组构造。  
  
 元素是中的值<xref:System.Array>。 长度<xref:System.Array>是可包含的元素总数。 下限<xref:System.Array>是其第一个元素的索引。 <xref:System.Array>可以有任何更低绑定，但该下限为零，默认情况下。 创建的实例时，可以定义其他下限<xref:System.Array>类使用<xref:System.Array.CreateInstance%2A>。多维<xref:System.Array>可以有不同每个维度的界限。 一个数组，最多可以输入了 32 维数。  
  
 与中的类不同<xref:System.Collections>命名空间，<xref:System.Array>具有固定的容量。 若要增加容量，你必须创建一个新<xref:System.Array>对象所需的容量、 复制元素从旧<xref:System.Array>到新对象，并删除旧<xref:System.Array>。  
  
 默认情况下的最大大小<xref:System.Array>是 2 千兆字节 (GB)。 在 64 位环境中，您可以通过设置来避免大小限制`enabled`的属性[gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)到的配置元素`true`在运行时环境中。 但是，该数组仍将限于总共 40 亿个元素，而 0X7FEFFFFF 任何给定维度 (0X7FFFFFC7 的字节数组和单字节结构的数组) 中的最大索引。  
  
 一维数组实现<xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>， <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>， <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>，<xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType>和<xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType>泛型接口。 在运行时，实现提供给数组和结果，泛型接口不显示在的声明语法<xref:System.Array>类。 此外，没有针对接口成员只能通过强制转换为泛型接口类型 （显式接口实现） 数组可访问的参考主题。 关键的一点需要注意的强制转换到这些接口之一的数组时是成员的添加，请插入或删除元素 throw <xref:System.NotSupportedException>。  
  
 <xref:System.Type> 对象提供有关数组类型声明信息。 <xref:System.Array> 具有相同的数组类型的对象共用同一个<xref:System.Type>对象。  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> 并<xref:System.Type.GetElementType%2A?displayProperty=nameWithType>可能不返回预期的结果与<xref:System.Array>因为如果数组转换为类型<xref:System.Array>，结果是一个对象，而不是数组。 即`typeof(System.Array).IsArray`将返回`false`，并`typeof(System.Array).GetElementType`返回`null`。  
  
 <xref:System.Array.Copy%2A?displayProperty=nameWithType>元素不仅之间相同类型的数组，但也不同类型的标准阵列之间复制的方法; 它处理的类型自动转换。  
  
 某些方法，如<xref:System.Array.CreateInstance%2A>， <xref:System.Array.Copy%2A>， <xref:System.Array.CopyTo%2A>， <xref:System.Array.GetValue%2A>，和<xref:System.Array.SetValue%2A>，提供接受 64 位整数作为参数，以适应大容量数组的重载。 <xref:System.Array.LongLength%2A> 和<xref:System.Array.GetLongLength%2A>返回 64 位整数，该值指示数组的长度。  
  
 <xref:System.Array>不保证排序。  您必须进行排序<xref:System.Array>在执行操作之前 (如<xref:System.Array.BinarySearch%2A>)，需要<xref:System.Array>进行排序。  
  
 使用<xref:System.Array>对象的本机代码中的指针的不受支持，将引发<xref:System.NotSupportedException>对几种方法。  
  
   
  
## Examples  
 下面的代码示例演示如何<xref:System.Array.Copy%2A?displayProperty=nameWithType>之间的整数类型数组和类型的数组的元素复制<xref:System.Object>。  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 下面的代码示例创建并初始化<xref:System.Array>，并显示其属性和它的元素。  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>公共静态 (<see langword="Shared" />在 Visual Basic 中) 的此类型的成员是线程安全。 但不保证所有实例成员都是线程安全的。  
  
此实现不提供同步 （线程安全） 包装器<see cref="T:System.Array" />; 但是，.NET Framework 类基于<see cref="T:System.Array" />提供集合使用其自己的同步的版本<see cref="P:System.Array.SyncRoot" />属性。  
  
枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
    <related type="Article" href="~/docs/csharp/programming-guide/arrays/index.md">数组（C# 编程指南）</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/arrays/index.md">Visual Basic 中的数组</related>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要包装在只读 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 包装器中的从零开始的一维数组。</param>
        <summary>返回指定数组的只读包装。</summary>
        <returns>指定数组的只读 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止对数组进行任何修改，公开只能通过此包装的数组。  
  
 集合是只读的只是一个集合与可防止修改集合; 的包装器因此，如果对基础集合进行更改，只读集合反映了这些更改。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的示例中的只读包装数组<xref:System.Collections.ObjectModel.ReadOnlyCollection%601>。  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用二进制搜索算法在一维的排序 <see cref="T:System.Array" /> 中搜索值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的排序一维 <see cref="T:System.Array" />。</param>
        <param name="value">要搜索的对象。</param>
        <summary>使用由数组中每个元素和指定对象实现的 <see cref="T:System.IComparable" /> 接口，在整个一维排序数组中搜索特定元素。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array` 必须调用此方法之前进行排序。  
  
 如果<xref:System.Array>不包含指定的值，该方法返回一个负整数。 可以将应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 为负数的结果，以生成的索引。 如果此索引是一个大于上限的数组，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 要么`value`的每个元素或`array`必须实现<xref:System.IComparable>接口，用于比较。 元素`array`必须已在提高根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。  
  
> [!NOTE]
>  如果`value`不实现<xref:System.IComparable>接口的元素`array`未测试的<xref:System.IComparable>搜索开始之前。 如果搜索遇到不实现的元素将引发异常<xref:System.IComparable>。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，该方法返回的仅有的匹配项，并不一定是第一个索引。  
  
 `null` 始终与任何其他引用类型;因此，具有比较`null`不会生成异常。  
  
> [!NOTE]
>  为进行测试，每个元素`value`传递给相应<xref:System.IComparable>实现，即使`value`是`null`。 即<xref:System.IComparable>实现确定给定的元素到有何`null`。  
  
 此方法为 O (log `n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Array.BinarySearch%2A>来查找中的特定对象<xref:System.Array>。  
  
> [!NOTE]
>  该数组创建，其元素按升序排序顺序。 <xref:System.Array.BinarySearch%2A>方法要求要按升序排序的数组。  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的排序一维 <see cref="T:System.Array" />。</param>
        <param name="value">要搜索的对象。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
- 或 - 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定 <see cref="T:System.Collections.IComparer" /> 接口，在整个一维排序数组中搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array` 必须调用此方法之前进行排序。  
  
 如果<xref:System.Array>不包含指定的值，该方法返回一个负整数。 可以将应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 为负数的结果，以生成的索引。 如果此索引是一个大于上限的数组，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 比较器自定义对元素进行比较。 例如，可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>作为要执行不区分大小写的字符串搜索的比较器。  
  
 如果`comparer`不是`null`中的元素`array`为指定的值使用指定比较<xref:System.Collections.IComparer>实现。 元素`array`必须已在提高根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。  
  
 如果`comparer`是`null`，完成比较使用<xref:System.IComparable>元素本身或指定的值提供的实现。 元素`array`必须已在提高根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。  
  
> [!NOTE]
>  如果`comparer`是`null`并`value`未实现<xref:System.IComparable>接口的元素`array`未测试的<xref:System.IComparable>搜索开始之前。 如果搜索遇到不实现的元素将引发异常<xref:System.IComparable>。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，该方法返回的仅有的匹配项，并不一定是第一个索引。  
  
 `null` 始终与任何其他引用类型;因此，具有比较`null`不会生成异常。  
  
> [!NOTE]
>  为进行测试，每个元素`value`传递给相应<xref:System.IComparable>实现，即使`value`是`null`。 即<xref:System.IComparable>实现确定给定的元素到有何`null`。  
  
 此方法为 O (log `n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，<paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的排序一维 <see cref="T:System.Array" />。</param>
        <param name="index">要搜索的范围的起始索引。</param>
        <param name="length">要搜索的范围的长度。</param>
        <param name="value">要搜索的对象。</param>
        <summary>使用由一维排序数组中每个元素和指定的值实现的 <see cref="T:System.IComparable" /> 接口，在该数组的一个元素范围内搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array` 必须调用此方法之前进行排序。  
  
 如果<xref:System.Array>不包含指定的值，该方法返回一个负整数。 可以将应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 为负数的结果，以生成的索引。 如果此索引是一个大于上限的数组，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 要么`value`的每个元素或`array`必须实现<xref:System.IComparable>接口，用于比较。 元素`array`必须已在提高根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。  
  
> [!NOTE]
>  如果`value`不实现<xref:System.IComparable>接口的元素`array`未测试的<xref:System.IComparable>搜索开始之前。 如果搜索遇到不实现的元素将引发异常<xref:System.IComparable>。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，该方法返回的仅有的匹配项，并不一定是第一个索引。  
  
 `null` 始终与任何其他引用类型;因此，具有比较`null`不会生成异常。  
  
> [!NOTE]
>  为进行测试，每个元素`value`传递给相应<xref:System.IComparable>实现，即使`value`是`null`。 即<xref:System.IComparable>实现确定给定的元素到有何`null`。  
  
 此方法为 O (log `n`) 操作，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  
  
- 或 - 
 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的排序一维 <see cref="T:System.Array" />。</param>
        <param name="index">要搜索的范围的起始索引。</param>
        <param name="length">要搜索的范围的长度。</param>
        <param name="value">要搜索的对象。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
- 或 - 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定 <see cref="T:System.Collections.IComparer" /> 接口，在一维排序数组的某个元素范围中搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array` 必须调用此方法之前进行排序。  
  
 如果<xref:System.Array>不包含指定的值，该方法返回一个负整数。 可以将应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 为负数的结果，以生成的索引。 如果此索引是一个大于上限的数组，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 比较器自定义对元素进行比较。 例如，可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>作为要执行不区分大小写的字符串搜索的比较器。  
  
 如果`comparer`不是`null`中的元素`array`为指定的值使用指定比较<xref:System.Collections.IComparer>实现。 元素`array`必须已在提高根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。  
  
 如果`comparer`是`null`，完成比较使用<xref:System.IComparable>元素本身或指定的值提供的实现。 元素`array`必须已在提高根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。  
  
> [!NOTE]
>  如果`comparer`是`null`并`value`未实现<xref:System.IComparable>接口的元素`array`未测试的<xref:System.IComparable>搜索开始之前。 如果搜索遇到不实现的元素将引发异常<xref:System.IComparable>。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，该方法返回的仅有的匹配项，并不一定是第一个索引。  
  
 `null` 始终与任何其他引用类型;因此，具有的比较`null`使用时不生成异常<xref:System.IComparable>。  
  
> [!NOTE]
>  为进行测试，每个元素`value`传递给相应<xref:System.IComparable>实现，即使`value`是`null`。 即<xref:System.IComparable>实现确定给定的元素到有何`null`。  
  
 此方法为 O (log `n`) 操作，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  
  
- 或 - 
 <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，<paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</param>
        <param name="value">要搜索的对象。</param>
        <summary>使用由 <see cref="T:System.Array" /> 中每个元素和指定对象实现的 <see cref="T:System.IComparable`1" /> 泛型接口，在整个一维排序数组中搜索特定元素。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array` 必须调用此方法之前进行排序。  
  
 如果`array`不包含指定的值，该方法返回一个负整数。 可以将应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 为负数的结果，以生成的索引。 如果此索引等于数组的大小，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 `T` 必须实现<xref:System.IComparable%601>泛型接口，用于比较。 元素`array`必须已在提高根据定义的排序顺序的值进行排序<xref:System.IComparable%601>实现; 否则，结果可能不正确。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，该方法返回的仅有的匹配项，并不一定是第一个索引。  
  
 `null` 始终与任何其他引用类型;因此，具有比较`null`不会生成异常。  
  
> [!NOTE]
>  为进行测试，每个元素`value`传递给相应<xref:System.IComparable%601>实现，即使`value`是`null`。 即<xref:System.IComparable%601>实现确定给定的元素到有何`null`。  
  
 此方法为 O (log `n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>泛型方法重载和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>泛型方法重载。 创建一个字符串数组，顺序不分先后。  
  
 数组为显示、 已排序，并再次显示。 数组必须进行排序，以便使用<xref:System.Array.BinarySearch%2A>方法。  
  
> [!NOTE]
>  对调用<xref:System.Array.Sort%2A>和<xref:System.Array.BinarySearch%2A>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。 如果您使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，可以看到泛型方法正被调用。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>然后使用泛型方法重载来搜索两个字符串，其中一个脚本并不在数组，另一个是。 数组和返回值的<xref:System.Array.BinarySearch%2A>方法传递给`ShowWhere`泛型方法，如果找到该字符串，否则元素的搜索字符串将介于在数组中显示的索引值。 索引为负，如果字符串不是在数组中，因此`ShowWhere`方法采用按位求补 (~ 运算符在 C# 和 Visual c + +，`Xor`在 Visual Basic 中的为-1) 若要获取大于搜索列表中的第一个元素的索引 str运算结果。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</param>
        <param name="value">要搜索的对象。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现。  
  
- 或 - 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 实现。</param>
        <summary>使用指定 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，在整个一维排序数组中搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array` 必须调用此方法之前进行排序。  
  
 如果<xref:System.Array>不包含指定的值，该方法返回一个负整数。 可以将应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 为负数的结果，以生成的索引。 如果此索引等于数组的大小，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 比较器自定义对元素进行比较。 例如，可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>作为要执行不区分大小写的字符串搜索的比较器。  
  
 如果`comparer`不是`null`中的元素`array`为指定的值使用指定比较<xref:System.Collections.Generic.IComparer%601>泛型接口实现。 元素`array`必须已在提高根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。  
  
 如果`comparer`是`null`，完成比较使用<xref:System.IComparable%601>提供的泛型接口实现`T`。 元素`array`必须已在提高根据定义的排序顺序的值进行排序<xref:System.IComparable%601>实现; 否则，结果可能不正确。  
  
> [!NOTE]
>  如果`comparer`是`null`并`value`未实现<xref:System.IComparable%601>泛型接口中的元素`array`未测试的<xref:System.IComparable%601>搜索开始之前。 如果搜索遇到不实现的元素将引发异常<xref:System.IComparable%601>。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，该方法返回的仅有的匹配项，并不一定是第一个索引。  
  
 `null` 始终与任何其他引用类型;因此，具有比较`null`不会生成异常。  
  
> [!NOTE]
>  为进行测试，每个元素`value`传递给相应<xref:System.IComparable%601>实现，即使`value`是`null`。 即<xref:System.IComparable%601>实现确定给定的元素到有何`null`。  
  
 此方法为 O (log `n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载。  
  
 代码示例定义一个名为`ReverseCompare`，它实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型接口。 该比较器调用<xref:System.String.CompareTo%28System.String%29>方法中，反转比较字的顺序，使字符串对高到低而不是低到高进行排序。  
  
 数组为显示、 已排序，并再次显示。 数组必须进行排序，以便使用<xref:System.Array.BinarySearch%2A>方法。  
  
> [!NOTE]
>  对调用<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。 如果您使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，可以看到泛型方法正被调用。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>然后使用泛型方法重载来搜索两个字符串，其中一个脚本并不在数组，另一个是。 数组和返回值的<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>方法传递给`ShowWhere`泛型方法，如果找到该字符串，否则元素的搜索字符串将介于在数组中显示的索引值。 索引为负，如果字符串不是 n 数组，因此`ShowWhere`方法采用按位求补 (~ 运算符在 C# 和 Visual c + +，`Xor`在 Visual Basic 中的为-1) 若要获取大于搜索 stri 列表中的第一个元素的索引ng。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</param>
        <param name="index">要搜索的范围的起始索引。</param>
        <param name="length">要搜索的范围的长度。</param>
        <param name="value">要搜索的对象。</param>
        <summary>使用由 <see cref="T:System.Array" /> 中每个元素和指定值实现的 <see cref="T:System.IComparable`1" /> 泛型接口，在一维排序数组的某个元素范围中搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array` 必须调用此方法之前进行排序。  
  
 如果数组不包含指定的值，该方法将返回一个负整数。 可以将应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 为负数的结果，以生成的索引。 如果此索引等于数组的大小，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 `T` 必须实现<xref:System.IComparable%601>泛型接口，用于比较。 元素`array`必须已在提高根据定义的排序顺序的值进行排序<xref:System.IComparable%601>实现; 否则，结果可能不正确。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，该方法返回的仅有的匹配项，并不一定是第一个索引。  
  
 `null` 始终与任何其他引用类型;因此，具有比较`null`不会生成异常。  
  
> [!NOTE]
>  为进行测试，每个元素`value`传递给相应<xref:System.IComparable%601>实现，即使`value`是`null`。 即<xref:System.IComparable%601>实现确定给定的元素到有何`null`。  
  
 此方法为 O (log `n`) 操作，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  
  
- 或 - 
 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</param>
        <param name="index">要搜索的范围的起始索引。</param>
        <param name="length">要搜索的范围的长度。</param>
        <param name="value">要搜索的对象。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现。  
  
- 或 - 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 实现。</param>
        <summary>使用指定 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，在一维排序数组的某个元素范围中搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array` 必须调用此方法之前进行排序。  
  
 如果数组不包含指定的值，该方法将返回一个负整数。 可以将应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 为负数的结果，以生成的索引。 如果此索引等于数组的大小，没有任何元素大于`value`数组中。 否则，它是大于第一个元素的索引`value`。  
  
 比较器自定义对元素进行比较。 例如，可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>作为要执行不区分大小写的字符串搜索的比较器。  
  
 如果`comparer`不是`null`中的元素`array`为指定的值使用指定比较<xref:System.Collections.Generic.IComparer%601>泛型接口实现。 元素`array`必须已在提高根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。  
  
 如果`comparer`是`null`，完成比较使用<xref:System.IComparable%601>为类型提供的泛型接口实现`T`。 元素`array`必须已在提高根据定义的排序顺序的值进行排序<xref:System.IComparable%601>实现; 否则，结果可能不正确。  
  
 允许重复的元素。 如果<xref:System.Array>包含多个元素等于`value`，该方法返回的仅有的匹配项，并不一定是第一个索引。  
  
 `null` 始终与任何其他引用类型;因此，具有的比较`null`使用时不生成异常<xref:System.IComparable%601>。  
  
> [!NOTE]
>  为进行测试，每个元素`value`传递给相应<xref:System.IComparable%601>实现，即使`value`是`null`。 即<xref:System.IComparable%601>实现确定给定的元素到有何`null`。  
  
 此方法为 O (log `n`) 操作，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  
  
- 或 - 
 <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">需要清除其元素的数组。</param>
        <param name="index">要清除的一系列元素的起始索引。</param>
        <param name="length">要清除的元素数。</param>
        <summary>将数组中的某个范围的元素设置为每个元素类型的默认值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将数组中的每个元素重置为元素类型的默认值。 设置元素的引用类型 (包括<xref:System.String>元素) 到`null`，并将值类型的元素设置为下表中显示的默认值。  
  
|类型|“值”|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|所有整型和浮点数值类型|0 （零）|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|其他值类型|默认值的类型的字段|  
  
 范围，已清除元素行多维数组中。  
  
 此方法仅限于清除的元素; 的值它不会删除这些元素本身。 数组具有固定的大小;因此，不能添加或删除元素。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Array.Clear%2A>方法来重置一维、 二维和三维数组中的整数值。  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 下面的示例定义`TimeZoneTime`结构，其中包含<xref:System.TimeZoneInfo>字段和一个<xref:System.DateTimeOffset>字段。 然后，它调用<xref:System.Array.Clear%2A>方法以清除的二元素数组中的一个元素`TimeZoneTime`值。 方法将已清除元素的值设置为默认值<xref:System.TimeZoneInfo>对象，它是`null`，默认值的<xref:System.DateTimeOffset>对象，它是<xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>。  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。  
  
- 或 - 
<paramref name="index" /> 和 <paramref name="length" /> 大于 <paramref name="array" /> 的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建 <see cref="T:System.Array" /> 的浅表副本。</summary>
        <returns><see cref="T:System.Array" /> 的浅表副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 浅表副本<xref:System.Array>的元素复制<xref:System.Array>，无论它们是引用类型还是值类型，但它不会复制所引用的对象。 在新的引用<xref:System.Array>指向相同对象的原始引用<xref:System.Array>指向。  
  
 与此相反的深层副本<xref:System.Array>复制元素和直接或间接引用的元素的所有内容。  
  
 克隆是同一<xref:System.Type>与原始<xref:System.Array>。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>。  
  
   
  
## Examples  
 下面的代码示例克隆<xref:System.Globalization.CultureInfo?displayProperty=nameWithType>数组并演示的浅表副本的行为。  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要复制的数据的 <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">一个 32 位整数，它表示 <paramref name="sourceArray" /> 中复制开始处的索引。</param>
        <param name="destinationArray">接收数据的 <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">一个 32 位整数，它表示 <paramref name="destinationArray" /> 中存储开始处的索引。</param>
        <param name="length">一个 32 位整数，它表示要复制的元素数目。</param>
        <summary>复制 <see cref="T:System.Array" /> 中的一系列元素（从指定的源索引开始），并将它们粘贴到另一 <see cref="T:System.Array" /> 中（从指定的目标索引开始）。  保证在复制未成功完成的情况下撤消所有更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`和`destinationArray`参数必须具有相同数量的维度。  `sourceArray`类型必须为相同或派生自`destinationArray`类型; 否则为<xref:System.ArrayTypeMismatchException>引发。  与不同<xref:System.Array.Copy%2A>，<xref:System.Array.ConstrainedCopy%2A>执行任何操作之前验证兼容性的数组类型。  
  
 多维数组之间复制时，该数组行为类似于长时间一维数组，其中的行 （或列） 从概念上讲列出了端到端。 例如，如果数组具有三个行 （或列） 包含四个元素从一开始的数组的每个复制六个元素会将复制所有四个元素的第一行 （或列） 和第二个行 （或列） 的前两个元素。 第三个行 （或列），第二个元素从其开始复制`sourceIndex`必须是第一个行 （或列） 的上限加上第二个行 （或列） 的长度再加上 2。  
  
 如果`sourceArray`并`destinationArray`重叠，此方法的行为像的原始值`sourceArray`在前一个临时位置保留`destinationArray`将被覆盖。  
  
 [C++]  
  
 此方法等效于标准的 C/c + + 函数`memmove`，而不`memcpy`。  
  
 数组可以是引用类型数组或值类型数组。  如果`sourceArray`并`destinationArray`这两个引用类型数组或类型的两个数组<xref:System.Object>，执行浅表副本。 浅表副本<xref:System.Array>是一种新<xref:System.Array>包含对原始与相同的元素的引用<xref:System.Array>。 元素本身或任何引用的元素不会复制。 与此相反的深层副本<xref:System.Array>复制元素和直接或间接引用的元素的所有内容。  
  
 如果此方法将引发异常时复制，请`destinationArray`保持不变; 因此，<xref:System.Array.ConstrainedCopy%2A>可以使用受约束的执行区域内 (<xref:System.Runtime.ConstrainedExecution.Cer>)。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="destinationArray" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> 类型与 <paramref name="destinationArray" /> 类型不同，且不派生自后者。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> 少于 <paramref name="sourceArray" /> 的第一个维度的下限。  
  
- 或 - 
 <paramref name="destinationIndex" /> 少于 <paramref name="destinationArray" /> 的第一个维度的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> 大于从 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 末尾的元素数。  
  
- 或 - 
 <paramref name="length" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 末尾的元素数。</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">源数组元素的类型。</typeparam>
        <typeparam name="TOutput">目标数组元素的类型。</typeparam>
        <param name="array">要转换为目标类型的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="converter">用于将每个元素从一种类型转换为另一种类型的 <see cref="T:System.Converter`2" />。</param>
        <summary>将一种类型的数组转换为另一种类型的数组。</summary>
        <returns>目标类型的数组，包含从源数组转换而来的元素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602>是一个委托，将对象转换为目标类型的方法。  元素`array`逐个传递给<xref:System.Converter%602>，并在新数组中保存转换后的元素。  
  
 源`array`保持不变。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例定义一个名为方法`PointFToPoint`，用于将<xref:System.Drawing.PointF>结构<xref:System.Drawing.Point>结构。 然后，示例创建一个数组<xref:System.Drawing.PointF>结构，创建`Converter<PointF, Point>`委托 (`Converter(Of PointF, Point)`在 Visual Basic 中) 来表示`PointFToPoint`方法，并将传递到委托<xref:System.Array.ConvertAll%2A>方法。 <xref:System.Array.ConvertAll%2A>方法将传递到输入列表的每个元素`PointFToPoint`方法并将转换后的元素放入新的列表<xref:System.Drawing.Point>结构。 显示这两个列表。  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="converter" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将一个 <see cref="T:System.Array" /> 的一部分元素复制到另一个 <see cref="T:System.Array" /> 中，并根据需要执行类型转换和装箱。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要复制的数据的 <see cref="T:System.Array" />。</param>
        <param name="destinationArray">接收数据的 <see cref="T:System.Array" />。</param>
        <param name="length">一个 32 位整数，它表示要复制的元素数目。</param>
        <summary>从第一个元素开始复制 <see cref="T:System.Array" /> 中的一系列元素，将它们粘贴到另一 <see cref="T:System.Array" /> 中（从第一个元素开始）。 长度指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`和`destinationArray`参数必须具有相同数量的维度。 此外，`destinationArray`必须已具有已确定了维度，并且必须具有足够数量的元素以容纳所复制的数据。  
  
 多维数组之间复制时，该数组行为类似于长时间一维数组，其中的行 （或列） 从概念上讲列出了端到端。 例如，如果数组具有三个行 （或列） 包含四个元素从一开始的数组的每个复制六个元素会将复制所有四个元素的第一行 （或列） 和第二个行 （或列） 的前两个元素。  
  
 如果`sourceArray`并`destinationArray`重叠，此方法的行为像的原始值`sourceArray`在前一个临时位置保留`destinationArray`将被覆盖。  
  
 [C++]  
  
 此方法等效于标准的 C/c + + 函数`memmove`，而不`memcpy`。  
  
 数组可以是引用类型数组或值类型数组。 执行类型向下转换，则所需的方式。  
  
-   当从引用类型数组复制到值类型数组，每个元素是取消装箱，然后将其复制。 当从值类型数组复制到引用类型数组，每个元素被装箱，然后将其复制。  
  
-   将引用类型或值类型阵列分区到从复制时<xref:System.Object>数组，<xref:System.Object>创建用来保存每个值或引用，然后将其复制。 从复制时<xref:System.Object>阵列分区到引用类型或值类型数组，以及赋值不能，<xref:System.InvalidCastException>引发。  
  
-   如果`sourceArray`并`destinationArray`这两个引用类型数组或类型的两个数组<xref:System.Object>，执行浅表副本。 浅表副本<xref:System.Array>是一种新<xref:System.Array>包含对原始与相同的元素的引用<xref:System.Array>。 元素本身或任何引用的元素不会复制。 与此相反的深层副本<xref:System.Array>复制元素和直接或间接引用的元素的所有内容。  
  
 <xref:System.ArrayTypeMismatchException>不兼容的类型的数组时引发。 类型兼容性定义，如下所示：  
  
-   一种类型适用于自身。  
  
-   值类型是与兼容<xref:System.Object>和由该值类型实现的接口类型。 仅当它实现该接口直接连接到接口视为值类型。 断开连接的类型不兼容。  
  
-   两个内部函数 （预定义的） 的值类型都兼容，如果将源类型从复制到目标类型是一个扩大转换。 扩大转换永远不会丢失信息，而收缩转换可能会丢失信息。 例如，将 32 位有符号的整数转换为 64 位有符号整数是扩大转换，并将 64 位有符号的整数转换为 32 位有符号整数都是收缩转换。 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
-   内部 （用户定义） 的值类型是本身仅与兼容。  
  
-   枚举具有隐式转换为<xref:System.Enum>和为其基础类型。  
  
 如果在每个元素`sourceArray`需要向下转换 （例如，从基类到派生类或接口的对象） 和一个或多个元素不能强制转换为相应的类型`destinationArray`、<xref:System.InvalidCastException>引发。  
  
 如果此方法将引发异常时复制的状态`destinationArray`是不确定的。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="destinationArray" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> 大于 <paramref name="sourceArray" /> 中的元素数。  
  
- 或 - 
 <paramref name="length" /> 大于 <paramref name="destinationArray" /> 中的元素数。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要复制的数据的 <see cref="T:System.Array" />。</param>
        <param name="destinationArray">接收数据的 <see cref="T:System.Array" />。</param>
        <param name="length">一个 64 位整数，它表示要复制的元素数目。 该整数必须介于零和 <see cref="F:System.Int32.MaxValue" /> 之间（包括这两个值）。</param>
        <summary>从第一个元素开始复制 <see cref="T:System.Array" /> 中的一系列元素，将它们粘贴到另一 <see cref="T:System.Array" /> 中（从第一个元素开始）。 长度指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`和`destinationArray`参数必须具有相同数量的维度。 此外，`destinationArray`必须已具有已确定了维度，并且必须具有足够数量的元素以容纳所复制的数据。  
  
 多维数组之间复制时，该数组行为类似于长时间一维数组，其中的行 （或列） 从概念上讲列出了端到端。 例如，如果数组具有三个行 （或列） 包含四个元素从一开始的数组的每个复制六个元素会将复制所有四个元素的第一行 （或列） 和第二个行 （或列） 的前两个元素。  
  
 如果`sourceArray`并`destinationArray`重叠，此方法的行为像的原始值`sourceArray`在前一个临时位置保留`destinationArray`将被覆盖。  
  
 [C++]  
  
 此方法等效于标准的 C/c + + 函数`memmove`，而不`memcpy`。  
  
 数组可以是引用类型数组或值类型数组。 执行类型向下转换，则所需的方式。  
  
-   当从引用类型数组复制到值类型数组，每个元素是取消装箱，然后将其复制。 当从值类型数组复制到引用类型数组，每个元素被装箱，然后将其复制。  
  
-   将引用类型或值类型阵列分区到从复制时<xref:System.Object>数组，<xref:System.Object>创建用来保存每个值或引用，然后将其复制。 从复制时<xref:System.Object>阵列分区到引用类型或值类型数组，以及赋值不能，<xref:System.InvalidCastException>引发。  
  
-   如果`sourceArray`并`destinationArray`这两个引用类型数组或类型的两个数组<xref:System.Object>，执行浅表副本。 浅表副本<xref:System.Array>是一种新<xref:System.Array>包含对原始与相同的元素的引用<xref:System.Array>。 元素本身或任何引用的元素不会复制。 与此相反的深层副本<xref:System.Array>复制元素和直接或间接引用的元素的所有内容。  
  
 <xref:System.ArrayTypeMismatchException>不兼容的类型的数组时引发。 类型兼容性定义，如下所示：  
  
-   一种类型适用于自身。  
  
-   值类型是与兼容<xref:System.Object>和由该值类型实现的接口类型。 仅当它实现该接口直接连接到接口视为值类型。 断开连接的类型不兼容。  
  
-   两个内部函数 （预定义的） 的值类型都兼容，如果将源类型从复制到目标类型是一个扩大转换。 扩大转换永远不会丢失信息，而收缩转换可能会丢失信息。 例如，将 32 位有符号的整数转换为 64 位有符号整数是扩大转换，并将 64 位有符号的整数转换为 32 位有符号整数都是收缩转换。 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
-   内部 （用户定义） 的值类型是本身仅与兼容。  
  
-   枚举具有隐式转换为<xref:System.Enum>和为其基础类型。  
  
 如果在每个元素`sourceArray`需要向下转换 （例如，从基类到派生类或接口的对象） 和一个或多个元素不能强制转换为相应的类型`destinationArray`、<xref:System.InvalidCastException>引发。  
  
 如果此方法将引发异常时复制的状态`destinationArray`是不确定的。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="destinationArray" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> 小于 0 或大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> 大于 <paramref name="sourceArray" /> 中的元素数。  
  
- 或 - 
 <paramref name="length" /> 大于 <paramref name="destinationArray" /> 中的元素数。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要复制的数据的 <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">一个 32 位整数，它表示 <paramref name="sourceArray" /> 中复制开始处的索引。</param>
        <param name="destinationArray">接收数据的 <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">一个 32 位整数，它表示 <paramref name="destinationArray" /> 中存储开始处的索引。</param>
        <param name="length">一个 32 位整数，它表示要复制的元素数目。</param>
        <summary>复制 <see cref="T:System.Array" /> 中的一系列元素（从指定的源索引开始），并将它们粘贴到另一 <see cref="T:System.Array" /> 中（从指定的目标索引开始）。 长度和索引指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`和`destinationArray`参数必须具有相同数量的维度。 此外，`destinationArray`必须已具有已确定了维度，并且必须具有足够数量的元素从开始`destinationIndex`位置以容纳所复制的数据。  
  
 多维数组之间复制时，该数组行为类似于长时间一维数组，其中的行 （或列） 从概念上讲列出了端到端。 例如，如果数组具有三个行 （或列） 包含四个元素从一开始的数组的每个复制六个元素会将复制所有四个元素的第一行 （或列） 和第二个行 （或列） 的前两个元素。 第三个行 （或列），第二个元素从其开始复制`sourceIndex`必须是第一个行 （或列） 的上限加上第二个行 （或列） 的长度再加上 2。  
  
 如果`sourceArray`并`destinationArray`重叠，此方法的行为像的原始值`sourceArray`在前一个临时位置保留`destinationArray`将被覆盖。  
  
 [C++]  
  
 此方法等效于标准的 C/c + + 函数`memmove`，而不`memcpy`。  
  
 数组可以是引用类型数组或值类型数组。 执行类型向下转换，则所需的方式。  
  
-   当从引用类型数组复制到值类型数组，每个元素是取消装箱，然后将其复制。 当从值类型数组复制到引用类型数组，每个元素被装箱，然后将其复制。  
  
-   将引用类型或值类型阵列分区到从复制时<xref:System.Object>数组，<xref:System.Object>创建用来保存每个值或引用，然后将其复制。 从复制时<xref:System.Object>阵列分区到引用类型或值类型数组，以及赋值不能，<xref:System.InvalidCastException>引发。  
  
-   如果`sourceArray`并`destinationArray`这两个引用类型数组或类型的两个数组<xref:System.Object>，执行浅表副本。 浅表副本<xref:System.Array>是一种新<xref:System.Array>包含对原始与相同的元素的引用<xref:System.Array>。 元素本身或任何引用的元素不会复制。 与此相反的深层副本<xref:System.Array>复制元素和直接或间接引用的元素的所有内容。  
  
 <xref:System.ArrayTypeMismatchException>不兼容的类型的数组时引发。 类型兼容性定义，如下所示：  
  
-   一种类型适用于自身。  
  
-   值类型是与兼容<xref:System.Object>和由该值类型实现的接口类型。 仅当它实现该接口直接连接到接口视为值类型。 断开连接的类型不兼容。  
  
-   两个内部函数 （预定义的） 的值类型都兼容，如果将源类型从复制到目标类型是一个扩大转换。 扩大转换永远不会丢失信息，而收缩转换可能会丢失信息。 例如，将 32 位有符号的整数转换为 64 位有符号整数是扩大转换，并将 64 位有符号的整数转换为 32 位有符号整数都是收缩转换。 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
-   内部 （用户定义） 的值类型是本身仅与兼容。  
  
-   枚举具有隐式转换为<xref:System.Enum>和为其基础类型。  
  
 如果在每个元素`sourceArray`需要向下转换 （例如，从基类到派生类或接口的对象） 和一个或多个元素不能强制转换为相应的类型`destinationArray`、<xref:System.InvalidCastException>引发。  
  
 如果此方法将引发异常时复制的状态`destinationArray`是不确定的。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何从一个将复制<xref:System.Array>类型的<xref:System.Object>到另一个<xref:System.Array>的整数类型。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="destinationArray" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> 少于 <paramref name="sourceArray" /> 的第一个维度的下限。  
  
- 或 - 
 <paramref name="destinationIndex" /> 少于 <paramref name="destinationArray" /> 的第一个维度的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> 大于从 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 末尾的元素数。  
  
- 或 - 
 <paramref name="length" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 末尾的元素数。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要复制的数据的 <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">一个 64 位整数，它表示复制开始处的 <paramref name="sourceArray" /> 中的索引。</param>
        <param name="destinationArray">接收数据的 <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">一个 64 位整数，它表示存储开始处的 <paramref name="destinationArray" /> 中的索引。</param>
        <param name="length">一个 64 位整数，它表示要复制的元素数目。 该整数必须介于零和 <see cref="F:System.Int32.MaxValue" /> 之间（包括这两个值）。</param>
        <summary>复制 <see cref="T:System.Array" /> 中的一系列元素（从指定的源索引开始），并将它们粘贴到另一 <see cref="T:System.Array" /> 中（从指定的目标索引开始）。 长度和索引指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray`和`destinationArray`参数必须具有相同数量的维度。 此外，`destinationArray`必须已具有已确定了维度，并且必须具有足够数量的元素从开始`destinationIndex`位置以容纳所复制的数据。  
  
 多维数组之间复制时，该数组行为类似于长时间一维数组，其中的行 （或列） 从概念上讲列出了端到端。 例如，如果数组具有三个行 （或列） 包含四个元素从一开始的数组的每个复制六个元素会将复制所有四个元素的第一行 （或列） 和第二个行 （或列） 的前两个元素。 第三个行 （或列），第二个元素从其开始复制`sourceIndex`必须是第一个行 （或列） 的上限加上第二个行 （或列） 的长度再加上 2。  
  
 如果`sourceArray`并`destinationArray`重叠，此方法的行为像的原始值`sourceArray`在前一个临时位置保留`destinationArray`将被覆盖。  
  
 [C++]  
  
 此方法等效于标准的 C/c + + 函数`memmove`，而不`memcpy`。  
  
 数组可以是引用类型数组或值类型数组。 执行类型向下转换，则所需的方式。  
  
-   当从引用类型数组复制到值类型数组，每个元素是取消装箱，然后将其复制。 当从值类型数组复制到引用类型数组，每个元素被装箱，然后将其复制。  
  
-   将引用类型或值类型阵列分区到从复制时<xref:System.Object>数组，<xref:System.Object>创建用来保存每个值或引用，然后将其复制。 从复制时<xref:System.Object>阵列分区到引用类型或值类型数组，以及赋值不能，<xref:System.InvalidCastException>引发。  
  
-   如果`sourceArray`并`destinationArray`这两个引用类型数组或类型的两个数组<xref:System.Object>，执行浅表副本。 浅表副本<xref:System.Array>是一种新<xref:System.Array>包含对原始与相同的元素的引用<xref:System.Array>。 元素本身或任何引用的元素不会复制。 与此相反的深层副本<xref:System.Array>复制元素和直接或间接引用的元素的所有内容。  
  
 <xref:System.ArrayTypeMismatchException>不兼容的类型的数组时引发。 类型兼容性定义，如下所示：  
  
-   一种类型适用于自身。  
  
-   值类型是与兼容<xref:System.Object>和由该值类型实现的接口类型。 仅当它实现该接口直接连接到接口视为值类型。 断开连接的类型不兼容。  
  
-   两个内部函数 （预定义的） 的值类型都兼容，如果将源类型从复制到目标类型是一个扩大转换。 扩大转换永远不会丢失信息，而收缩转换可能会丢失信息。 例如，将 32 位有符号的整数转换为 64 位有符号整数是扩大转换，并将 64 位有符号的整数转换为 32 位有符号整数都是收缩转换。 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
-   内部 （用户定义） 的值类型是本身仅与兼容。  
  
-   枚举具有隐式转换为<xref:System.Enum>和为其基础类型。  
  
 如果在每个元素`sourceArray`需要向下转换 （例如，从基类到派生类或接口的对象） 和一个或多个元素不能强制转换为相应的类型`destinationArray`、<xref:System.InvalidCastException>引发。  
  
 如果此方法将引发异常时复制的状态`destinationArray`是不确定的。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何从一个将复制<xref:System.Array>类型的<xref:System.Object>到另一个<xref:System.Array>的整数类型。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="destinationArray" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> 超出了 <paramref name="sourceArray" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="destinationIndex" /> 超出了 <paramref name="destinationArray" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="length" /> 小于 0 或大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> 大于从 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 末尾的元素数。  
  
- 或 - 
 <paramref name="length" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 末尾的元素数。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将当前一维数组的所有元素复制到指定的一维数组中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一维数组，它是从当前数组复制的元素的目标。</param>
        <param name="index">一个 32 位整数，它表示 <paramref name="array" /> 中复制开始处的索引。</param>
        <summary>从指定的目标数组索引处开始，将当前一维数组的所有元素复制到指定的一维数组中。 索引指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法会复制到当前数组实例的所有元素`array`目标数组，从索引处开始`index`。 `array`目标数组必须已具有已确定了维度，并且必须具有足够数量的元素，以便复制的元素。 否则，该方法将引发异常。  
  
 此方法支持<xref:System.Collections.ICollection?displayProperty=nameWithType>接口。 如果实现<xref:System.Collections.ICollection?displayProperty=nameWithType>是不明确需要，使用<xref:System.Array.Copy%2A>以避免额外的间接寻址。  
  
 如果此方法将引发异常时复制的状态`array`是不确定的。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>。它执行的浅表副本。  
  
   
  
## Examples  
 下面的代码示例演示如何将复制<xref:System.Array>到另一个<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 下面的代码示例演示如何将复制<xref:System.Array>到另一个<xref:System.Array>非零值的下限。 请注意，整个源<xref:System.Array>包括覆盖目标中的现有元素的空元素的复制<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> 是多维的。  
  
- 或 - 
源数组中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 的末尾之间的可用元素数。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">无法自动将源 <see cref="T:System.Array" /> 的类型转换为目标 <paramref name="array" /> 的类型。</exception>
        <exception cref="T:System.RankException">源数组是多维数组。</exception>
        <exception cref="T:System.InvalidCastException">源 <see cref="T:System.Array" /> 中至少有一个元素无法转换为目标 <paramref name="array" /> 的类型。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">一维数组，它是从当前数组复制的元素的目标。</param>
        <param name="index">一个 64 位整数，它表示 <paramref name="array" /> 中复制开始处的索引。</param>
        <summary>从指定的目标数组索引处开始，将当前一维数组的所有元素复制到指定的一维数组中。 索引指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法会复制到当前数组实例的所有元素`array`目标数组，从索引处开始`index`。 `array`目标数组必须已具有已确定了维度，并且必须具有足够数量的元素，以便复制的元素。 否则，该方法将引发异常。  
  
 此方法支持<xref:System.Collections.ICollection?displayProperty=nameWithType>接口。 如果实现<xref:System.Collections.ICollection?displayProperty=nameWithType>是不明确需要，使用<xref:System.Array.Copy%2A>以避免额外的间接寻址。  
  
 如果此方法将引发异常时复制的状态`array`是不确定的。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>。它执行的浅表副本。  
  
   
  
## Examples  
 下面的代码示例演示如何将复制<xref:System.Array>到另一个<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 下面的代码示例演示如何将复制<xref:System.Array>到另一个<xref:System.Array>非零值的下限。 请注意，整个源<xref:System.Array>包括覆盖目标中的现有元素的空元素的复制<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> 是多维的。  
  
- 或 - 
源数组中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 的末尾之间的可用元素数。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">无法自动将源 <see cref="T:System.Array" /> 的类型转换为目标 <paramref name="array" /> 的类型。</exception>
        <exception cref="T:System.RankException">源 <see cref="T:System.Array" /> 是多维的。</exception>
        <exception cref="T:System.InvalidCastException">源 <see cref="T:System.Array" /> 中至少有一个元素无法转换为目标 <paramref name="array" /> 的类型。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Array" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="length">要创建的 <see cref="T:System.Array" /> 的大小。</param>
        <summary>创建使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和长度的一维 <see cref="T:System.Array" />。</summary>
        <returns>使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和长度的新的一维 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大多数与类不同，<xref:System.Array>提供了<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许进行后期绑定访问。  
  
 引用类型元素将初始化为`null`。 值类型元素将初始化为零。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化一个一维<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  
  
- 或 - 
 <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="lengths">一个 32 位整数数组，它表示要创建的 <see cref="T:System.Array" /> 中每个维度的大小。</param>
        <summary>创建索引从零开始、具有指定 <see cref="T:System.Type" /> 和维长的多维 <see cref="T:System.Array" />。 维的长度在一个 32 位整数数组中指定。</summary>
        <returns>指定 <see cref="T:System.Type" /> 的新多维 <see cref="T:System.Array" />，该数组每个维具有指定长度，且使用从零开始的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大多数与类不同，<xref:System.Array>提供了<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许进行后期绑定访问。  
  
 中的元素数`lengths`阵列必须等于在新的维度数<xref:System.Array>。 每个元素`lengths`阵列必须在新指定的相应维度的长度<xref:System.Array>。  
  
 引用类型元素将初始化为`null`。 值类型元素将初始化为零。  
  
 此方法为 O (`n`) 操作，其中`n`是中的所有值的乘积`lengths`。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化的多维<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="lengths" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。  
  
- 或 - 
<paramref name="lengths" /> 数组包含的元素少于一个。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  
  
- 或 - 
 <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lengths" /> 中的任何值都小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="lengths">一个 64 位整数数组，它表示要创建的 <see cref="T:System.Array" /> 中每个维度的大小。 数组中的每个整数都必须介于零和 <see cref="F:System.Int32.MaxValue" /> 之间（包括这两个值）。</param>
        <summary>创建索引从零开始、具有指定 <see cref="T:System.Type" /> 和维长的多维 <see cref="T:System.Array" />。 维的长度在一个 64 位整数数组中指定。</summary>
        <returns>指定 <see cref="T:System.Type" /> 的新多维 <see cref="T:System.Array" />，该数组每个维具有指定长度，且使用从零开始的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大多数与类不同，<xref:System.Array>提供了<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许进行后期绑定访问。  
  
 中的元素数`lengths`阵列必须等于在新的维度数<xref:System.Array>。 每个元素`lengths`阵列必须在新指定的相应维度的长度<xref:System.Array>。  
  
 引用类型元素将初始化为`null`。 值类型元素将初始化为零。  
  
 此方法为 O (`n`) 操作，其中`n`是中的所有值的乘积`lengths`。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化的多维<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="lengths" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。  
  
- 或 - 
<paramref name="lengths" /> 数组包含的元素少于一个。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  
  
- 或 - 
 <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lengths" /> 中的任何值小于零或大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="length1">要创建的 <see cref="T:System.Array" /> 的第一维的大小。</param>
        <param name="length2">要创建的 <see cref="T:System.Array" /> 的第二维的大小。</param>
        <summary>创建使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和维长的二维 <see cref="T:System.Array" />。</summary>
        <returns>使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 的新的二维 <see cref="T:System.Array" />，其每个维度都为指定的长度。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大多数与类不同，<xref:System.Array>提供了<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许进行后期绑定访问。  
  
 引用类型元素将初始化为`null`。 值类型元素将初始化为零。  
  
 此方法为 O (`n`) 操作，其中`n`是乘积`length1`和`length2`。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化一个二维<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  
  
- 或 - 
 <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> 小于零。  
  
- 或 - 
 <paramref name="length2" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="lengths">一维数组，它包含要创建的 <see cref="T:System.Array" /> 的每个维度的大小。</param>
        <param name="lowerBounds">一维数组，它包含要创建的 <see cref="T:System.Array" /> 的每个维度的下限（起始索引）。</param>
        <summary>创建具有指定下限、指定 <see cref="T:System.Type" /> 和维长的多维 <see cref="T:System.Array" />。</summary>
        <returns>具有指定 <see cref="T:System.Type" /> 的新的多维 <see cref="T:System.Array" />，其每个维度都具有指定长度和下限。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大多数与类不同，<xref:System.Array>提供了<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许进行后期绑定访问。  
  
 `lengths`和`lowerBounds`数组必须具有相同数目的元素。 中的元素数`lengths`阵列必须等于在新的维度数<xref:System.Array>。  
  
 每个元素`lengths`阵列必须在新指定的相应维度的长度<xref:System.Array>。  
  
 每个元素`lowerBounds`阵列必须在新指定的相应维度的下限<xref:System.Array>。 通常情况下，.NET Framework 类库和许多编程语言不处理非零下限。  
  
 引用类型元素将初始化为`null`。 值类型元素将初始化为零。  
  
 此方法为 O (`n`) 操作，其中`n`是中的所有值的乘积`lengths`。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化的多维<xref:System.Array>具有指定的下限。  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="lengths" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="lowerBounds" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。  
  
- 或 - 
<paramref name="lengths" /> 数组包含的元素少于一个。  
  
- 或 - 
<paramref name="lengths" /> 和 <paramref name="lowerBounds" /> 数组包含的元素数不同。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  
  
- 或 - 
 <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lengths" /> 中的任何值都小于零。  
  
- 或 - 
<paramref name="lowerBounds" /> 中的任意一个值都很大，因此，维的下限和长度的和大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="length1">要创建的 <see cref="T:System.Array" /> 的第一维的大小。</param>
        <param name="length2">要创建的 <see cref="T:System.Array" /> 的第二维的大小。</param>
        <param name="length3">要创建的 <see cref="T:System.Array" /> 的第三维的大小。</param>
        <summary>创建使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和维长的三维 <see cref="T:System.Array" />。</summary>
        <returns>每个维具有指定长度、使用从零开始的索引的指定 <see cref="T:System.Type" /> 的新三维 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大多数与类不同，<xref:System.Array>提供了<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许进行后期绑定访问。  
  
 引用类型元素将初始化为`null`。 值类型元素将初始化为零。  
  
 此方法为 O (`n`) 操作，其中`n`是乘积`length1`， `length2`，和`length3`。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化的三维<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  
  
- 或 - 
 <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> 小于零。  
  
- 或 - 
 <paramref name="length2" /> 小于零。  
  
- 或 - 
 <paramref name="length3" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <summary>返回一个空数组。</summary>
        <returns>空数组。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>确定指定数组包含的元素是否与指定谓词定义的条件匹配。</summary>
        <returns>如果 <paramref name="array" /> 包含一个或多个与指定谓词所定义的条件相匹配的元素，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`逐个传递给<xref:System.Predicate%601>，并找到匹配项时停止处理。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建<xref:System.Predicate%601>显式委托。 这些语言推断从上下文正确的委托，并自动创建。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例指定的匹配条件<xref:System.Array.Exists%2A>方法 usinglambda 表达式，以检查是否全球以给定字母开头或全球是否位于给定的数组。  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 下面的示例使用<xref:System.Array.Exists%2A>方法，以指示是否使用指定的字符开始的字符串数组中的任何名称。 该示例实例化`StringSearcher`通过传递给其类构造函数搜索的字符串对象。 `StringSearcher.StartsWith`方法具有相同的签名<xref:System.Predicate%601>委托。 当<xref:System.Array.Exists%2A>方法调用，直到它返回数组的每个成员传递给委托`true`或循环访问数组中的所有元素。  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 可以使用 lambda 表达式，而不是显式定义的委托的签名是相对应的方法。 下面的示例将替换`StringSearcher`类并将其`StartsWith`方法使用 lambda 表达式。  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
        <related type="Article" href="~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md">Lambda 表达式（C# 编程指南）</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md">Lambda 表达式 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维数组。</param>
        <param name="match">用于定义要搜索的元素的条件的谓词。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中的第一个匹配元素。</summary>
        <returns>如果找到与指定谓词定义的条件匹配的第一个元素，则为该元素；否则为类型 <paramref name="T" /> 的默认值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是一种方法或 lambda 表达式返回的委托`true`如果该对象传递给委托或 lambda 表达式中定义的条件匹配。  元素`array`逐个传递给<xref:System.Predicate%601>，从第一个元素开始和结束的最后一个元素。  当找到匹配项时，停止处理。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Predicate%601>委托，其<xref:System.Array.Find%2A>泛型方法搜索的数组<xref:System.Drawing.Point>结构。 表示委托，该方法`ProductGT10`，返回`true`是否大于 100,000 的 X 和 Y 字段。 <xref:System.Array.Find%2A>方法返回满足测试条件的第一个点的数组的每个元素调用的代理。  
  
> [!NOTE]
>  Visual Basic 和 C# 用户不需要显式创建委托，或者指定泛型方法的类型参数。 编译器确定从提供的方法参数所需的类型。  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 而不是显式定义具有必需签名的方法实例化<xref:System.Predicate%601>委派，并将传递到委托<xref:System.Array.Find%2A>方法，惯例做法是使用 lambda 表达式。 下面的示例是与前一个相同，只不过它使用 lambda 表达式作为`match`参数。  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>检索与指定谓词定义的条件匹配的所有元素。</summary>
        <returns>如果找到一个 <see cref="T:System.Array" />，其中所有元素均与指定谓词定义的条件匹配，则为该数组；否则为一个空 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`逐个传递给<xref:System.Predicate%601>，并在返回的数组保存的条件相匹配的元素。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例使用范围可以介于 0 到 1000 的值创建 50 个随机数字的数组。 然后，它调用<xref:System.Array.FindAll%2A>方法使用 lambda 表达式的返回值，范围从 300 到 600。 请注意，lambda 表达式传递名为的参数`x`; 这表示传递到的单个数组成员<xref:System.Predicate%601>。 另请注意，本地`lBound`和`uBound`变量是可在 lambda 表达式中访问。  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 下面的代码示例演示<xref:System.Array.Find%2A>， <xref:System.Array.FindLast%2A>，和<xref:System.Array.FindAll%2A>泛型方法。 创建一个字符串数组，其中包含 8 恐龙名称，其中 （位于位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、，它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.Find%2A>泛型方法开始时，将每个元素传递给又从遍历数组`EndsWithSaurus`方法。 搜索将停止何时`EndsWithSaurus`方法将返回`true`"Amargasaurus"的元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindLast%2A>泛型方法用于搜索向后端的数组。 它找到的元素"Dilophosaurus"在位置 5。 <xref:System.Array.FindAll%2A>泛型方法用于返回包含以"saurus"结尾的所有元素的数组。 元素的显示。  
  
 代码示例还演示<xref:System.Array.Exists%2A>和<xref:System.Array.TrueForAll%2A>泛型方法。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 <see cref="T:System.Array" /> 或其某个部分中搜索与指定谓词所定义的条件相匹配的元素，并返回第一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中第一个匹配元素的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>向前的第一个元素开始和结束时间的最后一个元素搜索。  
  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`逐个传递给<xref:System.Predicate%601>。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个重载<xref:System.Array.FindIndex%2A>泛型方法。 创建一个字符串数组，其中包含 8 恐龙名称，其中 （位于位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、，它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从开始时，将每个元素传递给反过来遍历数组`EndsWithSaurus`方法。 搜索将停止何时`EndsWithSaurus`方法将返回`true`位于位置 1 处的元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索位置 2 开始，一直到数组末尾的数组。 它查找位置 5 处的元素。 最后，<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的位置 2 开始的三个元素的范围。 因为在该范围内没有以"saurus"结尾的恐龙名称，则返回-1。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Array" /> 中从指定索引到最后一个元素的元素范围内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>处开始向前搜索`startIndex`和结束时间的最后一个元素。  
  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`逐个传递给<xref:System.Predicate%601>。  
  
 此方法为 O (`n`) 操作，其中`n`是中的元素数目`startIndex`到末尾`array`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个重载<xref:System.Array.FindIndex%2A>泛型方法。 创建一个字符串数组，其中包含 8 恐龙名称，其中 （位于位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、，它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从开始时，将每个元素传递给反过来遍历数组`EndsWithSaurus`方法。 搜索将停止何时`EndsWithSaurus`方法将返回`true`位于位置 1 处的元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索位置 2 开始，一直到数组末尾的数组。 它查找位置 5 处的元素。 最后，<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的位置 2 开始的三个元素的范围。 因为在该范围内没有以"saurus"结尾的恐龙名称，则返回-1。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的一个元素，并返回 <see cref="T:System.Array" /> 中从指定的索引开始、包含指定元素个数的元素范围内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>处开始向前搜索`startIndex`结束时间`startIndex`plus`count`减 1，如果`count`大于 0。  
  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`逐个传递给<xref:System.Predicate%601>。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个重载<xref:System.Array.FindIndex%2A>泛型方法。 创建一个字符串数组，其中包含 8 恐龙名称，其中 （位于位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、，它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从开始时，将每个元素传递给反过来遍历数组`EndsWithSaurus`方法。 搜索将停止何时`EndsWithSaurus`方法将返回`true`位于位置 1 处的元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索位置 2 开始，一直到数组末尾的数组。 它查找位置 5 处的元素。 最后，<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的位置 2 开始的三个元素的范围。 因为在该范围内没有以"saurus"结尾的恐龙名称，则返回-1。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于零。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中的最后一个匹配元素。</summary>
        <returns>如果找到，则为与指定谓词所定义的条件相匹配的最后一个元素；否则为类型 <paramref name="T" /> 的默认值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`逐个传递给<xref:System.Predicate%601>、 移动中向后<xref:System.Array>，从最后一个元素开始和结束的第一个元素。  当找到匹配项时，停止处理。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Find%2A>， <xref:System.Array.FindLast%2A>，和<xref:System.Array.FindAll%2A>泛型方法。 创建一个字符串数组，其中包含 8 恐龙名称，其中 （位于位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、，它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.Find%2A>泛型方法开始时，将每个元素传递给又从遍历数组`EndsWithSaurus`方法。 搜索将停止何时`EndsWithSaurus`方法将返回`true`"Amargasaurus"的元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindLast%2A>泛型方法用于搜索向后端的数组。 它找到的元素"Dilophosaurus"在位置 5。 <xref:System.Array.FindAll%2A>泛型方法用于返回包含以"saurus"结尾的所有元素的数组。 元素的显示。  
  
 代码示例还演示<xref:System.Array.Exists%2A>和<xref:System.Array.TrueForAll%2A>泛型方法。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 <see cref="T:System.Array" /> 或其某个部分中搜索与指定谓词所定义的条件相匹配的元素，并返回最后一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中最后一个匹配元素的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>向后搜索的最后一个元素开始，结束时间的第一个元素。  
  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`逐个传递给<xref:System.Predicate%601>。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个重载<xref:System.Array.FindLastIndex%2A>泛型方法。 创建一个字符串数组，其中包含 8 恐龙名称，其中 （位于位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、，它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从结束时，将每个元素传递给反过来遍历向后的数组`EndsWithSaurus`方法。 搜索将停止何时`EndsWithSaurus`方法将返回`true`位置 5 处的元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索位置 4 开始，一直向后到数组的开头的数组。 它查找位置 1 处的元素。 最后，<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的三个元素从位置 4 开始，向回查找 （即，元素 4、 3 和 2） 的范围。 因为在该范围内没有以"saurus"结尾的恐龙名称，则返回-1。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与由指定谓词定义的条件相匹配的元素，并返回 <see cref="T:System.Array" /> 中从第一个元素到指定索引的元素范围内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>是搜索处开始向后`startIndex`和结束时间的第一个元素。  
  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`逐个传递给<xref:System.Predicate%601>。  
  
 此方法为 O (`n`) 操作，其中`n`是从开头的元素数目`array`到`startIndex`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个重载<xref:System.Array.FindLastIndex%2A>泛型方法。 创建一个字符串数组，其中包含 8 恐龙名称，其中 （位于位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、，它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从结束时，将每个元素传递给反过来遍历向后的数组`EndsWithSaurus`方法。 搜索将停止何时`EndsWithSaurus`方法将返回`true`位置 5 处的元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索位置 4 开始，一直向后到数组的开头的数组。 它查找位置 1 处的元素。 最后，<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的三个元素从位置 4 开始，向回查找 （即，元素 4、 3 和 2） 的范围。 因为在该范围内没有以"saurus"结尾的恐龙名称，则返回-1。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Array" /> 中包含指定元素个数、到指定索引结束的元素范围内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>是搜索处开始向后`startIndex`结束时间`startIndex`减去`count`加上 1，如果`count`大于 0。  
  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`逐个传递给<xref:System.Predicate%601>。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个重载<xref:System.Array.FindLastIndex%2A>泛型方法。 创建一个字符串数组，其中包含 8 恐龙名称，其中 （位于位置 1 和 5） 两个以"saurus"结尾。 该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、，它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从结束时，将每个元素传递给反过来遍历向后的数组`EndsWithSaurus`方法。 搜索将停止何时`EndsWithSaurus`方法将返回`true`位置 5 处的元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索位置 4 开始，一直向后到数组的开头的数组。 它查找位置 1 处的元素。 最后，<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的三个元素从位置 4 开始，向回查找 （即，元素 4、 3 和 2） 的范围。 因为在该范围内没有以"saurus"结尾的恐龙名称，则返回-1。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于零。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">从零开始的一维 <see cref="T:System.Array" />，要对其元素执行操作。</param>
        <param name="action">要对 <paramref name="array" /> 的每个元素执行的 <see cref="T:System.Action`1" />。</param>
        <summary>对指定数组的每个元素执行指定操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601>对象执行的操作方法的委托传递给它。  元素`array`逐个传递给<xref:System.Action%601>。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Array.ForEach%2A>整数数组中显示每个元素的平方。  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="action" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Collections.IEnumerator" /> 的 <see cref="T:System.Array" />。</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> 的一个 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic 中， C#]  
  
 `foreach` C# 语言的语句 (`for each` c + + 中`For Each`在 Visual Basic 中) 隐藏了枚举器的复杂性。 因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 <xref:System.Collections.IEnumerator.Reset%2A> 也会将枚举器放回此位置。  在此位置上，未定义 <xref:System.Collections.IEnumerator.Current%2A>。 因此，在读取 <xref:System.Collections.IEnumerator.MoveNext%2A> 的值之前，必须调用 <xref:System.Collections.IEnumerator.Current%2A> 将枚举器向前移动到集合的第一个元素。  
  
 在调用 <xref:System.Collections.IEnumerator.Current%2A> 或 <xref:System.Collections.IEnumerator.MoveNext%2A> 之前，<xref:System.Collections.IEnumerator.Reset%2A> 返回同一对象。 <xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.IEnumerator.Current%2A> 设置为下一个元素。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过集合，枚举器的末尾放置在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。 当枚举数位于此位置上，对后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。 若要再次将 <xref:System.Collections.IEnumerator.Current%2A> 设置为集合的第一个元素，可以调用 <xref:System.Collections.IEnumerator.Reset%2A> 并接着调用 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合保持不变，枚举数就保持有效。 如果对集合进行更改（如添加、修改或删除元素），则枚举数将失效且不可恢复，而且其行为是不确定的。  
  
 该枚举数不具有独占访问集合的权限；因此，枚举整个集合本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Array.GetEnumerator%2A>列出数组的元素。  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><see cref="T:System.Array" /> 的从零开始的维度，其长度需要确定。</param>
        <summary>获取一个 32 位整数，该整数表示 <see cref="T:System.Array" /> 的指定维中的元素数。</summary>
        <returns>一个 32 位整数，它表示指定维中的元素数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 举例<xref:System.Array.GetLength%2A>是`GetLength(0)`，其中返回的元素数中的第一个维度<xref:System.Array>。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Array.GetLength%2A>以显示两个具有不同秩的数组的维度。  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> 小于零。  
  
- 或 - 
 <paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><see cref="T:System.Array" /> 的从零开始的维度，其长度需要确定。</param>
        <summary>获取一个 64 位整数，该整数表示 <see cref="T:System.Array" /> 的指定维中的元素数。</summary>
        <returns>一个 64 位整数，它表示指定维中的元素数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 举例<xref:System.Array.GetLongLength%2A>是`GetLongLength(0)`，其中返回的元素数中的第一个维度<xref:System.Array>。  
  
 此方法为 o （1） 运算。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> 小于零。  
  
- 或 - 
 <paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">数组的从零开始的维度，其起始索引需要确定。</param>
        <summary>获取数组中指定维度第一个元素的索引。</summary>
        <returns>数组中指定维度第一个元素的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` 返回数组的第一个维的起始索引和`GetLowerBound(Rank - 1)`返回最后一个维度的数组的起始索引。  
  
 <xref:System.Array.GetLowerBound%2A>方法始终返回一个值，指示该数组的下限绑定的索引，即使数组为空。  
  
 请注意，尽管.NET Framework 中的大多数数组是从零开始 (即，<xref:System.Array.GetLowerBound%2A>方法返回一个数组的每个维度的零)，.NET Framework 支持不从零开始的数组。 可用于创建此类数组<xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29>方法，并且还可以从非托管代码返回。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法来显示一维和二维数组的界限并显示其数组元素的值。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> 小于零。  
  
- 或 - 
 <paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">数组的从零开始的维度，其上限需要确定。</param>
        <summary>获取数组中指定维度最后一个元素的索引。</summary>
        <returns>数组中指定维度最后一个元素的索引，或 -1（如果指定维度为空）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` 返回数组的第一个维度中的最后一个索引和`GetUpperBound(Rank - 1)`返回数组的最后一个维度的最后一个索引。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法来显示一维和二维数组的界限并显示其数组元素的值。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> 小于零。  
  
- 或 - 
 <paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Array" /> 中指定元素的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>获取一维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 32 位整数。</summary>
        <returns>一维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>并<xref:System.Array.GetUpperBound%2A>方法可以确定是否的值`index`超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 不是正好具有一个维度。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> 超出了当前 <see cref="T:System.Array" /> 的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">一个 32 位整数的一维数组，它表示指定要获取的 <see cref="T:System.Array" /> 元素的位置的索引。</param>
        <summary>获取多维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为一个 32 位整数数组。</summary>
        <returns>多维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的元素数`indices`中的维度数目必须相等<xref:System.Array>。 中的所有元素`indices`阵列必须共同指定所需元素的位置，在多维<xref:System.Array>。  
  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="indices" /> 中的任何元素都超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>获取一维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 64 位整数。</summary>
        <returns>一维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>并<xref:System.Array.GetUpperBound%2A>方法可以确定是否的值`index`超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 不是正好具有一个维度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 超出了当前 <see cref="T:System.Array" /> 的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">一个 64 位整数的一维数组，它表示指定要获取的 <see cref="T:System.Array" /> 元素的位置的索引。</param>
        <summary>获取多维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为一个 64 位整数数组。</summary>
        <returns>多维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的元素数`indices`中的维度数目必须相等<xref:System.Array>。 中的所有元素`indices`阵列必须共同指定所需元素的位置，在多维<xref:System.Array>。  
  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indices" /> 中的任何元素都超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <summary>获取二维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 32 位整数。</summary>
        <returns>二维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 不是正好具有两个维度。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <summary>获取二维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 64 位整数。</summary>
        <returns>二维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 不是正好具有两个维度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <param name="index3">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第三维索引。</param>
        <summary>获取三维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 32 位整数。</summary>
        <returns>三维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 不是正好具有三个维度。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <param name="index3">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第三维索引。</param>
        <summary>获取三维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 64 位整数。</summary>
        <returns>三维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 不是正好具有三个维度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在一个一维数组或该数组的一系列元素中搜索指定对象，并返回其首个匹配项的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维数组。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <summary>在一个一维数组中搜索指定对象，并返回其首个匹配项的索引。</summary>
        <returns>如果找到，则为 <paramref name="array" /> 中 <paramref name="value" /> 的第一个匹配项的索引；否则为该数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法搜索的一维 arrayfor 的所有元素`value`。 若要确定是否`value`中存在`array`，该方法通过调用每个元素执行相等比较`Equals`方法，直到它找到的匹配项。 这意味着，如果元素会替代<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，调用该重写。  
  
 由于大多数数组下限为零，此方法通常返回-1 如果`value`找不到。 在极少数情况下，它等于数组的下限<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) 和`value`找不到，此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF)。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 该示例将调用的以下三个重载<xref:System.Array.IndexOf%2A>方法以字符串数组中查找字符串的索引：  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>以确定第一次出现的字符串"the"中的字符串数组。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>以确定第一次出现的字符串"the"中的字符串数组的最后一个元素到第四个。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>以确定第一次出现的字符串"the"在字符串中数组从追踪到数组末尾的最后一个成功匹配的元素。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维数组。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">搜索的起始索引。 空数组中 0（零）为有效值。</param>
        <summary>在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。 该元素系列的范围为从指定索引到该数组结尾。</summary>
        <returns>如果在从 <paramref name="startIndex" /> 到最后一个元素的 <paramref name="array" /> 中的元素范围中找到了 <paramref name="value" /> 的第一个匹配项的索引，则为该索引；否则为数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法搜索索引处的元素从一维数组`startIndex`到最后一个元素。 若要确定是否`value`中存在`array`，该方法通过调用执行相等比较`Equals`的每个元素，直到它找到的匹配项的方法。 这意味着，如果元素会替代<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，调用该重写。  
  
 由于大多数数组下限为零，此方法通常返回-1 如果`value`找不到。 在极少数情况下，它等于数组的下限<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) 和`value`找不到，此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF)。  
  
 如果`startIndex`等于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法将返回-1。 如果`startIndex`大于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法将引发<xref:System.ArgumentOutOfRangeException>。  
  
 此方法为 O (`n`) 操作，其中`n`是中的元素数目`startIndex`到末尾`array`。  
  
   
  
## Examples  
 该示例将调用的以下三个重载<xref:System.Array.IndexOf%2A>方法以字符串数组中查找字符串的索引：  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>以确定第一次出现的字符串"the"中的字符串数组。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>以确定第一次出现的字符串"the"中的字符串数组的最后一个元素到第四个。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>以确定第一次出现的字符串"the"在字符串中数组从追踪到数组末尾的最后一个成功匹配的元素。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维数组。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">搜索的起始索引。 空数组中 0（零）为有效值。</param>
        <param name="count">要搜索的元素数。</param>
        <summary>在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。 该元素系列的范围从指定数量的元素的指定索引开始。</summary>
        <returns>如果在从索引 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> - 1 的 <paramref name="array" /> 中找到了 <paramref name="value" /> 的第一个匹配项的索引，则为该索引；否则为该数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法搜索的元素的一维 arrayfrom`startIndex`到`startIndex`加上`count`减 1，如果`count`大于 0。 若要确定是否`value`中存在`array`，该方法通过调用执行相等比较`Equals`的每个元素，直到它找到的匹配项的方法。 这意味着，如果元素会替代<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法，调用该重写。  
  
 Becausemost 数组具有下限为零，则此方法通常返回-1 时`value`找不到。 在极少数情况下，它等于数组的下限<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) 和`value`找不到，此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF)。  
  
 如果`startindex`等于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法将返回-1。 如果`startIndex`大于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法将引发<xref:System.ArgumentOutOfRangeException>。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 该示例将调用的以下三个重载<xref:System.Array.IndexOf%2A>方法以字符串数组中查找字符串的索引：  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>以确定第一次出现的字符串"the"中的字符串数组。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>以确定第一次出现的字符串"the"中的字符串数组的最后一个元素到第四个。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>以确定第一次出现的字符串"the"在字符串中数组从追踪到数组末尾的最后一个成功匹配的元素。 若要确定其值的`count`参数，它从起始的索引数组的上限数中减去，并添加一个。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于零。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维数组。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <summary>在一个一维数组中搜索指定对象，并返回其首个匹配项的索引。</summary>
        <returns>如果在整个 <paramref name="array" /> 中找到 <paramref name="value" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法搜索的一维数组的所有元素`value`。 若要确定是否`value`中存在`array`，该方法通过调用执行相等比较`T.Equals`上的每个元素的方法。 这意味着，如果`T`重写<xref:System.Object.Equals%2A>方法，调用该重写。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例演示的所有三个泛型重载<xref:System.Array.IndexOf%2A>方法。 创建一个字符串数组，其中有两次，出现在索引位置 0 和 5 的索引位置的一项。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从一开始，数组中搜索并查找字符串的第一个匹配项。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载用于搜索的索引位置 3 开头的数组，一直到数组末尾并查找字符串的第二个匹配项。 最后，<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的两个条目，开始的索引位置两个范围，则返回-1，因为没有在该范围内搜索字符串的实例。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维数组。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">从零开始的搜索的起始索引。 空数组中 0（零）为有效值。</param>
        <summary>在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。 该元素系列的范围为从指定索引到该数组结尾。</summary>
        <returns>如果在 <paramref name="value" /> 中从 <paramref name="array" /> 到最后一个元素这部分元素中找到 <paramref name="startIndex" /> 的匹配项，则为第一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法处的元素从一维数组中搜索`startIndex`到数组末尾。 若要确定是否`value`中存在`array`，该方法通过调用执行相等比较`T.Equals`上的每个元素的方法。 这意味着，如果`T`重写<xref:System.Object.Equals%2A>方法，调用该重写。  
  
 如果`startIndex`等于<xref:System.Array.Length%2A>，该方法将返回-1.If`startIndex`大于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法将引发<xref:System.ArgumentOutOfRangeException>。  
  
 此方法为 O (`n`) 操作，其中`n`是中的元素数目`startIndex`到末尾`array`。  
  
   
  
## Examples  
 下面的示例演示的所有三个泛型重载<xref:System.Array.IndexOf%2A>方法。 创建一个字符串数组，其中有两次，出现在索引位置 0 和 5 的索引位置的一项。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从一开始，数组中搜索并查找字符串的第一个匹配项。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载用于搜索的索引位置 3 开头的数组，一直到数组末尾并查找字符串的第二个匹配项。 最后，<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的两个条目，开始的索引位置两个范围，则返回-1，因为没有在该范围内搜索字符串的实例。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维数组。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">从零开始的搜索的起始索引。 空数组中 0（零）为有效值。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。 该元素系列的范围从指定数量的元素的指定索引开始。</summary>
        <returns>如果在从 <paramref name="count" /> 开始并且包含 <paramref name="startIndex" /> 中指定元素数量的 <paramref name="array" /> 元素范围中找到了 <paramref name="value" /> 第一个匹配项从零开始的索引，则为该索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法 searchesthe 元素中的一维数组`startIndex`到`startIndex`加上`count`减 1，如果`count`大于 0。 若要确定是否`value`中存在`array`，该方法通过调用执行相等比较`T.Equals`上的每个元素的方法。 这意味着，如果`T`重写<xref:System.Object.Equals%2A>方法，调用该重写。  
  
 如果`startIndex`等于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法将返回-1。  如果`startIndex`大于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法将引发<xref:System.ArgumentOutOfRangeException>。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 下面的示例演示的所有三个泛型重载<xref:System.Array.IndexOf%2A>方法。 创建一个字符串数组，其中有两次，出现在索引位置 0 和 5 的索引位置的一项。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从一开始，数组中搜索并查找字符串的第一个匹配项。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载用于搜索的索引位置 3 开头的数组，一直到数组末尾并查找字符串的第二个匹配项。 最后，<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的两个条目，开始的索引位置两个范围，则返回-1，因为没有在该范围内搜索字符串的实例。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于零。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通过调用值类型的默认构造函数，初始化值类型 <see cref="T:System.Array" /> 的每一个元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法旨在帮助编译器支持值类型数组;大多数用户不需要使用此方法。 它必须不能对引用类型数组。  
  
 如果<xref:System.Array>不是值类型<xref:System.Array>或值类型不具有默认构造函数，如果<xref:System.Array>则不会修改。  
  
 值类型<xref:System.Array>可以具有任何更低绑定和任意数量的维度。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>。  
  
> [!CAUTION]
>  可以仅在具有构造函数; 的值类型上使用此方法但是，值类型的本机 C# 没有构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Array" /> 是否具有固定大小。</summary>
        <value>对于所有数组，此属性始终为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 实现<xref:System.Array.IsFixedSize%2A>属性因为它必需的<xref:System.Collections.IList?displayProperty=nameWithType>接口。  
  
 具有固定大小的数组不允许添加或删除的元素，该数组创建，但它允许修改现有元素后。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Array" /> 是否为只读。</summary>
        <value>对于所有数组，此属性始终为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 实现<xref:System.Array.IsReadOnly%2A>属性因为它必需的<xref:System.Collections.IList?displayProperty=nameWithType>接口。 之后该数组创建数组，它是只读的不允许添加、 移除或修改元素。  
  
 如果需要只读集合，使用<xref:System.Collections>类，该类实现<xref:System.Collections.IList?displayProperty=nameWithType>接口。  
  
 如果强制转换或转换到的数组<xref:System.Collections.IList>接口对象<xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType>属性返回`false`。 但是，如果强制转换或转换到的数组<xref:System.Collections.Generic.IList%601>接口，`IsReadOnly`属性返回`true`。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否同步对 <see cref="T:System.Array" /> 的访问（线程安全）。</summary>
        <value>对于所有数组，此属性始终为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> 实现<xref:System.Array.IsSynchronized%2A>属性因为它必需的<xref:System.Collections.ICollection?displayProperty=nameWithType>接口。  
  
 .NET framework 类基于<xref:System.Array>提供集合使用其自己的同步的版本<xref:System.Array.SyncRoot%2A>属性。  
  
 使用数组的类还可实现其自己的同步使用<xref:System.Array.SyncRoot%2A>属性。 同步代码必须在执行操作`SyncRoot`的不是直接对集合的集合。 这样可确保对从其他对象派生的集合正确地执行操作。 具体而言，它维护与其他线程可能同时修改集合的正确同步。 请注意，某些实现的<xref:System.Array.SyncRoot%2A>可能会返回<xref:System.Array>本身。  
  
 枚举整个集合本质上不是线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的代码示例演示如何通过在整个枚举期间锁定数组<xref:System.Array.SyncRoot%2A>属性。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一维 <see cref="T:System.Array" /> 或 <see cref="T:System.Array" /> 的一部分中某个值的最后一个匹配项的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <summary>在整个一维 <see cref="T:System.Array" /> 中搜索指定的对象，并返回最后一个匹配项的索引。</summary>
        <returns>如果在整个 <paramref name="array" /> 中找到 <paramref name="value" /> 的最后一个匹配项的索引，则为该索引；否则为该数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一维<xref:System.Array>向后搜索的最后一个元素开始，结束时间的第一个元素。  
  
 对元素进行比较指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果元素类型是内部的 （用户定义） 类型，`Equals`使用该类型的实现。  
  
 由于大多数数组将下限为零，此方法通常将返回-1 时`value`找不到。 在极少数情况下，它等于数组的下限<xref:System.Int32.MinValue?displayProperty=nameWithType>并`value`未找到，则此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>，这是`System.Int32.MinValue - 1`。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
 在.NET Framework 2.0 版中，此方法使用<xref:System.Object.Equals%2A>并<xref:System.IComparable.CompareTo%2A>方法的<xref:System.Array>来确定是否<xref:System.Object>指定的`value`存在的参数。 在.NET Framework 的早期版本中，通过进行此判断<xref:System.Object.Equals%2A>并<xref:System.IComparable.CompareTo%2A>方法的`value`<xref:System.Object>本身。  
  
 <xref:System.IComparable.CompareTo%2A> 方法的`item`参数在集合中的对象。  
  
   
  
## Examples  
 下面的代码示例演示如何确定数组中指定的元素的最后一个匹配项的索引。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">向后搜索的起始索引。</param>
        <summary>搜索指定的对象，并返回一维 <see cref="T:System.Array" /> 中从第一个元素到指定索引的元素范围内最后一个匹配项的索引。</summary>
        <returns>如果在 <paramref name="array" /> 中从第一个元素到 <paramref name="startIndex" /> 的元素范围内找到了 <paramref name="value" /> 的最后一个匹配项的索引，则为该索引；否则为该数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一维<xref:System.Array>是搜索处开始向后`startIndex`和结束时间的第一个元素。  
  
 对元素进行比较指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果元素类型是内部的 （用户定义） 类型，`Equals`使用该类型的实现。  
  
 由于大多数数组将下限为零，此方法通常将返回-1 时`value`找不到。 在极少数情况下，它等于数组的下限<xref:System.Int32.MinValue?displayProperty=nameWithType>并`value`未找到，则此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>，这是`System.Int32.MinValue - 1`。  
  
 此方法为 O (`n`) 操作，其中`n`是从开头的元素数目`array`到`startIndex`。  
  
 在.NET Framework 2.0 版中，此方法使用<xref:System.Object.Equals%2A>并<xref:System.IComparable.CompareTo%2A>方法的<xref:System.Array>来确定是否<xref:System.Object>指定的`value`存在的参数。 在.NET Framework 的早期版本中，通过进行此判断<xref:System.Object.Equals%2A>并<xref:System.IComparable.CompareTo%2A>方法的`value`<xref:System.Object>本身。  
  
   
  
## Examples  
 下面的代码示例演示如何确定数组中指定的元素的最后一个匹配项的索引。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">向后搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的对象并返回一维 <see cref="T:System.Array" /> 中包含指定数目元素且在指定索引处结尾的元素范围内的最后一个匹配项的索引。</summary>
        <returns>如果在包含 <paramref name="count" /> 中指定的元素数并且在 <paramref name="startIndex" /> 结尾的 <paramref name="array" /> 中的元素范围内找到了 <paramref name="value" /> 的最后一个匹配项的索引，则为该索引；否则为该数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一维<xref:System.Array>是搜索处开始向后`startIndex`结束时间`startIndex`减去`count`加上 1，如果`count`大于 0。  
  
 对元素进行比较指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果元素类型是内部的 （用户定义） 类型，`Equals`使用该类型的实现。  
  
 由于大多数数组将下限为零，此方法通常将返回-1 时`value`找不到。 在极少数情况下，它等于数组的下限<xref:System.Int32.MinValue?displayProperty=nameWithType>并`value`未找到，则此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>，这是`System.Int32.MinValue - 1`。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
 在.NET Framework 2.0 版中，此方法使用<xref:System.Object.Equals%2A>并<xref:System.IComparable.CompareTo%2A>方法的<xref:System.Array>来确定是否<xref:System.Object>指定的`value`存在的参数。 在.NET Framework 的早期版本中，通过进行此判断<xref:System.Object.Equals%2A>并<xref:System.IComparable.CompareTo%2A>方法的`value`<xref:System.Object>本身。  
  
   
  
## Examples  
 下面的代码示例演示如何确定数组中指定的元素的最后一个匹配项的索引。 请注意，<xref:System.Array.LastIndexOf%2A>方法是向后搜索; 因此，`count`必须小于或等于 (`startIndex`数组加 1 的下限减)。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于零。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <summary>搜索指定的对象，并返回整个 <see cref="T:System.Array" /> 中最后一个匹配项的索引。</summary>
        <returns>如果在整个 <paramref name="array" /> 中找到 <paramref name="value" /> 的最后一个匹配项从零开始的索引，则为该索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>向后搜索的最后一个元素开始，结束时间的第一个元素。  
  
 对元素进行比较指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果元素类型是内部的 （用户定义） 类型，`Equals`使用该类型的实现。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个泛型重载<xref:System.Array.LastIndexOf%2A>方法。 创建一个字符串数组，其中有两次，出现在索引位置 0 和 5 的索引位置的一项。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从结束时，整个数组中搜索并查找字符串的第二个匹配项。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载用于搜索数组索引位置 3 的向后开始，一直到该数组的开头，并查找字符串的第一个匹配项。 最后，<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置 4 开始，往前的四个条目范围 （即，它搜索在位置 4、 3、 2 和 1 项）; 此搜索将返回-1，因为没有搜索的实例在该范围内的字符串。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <summary>搜索指定的对象并返回 <see cref="T:System.Array" /> 中从第一个元素到指定索引的元素范围内最后一个匹配项的索引。</summary>
        <returns>如果在 <paramref name="array" /> 中从第一个元素到 <paramref name="startIndex" /> 的元素范围中找到了该 <paramref name="value" /> 最后一个匹配项从零开始的索引，则为该索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>是搜索处开始向后`startIndex`和结束时间的第一个元素。  
  
 对元素进行比较指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果元素类型是内部的 （用户定义） 类型，`Equals`使用该类型的实现。  
  
 此方法为 O (`n`) 操作，其中`n`是从开头的元素数目`array`到`startIndex`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个泛型重载<xref:System.Array.LastIndexOf%2A>方法。 创建一个字符串数组，其中有两次，出现在索引位置 0 和 5 的索引位置的一项。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从结束时，整个数组中搜索并查找字符串的第二个匹配项。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载用于搜索数组索引位置 3 的向后开始，一直到该数组的开头，并查找字符串的第一个匹配项。 最后，<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置 4 开始，往前的四个条目范围 （即，它搜索在位置 4、 3、 2 和 1 项）; 此搜索将返回-1，因为没有搜索的实例在该范围内的字符串。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的对象，并返回 <see cref="T:System.Array" /> 中包含指定数目元素并在指定索引处结尾的元素范围内的最后一个匹配项的索引。</summary>
        <returns>如果在 <paramref name="startIndex" /> 中找到了包含 <paramref name="count" /> 中指定元素数并且到 <paramref name="array" /> 结尾的元素范围内的 <paramref name="value" /> 的最后一个匹配项的从零开始的索引，则为该索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>是搜索处开始向后`startIndex`结束时间`startIndex`减去`count`加上 1，如果`count`大于 0。  
  
 对元素进行比较指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。 如果元素类型是内部的 （用户定义） 类型，`Equals`使用该类型的实现。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 下面的代码示例演示的所有三个泛型重载<xref:System.Array.LastIndexOf%2A>方法。 创建一个字符串数组，其中有两次，出现在索引位置 0 和 5 的索引位置的一项。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从结束时，整个数组中搜索并查找字符串的第二个匹配项。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载用于搜索数组索引位置 3 的向后开始，一直到该数组的开头，并查找字符串的第一个匹配项。 最后，<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置 4 开始，往前的四个条目范围 （即，它搜索在位置 4、 3、 2 和 1 项）; 此搜索将返回-1，因为没有搜索的实例在该范围内的字符串。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于零。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Array" /> 的所有维度中的元素总数。</summary>
        <value><see cref="T:System.Array" /> 的所有维度中的元素总数；如果数组中无元素，则为零。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Array.Length%2A>属性来获取数组的元素总数。 它还使用<xref:System.Array.GetUpperBound%2A>方法，以确定每个维度的多维数组中的元素数。  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">数组是多维数组并且包含多个 <see cref="F:System.Int32.MaxValue" /> 元素。</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 64 位整数，该整数表示 <see cref="T:System.Array" /> 的所有维数中元素的总数。</summary>
        <value>一个 64 位整数，表示 <see cref="T:System.Array" /> 的所有维数中元素的总数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Array" /> 的秩（维数）。 例如，一维数组返回 1，二维数组返回 2，依次类推。</summary>
        <value><see cref="T:System.Array" /> 的秩（维数）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，Visual Basic 代码  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 和 C# 代码  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 创建使用三个维度的数组<xref:System.Array.Rank%2A>属性值为 3。  
  
 交错的数组 （数组的数组） 是一维数组中;值及其<xref:System.Array.Rank%2A>属性为 1。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的示例初始化一个一维数组、 一个二维数组和交错的数组，并检索<xref:System.Array.Rank%2A>每个属性。  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize :  * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要调整大小的一维数组，该数组从零开始；如果为 <see langword="null" />，则新建具有指定大小的数组。</param>
        <param name="newSize">新数组的大小。</param>
        <summary>将一维数组的元素数更改为指定的新大小。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法分配指定大小的新数组，从旧的数组的元素复制到新，然后使用新替换旧的数组。 `array` 必须是一个一维数组。  
  
 如果`array`是`null`，此方法具有指定大小创建一个新数组。  
  
 如果`newSize`大于<xref:System.Array.Length%2A>旧数组分配一个新数组和所有元素都复制到新旧的数组。  如果`newSize`是不会早于<xref:System.Array.Length%2A>旧数组分配一个新数组和元素从旧数组复制到新直至充满新; 旧数组中的元素的其余部分将被忽略。  如果`newSize`等同于<xref:System.Array.Length%2A>的旧的数组，此方法不执行任何操作。  
  
 此方法为 O (`n`) 操作，其中`n`是`newSize`。  
  
 <xref:System.Array.Resize%2A>方法调整大小的一维数组。 <xref:System.Array>类不包括调整多维数组的大小的方法。 若要执行此操作，必须提供你自己的代码或第三方库中调用专用方法。 以下代码演示了一种可能实现的方法的调整大小的数组*n*维度。  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 下面的示例演示如何重设大小会影响数组。  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newSize" /> 小于零。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>反转一维 <see cref="T:System.Array" /> 或部分 <see cref="T:System.Array" /> 中元素的顺序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">要反转的一维 <see cref="T:System.Array" />。</param>
        <summary>反转整个一维 <see cref="T:System.Array" /> 中元素的顺序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法，处的元素后`myArray[i]`，其中`i`是数组中的任何索引，将移至`myArray[j]`，其中`j`等于`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
 如下面的示例所示，<xref:System.Array.Reverse%2A>方法可用于反向交错的数组。 它将每个月的当前区域性的日历中的当前年份初始化交错的数组包含一个元素。 每个元素包含与该月有天的所有元素的数组。 该示例显示的内容的数组，调用<xref:System.Array.Reverse%2A>方法，然后显示反向数组的内容。  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 下面的代码示例演示如何反向中值的排序<xref:System.Array>。  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要反转的一维 <see cref="T:System.Array" />。</param>
        <param name="index">要反转的部分的起始索引。</param>
        <param name="length">要反转的部分中的元素数。</param>
        <summary>反转一维 <see cref="T:System.Array" /> 中某部分元素的元素顺序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法，处的元素后`myArray[i]`，其中`i`是数组中的任何索引，将移至`myArray[j]`，其中`j`等于`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`。  
  
 <xref:System.Array.Reverse%2A>方法可用于反向交错的数组。  
  
 此方法为 O (`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何反向中的元素范围内的值的排序<xref:System.Array>。  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将当前 <see cref="T:System.Array" /> 中的指定元素设置为指定值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>将值设置为一维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>并<xref:System.Array.GetUpperBound%2A>方法可以确定是否的值`index`超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型的数组的元素，该元素的所有字段都初始化为零。 元素的值不是空引用，并不能找到通过搜索空的引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 不是正好具有一个维度。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> 超出了当前 <see cref="T:System.Array" /> 的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="indices">32 位整数的一维数组，它表示用于指定要设置的元素的位置的索引。</param>
        <summary>将值设置为多维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为一个 32 位整数数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的元素数`indices`中的维度数目必须相等<xref:System.Array>。 中的所有元素`indices`阵列必须共同指定所需元素的位置，在多维<xref:System.Array>。  
  
 <xref:System.Array.GetLowerBound%2A>并<xref:System.Array.GetUpperBound%2A>方法可以确定是否有任何中的值`indices`数组是超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型的数组的元素，该元素的所有字段都初始化为零。 元素的值不是空引用，并不能找到通过搜索空的引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="indices" /> 中的任何元素都超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>将值设置为一维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>并<xref:System.Array.GetUpperBound%2A>方法可以确定是否的值`index`超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型的数组的元素，该元素的所有字段都初始化为零。 元素的值不是空引用，并不能找到通过搜索空的引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 不是正好具有一个维度。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 超出了当前 <see cref="T:System.Array" /> 的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="indices">64 位整数的一维数组，它表示用于指定要设置的元素的位置的索引。</param>
        <summary>将值设置为多维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为一个 64 位整数数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的元素数`indices`中的维度数目必须相等<xref:System.Array>。 中的所有元素`indices`阵列必须共同指定所需元素的位置，在多维<xref:System.Array>。  
  
 <xref:System.Array.GetLowerBound%2A>并<xref:System.Array.GetUpperBound%2A>方法可以确定是否有任何中的值`indices`数组是超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型的数组的元素，该元素的所有字段都初始化为零。 元素的值不是空引用，并不能找到通过搜索空的引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indices" /> 中的任何元素都超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index1">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <summary>将某值设置给二维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型的数组的元素，该元素的所有字段都初始化为零。 元素的值不是空引用，并不能找到通过搜索空的引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 不是正好具有两个维度。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index1">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <summary>将某值设置给二维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型的数组的元素，该元素的所有字段都初始化为零。 元素的值不是空引用，并不能找到通过搜索空的引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 不是正好具有两个维度。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index1">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <param name="index3">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第三维索引。</param>
        <summary>将值设置为三维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型的数组的元素，该元素的所有字段都初始化为零。 元素的值不是空引用，并不能找到通过搜索空的引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 不是正好具有三个维度。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index1">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <param name="index3">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第三维索引。</param>
        <summary>将值设置为三维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 有关转换的详细信息，请参阅<xref:System.Convert>。  
  
 此方法为 o （1） 运算。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型的数组的元素，该元素的所有字段都初始化为零。 元素的值不是空引用，并不能找到通过搜索空的引用。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取一维或多维数组中的特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 不是正好具有三个维度。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出了当前 <see cref="T:System.Array" /> 的相应维度的有效索引范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>对一维数组中的元素进行排序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一维 <see cref="T:System.Array" />。</param>
        <summary>使用 <see cref="T:System.Array" /> 中每个元素的 <see cref="T:System.IComparable" /> 实现，对整个一维 <see cref="T:System.Array" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个元素`array`必须实现<xref:System.IComparable>接口，才能与每个其他元素中的比较的`array`。  
  
 如果排序未成功完成，则结果不确定。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示如何对中的值进行排序<xref:System.Array>使用默认比较器和将反转排序顺序的自定义比较器。 请注意，结果可能因当前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">一维 <see cref="T:System.Array" />，其中包含要排序的关键字。</param>
        <param name="items">一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /><see cref="T:System.Array" /> 中每个关键字对应的项。  
  
- 或 - 
 如果为 <see langword="null" />，则只对 <paramref name="keys" /><see cref="T:System.Array" /> 进行排序。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.IComparable" /> 实现，对两个一维 <see cref="T:System.Array" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位一个键`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>按照中的对应键的排列方式排序`keys` <xref:System.Array>。  
  
 在每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable>接口，才能与其他任何关键字进行比较。  
  
 如果有更多的项比密钥，但不是进行排序有没有对应的键的项，您可以进行排序。 如果以上的项; 更多密钥不能进行排序这样做将引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成，则结果不确定。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`keys`。  
  
   
  
## Examples  
 下面的示例演示如何对两个关联的数组，其中第一个数组包含关键字，第二个数组包含的值进行排序。 完成排序使用的默认比较器和将反转排序顺序的自定义比较器。 请注意，结果可能因当前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。  
  
- 或 - 
<paramref name="items" /><see cref="T:System.Array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一维数组。</param>
        <param name="comparer">比较元素时要使用的实现。  
  
- 或 - 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定的 <see cref="T:System.Collections.IComparer" />，对一维 <see cref="T:System.Array" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`是`null`，每个元素的`array`必须实现<xref:System.IComparable>接口，才能与每个其他元素中的比较的`array`。  
  
 如果排序未成功完成，则结果不确定。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
 .NET Framework 包括预定义<xref:System.Collections.IComparer>下表中列出的实现。  
  
|实现|描述|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比较任何两个对象，但执行不区分大小写的字符串比较。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用当前区域性的排序约定比较任何两个对象。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|使用固定区域性的排序约定比较任何两个对象。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|比较两个对象类型的`T`使用该类型的默认排序顺序。|  
  
 此外可以通过提供你自己的实例来支持自定义比较<xref:System.Collections.IComparer>实现`comparer`参数。 该示例通过定义来执行此`ReverseComparer`反转的默认排序顺序的类类型的实例和执行不区分大小写的字符串比较。  
  
   
  
## Examples  
 下面的示例对使用默认比较器字符串 arrayby 中的值进行排序。 它还定义一个自定义<xref:System.Collections.IComparer>实现名为`ReverseComparer`的执行不区分大小写的字符串比较时反转对象的默认排序顺序。 请注意，输出可能会有所不同，具体取决于当前区域性。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 和更早版本使用仅快速排序算法。 快速排序标识无效的比较器在某些情况下，在排序操作将引发<see cref="T:System.IndexOutOfRangeException" />异常，并且会引发<see cref="T:System.ArgumentException" />给调用方的异常。 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，就可以，以前排序操作引发了<see cref="T:System.ArgumentException" />不会引发异常，因为插入排序和 heapsort 算法不检测无效的比较器。 大多数情况下，这适用于具有少于 16 个元素的数组。</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">一维 <see cref="T:System.Array" />，其中包含要排序的关键字。</param>
        <param name="items">一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /><see cref="T:System.Array" /> 中每个关键字对应的项。  
  
- 或 - 
 如果为 <see langword="null" />，则只对 <paramref name="keys" /><see cref="T:System.Array" /> 进行排序。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
- 或 - 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Collections.IComparer" />，对两个一维 <see cref="T:System.Array" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位一个键`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>按照中的对应键的排列方式排序`keys` <xref:System.Array>。  
  
 如果`comparer`是`null`，则每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable>接口，才能与其他任何关键字进行比较。  
  
 如果有更多的项比密钥，但不是进行排序有没有对应的键的项，您可以进行排序。 如果以上的项; 更多密钥不能进行排序这样做将引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成，则结果不确定。  
  
 .NET Framework 包括预定义<xref:System.Collections.IComparer>下表中列出的实现。  
  
|实现|描述|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比较任何两个对象，但执行不区分大小写的字符串比较。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用当前区域性的排序约定比较任何两个对象。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|使用固定区域性的排序约定比较任何两个对象。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|比较两个对象类型的`T`使用该类型的默认排序顺序。|  
  
 此外可以通过提供你自己的实例来支持自定义比较<xref:System.Collections.IComparer>实现`comparer`参数。 该示例通过定义来执行此<xref:System.Collections.IComparer>实现的操作将默认的排序顺序和执行不区分大小写的字符串比较。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`keys`。  
  
   
  
## Examples  
 下面的示例演示如何对两个关联的数组，其中第一个数组包含关键字，第二个数组包含的值进行排序。 完成排序使用的默认比较器和将反转排序顺序的自定义比较器。 请注意，结果可能因当前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。  
  
- 或 - 
<paramref name="items" /><see cref="T:System.Array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  
  
- 或 - 
<paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 和更早版本使用仅快速排序算法。 快速排序标识无效的比较器在某些情况下，在排序操作将引发<see cref="T:System.IndexOutOfRangeException" />异常，并且会引发<see cref="T:System.ArgumentException" />给调用方的异常。 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，可能的排序操作该 previouslythrew<see cref="T:System.ArgumentException" />不会引发异常，因为插入排序和 heapsort 算法不检测无效的比较器。 大多数情况下，这适用于具有少于 16 个元素的数组。</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一维 <see cref="T:System.Array" />。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <summary>使用 <see cref="T:System.Array" /> 中每个元素的 <see cref="T:System.IComparable" /> 实现，对一维 <see cref="T:System.Array" /> 中的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的元素指定的范围内的每个元素`array`必须实现<xref:System.IComparable>接口，才能与每个其他元素中的比较的`array`。  
  
 如果排序未成功完成，则结果不确定。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何对中的值进行排序<xref:System.Array>使用默认比较器和将反转排序顺序的自定义比较器。 请注意，结果可能因当前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">一维 <see cref="T:System.Array" />，其中包含要排序的关键字。</param>
        <param name="items">一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /><see cref="T:System.Array" /> 中每个关键字对应的项。  
  
- 或 - 
 如果为 <see langword="null" />，则只对 <paramref name="keys" /><see cref="T:System.Array" /> 进行排序。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.IComparable" /> 实现，对两个一维 <see cref="T:System.Array" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位一个键`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>按照中的对应键的排列方式排序`keys` <xref:System.Array>。  
  
 中的元素指定的范围内的每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable>接口，才能与其他任何关键字进行比较。  
  
 如果有更多的项比密钥，但不是进行排序有没有对应的键的项，您可以进行排序。 如果以上的项; 更多密钥不能进行排序这样做将引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成，则结果不确定。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何对两个关联的数组，其中第一个数组包含关键字，第二个数组包含的值进行排序。 完成排序使用的默认比较器和将反转排序顺序的自定义比较器。 请注意，结果可能因当前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。  
  
- 或 - 
<paramref name="items" /><see cref="T:System.Array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  
  
- 或 - 
 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。  
  
- 或 - 
 <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一维 <see cref="T:System.Array" />。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
- 或 - 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定的 <see cref="T:System.Collections.IComparer" />，对一维 <see cref="T:System.Array" /> 中的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`是`null`，每个元素中的元素指定的范围内`array`必须实现<xref:System.IComparable>接口，才能与每个其他元素中的比较的`array`。  
  
 如果排序未成功完成，则结果不确定。  
  
 .NET Framework 包括预定义<xref:System.Collections.IComparer>下表中列出的实现。  
  
|实现|描述|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比较任何两个对象，但执行不区分大小写的字符串比较。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用当前区域性的排序约定比较任何两个对象。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|使用固定区域性的排序约定比较任何两个对象。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|比较两个对象类型的`T`使用该类型的默认排序顺序。|  
  
 此外可以通过提供你自己的实例来支持自定义比较<xref:System.Collections.IComparer>实现`comparer`参数。 该示例通过定义来执行此`ReverseComparer`反转的默认排序顺序的类类型的实例和执行不区分大小写的字符串比较。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何对中的值进行排序<xref:System.Array>使用默认比较器和将反转排序顺序的自定义比较器。 请注意，结果可能因当前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  
  
- 或 - 
<paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 和更早版本使用仅快速排序算法。 快速排序标识无效的比较器在某些情况下，在排序操作将引发<see cref="T:System.IndexOutOfRangeException" />异常，并且会引发<see cref="T:System.ArgumentException" />给调用方的异常。 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，就可以，以前排序操作引发了<see cref="T:System.ArgumentException" />不会引发异常，因为插入排序和 heapsort 算法不检测无效的比较器。 大多数情况下，这适用于具有少于 16 个元素的数组。</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">一维 <see cref="T:System.Array" />，其中包含要排序的关键字。</param>
        <param name="items">一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /><see cref="T:System.Array" /> 中每个关键字对应的项。  
  
- 或 - 
 如果为 <see langword="null" />，则只对 <paramref name="keys" /><see cref="T:System.Array" /> 进行排序。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
- 或 - 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Collections.IComparer" />，对两个一维 <see cref="T:System.Array" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位一个键`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>按照中的对应键的排列方式排序`keys` <xref:System.Array>。  
  
 如果`comparer`是`null`，指定范围中的元素内的每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable>接口，才能与其他任何关键字进行比较。  
  
 如果有更多的项比密钥，但不是进行排序有没有对应的键的项，您可以进行排序。 如果以上的项; 更多密钥不能进行排序这样做将引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成，则结果不确定。  
  
 .NET Framework 包括预定义<xref:System.Collections.IComparer>下表中列出的实现。  
  
|实现|描述|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比较任何两个对象，但执行不区分大小写的字符串比较。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用当前区域性的排序约定比较任何两个对象。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|使用固定区域性的排序约定比较任何两个对象。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|比较两个对象类型的`T`使用该类型的默认排序顺序。|  
  
 此外可以通过提供你自己的实例来支持自定义比较<xref:System.Collections.IComparer>实现`comparer`参数。 该示例通过定义一个自定义执行此<xref:System.Collections.IComparer>实现的操作将默认的排序顺序和执行不区分大小写的字符串比较。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何对两个关联的数组，其中第一个数组包含关键字，第二个数组包含的值进行排序。 完成排序使用的默认比较器和将反转排序顺序的自定义比较器。 请注意，结果可能因当前<xref:System.Globalization.CultureInfo>。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。  
  
- 或 - 
<paramref name="items" /><see cref="T:System.Array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。  
  
- 或 - 
 <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  
  
- 或 - 
 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。  
  
- 或 - 
 <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。  
  
- 或 - 
<paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 和更早版本使用仅快速排序算法。 快速排序标识无效的比较器在某些情况下，在排序操作将引发<see cref="T:System.IndexOutOfRangeException" />异常，并且会引发<see cref="T:System.ArgumentException" />给调用方的异常。 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，就可以，以前排序操作引发了<see cref="T:System.ArgumentException" />不会引发异常，因为插入排序和 heapsort 算法不检测无效的比较器。 大多数情况下，这适用于具有少于 16 个元素的数组。</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要排序的从零开始的一维 <see cref="T:System.Array" />。</param>
        <summary>使用 <see cref="T:System.Array" /> 中每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现，对整个 <see cref="T:System.Array" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个元素`array`必须实现<xref:System.IComparable%601>泛型接口，才能与每个其他元素中的比较的`array`。  
  
 如果排序未成功完成，则结果不确定。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>泛型方法重载和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>泛型方法重载。 创建一个字符串数组，顺序不分先后。  
  
 数组为显示、 已排序，并再次显示。  
  
> [!NOTE]
>  对调用<xref:System.Array.Sort%2A>和<xref:System.Array.BinarySearch%2A>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。 如果您使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，可以看到泛型方法正被调用。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>然后使用泛型方法重载来搜索两个字符串，其中一个脚本并不在数组，另一个是。 数组和返回值的<xref:System.Array.BinarySearch%2A>方法传递给`ShowWhere`泛型方法，如果找到该字符串，否则元素的搜索字符串将介于在数组中显示的索引值。 索引为负，如果字符串不是 n 数组，因此`ShowWhere`方法采用按位求补 (~ 运算符在 C# 和 Visual c + +，`Xor`在 Visual Basic 中的为-1) 若要获取大于搜索 stri 列表中的第一个元素的索引ng。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要排序的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="comparer">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</param>
        <summary>使用指定的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，对 <see cref="T:System.Array" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`是`null`，每个元素的`array`必须实现<xref:System.IComparable%601>泛型接口，才能与每个其他元素中的比较的`array`。  
  
 如果排序未成功完成，则结果不确定。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载。  
  
 代码示例定义一个名为`ReverseCompare`，它实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型接口。 该比较器调用<xref:System.String.CompareTo%28System.String%29>方法中，反转比较字的顺序，使字符串对高到低而不是低到高进行排序。  
  
 数组为显示、 已排序，并再次显示。 数组必须进行排序，以便使用<xref:System.Array.BinarySearch%2A>方法。  
  
> [!NOTE]
>  对调用<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。 如果您使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，可以看到泛型方法正被调用。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>然后使用泛型方法重载来搜索两个字符串，其中一个脚本并不在数组，另一个是。 数组和返回值的<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>方法传递给`ShowWhere`泛型方法，如果找到该字符串，否则元素的搜索字符串将介于在数组中显示的索引值。 索引为负，如果字符串不是 n 数组，因此`ShowWhere`方法采用按位求补 (~ 运算符在 C# 和 Visual c + +，`Xor`在 Visual Basic 中的为-1) 若要获取大于搜索 stri 列表中的第一个元素的索引ng。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 和更早版本使用仅快速排序算法。 快速排序标识无效的比较器在某些情况下，在排序操作将引发<see cref="T:System.IndexOutOfRangeException" />异常，并且会引发<see cref="T:System.ArgumentException" />给调用方的异常。 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，就可以，以前排序操作引发了<see cref="T:System.ArgumentException" />不会引发异常，因为插入排序和 heapsort 算法不检测无效的比较器。 大多数情况下，这适用于具有少于 16 个元素的数组。</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要排序的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="comparison">比较元素时要使用的 <see cref="T:System.Comparison`1" />。</param>
        <summary>使用指定的 <see cref="T:System.Comparison`1" />，对 <see cref="T:System.Array" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果排序未成功完成，则结果不确定。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>方法重载。  
  
 代码示例定义名为的字符串替换比较方法`CompareDinosByLength`。 此方法的工作方式如下：首先，comparandsare 测试为`null`，并为 null 引用被视为小于非空。 其次，比较字符串长度，并更长的字符串被认为更高版本。 第三，如果长度相等，则使用常规字符串比较。  
  
 创建并填充了四个字符串，不按特定顺序的字符串数组。 列表还包括一个空字符串和 null 引用。 显示列表，使用排序<xref:System.Comparison%601>泛型委托表示`CompareDinosByLength`方法，并再次显示。  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="comparison" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparison" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparison" /> 可能不返回 0。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 和更早版本使用仅快速排序算法。 快速排序标识无效的比较器在某些情况下，在排序操作将引发<see cref="T:System.IndexOutOfRangeException" />异常，并且会引发<see cref="T:System.ArgumentException" />给调用方的异常。 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，就可以，以前排序操作引发了<see cref="T:System.ArgumentException" />不会引发异常，因为插入排序和 heapsort 算法不检测无效的比较器。 大多数情况下，这适用于具有少于 16 个元素的数组。</para></block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要排序的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <summary>使用 <see cref="T:System.Array" /> 中每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现，对 <see cref="T:System.Array" /> 中元素范围内的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的元素指定的范围内的每个元素`array`必须实现<xref:System.IComparable%601>泛型接口，才能与每个其他元素中的比较的`array`。  
  
 如果排序未成功完成，则结果不确定。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>泛型方法重载和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>数组中的范围进行排序的泛型方法重载。  
  
 代码示例定义一个名为`ReverseCompare`，它实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型接口。 该比较器调用<xref:System.String.CompareTo%28System.String%29>方法中，反转比较字的顺序，使字符串对高到低而不是低到高进行排序。  
  
 代码示例创建并显示包含的三个食肉恐龙 (tyrannosaurids，确切地说) 后跟三个草食的恐龙名称的数组。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用泛型方法重载进行排序的数组，随后显示的最后三个元素。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>与使用泛型方法重载`ReverseCompare`按相反的顺序排序的最后三个元素。 彻底无恐龙都暗示会再次显示。  
  
> [!NOTE]
>  对调用<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。 如果您使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，可以看到泛型方法正被调用。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要排序的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <param name="comparer">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</param>
        <summary>使用指定的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，对 <see cref="T:System.Array" /> 中的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`是`null`，每个元素中的元素指定的范围内`array`必须实现<xref:System.IComparable%601>泛型接口，才能与每个其他元素中的比较的`array`。  
  
 如果排序未成功完成，则结果不确定。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>泛型方法重载和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>数组中的范围进行排序的泛型方法重载。  
  
 代码示例定义一个名为`ReverseCompare`，它实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型接口。 该比较器调用<xref:System.String.CompareTo%28System.String%29>方法中，反转比较字的顺序，使字符串对高到低而不是低到高进行排序。  
  
 代码示例创建并显示包含的三个食肉恐龙 (tyrannosaurids，确切地说) 后跟三个草食的恐龙名称的数组。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用泛型方法重载进行排序的数组，随后显示的最后三个元素。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>与使用泛型方法重载`ReverseCompare`按相反的顺序排序的最后三个元素。 彻底无恐龙都暗示会再次显示。  
  
> [!NOTE]
>  对调用<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。 如果您使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，可以看到泛型方法正被调用。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  
  
- 或 - 
<paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 和更早版本使用仅快速排序算法。 快速排序标识无效的比较器在某些情况下，在排序操作将引发<see cref="T:System.IndexOutOfRangeException" />异常，并且会引发<see cref="T:System.ArgumentException" />给调用方的异常。 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，就可以，以前排序操作引发了<see cref="T:System.ArgumentException" />不会引发异常，因为插入排序和 heapsort 算法不检测无效的比较器。 大多数情况下，这适用于具有少于 16 个元素的数组。</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">关键字数组元素的类型。</typeparam>
        <typeparam name="TValue">项数组元素的类型。</typeparam>
        <param name="keys">从零开始的一维 <see cref="T:System.Array" />，其中包含要排序的关键字。</param>
        <param name="items">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <paramref name="keys" /> 进行排序。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的键，使用每个键的 <see cref="T:System.IComparable`1" /> 泛型接口实现，对一对 <see cref="T:System.Array" /> 对象（一个包含键，另一个包含对应的项）进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位一个键`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>按照中的对应键的排列方式排序`keys` <xref:System.Array>。  
  
 在每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable%601>泛型接口，才能与其他任何关键字进行比较。  
  
 如果有更多的项比密钥，但不是进行排序有没有对应的键的项，您可以进行排序。 如果以上的项; 更多密钥不能进行排序这样做将引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成，则结果不确定。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>，和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载，对表示键和值的数组进行排序。  
  
 代码示例定义一个名为`ReverseCompare`，它实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型接口。 该比较器调用<xref:System.String.CompareTo%28System.String%29>方法中，反转比较字的顺序，使字符串对高到低而不是低到高进行排序。  
  
 代码示例创建并显示恢复不复存在名称 （键） 的数组，表示以米为单位 （值） 的每个恢复不复存在的最大长度的整数数组。 然后，数组进行排序和显示几次：  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于对这两个数组中的第一个数组中的恐龙名称顺序进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载和实例`ReverseCompare`用于反转排序顺序的配对的数组。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用重载的两个数组的最后三个元素进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载用于按相反的顺序对两个数组的最后三个元素进行排序。  
  
> [!NOTE]
>  对泛型方法的调用不查找下面任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断与前两个参数的类型的泛型类型参数的类型。 如果您使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，可以看到泛型方法正被调用。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。  
  
- 或 - 
 <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">关键字数组元素的类型。</typeparam>
        <typeparam name="TValue">项数组元素的类型。</typeparam>
        <param name="keys">从零开始的一维 <see cref="T:System.Array" />，其中包含要排序的关键字。</param>
        <param name="items">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <paramref name="keys" /> 进行排序。</param>
        <param name="comparer">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，对两个 <see cref="T:System.Array" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位一个键`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>按照中的对应键的排列方式排序`keys` <xref:System.Array>。  
  
 如果`comparer`是`null`，则每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable%601>泛型接口，才能与其他任何关键字进行比较。  
  
 如果有更多的项比密钥，但不是进行排序有没有对应的键的项，您可以进行排序。 如果以上的项; 更多密钥不能进行排序这样做将引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成，则结果不确定。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>，[\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >，<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>，和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载，对表示键和值的数组进行排序。  
  
 代码示例定义一个名为`ReverseCompare`，它实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型接口。 该比较器调用<xref:System.String.CompareTo%28System.String%29>方法中，反转比较字的顺序，使字符串对高到低而不是低到高进行排序。  
  
 代码示例创建并显示恢复不复存在名称 （键） 的数组，表示以米为单位 （值） 的每个恢复不复存在的最大长度的整数数组。 然后，数组进行排序和显示几次：  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于对这两个数组中的第一个数组中的恐龙名称顺序进行排序。  
  
-   [\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > 重载和实例`ReverseCompare`用于反转排序顺序配对的数组。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用重载的两个数组的最后三个元素进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载用于按相反的顺序对两个数组的最后三个元素进行排序。  
  
> [!NOTE]
>  对泛型方法的调用不查找下面任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断与前两个参数的类型的泛型类型参数的类型。 如果您使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，可以看到泛型方法正被调用。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。  
  
- 或 - 
 <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  
  
- 或 - 
<paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 和更早版本使用仅快速排序算法。 快速排序标识无效的比较器在某些情况下，在排序操作将引发<see cref="T:System.IndexOutOfRangeException" />异常，并且会引发<see cref="T:System.ArgumentException" />给调用方的异常。 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，就可以，以前排序操作引发了<see cref="T:System.ArgumentException" />不会引发异常，因为插入排序和 heapsort 算法不检测无效的比较器。 大多数情况下，这适用于具有少于 16 个元素的数组。</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">关键字数组元素的类型。</typeparam>
        <typeparam name="TValue">项数组元素的类型。</typeparam>
        <param name="keys">从零开始的一维 <see cref="T:System.Array" />，其中包含要排序的关键字。</param>
        <param name="items">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <paramref name="keys" /> 进行排序。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的键，使用每个键的 <see cref="T:System.IComparable`1" /> 泛型接口实现，对两个 <see cref="T:System.Array" /> 对象（一个包含键，另一个包含对应的项）的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位一个键`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>按照中的对应键的排列方式排序`keys` <xref:System.Array>。  
  
 中的元素指定的范围内的每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable%601>泛型接口，才能与其他任何关键字进行比较。  
  
 如果有更多的项比密钥，但不是进行排序有没有对应的键的项，您可以进行排序。 如果以上的项; 更多密钥不能进行排序这样做将引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成，则结果不确定。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>，[\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >，和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载，对表示键和值的数组进行排序。  
  
 代码示例定义一个名为`ReverseCompare`，它实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型接口。 该比较器调用<xref:System.String.CompareTo%28System.String%29>方法中，反转比较字的顺序，使字符串对高到低而不是低到高进行排序。  
  
 代码示例创建并显示恢复不复存在名称 （键） 的数组，表示以米为单位 （值） 的每个恢复不复存在的最大长度的整数数组。 然后，数组进行排序和显示几次：  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于对这两个数组中的第一个数组中的恐龙名称顺序进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载和实例`ReverseCompare`用于反转排序顺序的配对的数组。  
  
-   [\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > 使用重载的两个数组的最后三个元素进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载用于按相反的顺序对两个数组的最后三个元素进行排序。  
  
> [!NOTE]
>  对泛型方法的调用不查找下面任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断与前两个参数的类型的泛型类型参数的类型。 如果您使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，可以看到泛型方法正被调用。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。  
  
- 或 - 
 <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  
  
- 或 - 
 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。  
  
- 或 - 
 <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">关键字数组元素的类型。</typeparam>
        <typeparam name="TValue">项数组元素的类型。</typeparam>
        <param name="keys">从零开始的一维 <see cref="T:System.Array" />，其中包含要排序的关键字。</param>
        <param name="items">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <paramref name="keys" /> 进行排序。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <param name="comparer">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，对两个 <see cref="T:System.Array" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。 在排序中的相应项过程时重新定位一个键`items`<xref:System.Array>同样重新定位。 因此， `items` <xref:System.Array>按照中的对应键的排列方式排序`keys` <xref:System.Array>。  
  
 如果`comparer`是`null`，指定范围中的元素内的每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable%601>泛型接口，才能与其他任何关键字进行比较。  
  
 如果有更多的项比密钥，但不是进行排序有没有对应的键的项，您可以进行排序。 如果以上的项; 更多密钥不能进行排序这样做将引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成，则结果不确定。  
  
 此方法使用内省排序 (introsort) 算法，如下所示：  
  
-   如果分区大小少于 16 个元素，则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用[Quicksort](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，可能不会保留其顺序。 与此相反，一个稳定排序保留相等元素的顺序。  
  
 对于在最坏情况下使用 Heapsort 和快速排序算法进行排序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>，和 [\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > 泛型方法重载，对表示键和值的数组进行排序。  
  
 代码示例定义一个名为`ReverseCompare`，它实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中`IComparer<String^>`Visual c + +) 泛型接口。 该比较器调用<xref:System.String.CompareTo%28System.String%29>方法中，反转比较字的顺序，使字符串对高到低而不是低到高进行排序。  
  
 代码示例创建并显示恢复不复存在名称 （键） 的数组，表示以米为单位 （值） 的每个恢复不复存在的最大长度的整数数组。 然后，数组进行排序和显示几次：  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于对这两个数组中的第一个数组中的恐龙名称顺序进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载和实例`ReverseCompare`用于反转排序顺序的配对的数组。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用重载的两个数组的最后三个元素进行排序。  
  
-   [\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > 使用重载进行排序后的三个这两个元素的数组按相反的顺序。  
  
> [!NOTE]
>  对泛型方法的调用不查找下面任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断与前两个参数的类型的泛型类型参数的类型。 如果您使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，可以看到泛型方法正被调用。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。  
  
- 或 - 
 <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  
  
- 或 - 
 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。  
  
- 或 - 
 <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。  
  
- 或 - 
<paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 和更早版本使用仅快速排序算法。 快速排序标识无效的比较器在某些情况下，在排序操作将引发<see cref="T:System.IndexOutOfRangeException" />异常，并且会引发<see cref="T:System.ArgumentException" />给调用方的异常。 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，就可以，以前排序操作引发了<see cref="T:System.ArgumentException" />不会引发异常，因为插入排序和 heapsort 算法不检测无效的比较器。 大多数情况下，这适用于具有少于 16 个元素的数组。</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</summary>
        <value>可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性实现<xref:System.Collections.ICollection?displayProperty=nameWithType>接口。  
  
 .NET framework 类基于<xref:System.Array>提供集合使用其自己的同步的版本<xref:System.Array.SyncRoot%2A>属性。  
  
 使用数组的类还可实现其自己的同步使用<xref:System.Array.SyncRoot%2A>属性。 同步代码必须在执行操作`SyncRoot`的不是直接对集合的集合。 这样可确保对从其他对象派生的集合正确地执行操作。 具体而言，它维护与其他线程可能同时修改集合的正确同步。 请注意，某些实现的<xref:System.Array.SyncRoot%2A>可能会返回<xref:System.Array>本身。  
  
 枚举整个集合本质上不是线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的代码示例演示如何通过在整个枚举期间锁定数组<xref:System.Array.SyncRoot%2A>属性。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Array" /> 中包含的元素数。</summary>
        <value>集合中包含的元素数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.ICollection> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示对 <see cref="T:System.Array" /> 的访问是否同步（线程安全）。</summary>
        <value>如果对 <see cref="T:System.Array" /> 的访问是同步的（线程安全），则为 true；否则为 false。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</summary>
        <value>可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要添加到 <see cref="T:System.Collections.IList" /> 的对象。</param>
        <summary>调用此方法始终会引发 <see cref="T:System.NotSupportedException" /> 异常。</summary>
        <returns>不支持向数组添加值。 不返回任何值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常，<xref:System.Collections.IList.Add%2A?displayProperty=nameWithType>实现将成员添加到集合。 但是，因为数组具有固定的大小 (<xref:System.Array.IsFixedSize%2A>属性始终返回`true`)，此方法始终引发<xref:System.NotSupportedException>异常。  
  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从 <see cref="T:System.Collections.IList" /> 中移除所有项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> 为只读。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在当前列表中定位的对象。 要定位的元素对于引用类型可以是 <see langword="null" />。</param>
        <summary>确定某元素是否在 <see cref="T:System.Collections.IList" /> 中。</summary>
        <returns>如果在 <see langword="true" /> 中找到 <paramref name="value" />，则为 <see cref="T:System.Collections.IList" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在当前列表中定位的对象。</param>
        <summary>确定 <see cref="T:System.Collections.IList" /> 中特定项的索引。</summary>
        <returns>如果在列表中找到，则为值的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">应插入 <paramref name="value" /> 的索引位置。</param>
        <param name="value">要插入的对象。</param>
        <summary>在 <see cref="T:System.Collections.IList" /> 中的指定索引处插入一个项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> 为只读。  
  
- 或 - 
<see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> 是 <see cref="T:System.Collections.IList" /> 中的 null 引用。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Array" /> 是否具有固定大小。</summary>
        <value>如果<see cref="T:System.Array" />具有固定大小; 否则为 false。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Array" /> 是否为只读。</summary>
        <value>如果<see cref="T:System.Array" />为只读的; 否则为 false。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要获取或设置的元素的索引。</param>
        <summary>获取或设置指定索引处的元素。</summary>
        <value>指定索引处的元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零。  
  
- 或 - 
 <paramref name="index" /> 等于或大于 <see cref="P:System.Collections.ICollection.Count" />。</exception>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 不是正好具有一个维度。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要从 <see cref="T:System.Collections.IList" /> 中删除的对象。</param>
        <summary>从 <see cref="T:System.Collections.IList" /> 中移除特定对象的第一个匹配项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> 为只读。  
  
- 或 - 
<see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的元素的索引。</param>
        <summary>移除位于指定索引处的 <see cref="T:System.Collections.IList" /> 项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">索引不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> 为只读。  
  
- 或 - 
<see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">要与当前实例进行比较的对象。</param>
        <param name="comparer">一个将当前对象与 <paramref name="other" /> 进行比较的对象。</param>
        <summary>确定当前集合对象在排序顺序中的位置是位于另一个对象之前、之后还是与其位置相同。</summary>
        <returns>一个指示当前集合对象与其他对象的关系的整数，如下表所示。  
  
 <list type="table"><listheader><term> 返回值 
 </term><description> 描述 
 </description></listheader><item><term> -1 
 </term><description> 当前实例位于 <paramref name="other" /> 之前。  
  
 </description></item><item><term> 0 
 </term><description> 当前实例与 <paramref name="other" /> 位于同一位置。  
  
 </description></item><item><term> 1 
 </term><description> 当前实例位于 <paramref name="other" /> 之后。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IStructuralComparable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">要与当前实例进行比较的对象。</param>
        <param name="comparer">一个对象，用于确定当前实例和 <paramref name="other" /> 是否相等。</param>
        <summary>确定某个对象与当前实例是否相等。</summary>
        <returns>如果两个对象相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IStructuralEquatable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">一个计算当前对象的哈希代码的对象。</param>
        <summary>返回当前实例的哈希代码。</summary>
        <returns>当前实例的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IStructuralEquatable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">从零开始的一维 <see cref="T:System.Array" />，它将对照条件进行检查。</param>
        <param name="match">用于定义检查元素时要对照的条件的谓词。</param>
        <summary>确定数组中的每个元素是否都与指定谓词定义的条件匹配。</summary>
        <returns>如果 <paramref name="array" /> 中的每个元素都与指定谓词定义的条件匹配，则为 <see langword="true" />；否则为 <see langword="false" />。 如果数组中没有元素，则返回值为 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回的方法的委托`true`如果该对象传递给委托中定义的条件匹配。  元素`array`逐个传递给<xref:System.Predicate%601>，并且在委托返回时停止处理`false`的任何元素。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例确定一个字符串数组中每个元素的最后一个字符是否是一个数字。 它将创建两个字符串数组。 第一个 arrayincludes 同时字符串结尾字母字符和字符串和数字的字符结尾。第二个数组仅包含数字字符结尾的字符串。 该示例还定义了`EndWithANumber`方法，其签名与匹配<xref:System.Predicate%601>委托。 该示例将为每个数组<xref:System.Array.TrueForAll%2A>方法以及一个委托，表示`EndsWithANumber`方法。  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 下面的示例是类似于第一个，只不过它将传递到的字符串数组<xref:System.Array.TrueForAll%2A>方法以及确定是否从特定的数组元素结尾的数字的字符串表示形式的 lambda 表达式。  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 在这两种情况下，<xref:System.Array.TrueForAll%2A>方法将返回`false`一旦遇到不以数字结尾的第一个数组元素。 否则，它将返回`true`后循环访问数组中的所有元素。  
  
> [!NOTE]
>  如这两个示例所示，在 C# 和 Visual Basic 中，不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>