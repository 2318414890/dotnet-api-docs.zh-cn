<Type Name="Array" FullName="System.Array">
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="31c36-101">提供一些方法，用于创建、处理、搜索数组并对数组进行排序，从而充当公共语言运行时中所有数组的基类。</span><span class="sxs-lookup"><span data-stu-id="31c36-101">Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-102"><xref:System.Array>类不是属于<xref:System.Collections>命名空间。</span><span class="sxs-lookup"><span data-stu-id="31c36-102">The <xref:System.Array> class is not part of the <xref:System.Collections> namespaces.</span></span> <span data-ttu-id="31c36-103">但是，仍将其视为集合因为它基于<xref:System.Collections.IList>接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-103">However, it is still considered a collection because it is based on the <xref:System.Collections.IList> interface.</span></span>  
  
 <span data-ttu-id="31c36-104"><xref:System.Array>类是支持数组的语言实现的基类。</span><span class="sxs-lookup"><span data-stu-id="31c36-104">The <xref:System.Array> class is the base class for language implementations that support arrays.</span></span> <span data-ttu-id="31c36-105">但是，只有系统和编译器可以从显式派生<xref:System.Array>类。</span><span class="sxs-lookup"><span data-stu-id="31c36-105">However, only the system and compilers can derive explicitly from the <xref:System.Array> class.</span></span> <span data-ttu-id="31c36-106">用户应采用由语言提供的数组构造。</span><span class="sxs-lookup"><span data-stu-id="31c36-106">Users should employ the array constructs provided by the language.</span></span>  
  
 <span data-ttu-id="31c36-107">元素是中的值<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-107">An element is a value in an <xref:System.Array>.</span></span> <span data-ttu-id="31c36-108">长度<xref:System.Array>是它可以包含的元素总数。</span><span class="sxs-lookup"><span data-stu-id="31c36-108">The length of an <xref:System.Array> is the total number of elements it can contain.</span></span> <span data-ttu-id="31c36-109">下限为<xref:System.Array>是其第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-109">The lower bound of an <xref:System.Array> is the index of its first element.</span></span> <span data-ttu-id="31c36-110"><xref:System.Array>可以有任何下限，但该下限为零，默认情况下。</span><span class="sxs-lookup"><span data-stu-id="31c36-110">An <xref:System.Array> can have any lower bound, but it has a lower bound of zero by default.</span></span> <span data-ttu-id="31c36-111">创建的实例时，可以定义不同的下限<xref:System.Array>类使用<xref:System.Array.CreateInstance%2A>。多维<xref:System.Array>可以为每个维度的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-111">A different lower bound can be defined when creating an instance of the <xref:System.Array> class using <xref:System.Array.CreateInstance%2A>.A multidimensional <xref:System.Array> can have different bounds for each dimension.</span></span> <span data-ttu-id="31c36-112">32 维数的最多可以有一个数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-112">An array can have a maximum of 32 dimensions.</span></span>  
  
 <span data-ttu-id="31c36-113">与中的类不同<xref:System.Collections>命名空间，<xref:System.Array>具有固定的容量。</span><span class="sxs-lookup"><span data-stu-id="31c36-113">Unlike the classes in the <xref:System.Collections> namespaces, <xref:System.Array> has a fixed capacity.</span></span> <span data-ttu-id="31c36-114">若要增加容量，你必须创建一个新<xref:System.Array>对象具有所需容量，旧中的元素复制<xref:System.Array>到新对象，并删除旧<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-114">To increase the capacity, you must create a new <xref:System.Array> object with the required capacity, copy the elements from the old <xref:System.Array> object to the new one, and delete the old <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-115">默认情况下的最大大小<xref:System.Array>是 2 千兆字节 (GB)。</span><span class="sxs-lookup"><span data-stu-id="31c36-115">By default, the maximum size of an <xref:System.Array> is 2 gigabytes (GB).</span></span> <span data-ttu-id="31c36-116">在 64 位环境中，你可以通过设置来避免大小限制`enabled`属性[gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)到的配置元素`true`在运行时环境中。</span><span class="sxs-lookup"><span data-stu-id="31c36-116">In a 64-bit environment, you can avoid the size restriction by setting the `enabled` attribute of the [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) configuration element to `true` in the run-time environment.</span></span> <span data-ttu-id="31c36-117">但是，数组仍将仅限于总数 40 亿个元素，以及 0X7FEFFFFF 的任何给定维度 (0X7FFFFFC7 字节数组和单字节结构的数组) 中的最大索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-117">However, the array will still be limited to a total of 4 billion elements, and to a maximum index of 0X7FEFFFFF in any given dimension (0X7FFFFFC7 for byte arrays and arrays of single-byte structures).</span></span>  
  
 <span data-ttu-id="31c36-118">一维数组实现<xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>， <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>， <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>，<xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType>和<xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType>泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-118">Single-dimensional arrays implement the <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> generic interfaces.</span></span> <span data-ttu-id="31c36-119">在运行时，实现提供给数组和泛型接口结果是，不显示在的声明语法<xref:System.Array>类。</span><span class="sxs-lookup"><span data-stu-id="31c36-119">The implementations are provided to arrays at run time, and as a result, the generic interfaces do not appear in the declaration syntax for the <xref:System.Array> class.</span></span> <span data-ttu-id="31c36-120">此外，还有只能通过强制转换为泛型接口类型 （显式接口实现） 的数组是可访问的接口成员没有参考主题。</span><span class="sxs-lookup"><span data-stu-id="31c36-120">In addition,  there are no reference topics for interface members that are accessible only by casting an array to the generic interface type (explicit interface implementations).</span></span> <span data-ttu-id="31c36-121">关键的一点需要注意的当强制转换到这些接口之一的数组是成员将其添加，插入或删除元素 throw <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="31c36-121">The key thing to be aware of when you cast an array to one of these interfaces is that members which add, insert, or remove elements throw <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="31c36-122"><xref:System.Type> 对象提供有关数组类型声明的信息。</span><span class="sxs-lookup"><span data-stu-id="31c36-122"><xref:System.Type> objects provide information about array type declarations.</span></span> <span data-ttu-id="31c36-123"><xref:System.Array> 使用相同的数组类型的对象共享相同<xref:System.Type>对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-123"><xref:System.Array> objects with the same array type share the same <xref:System.Type> object.</span></span>  
  
 <span data-ttu-id="31c36-124"><xref:System.Type.IsArray%2A?displayProperty=nameWithType> 和<xref:System.Type.GetElementType%2A?displayProperty=nameWithType>可能不返回预期的结果与<xref:System.Array>因为如果数组被强制转换为类型<xref:System.Array>，结果是一个对象，不是数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-124"><xref:System.Type.IsArray%2A?displayProperty=nameWithType> and <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> might not return the expected results with <xref:System.Array> because if an array is cast to the type <xref:System.Array>, the result is an object, not an array.</span></span> <span data-ttu-id="31c36-125">也就是说，`typeof(System.Array).IsArray`返回`false`，和`typeof(System.Array).GetElementType`返回`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-125">That is, `typeof(System.Array).IsArray` returns `false`, and `typeof(System.Array).GetElementType` returns `null`.</span></span>  
  
 <span data-ttu-id="31c36-126"><xref:System.Array.Copy%2A?displayProperty=nameWithType>方法复制不仅之间相同类型的数组，但还的不同类型的标准阵列之间的元素; 它处理自动强制转换的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-126">The <xref:System.Array.Copy%2A?displayProperty=nameWithType> method copies elements not only between arrays of the same type but also between standard arrays of different types; it handles type casting automatically.</span></span>  
  
 <span data-ttu-id="31c36-127">某些方法，如<xref:System.Array.CreateInstance%2A>， <xref:System.Array.Copy%2A>， <xref:System.Array.CopyTo%2A>， <xref:System.Array.GetValue%2A>，和<xref:System.Array.SetValue%2A>，提供重载，以适应大容量数组作为参数接受 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-127">Some methods, such as <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, and <xref:System.Array.SetValue%2A>, provide overloads that accept 64-bit integers as parameters to accommodate large capacity arrays.</span></span> <span data-ttu-id="31c36-128"><xref:System.Array.LongLength%2A> 和<xref:System.Array.GetLongLength%2A>返回 64 位整数，表示数组的长度。</span><span class="sxs-lookup"><span data-stu-id="31c36-128"><xref:System.Array.LongLength%2A> and <xref:System.Array.GetLongLength%2A> return 64-bit integers indicating the length of the array.</span></span>  
  
 <span data-ttu-id="31c36-129"><xref:System.Array>不一定进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-129">The <xref:System.Array> is not guaranteed to be sorted.</span></span>  <span data-ttu-id="31c36-130">您必须对进行排序<xref:System.Array>之前执行操作 (如<xref:System.Array.BinarySearch%2A>) 需要<xref:System.Array>进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-130">You must sort the <xref:System.Array> prior to performing operations (such as <xref:System.Array.BinarySearch%2A>) that require the <xref:System.Array> to be sorted.</span></span>  
  
 <span data-ttu-id="31c36-131">使用<xref:System.Array>的本机代码中的指针的对象不受支持，将引发<xref:System.NotSupportedException>对几种方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-131">Using an <xref:System.Array> object of pointers in native code is not supported and will throw a <xref:System.NotSupportedException> for several methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-132">下面的代码示例演示如何<xref:System.Array.Copy%2A?displayProperty=nameWithType>之间的整数类型的数组和类型的数组的元素复制<xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="31c36-132">The following code example shows how <xref:System.Array.Copy%2A?displayProperty=nameWithType> copies elements between an array of type integer and an array of type <xref:System.Object>.</span></span>  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 <span data-ttu-id="31c36-133">下面的代码示例创建并初始化<xref:System.Array>并显示其属性和它的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-133">The following code example creates and initializes an <xref:System.Array> and displays its properties and its elements.</span></span>  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="31c36-134">公共静态 (<see langword="Shared" />在 Visual Basic 中) 的此类型的成员都是线程安全。</span><span class="sxs-lookup"><span data-stu-id="31c36-134">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span></span> <span data-ttu-id="31c36-135">但不保证所有实例成员都是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="31c36-135">Any instance members are not guaranteed to be thread safe.</span></span>  
  
 <span data-ttu-id="31c36-136">此实现不提供同步 （线程安全） 包装器<see cref="T:System.Array" />; 但是，.NET Framework 类基于<see cref="T:System.Array" />提供其自己的同步的版本的集合使用<see cref="P:System.Array.SyncRoot" />属性。</span><span class="sxs-lookup"><span data-stu-id="31c36-136">This implementation does not provide a synchronized (thread safe) wrapper for an <see cref="T:System.Array" />; however, .NET Framework classes based on <see cref="T:System.Array" /> provide their own synchronized version of the collection using the <see cref="P:System.Array.SyncRoot" /> property.</span></span>  
  
 <span data-ttu-id="31c36-137">枚举整个集合本质上不是一个线程安全的过程。</span><span class="sxs-lookup"><span data-stu-id="31c36-137">Enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="31c36-138">即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-138">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="31c36-139">若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-139">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span></threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-140">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-140">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-141">要包装在只读 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 包装器中的从零开始的一维数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-141">The one-dimensional, zero-based array to wrap in a read-only <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> wrapper.</span></span></param>
        <summary><span data-ttu-id="31c36-142">返回指定数组的只读包装。</span><span class="sxs-lookup"><span data-stu-id="31c36-142">Returns a read-only wrapper for the specified array.</span></span></summary>
        <returns><span data-ttu-id="31c36-143">指定数组的只读 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 包装。</span><span class="sxs-lookup"><span data-stu-id="31c36-143">A read-only <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> wrapper for the specified array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-144">若要防止对数组进行任何修改，公开只通过此包装器数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-144">To prevent any modifications to the array, expose the array only through this wrapper.</span></span>  
  
 <span data-ttu-id="31c36-145">集合是只读的是只是一个集合与防止集合; 进行修改的包装因此，如果对基础集合进行更改，只读集合将反映这些更改。</span><span class="sxs-lookup"><span data-stu-id="31c36-145">A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</span></span>  
  
 <span data-ttu-id="31c36-146">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-146">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-147">下面的示例将数组包装在只读的<xref:System.Collections.ObjectModel.ReadOnlyCollection%601>。</span><span class="sxs-lookup"><span data-stu-id="31c36-147">The following example wraps an array in a read-only <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-148"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-148"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31c36-149">使用二进制搜索算法在一维的排序 <see cref="T:System.Array" /> 中搜索值。</span><span class="sxs-lookup"><span data-stu-id="31c36-149">Searches a one-dimensional sorted <see cref="T:System.Array" /> for a value, using a binary search algorithm.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-150">要搜索的排序一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-150">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-151">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-151">The object to search for.</span></span></param>
        <summary><span data-ttu-id="31c36-152">使用由数组中每个元素和指定对象实现的 <see cref="T:System.IComparable" /> 接口，在整个一维排序数组中搜索特定元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-152">Searches an entire one-dimensional sorted array for a specific element, using the <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified object.</span></span></summary>
        <returns><span data-ttu-id="31c36-153">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="31c36-153">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="31c36-154">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-154">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="31c36-155">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-155">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="31c36-156">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="31c36-156">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-157">此方法不支持包含负索引的搜索数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-157">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="31c36-158">`array` 必须调用此方法之前进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-158">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="31c36-159">如果<xref:System.Array>不包含指定的值，该方法返回负整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-159">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="31c36-160">你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-160">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="31c36-161">如果此索引是一种大于上限的数组，没有任何元素大于`value`数组中。</span><span class="sxs-lookup"><span data-stu-id="31c36-161">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="31c36-162">否则，它是大于第一个元素的索引`value`。</span><span class="sxs-lookup"><span data-stu-id="31c36-162">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="31c36-163">请`value`或的每个元素`array`必须实现<xref:System.IComparable>接口，用于比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-163">Either `value` or every element of `array` must implement the <xref:System.IComparable> interface, which is used for comparisons.</span></span> <span data-ttu-id="31c36-164">元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="31c36-164">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-165">如果`value`不实现<xref:System.IComparable>接口的元素`array`未测试的<xref:System.IComparable>开始执行搜索之前。</span><span class="sxs-lookup"><span data-stu-id="31c36-165">If`value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="31c36-166">如果搜索遇到不实现的元素将引发异常<xref:System.IComparable>。</span><span class="sxs-lookup"><span data-stu-id="31c36-166">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="31c36-167">允许重复的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-167">Duplicate elements are allowed.</span></span> <span data-ttu-id="31c36-168">如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-168">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="31c36-169">`null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`不生成异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-169">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-170">为测试，每个元素`value`传递给相应<xref:System.IComparable>实现，即使`value`是`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-170">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="31c36-171">也就是说，<xref:System.IComparable>实现确定给定的元素如何比较到`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-171">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="31c36-172">此方法为 O (日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-172">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-173">下面的代码示例演示如何使用<xref:System.Array.BinarySearch%2A>查找中的特定对象<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-173">The following code example shows how to use <xref:System.Array.BinarySearch%2A> to locate a specific object in an <xref:System.Array>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-174">创建数组时，其元素以升序排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-174">The array is created with its elements in ascending sort order.</span></span> <span data-ttu-id="31c36-175"><xref:System.Array.BinarySearch%2A>方法要求要以升序排序的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-175">The <xref:System.Array.BinarySearch%2A> method requires the array to be sorted in ascending order.</span></span>  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-176"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-176"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-177"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-177"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-178"><paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</span><span class="sxs-lookup"><span data-stu-id="31c36-178"><paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-179"><paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-179"><paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-180">要搜索的排序一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-180">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-181">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-181">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="31c36-182">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-182">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="31c36-183">或</span><span class="sxs-lookup"><span data-stu-id="31c36-183">-or-</span></span>  
  
 <span data-ttu-id="31c36-184">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-184"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="31c36-185">使用指定 <see cref="T:System.Collections.IComparer" /> 接口，在整个一维排序数组中搜索值。</span><span class="sxs-lookup"><span data-stu-id="31c36-185">Searches an entire one-dimensional sorted array for a value using the specified <see cref="T:System.Collections.IComparer" /> interface.</span></span></summary>
        <returns><span data-ttu-id="31c36-186">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="31c36-186">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="31c36-187">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-187">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="31c36-188">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-188">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="31c36-189">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="31c36-189">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-190">此方法不支持包含负索引的搜索数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-190">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="31c36-191">`array` 必须调用此方法之前进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-191">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="31c36-192">如果<xref:System.Array>不包含指定的值，该方法返回负整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-192">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="31c36-193">你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-193">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="31c36-194">如果此索引是一种大于上限的数组，没有任何元素大于`value`数组中。</span><span class="sxs-lookup"><span data-stu-id="31c36-194">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="31c36-195">否则，它是大于第一个元素的索引`value`。</span><span class="sxs-lookup"><span data-stu-id="31c36-195">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="31c36-196">比较器自定义如何比较元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-196">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="31c36-197">例如，你可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>作为要执行不区分大小写的字符串搜索的比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-197">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="31c36-198">如果`comparer`不`null`的元素`array`与使用指定的指定值进行比较<xref:System.Collections.IComparer>实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-198">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.IComparer> implementation.</span></span> <span data-ttu-id="31c36-199">元素`array`必须已在增加根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="31c36-199">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="31c36-200">如果`comparer`是`null`，完成比较使用<xref:System.IComparable>通过自身的元素或指定的值提供的实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-200">If`comparer` is `null`, the comparison is done using the <xref:System.IComparable> implementation provided by the element itself or by the specified value.</span></span> <span data-ttu-id="31c36-201">元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="31c36-201">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-202">如果`comparer`是`null`和`value`不实现<xref:System.IComparable>接口的元素`array`未测试的<xref:System.IComparable>开始执行搜索之前。</span><span class="sxs-lookup"><span data-stu-id="31c36-202">If `comparer` is `null` and `value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="31c36-203">如果搜索遇到不实现的元素将引发异常<xref:System.IComparable>。</span><span class="sxs-lookup"><span data-stu-id="31c36-203">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="31c36-204">允许重复的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-204">Duplicate elements are allowed.</span></span> <span data-ttu-id="31c36-205">如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-205">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="31c36-206">`null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`不生成异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-206">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-207">为测试，每个元素`value`传递给相应<xref:System.IComparable>实现，即使`value`是`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-207">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="31c36-208">也就是说，<xref:System.IComparable>实现确定给定的元素如何比较到`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-208">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="31c36-209">此方法为 O (日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-209">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-210"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-210"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-211"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-211"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-212"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</span><span class="sxs-lookup"><span data-stu-id="31c36-212"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-213"><paramref name="comparer" /> 为 <see langword="null" />，<paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-213"><paramref name="comparer" /> is <see langword="null" />, <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-214">要搜索的排序一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-214">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-215">要搜索的范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-215">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-216">要搜索的范围的长度。</span><span class="sxs-lookup"><span data-stu-id="31c36-216">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-217">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-217">The object to search for.</span></span></param>
        <summary><span data-ttu-id="31c36-218">使用由一维排序数组中每个元素和指定的值实现的 <see cref="T:System.IComparable" /> 接口，在该数组的一个元素范围内搜索值。</span><span class="sxs-lookup"><span data-stu-id="31c36-218">Searches a range of elements in a one-dimensional sorted array for a value, using the <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified value.</span></span></summary>
        <returns><span data-ttu-id="31c36-219">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="31c36-219">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="31c36-220">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-220">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="31c36-221">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-221">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="31c36-222">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="31c36-222">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-223">此方法不支持包含负索引的搜索数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-223">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="31c36-224">`array` 必须调用此方法之前进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-224">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="31c36-225">如果<xref:System.Array>不包含指定的值，该方法返回负整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-225">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="31c36-226">你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-226">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result to produce an index.</span></span> <span data-ttu-id="31c36-227">如果此索引是一种大于上限的数组，没有任何元素大于`value`数组中。</span><span class="sxs-lookup"><span data-stu-id="31c36-227">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="31c36-228">否则，它是大于第一个元素的索引`value`。</span><span class="sxs-lookup"><span data-stu-id="31c36-228">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="31c36-229">请`value`或的每个元素`array`必须实现<xref:System.IComparable>接口，用于比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-229">Either `value` or every element of `array` must implement the <xref:System.IComparable> interface, which is used for comparisons.</span></span> <span data-ttu-id="31c36-230">元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="31c36-230">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-231">如果`value`不实现<xref:System.IComparable>接口的元素`array`未测试的<xref:System.IComparable>开始执行搜索之前。</span><span class="sxs-lookup"><span data-stu-id="31c36-231">If `value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="31c36-232">如果搜索遇到不实现的元素将引发异常<xref:System.IComparable>。</span><span class="sxs-lookup"><span data-stu-id="31c36-232">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="31c36-233">允许重复的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-233">Duplicate elements are allowed.</span></span> <span data-ttu-id="31c36-234">如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-234">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="31c36-235">`null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`不生成异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-235">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-236">为测试，每个元素`value`传递给相应<xref:System.IComparable>实现，即使`value`是`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-236">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="31c36-237">也就是说，<xref:System.IComparable>实现确定给定的元素如何比较到`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-237">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="31c36-238">此方法为 O (日志`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-238">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-239"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-239"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-240"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-240"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-241"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-241"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-242">或</span><span class="sxs-lookup"><span data-stu-id="31c36-242">-or-</span></span>  
  
 <span data-ttu-id="31c36-243"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-243"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-244"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-244"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-245">或</span><span class="sxs-lookup"><span data-stu-id="31c36-245">-or-</span></span>  
  
 <span data-ttu-id="31c36-246"><paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</span><span class="sxs-lookup"><span data-stu-id="31c36-246"><paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-247"><paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-247"><paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-248">要搜索的排序一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-248">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-249">要搜索的范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-249">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-250">要搜索的范围的长度。</span><span class="sxs-lookup"><span data-stu-id="31c36-250">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-251">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-251">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="31c36-252">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-252">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="31c36-253">或</span><span class="sxs-lookup"><span data-stu-id="31c36-253">-or-</span></span>  
  
 <span data-ttu-id="31c36-254">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-254"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="31c36-255">使用指定 <see cref="T:System.Collections.IComparer" /> 接口，在一维排序数组的某个元素范围中搜索值。</span><span class="sxs-lookup"><span data-stu-id="31c36-255">Searches a range of elements in a one-dimensional sorted array for a value, using the specified <see cref="T:System.Collections.IComparer" /> interface.</span></span></summary>
        <returns><span data-ttu-id="31c36-256">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="31c36-256">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="31c36-257">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-257">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="31c36-258">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-258">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="31c36-259">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="31c36-259">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-260">此方法不支持包含负索引的搜索数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-260">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="31c36-261">`array` 必须调用此方法之前进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-261">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="31c36-262">如果<xref:System.Array>不包含指定的值，该方法返回负整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-262">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="31c36-263">你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-263">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="31c36-264">如果此索引是一种大于上限的数组，没有任何元素大于`value`数组中。</span><span class="sxs-lookup"><span data-stu-id="31c36-264">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="31c36-265">否则，它是大于第一个元素的索引`value`。</span><span class="sxs-lookup"><span data-stu-id="31c36-265">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="31c36-266">比较器自定义如何比较元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-266">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="31c36-267">例如，你可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>作为要执行不区分大小写的字符串搜索的比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-267">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="31c36-268">如果`comparer`不`null`的元素`array`与使用指定的指定值进行比较<xref:System.Collections.IComparer>实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-268">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.IComparer> implementation.</span></span> <span data-ttu-id="31c36-269">元素`array`必须已在增加根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="31c36-269">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="31c36-270">如果`comparer`是`null`，完成比较使用<xref:System.IComparable>通过自身的元素或指定的值提供的实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-270">If `comparer` is `null`, the comparison is done using the <xref:System.IComparable> implementation provided by the element itself or by the specified value.</span></span> <span data-ttu-id="31c36-271">元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="31c36-271">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-272">如果`comparer`是`null`和`value`不实现<xref:System.IComparable>接口的元素`array`未测试的<xref:System.IComparable>开始执行搜索之前。</span><span class="sxs-lookup"><span data-stu-id="31c36-272">If `comparer` is `null` and `value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="31c36-273">如果搜索遇到不实现的元素将引发异常<xref:System.IComparable>。</span><span class="sxs-lookup"><span data-stu-id="31c36-273">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="31c36-274">允许重复的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-274">Duplicate elements are allowed.</span></span> <span data-ttu-id="31c36-275">如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-275">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="31c36-276">`null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`使用时不生成异常<xref:System.IComparable>。</span><span class="sxs-lookup"><span data-stu-id="31c36-276">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception when using <xref:System.IComparable>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-277">为测试，每个元素`value`传递给相应<xref:System.IComparable>实现，即使`value`是`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-277">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="31c36-278">也就是说，<xref:System.IComparable>实现确定给定的元素如何比较到`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-278">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="31c36-279">此方法为 O (日志`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-279">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-280"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-280"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-281"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-281"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-282"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-282"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-283">或</span><span class="sxs-lookup"><span data-stu-id="31c36-283">-or-</span></span>  
  
 <span data-ttu-id="31c36-284"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-284"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-285"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-285"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-286">或</span><span class="sxs-lookup"><span data-stu-id="31c36-286">-or-</span></span>  
  
 <span data-ttu-id="31c36-287"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</span><span class="sxs-lookup"><span data-stu-id="31c36-287"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-288"><paramref name="comparer" /> 为 <see langword="null" />，<paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-288"><paramref name="comparer" /> is <see langword="null" />, <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-289">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-289">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-290">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-290">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-291">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-291">The object to search for.</span></span></param>
        <summary><span data-ttu-id="31c36-292">使用由 <see cref="T:System.Array" /> 中每个元素和指定对象实现的 <see cref="T:System.IComparable`1" /> 泛型接口，在整个一维排序数组中搜索特定元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-292">Searches an entire one-dimensional sorted array for a specific element, using the <see cref="T:System.IComparable`1" /> generic interface implemented by each element of the <see cref="T:System.Array" /> and by the specified object.</span></span></summary>
        <returns><span data-ttu-id="31c36-293">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="31c36-293">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="31c36-294">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-294">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="31c36-295">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-295">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="31c36-296">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="31c36-296">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-297">此方法不支持包含负索引的搜索数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-297">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="31c36-298">`array` 必须调用此方法之前进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-298">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="31c36-299">如果`array`不包含指定的值，该方法返回负整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-299">If `array` does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="31c36-300">你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-300">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="31c36-301">如果此索引等于数组的大小，没有任何元素大于`value`数组中。</span><span class="sxs-lookup"><span data-stu-id="31c36-301">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="31c36-302">否则，它是大于第一个元素的索引`value`。</span><span class="sxs-lookup"><span data-stu-id="31c36-302">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="31c36-303">`T` 必须实现<xref:System.IComparable%601>泛型接口，用于比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-303">`T` must implement the <xref:System.IComparable%601> generic interface, which is used for comparisons.</span></span> <span data-ttu-id="31c36-304">元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable%601>实现; 否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="31c36-304">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="31c36-305">允许重复的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-305">Duplicate elements are allowed.</span></span> <span data-ttu-id="31c36-306">如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-306">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="31c36-307">`null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`不生成异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-307">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-308">为测试，每个元素`value`传递给相应<xref:System.IComparable%601>实现，即使`value`是`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-308">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="31c36-309">也就是说，<xref:System.IComparable%601>实现确定给定的元素如何比较到`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-309">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="31c36-310">此方法为 O (日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-310">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-311">下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>泛型方法重载与<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>泛型方法重载。</span><span class="sxs-lookup"><span data-stu-id="31c36-311">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload.</span></span> <span data-ttu-id="31c36-312">创建一个字符串数组，顺序不分先后。</span><span class="sxs-lookup"><span data-stu-id="31c36-312">An array of strings is created, in no particular order.</span></span>  
  
 <span data-ttu-id="31c36-313">数组是显示、 排序，并且再次显示。</span><span class="sxs-lookup"><span data-stu-id="31c36-313">The array is displayed, sorted, and displayed again.</span></span> <span data-ttu-id="31c36-314">数组必须进行排序以便使用<xref:System.Array.BinarySearch%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-314">Arrays must be sorted in order to use the <xref:System.Array.BinarySearch%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-315">对调用<xref:System.Array.Sort%2A>和<xref:System.Array.BinarySearch%2A>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-315">The calls to the <xref:System.Array.Sort%2A> and <xref:System.Array.BinarySearch%2A> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="31c36-316">如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-316">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="31c36-317"><xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>泛型方法重载然后用于两个字符串搜索，另一个不在使用数组和一个，是。</span><span class="sxs-lookup"><span data-stu-id="31c36-317">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="31c36-318">数组和返回值的<xref:System.Array.BinarySearch%2A>方法传递给`ShowWhere`泛型方法，如果找到该字符串，而且否则元素的搜索字符串将介于像它是数组中显示的索引值。</span><span class="sxs-lookup"><span data-stu-id="31c36-318">The array and the return value of the <xref:System.Array.BinarySearch%2A> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="31c36-319">索引为负如果字符串不是在数组中，因此`ShowWhere`方法采用的按位求补 (~ 中 C# 和 Visual c + + 中，运算符`Xor`在 Visual Basic 中的为-1) 若要获取大于搜索列表中的第一个元素的索引 str运算结果。</span><span class="sxs-lookup"><span data-stu-id="31c36-319">The index is negative if the string is not in the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor`-1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-320"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-320"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-321"><paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-321"><paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-322">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-322">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-323">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-323">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-324">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-324">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="31c36-325">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-325">The <see cref="T:System.Collections.Generic.IComparer`1" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="31c36-326">或</span><span class="sxs-lookup"><span data-stu-id="31c36-326">-or-</span></span>  
  
 <span data-ttu-id="31c36-327">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-327"><see langword="null" /> to use the <see cref="T:System.IComparable`1" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="31c36-328">使用指定 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，在整个一维排序数组中搜索值。</span><span class="sxs-lookup"><span data-stu-id="31c36-328">Searches an entire one-dimensional sorted array for a value using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <returns><span data-ttu-id="31c36-329">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="31c36-329">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="31c36-330">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-330">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="31c36-331">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-331">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="31c36-332">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="31c36-332">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-333">此方法不支持包含负索引的搜索数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-333">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="31c36-334">`array` 必须调用此方法之前进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-334">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="31c36-335">如果<xref:System.Array>不包含指定的值，该方法返回负整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-335">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="31c36-336">你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-336">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result to produce an index.</span></span> <span data-ttu-id="31c36-337">如果此索引等于数组的大小，没有任何元素大于`value`数组中。</span><span class="sxs-lookup"><span data-stu-id="31c36-337">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="31c36-338">否则，它是大于第一个元素的索引`value`。</span><span class="sxs-lookup"><span data-stu-id="31c36-338">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="31c36-339">比较器自定义如何比较元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-339">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="31c36-340">例如，你可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>作为要执行不区分大小写的字符串搜索的比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-340">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="31c36-341">如果`comparer`不`null`的元素`array`与使用指定的指定值进行比较<xref:System.Collections.Generic.IComparer%601>泛型接口实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-341">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.Generic.IComparer%601> generic interface implementation.</span></span> <span data-ttu-id="31c36-342">元素`array`必须已在增加根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="31c36-342">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="31c36-343">如果`comparer`是`null`，完成比较使用<xref:System.IComparable%601>由提供的泛型接口实现`T`。</span><span class="sxs-lookup"><span data-stu-id="31c36-343">If `comparer` is `null`, the comparison is done using the <xref:System.IComparable%601> generic interface implementation provided by `T`.</span></span> <span data-ttu-id="31c36-344">元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable%601>实现; 否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="31c36-344">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-345">如果`comparer`是`null`和`value`不实现<xref:System.IComparable%601>泛型接口的元素`array`未测试的<xref:System.IComparable%601>开始执行搜索之前。</span><span class="sxs-lookup"><span data-stu-id="31c36-345">If `comparer` is `null` and `value` does not implement the <xref:System.IComparable%601> generic interface, the elements of `array` are not tested for <xref:System.IComparable%601> before the search begins.</span></span> <span data-ttu-id="31c36-346">如果搜索遇到不实现的元素将引发异常<xref:System.IComparable%601>。</span><span class="sxs-lookup"><span data-stu-id="31c36-346">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable%601>.</span></span>  
  
 <span data-ttu-id="31c36-347">允许重复的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-347">Duplicate elements are allowed.</span></span> <span data-ttu-id="31c36-348">如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-348">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="31c36-349">`null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`不生成异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-349">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-350">为测试，每个元素`value`传递给相应<xref:System.IComparable%601>实现，即使`value`是`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-350">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="31c36-351">也就是说，<xref:System.IComparable%601>实现确定给定的元素如何比较到`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-351">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="31c36-352">此方法为 O (日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-352">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-353">下面的示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载与<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载。</span><span class="sxs-lookup"><span data-stu-id="31c36-353">The following example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload.</span></span>  
  
 <span data-ttu-id="31c36-354">代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-354">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="31c36-355">比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。</span><span class="sxs-lookup"><span data-stu-id="31c36-355">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="31c36-356">数组是显示、 排序，并且再次显示。</span><span class="sxs-lookup"><span data-stu-id="31c36-356">The array is displayed, sorted, and displayed again.</span></span> <span data-ttu-id="31c36-357">数组必须进行排序以便使用<xref:System.Array.BinarySearch%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-357">Arrays must be sorted in order to use the <xref:System.Array.BinarySearch%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-358">对调用<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-358">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="31c36-359">如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-359">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="31c36-360"><xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载然后用于两个字符串搜索，另一个不在使用数组和一个，是。</span><span class="sxs-lookup"><span data-stu-id="31c36-360">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="31c36-361">数组和返回值的<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>方法传递给`ShowWhere`泛型方法，如果找到该字符串，而且否则元素的搜索字符串将介于像它是数组中显示的索引值。</span><span class="sxs-lookup"><span data-stu-id="31c36-361">The array and the return value of the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="31c36-362">索引是如果字符串不是 n 负数组，因此`ShowWhere`方法采用的按位求补 (~ 中 C# 和 Visual c + + 中，运算符`Xor`在 Visual Basic 中的为-1) 若要获取大于搜索 stri 列表中的第一个元素的索引ng。</span><span class="sxs-lookup"><span data-stu-id="31c36-362">The index is negative if the string is not n the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-363"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-363"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-364"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</span><span class="sxs-lookup"><span data-stu-id="31c36-364"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-365"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口</span><span class="sxs-lookup"><span data-stu-id="31c36-365"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface</span></span></exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-366">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-366">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-367">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-367">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-368">要搜索的范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-368">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-369">要搜索的范围的长度。</span><span class="sxs-lookup"><span data-stu-id="31c36-369">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-370">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-370">The object to search for.</span></span></param>
        <summary><span data-ttu-id="31c36-371">使用由 <see cref="T:System.Array" /> 中每个元素和指定值实现的 <see cref="T:System.IComparable`1" /> 泛型接口，在一维排序数组的某个元素范围中搜索值。</span><span class="sxs-lookup"><span data-stu-id="31c36-371">Searches a range of elements in a one-dimensional sorted array for a value, using the <see cref="T:System.IComparable`1" /> generic interface implemented by each element of the <see cref="T:System.Array" /> and by the specified value.</span></span></summary>
        <returns><span data-ttu-id="31c36-372">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="31c36-372">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="31c36-373">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-373">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="31c36-374">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-374">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="31c36-375">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="31c36-375">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-376">此方法不支持包含负索引的搜索数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-376">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="31c36-377">`array` 必须调用此方法之前进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-377">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="31c36-378">如果数组不包含指定的值，此方法将返回负整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-378">If the array does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="31c36-379">你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-379">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="31c36-380">如果此索引等于数组的大小，没有任何元素大于`value`数组中。</span><span class="sxs-lookup"><span data-stu-id="31c36-380">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="31c36-381">否则，它是大于第一个元素的索引`value`。</span><span class="sxs-lookup"><span data-stu-id="31c36-381">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="31c36-382">`T` 必须实现<xref:System.IComparable%601>泛型接口，用于比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-382">`T` must implement the <xref:System.IComparable%601> generic interface, which is used for comparisons.</span></span> <span data-ttu-id="31c36-383">元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable%601>实现; 否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="31c36-383">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="31c36-384">允许重复的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-384">Duplicate elements are allowed.</span></span> <span data-ttu-id="31c36-385">如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-385">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="31c36-386">`null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`不生成异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-386">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-387">为测试，每个元素`value`传递给相应<xref:System.IComparable%601>实现，即使`value`是`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-387">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="31c36-388">也就是说，<xref:System.IComparable%601>实现确定给定的元素如何比较到`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-388">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="31c36-389">此方法为 O (日志`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-389">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-390"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-390"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-391"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-391"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-392">或</span><span class="sxs-lookup"><span data-stu-id="31c36-392">-or-</span></span>  
  
 <span data-ttu-id="31c36-393"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-393"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-394"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-394"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-395">或</span><span class="sxs-lookup"><span data-stu-id="31c36-395">-or-</span></span>  
  
 <span data-ttu-id="31c36-396"><paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</span><span class="sxs-lookup"><span data-stu-id="31c36-396"><paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-397"><paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-397"><paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-398">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-398">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-399">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-399">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-400">要搜索的范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-400">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-401">要搜索的范围的长度。</span><span class="sxs-lookup"><span data-stu-id="31c36-401">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-402">要搜索的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-402">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="31c36-403">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-403">The <see cref="T:System.Collections.Generic.IComparer`1" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="31c36-404">或</span><span class="sxs-lookup"><span data-stu-id="31c36-404">-or-</span></span>  
  
 <span data-ttu-id="31c36-405">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-405"><see langword="null" /> to use the <see cref="T:System.IComparable`1" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="31c36-406">使用指定 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，在一维排序数组的某个元素范围中搜索值。</span><span class="sxs-lookup"><span data-stu-id="31c36-406">Searches a range of elements in a one-dimensional sorted array for a value, using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <returns><span data-ttu-id="31c36-407">如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。</span><span class="sxs-lookup"><span data-stu-id="31c36-407">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="31c36-408">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-408">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="31c36-409">如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。</span><span class="sxs-lookup"><span data-stu-id="31c36-409">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="31c36-410">如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</span><span class="sxs-lookup"><span data-stu-id="31c36-410">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-411">此方法不支持包含负索引的搜索数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-411">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="31c36-412">`array` 必须调用此方法之前进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-412">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="31c36-413">如果数组不包含指定的值，此方法将返回负整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-413">If the array does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="31c36-414">你可以应用按位求补运算符 (~ 在 C# 中，`Not`在 Visual Basic 中) 到负数的结果生成索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-414">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="31c36-415">如果此索引等于数组的大小，没有任何元素大于`value`数组中。</span><span class="sxs-lookup"><span data-stu-id="31c36-415">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="31c36-416">否则，它是大于第一个元素的索引`value`。</span><span class="sxs-lookup"><span data-stu-id="31c36-416">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="31c36-417">比较器自定义如何比较元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-417">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="31c36-418">例如，你可以使用<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>作为要执行不区分大小写的字符串搜索的比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-418">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="31c36-419">如果`comparer`不`null`的元素`array`与使用指定的指定值进行比较<xref:System.Collections.Generic.IComparer%601>泛型接口实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-419">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.Generic.IComparer%601> generic interface implementation.</span></span> <span data-ttu-id="31c36-420">元素`array`必须已在增加根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="31c36-420">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="31c36-421">如果`comparer`是`null`，完成比较使用<xref:System.IComparable%601>为类型提供的泛型接口实现`T`。</span><span class="sxs-lookup"><span data-stu-id="31c36-421">If `comparer` is `null`, the comparison is done using the <xref:System.IComparable%601> generic interface implementation provided for type `T`.</span></span> <span data-ttu-id="31c36-422">元素`array`必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable%601>实现; 否则，结果可能不正确。</span><span class="sxs-lookup"><span data-stu-id="31c36-422">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="31c36-423">允许重复的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-423">Duplicate elements are allowed.</span></span> <span data-ttu-id="31c36-424">如果<xref:System.Array>包含多个元素等于`value`，此方法返回的仅有一匹配项，并不一定的第一个索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-424">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="31c36-425">`null` 始终可以与任何其他引用类型; 比较因此，具有比较`null`使用时不生成异常<xref:System.IComparable%601>。</span><span class="sxs-lookup"><span data-stu-id="31c36-425">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception when using <xref:System.IComparable%601>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-426">为测试，每个元素`value`传递给相应<xref:System.IComparable%601>实现，即使`value`是`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-426">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="31c36-427">也就是说，<xref:System.IComparable%601>实现确定给定的元素如何比较到`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-427">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="31c36-428">此方法为 O (日志`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-428">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-429"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-429"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-430"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-430"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-431">或</span><span class="sxs-lookup"><span data-stu-id="31c36-431">-or-</span></span>  
  
 <span data-ttu-id="31c36-432"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-432"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-433"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-433"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-434">或</span><span class="sxs-lookup"><span data-stu-id="31c36-434">-or-</span></span>  
  
 <span data-ttu-id="31c36-435"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</span><span class="sxs-lookup"><span data-stu-id="31c36-435"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-436"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-436"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-437">需要清除其元素的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-437">The array whose elements need to be cleared.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-438">要清除的一系列元素的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-438">The starting index of the range of elements to clear.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-439">要清除的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-439">The number of elements to clear.</span></span></param>
        <summary><span data-ttu-id="31c36-440">将数组中的某个范围的元素设置为每个元素类型的默认值。</span><span class="sxs-lookup"><span data-stu-id="31c36-440">Sets a range of elements in an array to the default value of each element type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-441">此方法将在数组中的每个元素重置为元素类型的默认值。</span><span class="sxs-lookup"><span data-stu-id="31c36-441">This method resets each element in an array to the element type's default value.</span></span> <span data-ttu-id="31c36-442">它设置每个元素的引用类型 (包括<xref:System.String>元素) 到`null`，并将值类型的元素设置为下表中显示的默认值。</span><span class="sxs-lookup"><span data-stu-id="31c36-442">It sets elements of reference types (including <xref:System.String> elements) to `null`, and sets elements of value types to the default values shown in the following table.</span></span>  
  
|<span data-ttu-id="31c36-443">类型</span><span class="sxs-lookup"><span data-stu-id="31c36-443">Type</span></span>|<span data-ttu-id="31c36-444">“值”</span><span class="sxs-lookup"><span data-stu-id="31c36-444">Value</span></span>|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|<span data-ttu-id="31c36-445">所有整型和浮点数字类型</span><span class="sxs-lookup"><span data-stu-id="31c36-445">All integral and floating point numeric types</span></span>|<span data-ttu-id="31c36-446">0 （零）</span><span class="sxs-lookup"><span data-stu-id="31c36-446">0 (zero)</span></span>|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|<span data-ttu-id="31c36-447">其他值类型</span><span class="sxs-lookup"><span data-stu-id="31c36-447">Other value types</span></span>|<span data-ttu-id="31c36-448">该类型的字段的默认值</span><span class="sxs-lookup"><span data-stu-id="31c36-448">Default value of the type's fields</span></span>|  
  
 <span data-ttu-id="31c36-449">范围清除元素换行从行至行多维数组中。</span><span class="sxs-lookup"><span data-stu-id="31c36-449">The range of cleared elements wrap from row to row in a multi-dimensional array.</span></span>  
  
 <span data-ttu-id="31c36-450">此方法仅清除元素; 的值它不会删除元素本身。</span><span class="sxs-lookup"><span data-stu-id="31c36-450">This method only clears the values of the elements; it does not delete the elements themselves.</span></span> <span data-ttu-id="31c36-451">数组具有固定的大小，则因此，不能添加或删除元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-451">An array has a fixed size; therefore, elements cannot be added or removed.</span></span>  
  
 <span data-ttu-id="31c36-452">此方法为 O (`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-452">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-453">下面的示例使用<xref:System.Array.Clear%2A>方法来重置一维、 二维和三维数组中的整数值。</span><span class="sxs-lookup"><span data-stu-id="31c36-453">The following example uses the <xref:System.Array.Clear%2A> method to reset integer values in a one-dimensional, two-dimensional, and three-dimensional array.</span></span>  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 <span data-ttu-id="31c36-454">下面的示例定义`TimeZoneTime`结构，其中包含<xref:System.TimeZoneInfo>字段和<xref:System.DateTimeOffset>字段。</span><span class="sxs-lookup"><span data-stu-id="31c36-454">The following example defines a `TimeZoneTime` structure that includes a <xref:System.TimeZoneInfo> field and a <xref:System.DateTimeOffset> field.</span></span> <span data-ttu-id="31c36-455">然后，它调用<xref:System.Array.Clear%2A>方法清除在两个元素数组中的一个元素`TimeZoneTime`值。</span><span class="sxs-lookup"><span data-stu-id="31c36-455">It then calls the <xref:System.Array.Clear%2A> method to clear one element in a two-element array of `TimeZoneTime` values.</span></span> <span data-ttu-id="31c36-456">该方法将清除元素的值设置的默认值为<xref:System.TimeZoneInfo>对象，它是`null`，和的默认值<xref:System.DateTimeOffset>对象，它是<xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="31c36-456">The method sets the value of the cleared element to the default value of a <xref:System.TimeZoneInfo> object, which is `null`, and the default value of a <xref:System.DateTimeOffset> object, which is <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-457"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-457"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="31c36-458"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-458"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-459">或</span><span class="sxs-lookup"><span data-stu-id="31c36-459">-or-</span></span>  
  
 <span data-ttu-id="31c36-460"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-460"><paramref name="length" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-461">或</span><span class="sxs-lookup"><span data-stu-id="31c36-461">-or-</span></span>  
  
 <span data-ttu-id="31c36-462"><paramref name="index" /> 和 <paramref name="length" /> 大于 <paramref name="array" /> 的大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-462">The sum of <paramref name="index" /> and <paramref name="length" /> is greater than the size of <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31c36-463">创建 <see cref="T:System.Array" /> 的浅表副本。</span><span class="sxs-lookup"><span data-stu-id="31c36-463">Creates a shallow copy of the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="31c36-464"><see cref="T:System.Array" /> 的浅表副本。</span><span class="sxs-lookup"><span data-stu-id="31c36-464">A shallow copy of the <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-465">浅表复制<xref:System.Array>的元素复制<xref:System.Array>，无论它们是引用类型还是值类型，但它不会复制引用所引用的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-465">A shallow copy of an <xref:System.Array> copies only the elements of the <xref:System.Array>, whether they are reference types or value types, but it does not copy the objects that the references refer to.</span></span> <span data-ttu-id="31c36-466">在新的引用<xref:System.Array>指向相同对象的原始中的引用<xref:System.Array>指向。</span><span class="sxs-lookup"><span data-stu-id="31c36-466">The references in the new <xref:System.Array> point to the same objects that the references in the original <xref:System.Array> point to.</span></span>  
  
 <span data-ttu-id="31c36-467">与此相反的深层副本<xref:System.Array>将复制的元素，并直接或间接引用的元素的所有内容。</span><span class="sxs-lookup"><span data-stu-id="31c36-467">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="31c36-468">克隆属于相同<xref:System.Type>与原始<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-468">The clone is of the same <xref:System.Type> as the original <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-469">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="31c36-469">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-470">下面的代码示例克隆<xref:System.Globalization.CultureInfo?displayProperty=nameWithType>数组和演示的浅表副本的行为。</span><span class="sxs-lookup"><span data-stu-id="31c36-470">The following code example clones a <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> array and demonstrates the behavior of a shallow copy.</span></span>  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="31c36-471">包含要复制的数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-471">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="sourceIndex"><span data-ttu-id="31c36-472">一个 32 位整数，它表示 <c>sourceArray</c> 中复制开始处的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-472">A 32-bit integer that represents the index in the <c>sourceArray</c> at which copying begins.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="31c36-473">接收数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-473">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="31c36-474">一个 32 位整数，它表示 <c>destinationArray</c> 中存储开始处的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-474">A 32-bit integer that represents the index in the <c>destinationArray</c> at which storing begins.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-475">一个 32 位整数，它表示要复制的元素数目。</span><span class="sxs-lookup"><span data-stu-id="31c36-475">A 32-bit integer that represents the number of elements to copy.</span></span></param>
        <summary><span data-ttu-id="31c36-476">复制 <see cref="T:System.Array" /> 中的一系列元素（从指定的源索引开始），并将它们粘贴到另一 <see cref="T:System.Array" /> 中（从指定的目标索引开始）。</span><span class="sxs-lookup"><span data-stu-id="31c36-476">Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index.</span></span>  <span data-ttu-id="31c36-477">保证在复制未成功完成的情况下撤消所有更改。</span><span class="sxs-lookup"><span data-stu-id="31c36-477">Guarantees that all changes are undone if the copy does not succeed completely.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-478">`sourceArray`和`destinationArray`参数必须具有相同数量的维度。</span><span class="sxs-lookup"><span data-stu-id="31c36-478">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span>  <span data-ttu-id="31c36-479">`sourceArray`类型必须相同或派生自`destinationArray`类型; 否则为<xref:System.ArrayTypeMismatchException>引发。</span><span class="sxs-lookup"><span data-stu-id="31c36-479">The `sourceArray` type must be the same as or derived from the `destinationArray` type; otherwise, an <xref:System.ArrayTypeMismatchException> is thrown.</span></span>  <span data-ttu-id="31c36-480">与不同<xref:System.Array.Copy%2A>，<xref:System.Array.ConstrainedCopy%2A>在执行任何操作之前验证数组类型的兼容性。</span><span class="sxs-lookup"><span data-stu-id="31c36-480">Unlike <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> verifies the compatibility of the array types before performing any operation.</span></span>  
  
 <span data-ttu-id="31c36-481">在多维阵列之间复制时，该数组表现得像是长时间一维数组，其中的行 （或多个列） 从概念上讲列出了端到端。</span><span class="sxs-lookup"><span data-stu-id="31c36-481">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</span></span> <span data-ttu-id="31c36-482">例如，如果数组有三个行 （列） 带有四个元素从数组的开头的每个，复制的六个元素会将复制所有四个元素的第一行 （或列） 和第二个行 （或列） 的前两个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-482">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span> <span data-ttu-id="31c36-483">第三个行 （或列），第二个元素从其开始复制`sourceIndex`必须是第一个行 （或列） 的上限加上的第二个行 （或列） 的长度值，再加上 2。</span><span class="sxs-lookup"><span data-stu-id="31c36-483">To start copying from the second element of the third row (or column), `sourceIndex` must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</span></span>  
  
 <span data-ttu-id="31c36-484">如果`sourceArray`和`destinationArray`重叠，此方法的行为就像的原始值`sourceArray`在临时位置之前保留`destinationArray`将被覆盖。</span><span class="sxs-lookup"><span data-stu-id="31c36-484">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="31c36-485">[C++]</span><span class="sxs-lookup"><span data-stu-id="31c36-485">[C++]</span></span>  
  
 <span data-ttu-id="31c36-486">此方法相当于标准的 C/c + + 函数`memmove`，而不`memcpy`。</span><span class="sxs-lookup"><span data-stu-id="31c36-486">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="31c36-487">数组可以是引用类型的数组或值类型数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-487">The arrays can be reference-type arrays or value-type arrays.</span></span>  <span data-ttu-id="31c36-488">如果`sourceArray`和`destinationArray`两个引用类型数组或类型的两个数组<xref:System.Object>，执行的浅表副本。</span><span class="sxs-lookup"><span data-stu-id="31c36-488">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="31c36-489">浅表复制<xref:System.Array>是一种新<xref:System.Array>包含对原始与相同的元素的引用<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-489">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="31c36-490">元素本身或任何引用的元素不会复制。</span><span class="sxs-lookup"><span data-stu-id="31c36-490">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="31c36-491">与此相反的深层副本<xref:System.Array>将复制的元素，并直接或间接引用的元素的所有内容。</span><span class="sxs-lookup"><span data-stu-id="31c36-491">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="31c36-492">如果此方法将引发时复制时，出现异常`destinationArray`保持不变; 因此，<xref:System.Array.ConstrainedCopy%2A>可以受约束的执行区域内使用 (<xref:System.Runtime.ConstrainedExecution.Cer>)。</span><span class="sxs-lookup"><span data-stu-id="31c36-492">If this method throws an exception while copying, the `destinationArray` remains unchanged; therefore, <xref:System.Array.ConstrainedCopy%2A> can be used within a constrained execution region (<xref:System.Runtime.ConstrainedExecution.Cer>).</span></span>  
  
 <span data-ttu-id="31c36-493">此方法为 O (`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-493">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-494"><paramref name="sourceArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-494"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-495">或</span><span class="sxs-lookup"><span data-stu-id="31c36-495">-or-</span></span>  
  
 <span data-ttu-id="31c36-496"><paramref name="destinationArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-496"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-497"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</span><span class="sxs-lookup"><span data-stu-id="31c36-497"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="31c36-498"><paramref name="sourceArray" /> 类型与 <paramref name="destinationArray" /> 类型不同，且不派生自后者。</span><span class="sxs-lookup"><span data-stu-id="31c36-498">The <paramref name="sourceArray" /> type is neither the same as nor derived from the <paramref name="destinationArray" /> type.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="31c36-499"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-499">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-500"><paramref name="sourceIndex" /> 少于 <paramref name="sourceArray" /> 的第一个维度的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-500"><paramref name="sourceIndex" /> is less than the lower bound of the first dimension of <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="31c36-501">或</span><span class="sxs-lookup"><span data-stu-id="31c36-501">-or-</span></span>  
  
 <span data-ttu-id="31c36-502"><paramref name="destinationIndex" /> 少于 <paramref name="destinationArray" /> 的第一个维度的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-502"><paramref name="destinationIndex" /> is less than the lower bound of the first dimension of <paramref name="destinationArray" />.</span></span>  
  
 <span data-ttu-id="31c36-503">或</span><span class="sxs-lookup"><span data-stu-id="31c36-503">-or-</span></span>  
  
 <span data-ttu-id="31c36-504"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-504"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-505"><paramref name="length" /> 大于从 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 末尾的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-505"><paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="31c36-506">或</span><span class="sxs-lookup"><span data-stu-id="31c36-506">-or-</span></span>  
  
 <span data-ttu-id="31c36-507"><paramref name="length" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 末尾的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-507"><paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput"><span data-ttu-id="31c36-508">源数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-508">The type of the elements of the source array.</span></span></typeparam>
        <typeparam name="TOutput"><span data-ttu-id="31c36-509">目标数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-509">The type of the elements of the target array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-510">要转换为目标类型的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-510">The one-dimensional, zero-based <see cref="T:System.Array" /> to convert to a target type.</span></span></param>
        <param name="converter"><span data-ttu-id="31c36-511">用于将每个元素从一种类型转换为另一种类型的 <see cref="T:System.Converter`2" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-511">A <see cref="T:System.Converter`2" /> that converts each element from one type to another type.</span></span></param>
        <summary><span data-ttu-id="31c36-512">将一种类型的数组转换为另一种类型的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-512">Converts an array of one type to an array of another type.</span></span></summary>
        <returns><span data-ttu-id="31c36-513">目标类型的数组，包含从源数组转换而来的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-513">An array of the target type containing the converted elements from the source array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-514"><xref:System.Converter%602>是将对象转换为目标类型的方法的委托。</span><span class="sxs-lookup"><span data-stu-id="31c36-514">The <xref:System.Converter%602> is a delegate to a method that converts an object to the target type.</span></span>  <span data-ttu-id="31c36-515">元素`array`单独传递给<xref:System.Converter%602>，和转换后的元素保存在新的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-515">The elements of `array` are individually passed to the <xref:System.Converter%602>, and the converted elements are saved in the new array.</span></span>  
  
 <span data-ttu-id="31c36-516">源`array`保持不变。</span><span class="sxs-lookup"><span data-stu-id="31c36-516">The source `array` remains unchanged.</span></span>  
  
 <span data-ttu-id="31c36-517">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-517">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-518">下面的代码示例定义一个名为方法`PointFToPoint`，用于将转换<xref:System.Drawing.PointF>结构<xref:System.Drawing.Point>结构。</span><span class="sxs-lookup"><span data-stu-id="31c36-518">The following code example defines a method named `PointFToPoint` that converts a <xref:System.Drawing.PointF> structure to a <xref:System.Drawing.Point> structure.</span></span> <span data-ttu-id="31c36-519">然后，示例创建的数组<xref:System.Drawing.PointF>结构，创建`Converter<PointF, Point>`委托 (`Converter(Of PointF, Point)`在 Visual Basic 中) 来表示`PointFToPoint`方法，并将传递到委托<xref:System.Array.ConvertAll%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-519">The example then creates an array of <xref:System.Drawing.PointF> structures, creates a `Converter<PointF, Point>` delegate (`Converter(Of PointF, Point)` in Visual Basic) to represent the `PointFToPoint` method, and passes the delegate to the <xref:System.Array.ConvertAll%2A> method.</span></span> <span data-ttu-id="31c36-520"><xref:System.Array.ConvertAll%2A>方法将传递到输入列表的每个元素`PointFToPoint`方法并将转换后的元素放入一个新的列表<xref:System.Drawing.Point>结构。</span><span class="sxs-lookup"><span data-stu-id="31c36-520">The <xref:System.Array.ConvertAll%2A> method passes each element of the input list to the `PointFToPoint` method and puts the converted elements into a new list of <xref:System.Drawing.Point> structures.</span></span> <span data-ttu-id="31c36-521">显示这两个列表。</span><span class="sxs-lookup"><span data-stu-id="31c36-521">Both lists are displayed.</span></span>  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-522"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-522"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-523">或</span><span class="sxs-lookup"><span data-stu-id="31c36-523">-or-</span></span>  
  
 <span data-ttu-id="31c36-524"><paramref name="converter" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-524"><paramref name="converter" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31c36-525">将一个 <see cref="T:System.Array" /> 的一部分元素复制到另一个 <see cref="T:System.Array" /> 中，并根据需要执行类型强制转换和装箱。</span><span class="sxs-lookup"><span data-stu-id="31c36-525">Copies a range of elements in one <see cref="T:System.Array" /> to another <see cref="T:System.Array" /> and performs type casting and boxing as required.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="31c36-526">包含要复制的数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-526">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="31c36-527">接收数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-527">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-528">一个 32 位整数，它表示要复制的元素数目。</span><span class="sxs-lookup"><span data-stu-id="31c36-528">A 32-bit integer that represents the number of elements to copy.</span></span></param>
        <summary><span data-ttu-id="31c36-529">从第一个元素开始复制 <see cref="T:System.Array" /> 中的一系列元素，将它们粘贴到另一 <see cref="T:System.Array" /> 中（从第一个元素开始）。</span><span class="sxs-lookup"><span data-stu-id="31c36-529">Copies a range of elements from an <see cref="T:System.Array" /> starting at the first element and pastes them into another <see cref="T:System.Array" /> starting at the first element.</span></span> <span data-ttu-id="31c36-530">长度指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-530">The length is specified as a 32-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-531">`sourceArray`和`destinationArray`参数必须具有相同数量的维度。</span><span class="sxs-lookup"><span data-stu-id="31c36-531">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="31c36-532">此外，`destinationArray`必须已具有已指定维度，并且必须具有足够数量的元素，以容纳所复制的数据。</span><span class="sxs-lookup"><span data-stu-id="31c36-532">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="31c36-533">在多维阵列之间复制时，数组表现得像是长时间一维数组，其中的行 （或多个列） 从概念上讲首尾相连。</span><span class="sxs-lookup"><span data-stu-id="31c36-533">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</span></span> <span data-ttu-id="31c36-534">例如，如果数组有三个行 （列） 带有四个元素从数组的开头的每个，复制的六个元素会将复制所有四个元素的第一行 （或列） 和第二个行 （或列） 的前两个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-534">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span>  
  
 <span data-ttu-id="31c36-535">如果`sourceArray`和`destinationArray`重叠，此方法的行为就像的原始值`sourceArray`在临时位置之前保留`destinationArray`将被覆盖。</span><span class="sxs-lookup"><span data-stu-id="31c36-535">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="31c36-536">[C++]</span><span class="sxs-lookup"><span data-stu-id="31c36-536">[C++]</span></span>  
  
 <span data-ttu-id="31c36-537">此方法相当于标准的 C/c + + 函数`memmove`，而不`memcpy`。</span><span class="sxs-lookup"><span data-stu-id="31c36-537">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="31c36-538">数组可以是引用类型的数组或值类型数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-538">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="31c36-539">执行类型转换，则所需的方式。</span><span class="sxs-lookup"><span data-stu-id="31c36-539">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="31c36-540">当从引用类型的数组复制到值类型的数组，每个元素是取消装箱，然后将其复制。</span><span class="sxs-lookup"><span data-stu-id="31c36-540">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="31c36-541">当从值类型数组复制到引用类型的数组，每个元素被装箱，然后将其复制。</span><span class="sxs-lookup"><span data-stu-id="31c36-541">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="31c36-542">在复制到一个引用类型或值类型数组中<xref:System.Object>数组，<xref:System.Object>然后复制并创建来保存每个值或引用。</span><span class="sxs-lookup"><span data-stu-id="31c36-542">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="31c36-543">当从复制<xref:System.Object>到引用类型或值类型数组和分配的数组不能，<xref:System.InvalidCastException>引发。</span><span class="sxs-lookup"><span data-stu-id="31c36-543">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="31c36-544">如果`sourceArray`和`destinationArray`两个引用类型数组或类型的两个数组<xref:System.Object>，执行的浅表副本。</span><span class="sxs-lookup"><span data-stu-id="31c36-544">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="31c36-545">浅表复制<xref:System.Array>是一种新<xref:System.Array>包含对原始与相同的元素的引用<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-545">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="31c36-546">元素本身或任何引用的元素不会复制。</span><span class="sxs-lookup"><span data-stu-id="31c36-546">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="31c36-547">与此相反的深层副本<xref:System.Array>将复制的元素，并直接或间接引用的元素的所有内容。</span><span class="sxs-lookup"><span data-stu-id="31c36-547">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="31c36-548"><xref:System.ArrayTypeMismatchException>引发如果数组的不可兼容类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-548">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="31c36-549">类型兼容性定义如下：</span><span class="sxs-lookup"><span data-stu-id="31c36-549">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="31c36-550">一种类型适用于本身。</span><span class="sxs-lookup"><span data-stu-id="31c36-550">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="31c36-551">值类型适用于<xref:System.Object>和与该值类型实现的接口类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-551">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="31c36-552">值类型被视为连接的接口，仅当它直接实现该接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-552">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="31c36-553">断开连接的类型不兼容。</span><span class="sxs-lookup"><span data-stu-id="31c36-553">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="31c36-554">两个内部函数 （预定义） 的值类型相兼容。 如果将源类型从复制到目标类型是一个的扩大转换。</span><span class="sxs-lookup"><span data-stu-id="31c36-554">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="31c36-555">扩大转换永远不会丢失信息，而收缩转换可能会丢失信息。</span><span class="sxs-lookup"><span data-stu-id="31c36-555">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="31c36-556">例如，将一个 32 位带符号的整数转换为 64 位有符号整数是扩大转换，并将一个 64 位带符号的整数转换为 32 位有符号整数都是收缩转换。</span><span class="sxs-lookup"><span data-stu-id="31c36-556">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="31c36-557">有关转换的详细信息，请参阅<xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="31c36-557">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="31c36-558">内部 （用户定义） 的值类型是只与其本身兼容。</span><span class="sxs-lookup"><span data-stu-id="31c36-558">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="31c36-559">枚举具有隐式转换为<xref:System.Enum>和为其基础类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-559">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="31c36-560">如果在每个元素`sourceArray`需要向下转换 （例如，从派生类的基类或接口的对象） 和一个或多个元素不能强制转换为中的对应类型`destinationArray`、<xref:System.InvalidCastException>引发。</span><span class="sxs-lookup"><span data-stu-id="31c36-560">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="31c36-561">如果此方法将引发异常时复制的状态`destinationArray`是不确定的。</span><span class="sxs-lookup"><span data-stu-id="31c36-561">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="31c36-562">此方法为 O (`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-562">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-563"><paramref name="sourceArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-563"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-564">或</span><span class="sxs-lookup"><span data-stu-id="31c36-564">-or-</span></span>  
  
 <span data-ttu-id="31c36-565"><paramref name="destinationArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-565"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-566"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</span><span class="sxs-lookup"><span data-stu-id="31c36-566"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <span data-ttu-id="31c36-567"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-567"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="31c36-568"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-568">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-569"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-569"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-570"><paramref name="length" /> 大于 <paramref name="sourceArray" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-570"><paramref name="length" /> is greater than the number of elements in <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="31c36-571">或</span><span class="sxs-lookup"><span data-stu-id="31c36-571">-or-</span></span>  
  
 <span data-ttu-id="31c36-572"><paramref name="length" /> 大于 <paramref name="destinationArray" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-572"><paramref name="length" /> is greater than the number of elements in <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="31c36-573">包含要复制的数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-573">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="31c36-574">接收数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-574">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-575">一个 64 位整数，它表示要复制的元素数目。</span><span class="sxs-lookup"><span data-stu-id="31c36-575">A 64-bit integer that represents the number of elements to copy.</span></span> <span data-ttu-id="31c36-576">该整数必须介于零和 <see cref="F:System.Int32.MaxValue" /> 之间（包括这两个值）。</span><span class="sxs-lookup"><span data-stu-id="31c36-576">The integer must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</span></span></param>
        <summary><span data-ttu-id="31c36-577">从第一个元素开始复制 <see cref="T:System.Array" /> 中的一系列元素，将它们粘贴到另一 <see cref="T:System.Array" /> 中（从第一个元素开始）。</span><span class="sxs-lookup"><span data-stu-id="31c36-577">Copies a range of elements from an <see cref="T:System.Array" /> starting at the first element and pastes them into another <see cref="T:System.Array" /> starting at the first element.</span></span> <span data-ttu-id="31c36-578">长度指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-578">The length is specified as a 64-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-579">`sourceArray`和`destinationArray`参数必须具有相同数量的维度。</span><span class="sxs-lookup"><span data-stu-id="31c36-579">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="31c36-580">此外，`destinationArray`必须已具有已指定维度，并且必须具有足够数量的元素，以容纳所复制的数据。</span><span class="sxs-lookup"><span data-stu-id="31c36-580">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="31c36-581">在多维阵列之间复制时，数组表现得像是长时间一维数组，其中的行 （或多个列） 从概念上讲首尾相连。</span><span class="sxs-lookup"><span data-stu-id="31c36-581">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</span></span> <span data-ttu-id="31c36-582">例如，如果数组有三个行 （列） 带有四个元素从数组的开头的每个，复制的六个元素会将复制所有四个元素的第一行 （或列） 和第二个行 （或列） 的前两个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-582">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span>  
  
 <span data-ttu-id="31c36-583">如果`sourceArray`和`destinationArray`重叠，此方法的行为就像的原始值`sourceArray`在临时位置之前保留`destinationArray`将被覆盖。</span><span class="sxs-lookup"><span data-stu-id="31c36-583">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="31c36-584">[C++]</span><span class="sxs-lookup"><span data-stu-id="31c36-584">[C++]</span></span>  
  
 <span data-ttu-id="31c36-585">此方法相当于标准的 C/c + + 函数`memmove`，而不`memcpy`。</span><span class="sxs-lookup"><span data-stu-id="31c36-585">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="31c36-586">数组可以是引用类型的数组或值类型数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-586">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="31c36-587">执行类型转换，则所需的方式。</span><span class="sxs-lookup"><span data-stu-id="31c36-587">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="31c36-588">当从引用类型的数组复制到值类型的数组，每个元素是取消装箱，然后将其复制。</span><span class="sxs-lookup"><span data-stu-id="31c36-588">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="31c36-589">当从值类型数组复制到引用类型的数组，每个元素被装箱，然后将其复制。</span><span class="sxs-lookup"><span data-stu-id="31c36-589">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="31c36-590">在复制到一个引用类型或值类型数组中<xref:System.Object>数组，<xref:System.Object>然后复制并创建来保存每个值或引用。</span><span class="sxs-lookup"><span data-stu-id="31c36-590">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="31c36-591">当从复制<xref:System.Object>到引用类型或值类型数组和分配的数组不能，<xref:System.InvalidCastException>引发。</span><span class="sxs-lookup"><span data-stu-id="31c36-591">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="31c36-592">如果`sourceArray`和`destinationArray`两个引用类型数组或类型的两个数组<xref:System.Object>，执行的浅表副本。</span><span class="sxs-lookup"><span data-stu-id="31c36-592">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="31c36-593">浅表复制<xref:System.Array>是一种新<xref:System.Array>包含对原始与相同的元素的引用<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-593">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="31c36-594">元素本身或任何引用的元素不会复制。</span><span class="sxs-lookup"><span data-stu-id="31c36-594">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="31c36-595">与此相反的深层副本<xref:System.Array>将复制的元素，并直接或间接引用的元素的所有内容。</span><span class="sxs-lookup"><span data-stu-id="31c36-595">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="31c36-596"><xref:System.ArrayTypeMismatchException>引发如果数组的不可兼容类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-596">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="31c36-597">类型兼容性定义如下：</span><span class="sxs-lookup"><span data-stu-id="31c36-597">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="31c36-598">一种类型适用于本身。</span><span class="sxs-lookup"><span data-stu-id="31c36-598">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="31c36-599">值类型适用于<xref:System.Object>和与该值类型实现的接口类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-599">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="31c36-600">值类型被视为连接的接口，仅当它直接实现该接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-600">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="31c36-601">断开连接的类型不兼容。</span><span class="sxs-lookup"><span data-stu-id="31c36-601">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="31c36-602">两个内部函数 （预定义） 的值类型相兼容。 如果将源类型从复制到目标类型是一个的扩大转换。</span><span class="sxs-lookup"><span data-stu-id="31c36-602">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="31c36-603">扩大转换永远不会丢失信息，而收缩转换可能会丢失信息。</span><span class="sxs-lookup"><span data-stu-id="31c36-603">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="31c36-604">例如，将一个 32 位带符号的整数转换为 64 位有符号整数是扩大转换，并将一个 64 位带符号的整数转换为 32 位有符号整数都是收缩转换。</span><span class="sxs-lookup"><span data-stu-id="31c36-604">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="31c36-605">有关转换的详细信息，请参阅<xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="31c36-605">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="31c36-606">内部 （用户定义） 的值类型是只与其本身兼容。</span><span class="sxs-lookup"><span data-stu-id="31c36-606">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="31c36-607">枚举具有隐式转换为<xref:System.Enum>和为其基础类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-607">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="31c36-608">如果在每个元素`sourceArray`需要向下转换 （例如，从派生类的基类或接口的对象） 和一个或多个元素不能强制转换为中的对应类型`destinationArray`、<xref:System.InvalidCastException>引发。</span><span class="sxs-lookup"><span data-stu-id="31c36-608">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="31c36-609">如果此方法将引发异常时复制的状态`destinationArray`是不确定的。</span><span class="sxs-lookup"><span data-stu-id="31c36-609">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="31c36-610">此方法为 O (`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-610">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-611"><paramref name="sourceArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-611"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-612">或</span><span class="sxs-lookup"><span data-stu-id="31c36-612">-or-</span></span>  
  
 <span data-ttu-id="31c36-613"><paramref name="destinationArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-613"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-614"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</span><span class="sxs-lookup"><span data-stu-id="31c36-614"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <span data-ttu-id="31c36-615"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-615"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="31c36-616"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-616">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-617"><paramref name="length" /> 小于 0 或大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-617"><paramref name="length" /> is less than 0 or greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-618"><paramref name="length" /> 大于 <paramref name="sourceArray" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-618"><paramref name="length" /> is greater than the number of elements in <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="31c36-619">或</span><span class="sxs-lookup"><span data-stu-id="31c36-619">-or-</span></span>  
  
 <span data-ttu-id="31c36-620"><paramref name="length" /> 大于 <paramref name="destinationArray" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-620"><paramref name="length" /> is greater than the number of elements in <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="31c36-621">包含要复制的数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-621">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="sourceIndex"><span data-ttu-id="31c36-622">一个 32 位整数，它表示 <c>sourceArray</c> 中复制开始处的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-622">A 32-bit integer that represents the index in the <c>sourceArray</c> at which copying begins.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="31c36-623">接收数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-623">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="31c36-624">一个 32 位整数，它表示 <c>destinationArray</c> 中存储开始处的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-624">A 32-bit integer that represents the index in the <c>destinationArray</c> at which storing begins.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-625">一个 32 位整数，它表示要复制的元素数目。</span><span class="sxs-lookup"><span data-stu-id="31c36-625">A 32-bit integer that represents the number of elements to copy.</span></span></param>
        <summary><span data-ttu-id="31c36-626">复制 <see cref="T:System.Array" /> 中的一系列元素（从指定的源索引开始），并将它们粘贴到另一 <see cref="T:System.Array" /> 中（从指定的目标索引开始）。</span><span class="sxs-lookup"><span data-stu-id="31c36-626">Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index.</span></span> <span data-ttu-id="31c36-627">长度和索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-627">The length and the indexes are specified as 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-628">`sourceArray`和`destinationArray`参数必须具有相同数量的维度。</span><span class="sxs-lookup"><span data-stu-id="31c36-628">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="31c36-629">此外，`destinationArray`必须已具有已指定维度，并且必须具有足够数量的元素从开始`destinationIndex`以容纳所复制的数据的位置。</span><span class="sxs-lookup"><span data-stu-id="31c36-629">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements starting from the `destinationIndex` position to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="31c36-630">在多维阵列之间复制时，该数组表现得像是长时间一维数组，其中的行 （或多个列） 从概念上讲列出了端到端。</span><span class="sxs-lookup"><span data-stu-id="31c36-630">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</span></span> <span data-ttu-id="31c36-631">例如，如果数组有三个行 （列） 带有四个元素从数组的开头的每个，复制的六个元素会将复制所有四个元素的第一行 （或列） 和第二个行 （或列） 的前两个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-631">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span> <span data-ttu-id="31c36-632">第三个行 （或列），第二个元素从其开始复制`sourceIndex`必须是第一个行 （或列） 的上限加上的第二个行 （或列） 的长度值，再加上 2。</span><span class="sxs-lookup"><span data-stu-id="31c36-632">To start copying from the second element of the third row (or column), `sourceIndex` must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</span></span>  
  
 <span data-ttu-id="31c36-633">如果`sourceArray`和`destinationArray`重叠，此方法的行为就像的原始值`sourceArray`在临时位置之前保留`destinationArray`将被覆盖。</span><span class="sxs-lookup"><span data-stu-id="31c36-633">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="31c36-634">[C++]</span><span class="sxs-lookup"><span data-stu-id="31c36-634">[C++]</span></span>  
  
 <span data-ttu-id="31c36-635">此方法相当于标准的 C/c + + 函数`memmove`，而不`memcpy`。</span><span class="sxs-lookup"><span data-stu-id="31c36-635">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="31c36-636">数组可以是引用类型的数组或值类型数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-636">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="31c36-637">执行类型转换，则所需的方式。</span><span class="sxs-lookup"><span data-stu-id="31c36-637">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="31c36-638">当从引用类型的数组复制到值类型的数组，每个元素是取消装箱，然后将其复制。</span><span class="sxs-lookup"><span data-stu-id="31c36-638">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="31c36-639">当从值类型数组复制到引用类型的数组，每个元素被装箱，然后将其复制。</span><span class="sxs-lookup"><span data-stu-id="31c36-639">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="31c36-640">在复制到一个引用类型或值类型数组中<xref:System.Object>数组，<xref:System.Object>然后复制并创建来保存每个值或引用。</span><span class="sxs-lookup"><span data-stu-id="31c36-640">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="31c36-641">当从复制<xref:System.Object>到引用类型或值类型数组和分配的数组不能，<xref:System.InvalidCastException>引发。</span><span class="sxs-lookup"><span data-stu-id="31c36-641">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="31c36-642">如果`sourceArray`和`destinationArray`两个引用类型数组或类型的两个数组<xref:System.Object>，执行的浅表副本。</span><span class="sxs-lookup"><span data-stu-id="31c36-642">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="31c36-643">浅表复制<xref:System.Array>是一种新<xref:System.Array>包含对原始与相同的元素的引用<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-643">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="31c36-644">元素本身或任何引用的元素不会复制。</span><span class="sxs-lookup"><span data-stu-id="31c36-644">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="31c36-645">与此相反的深层副本<xref:System.Array>将复制的元素，并直接或间接引用的元素的所有内容。</span><span class="sxs-lookup"><span data-stu-id="31c36-645">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="31c36-646"><xref:System.ArrayTypeMismatchException>引发如果数组的不可兼容类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-646">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="31c36-647">类型兼容性定义如下：</span><span class="sxs-lookup"><span data-stu-id="31c36-647">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="31c36-648">一种类型适用于本身。</span><span class="sxs-lookup"><span data-stu-id="31c36-648">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="31c36-649">值类型适用于<xref:System.Object>和与该值类型实现的接口类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-649">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="31c36-650">值类型被视为连接的接口，仅当它直接实现该接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-650">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="31c36-651">断开连接的类型不兼容。</span><span class="sxs-lookup"><span data-stu-id="31c36-651">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="31c36-652">两个内部函数 （预定义） 的值类型相兼容。 如果将源类型从复制到目标类型是一个的扩大转换。</span><span class="sxs-lookup"><span data-stu-id="31c36-652">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="31c36-653">扩大转换永远不会丢失信息，而收缩转换可能会丢失信息。</span><span class="sxs-lookup"><span data-stu-id="31c36-653">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="31c36-654">例如，将一个 32 位带符号的整数转换为 64 位有符号整数是扩大转换，并将一个 64 位带符号的整数转换为 32 位有符号整数都是收缩转换。</span><span class="sxs-lookup"><span data-stu-id="31c36-654">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="31c36-655">有关转换的详细信息，请参阅<xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="31c36-655">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="31c36-656">内部 （用户定义） 的值类型是只与其本身兼容。</span><span class="sxs-lookup"><span data-stu-id="31c36-656">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="31c36-657">枚举具有隐式转换为<xref:System.Enum>和为其基础类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-657">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="31c36-658">如果在每个元素`sourceArray`需要向下转换 （例如，从派生类的基类或接口的对象） 和一个或多个元素不能强制转换为中的对应类型`destinationArray`、<xref:System.InvalidCastException>引发。</span><span class="sxs-lookup"><span data-stu-id="31c36-658">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="31c36-659">如果此方法将引发异常时复制的状态`destinationArray`是不确定的。</span><span class="sxs-lookup"><span data-stu-id="31c36-659">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="31c36-660">此方法为 O (`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-660">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-661">下面的代码示例演示如何从某个复制<xref:System.Array>类型的<xref:System.Object>到另一个<xref:System.Array>的整数类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-661">The following code example shows how to copy from one <xref:System.Array> of type <xref:System.Object> to another <xref:System.Array> of type integer.</span></span>  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-662"><paramref name="sourceArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-662"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-663">或</span><span class="sxs-lookup"><span data-stu-id="31c36-663">-or-</span></span>  
  
 <span data-ttu-id="31c36-664"><paramref name="destinationArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-664"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-665"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</span><span class="sxs-lookup"><span data-stu-id="31c36-665"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <span data-ttu-id="31c36-666"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-666"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="31c36-667"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-667">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-668"><paramref name="sourceIndex" /> 少于 <paramref name="sourceArray" /> 的第一个维度的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-668"><paramref name="sourceIndex" /> is less than the lower bound of the first dimension of <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="31c36-669">或</span><span class="sxs-lookup"><span data-stu-id="31c36-669">-or-</span></span>  
  
 <span data-ttu-id="31c36-670"><paramref name="destinationIndex" /> 少于 <paramref name="destinationArray" /> 的第一个维度的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-670"><paramref name="destinationIndex" /> is less than the lower bound of the first dimension of <paramref name="destinationArray" />.</span></span>  
  
 <span data-ttu-id="31c36-671">或</span><span class="sxs-lookup"><span data-stu-id="31c36-671">-or-</span></span>  
  
 <span data-ttu-id="31c36-672"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-672"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-673"><paramref name="length" /> 大于从 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 末尾的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-673"><paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="31c36-674">或</span><span class="sxs-lookup"><span data-stu-id="31c36-674">-or-</span></span>  
  
 <span data-ttu-id="31c36-675"><paramref name="length" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 末尾的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-675"><paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="31c36-676">包含要复制的数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-676">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="sourceIndex"><span data-ttu-id="31c36-677">一个 64 位整数，它表示 <c>sourceArray</c> 中复制开始处的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-677">A 64-bit integer that represents the index in the <c>sourceArray</c> at which copying begins.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="31c36-678">接收数据的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-678">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="31c36-679">一个 64 位整数，它表示 <c>destinationArray</c> 中存储开始处的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-679">A 64-bit integer that represents the index in the <c>destinationArray</c> at which storing begins.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-680">一个 64 位整数，它表示要复制的元素数目。</span><span class="sxs-lookup"><span data-stu-id="31c36-680">A 64-bit integer that represents the number of elements to copy.</span></span> <span data-ttu-id="31c36-681">该整数必须介于零和 <see cref="F:System.Int32.MaxValue" /> 之间（包括这两个值）。</span><span class="sxs-lookup"><span data-stu-id="31c36-681">The integer must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</span></span></param>
        <summary><span data-ttu-id="31c36-682">复制 <see cref="T:System.Array" /> 中的一系列元素（从指定的源索引开始），并将它们粘贴到另一 <see cref="T:System.Array" /> 中（从指定的目标索引开始）。</span><span class="sxs-lookup"><span data-stu-id="31c36-682">Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index.</span></span> <span data-ttu-id="31c36-683">长度和索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-683">The length and the indexes are specified as 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-684">`sourceArray`和`destinationArray`参数必须具有相同数量的维度。</span><span class="sxs-lookup"><span data-stu-id="31c36-684">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="31c36-685">此外，`destinationArray`必须已具有已指定维度，并且必须具有足够数量的元素从开始`destinationIndex`以容纳所复制的数据的位置。</span><span class="sxs-lookup"><span data-stu-id="31c36-685">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements starting from the `destinationIndex` position to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="31c36-686">在多维阵列之间复制时，该数组表现得像是长时间一维数组，其中的行 （或多个列） 从概念上讲列出了端到端。</span><span class="sxs-lookup"><span data-stu-id="31c36-686">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</span></span> <span data-ttu-id="31c36-687">例如，如果数组有三个行 （列） 带有四个元素从数组的开头的每个，复制的六个元素会将复制所有四个元素的第一行 （或列） 和第二个行 （或列） 的前两个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-687">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span> <span data-ttu-id="31c36-688">第三个行 （或列），第二个元素从其开始复制`sourceIndex`必须是第一个行 （或列） 的上限加上的第二个行 （或列） 的长度值，再加上 2。</span><span class="sxs-lookup"><span data-stu-id="31c36-688">To start copying from the second element of the third row (or column), `sourceIndex` must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</span></span>  
  
 <span data-ttu-id="31c36-689">如果`sourceArray`和`destinationArray`重叠，此方法的行为就像的原始值`sourceArray`在临时位置之前保留`destinationArray`将被覆盖。</span><span class="sxs-lookup"><span data-stu-id="31c36-689">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="31c36-690">[C++]</span><span class="sxs-lookup"><span data-stu-id="31c36-690">[C++]</span></span>  
  
 <span data-ttu-id="31c36-691">此方法相当于标准的 C/c + + 函数`memmove`，而不`memcpy`。</span><span class="sxs-lookup"><span data-stu-id="31c36-691">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="31c36-692">数组可以是引用类型的数组或值类型数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-692">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="31c36-693">执行类型转换，则所需的方式。</span><span class="sxs-lookup"><span data-stu-id="31c36-693">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="31c36-694">当从引用类型的数组复制到值类型的数组，每个元素是取消装箱，然后将其复制。</span><span class="sxs-lookup"><span data-stu-id="31c36-694">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="31c36-695">当从值类型数组复制到引用类型的数组，每个元素被装箱，然后将其复制。</span><span class="sxs-lookup"><span data-stu-id="31c36-695">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="31c36-696">在复制到一个引用类型或值类型数组中<xref:System.Object>数组，<xref:System.Object>然后复制并创建来保存每个值或引用。</span><span class="sxs-lookup"><span data-stu-id="31c36-696">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="31c36-697">当从复制<xref:System.Object>到引用类型或值类型数组和分配的数组不能，<xref:System.InvalidCastException>引发。</span><span class="sxs-lookup"><span data-stu-id="31c36-697">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="31c36-698">如果`sourceArray`和`destinationArray`两个引用类型数组或类型的两个数组<xref:System.Object>，执行的浅表副本。</span><span class="sxs-lookup"><span data-stu-id="31c36-698">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="31c36-699">浅表复制<xref:System.Array>是一种新<xref:System.Array>包含对原始与相同的元素的引用<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-699">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="31c36-700">元素本身或任何引用的元素不会复制。</span><span class="sxs-lookup"><span data-stu-id="31c36-700">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="31c36-701">与此相反的深层副本<xref:System.Array>将复制的元素，并直接或间接引用的元素的所有内容。</span><span class="sxs-lookup"><span data-stu-id="31c36-701">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="31c36-702"><xref:System.ArrayTypeMismatchException>引发如果数组的不可兼容类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-702">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="31c36-703">类型兼容性定义如下：</span><span class="sxs-lookup"><span data-stu-id="31c36-703">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="31c36-704">一种类型适用于本身。</span><span class="sxs-lookup"><span data-stu-id="31c36-704">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="31c36-705">值类型适用于<xref:System.Object>和与该值类型实现的接口类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-705">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="31c36-706">值类型被视为连接的接口，仅当它直接实现该接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-706">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="31c36-707">断开连接的类型不兼容。</span><span class="sxs-lookup"><span data-stu-id="31c36-707">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="31c36-708">两个内部函数 （预定义） 的值类型相兼容。 如果将源类型从复制到目标类型是一个的扩大转换。</span><span class="sxs-lookup"><span data-stu-id="31c36-708">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="31c36-709">扩大转换永远不会丢失信息，而收缩转换可能会丢失信息。</span><span class="sxs-lookup"><span data-stu-id="31c36-709">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="31c36-710">例如，将一个 32 位带符号的整数转换为 64 位有符号整数是扩大转换，并将一个 64 位带符号的整数转换为 32 位有符号整数都是收缩转换。</span><span class="sxs-lookup"><span data-stu-id="31c36-710">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="31c36-711">有关转换的详细信息，请参阅<xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="31c36-711">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="31c36-712">内部 （用户定义） 的值类型是只与其本身兼容。</span><span class="sxs-lookup"><span data-stu-id="31c36-712">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="31c36-713">枚举具有隐式转换为<xref:System.Enum>和为其基础类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-713">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="31c36-714">如果在每个元素`sourceArray`需要向下转换 （例如，从派生类的基类或接口的对象） 和一个或多个元素不能强制转换为中的对应类型`destinationArray`、<xref:System.InvalidCastException>引发。</span><span class="sxs-lookup"><span data-stu-id="31c36-714">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="31c36-715">如果此方法将引发异常时复制的状态`destinationArray`是不确定的。</span><span class="sxs-lookup"><span data-stu-id="31c36-715">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="31c36-716">此方法为 O (`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-716">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-717">下面的代码示例演示如何从某个复制<xref:System.Array>类型的<xref:System.Object>到另一个<xref:System.Array>的整数类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-717">The following code example shows how to copy from one <xref:System.Array> of type <xref:System.Object> to another <xref:System.Array> of type integer.</span></span>  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-718"><paramref name="sourceArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-718"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-719">或</span><span class="sxs-lookup"><span data-stu-id="31c36-719">-or-</span></span>  
  
 <span data-ttu-id="31c36-720"><paramref name="destinationArray" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-720"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-721"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</span><span class="sxs-lookup"><span data-stu-id="31c36-721"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <span data-ttu-id="31c36-722"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-722"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="31c36-723"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-723">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-724"><paramref name="sourceIndex" /> 超出了 <paramref name="sourceArray" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-724"><paramref name="sourceIndex" /> is outside the range of valid indexes for the <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="31c36-725">或</span><span class="sxs-lookup"><span data-stu-id="31c36-725">-or-</span></span>  
  
 <span data-ttu-id="31c36-726"><paramref name="destinationIndex" /> 超出了 <paramref name="destinationArray" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-726"><paramref name="destinationIndex" /> is outside the range of valid indexes for the <paramref name="destinationArray" />.</span></span>  
  
 <span data-ttu-id="31c36-727">或</span><span class="sxs-lookup"><span data-stu-id="31c36-727">-or-</span></span>  
  
 <span data-ttu-id="31c36-728"><paramref name="length" /> 小于 0 或大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-728"><paramref name="length" /> is less than 0 or greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-729"><paramref name="length" /> 大于从 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 末尾的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-729"><paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="31c36-730">或</span><span class="sxs-lookup"><span data-stu-id="31c36-730">-or-</span></span>  
  
 <span data-ttu-id="31c36-731"><paramref name="length" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 末尾的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-731"><paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31c36-732">将当前一维数组的所有元素复制到指定的一维数组中。</span><span class="sxs-lookup"><span data-stu-id="31c36-732">Copies all the elements of the current one-dimensional array to the specified one-dimensional array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-733">一维数组，它是从当前数组复制的元素的目标。</span><span class="sxs-lookup"><span data-stu-id="31c36-733">The one-dimensional array that is the destination of the elements copied from the current array.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-734">一个 32 位整数，它表示 <c>array</c> 中复制开始处的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-734">A 32-bit integer that represents the index in <c>array</c> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="31c36-735">从指定的目标数组索引处开始，将当前一维数组的所有元素复制到指定的一维数组中。</span><span class="sxs-lookup"><span data-stu-id="31c36-735">Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</span></span> <span data-ttu-id="31c36-736">索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-736">The index is specified as a 32-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-737">此方法会复制到当前数组实例的所有元素`array`目标数组索引处开始`index`。</span><span class="sxs-lookup"><span data-stu-id="31c36-737">This method copies all the elements of the current array instance to the `array` destination array, starting at index `index`.</span></span> <span data-ttu-id="31c36-738">`array`目标数组必须已具有已指定维度，并且必须具有足够数量的元素，以适应复制的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-738">The `array` destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</span></span> <span data-ttu-id="31c36-739">否则，该方法将引发异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-739">Otherwise, the method throws an exception.</span></span>  
  
 <span data-ttu-id="31c36-740">此方法支持<xref:System.Collections.ICollection?displayProperty=nameWithType>接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-740">This method supports the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="31c36-741">如果实现<xref:System.Collections.ICollection?displayProperty=nameWithType>是不明确要求，使用<xref:System.Array.Copy%2A>以避免额外间接寻址。</span><span class="sxs-lookup"><span data-stu-id="31c36-741">If implementing <xref:System.Collections.ICollection?displayProperty=nameWithType> is not explicitly required, use <xref:System.Array.Copy%2A> to avoid an extra indirection.</span></span>  
  
 <span data-ttu-id="31c36-742">如果此方法将引发异常时复制的状态`array`是不确定的。</span><span class="sxs-lookup"><span data-stu-id="31c36-742">If this method throws an exception while copying, the state of `array` is undefined.</span></span>  
  
 <span data-ttu-id="31c36-743">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>。它执行的浅表副本。</span><span class="sxs-lookup"><span data-stu-id="31c36-743">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.It performs a shallow copy only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-744">下面的代码示例演示如何复制<xref:System.Array>到另一个<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-744">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 <span data-ttu-id="31c36-745">下面的代码示例演示如何复制<xref:System.Array>到另一个<xref:System.Array>、 非零的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-745">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array> with a nonzero lower bound.</span></span> <span data-ttu-id="31c36-746">请注意，整个源<xref:System.Array>包括覆盖目标中的现有元素的空元素的复制<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-746">Note that the entire source <xref:System.Array> is copied, including empty elements that overwrite existing elements in the target <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-747"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-747"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-748"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-748"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-749"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-749"><paramref name="array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="31c36-750">或</span><span class="sxs-lookup"><span data-stu-id="31c36-750">-or-</span></span>  
  
 <span data-ttu-id="31c36-751">源数组中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 的末尾之间的可用元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-751">The number of elements in the source array is greater than the available number of elements from <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="31c36-752">无法自动将源 <see cref="T:System.Array" /> 的类型转换为目标 <paramref name="array" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-752">The type of the source <see cref="T:System.Array" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="31c36-753">源数组是多维数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-753">The source array is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="31c36-754">源 <see cref="T:System.Array" /> 中至少有一个元素无法转换为目标 <paramref name="array" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-754">At least one element in the source <see cref="T:System.Array" /> cannot be cast to the type of destination <paramref name="array" />.</span></span></exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-755">一维数组，它是从当前数组复制的元素的目标。</span><span class="sxs-lookup"><span data-stu-id="31c36-755">The one-dimensional array that is the destination of the elements copied from the current array.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-756">一个 64 位整数，它表示 <c>array</c> 中复制开始处的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-756">A 64-bit integer that represents the index in <c>array</c> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="31c36-757">从指定的目标数组索引处开始，将当前一维数组的所有元素复制到指定的一维数组中。</span><span class="sxs-lookup"><span data-stu-id="31c36-757">Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</span></span> <span data-ttu-id="31c36-758">索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-758">The index is specified as a 64-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-759">此方法会复制到当前数组实例的所有元素`array`目标数组索引处开始`index`。</span><span class="sxs-lookup"><span data-stu-id="31c36-759">This method copies all the elements of the current array instance to the `array` destination array, starting at index `index`.</span></span> <span data-ttu-id="31c36-760">`array`目标数组必须已具有已指定维度，并且必须具有足够数量的元素，以适应复制的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-760">The `array` destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</span></span> <span data-ttu-id="31c36-761">否则，该方法将引发异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-761">Otherwise, the method throws an exception.</span></span>  
  
 <span data-ttu-id="31c36-762">此方法支持<xref:System.Collections.ICollection?displayProperty=nameWithType>接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-762">This method supports the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="31c36-763">如果实现<xref:System.Collections.ICollection?displayProperty=nameWithType>是不明确要求，使用<xref:System.Array.Copy%2A>以避免额外间接寻址。</span><span class="sxs-lookup"><span data-stu-id="31c36-763">If implementing <xref:System.Collections.ICollection?displayProperty=nameWithType> is not explicitly required, use <xref:System.Array.Copy%2A> to avoid an extra indirection.</span></span>  
  
 <span data-ttu-id="31c36-764">如果此方法将引发异常时复制的状态`array`是不确定的。</span><span class="sxs-lookup"><span data-stu-id="31c36-764">If this method throws an exception while copying, the state of `array` is undefined.</span></span>  
  
 <span data-ttu-id="31c36-765">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>。它执行的浅表副本。</span><span class="sxs-lookup"><span data-stu-id="31c36-765">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.It performs a shallow copy only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-766">下面的代码示例演示如何复制<xref:System.Array>到另一个<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-766">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 <span data-ttu-id="31c36-767">下面的代码示例演示如何复制<xref:System.Array>到另一个<xref:System.Array>、 非零的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-767">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array> with a nonzero lower bound.</span></span> <span data-ttu-id="31c36-768">请注意，整个源<xref:System.Array>包括覆盖目标中的现有元素的空元素的复制<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-768">Note that the entire source <xref:System.Array> is copied, including empty elements that overwrite existing elements in the target <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-769"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-769"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-770"><paramref name="index" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-770"><paramref name="index" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-771"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-771"><paramref name="array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="31c36-772">或</span><span class="sxs-lookup"><span data-stu-id="31c36-772">-or-</span></span>  
  
 <span data-ttu-id="31c36-773">源数组中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 的末尾之间的可用元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-773">The number of elements in the source array is greater than the available number of elements from <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="31c36-774">无法自动将源 <see cref="T:System.Array" /> 的类型转换为目标 <paramref name="array" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-774">The type of the source <see cref="T:System.Array" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="31c36-775">源 <see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-775">The source <see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="31c36-776">源 <see cref="T:System.Array" /> 中至少有一个元素无法转换为目标 <paramref name="array" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-776">At least one element in the source <see cref="T:System.Array" /> cannot be cast to the type of destination <paramref name="array" />.</span></span></exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31c36-777">初始化 <see cref="T:System.Array" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="31c36-777">Initializes a new instance of the <see cref="T:System.Array" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="31c36-778">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-778">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-779">要创建的 <see cref="T:System.Array" /> 的大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-779">The size of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="31c36-780">创建使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和长度的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-780">Creates a one-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and length, with zero-based indexing.</span></span></summary>
        <returns><span data-ttu-id="31c36-781">使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和长度的新的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-781">A new one-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-782">与大多数类时，不同<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="31c36-782">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="31c36-783">引用类型元素将初始化为`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-783">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="31c36-784">值类型的元素将初始化为零。</span><span class="sxs-lookup"><span data-stu-id="31c36-784">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="31c36-785">此方法为 O (`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-785">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-786">下面的代码示例演示如何创建和初始化一维<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-786">The following code example shows how to create and initialize a one-dimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-787"><paramref name="elementType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-787"><paramref name="elementType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-788"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-788"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="31c36-789">不支持 <paramref name="elementType" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-789"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="31c36-790">例如，不支持 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-790">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="31c36-791">或</span><span class="sxs-lookup"><span data-stu-id="31c36-791">-or-</span></span>  
  
 <span data-ttu-id="31c36-792"><paramref name="elementType" /> 为开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-792"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-793"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-793"><paramref name="length" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="31c36-794">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-794">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lengths"><span data-ttu-id="31c36-795">一个 32 位整数数组，它表示要创建的 <see cref="T:System.Array" /> 中每个维度的大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-795">An array of 32-bit integers that represent the size of each dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="31c36-796">创建索引从零开始、具有指定 <see cref="T:System.Type" /> 和维长的多维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-796">Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span> <span data-ttu-id="31c36-797">维的长度在一个 32 位整数数组中指定。</span><span class="sxs-lookup"><span data-stu-id="31c36-797">The dimension lengths are specified in an array of 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="31c36-798">指定 <see cref="T:System.Type" /> 的新多维 <see cref="T:System.Array" />，该数组每个维具有指定长度，且使用从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-798">A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-799">与大多数类时，不同<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="31c36-799">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="31c36-800">中的元素数`lengths`数组必须等于在新的维度数<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-800">The number of elements in the `lengths` array must equal the number of dimensions in the new <xref:System.Array>.</span></span> <span data-ttu-id="31c36-801">每个元素`lengths`数组必须在新中指定的相应维度的长度<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-801">Each element of the `lengths` array must specify the length of the corresponding dimension in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-802">引用类型元素将初始化为`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-802">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="31c36-803">值类型的元素将初始化为零。</span><span class="sxs-lookup"><span data-stu-id="31c36-803">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="31c36-804">此方法为 O (`n`) 操作，其中`n`是中的所有值的乘积`lengths`。</span><span class="sxs-lookup"><span data-stu-id="31c36-804">This method is an O(`n`) operation, where `n` is the product of all values in `lengths`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-805">下面的代码示例演示如何创建和初始化的多维<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-805">The following code example shows how to create and initialize a multidimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-806"><paramref name="elementType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-806"><paramref name="elementType" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-807">或</span><span class="sxs-lookup"><span data-stu-id="31c36-807">-or-</span></span>  
  
 <span data-ttu-id="31c36-808"><paramref name="lengths" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-808"><paramref name="lengths" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-809"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-809"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span>  
  
 <span data-ttu-id="31c36-810">或</span><span class="sxs-lookup"><span data-stu-id="31c36-810">-or-</span></span>  
  
 <span data-ttu-id="31c36-811"><paramref name="lengths" /> 数组包含的元素少于一个。</span><span class="sxs-lookup"><span data-stu-id="31c36-811">The <paramref name="lengths" /> array contains less than one element.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="31c36-812">不支持 <paramref name="elementType" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-812"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="31c36-813">例如，不支持 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-813">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="31c36-814">或</span><span class="sxs-lookup"><span data-stu-id="31c36-814">-or-</span></span>  
  
 <span data-ttu-id="31c36-815"><paramref name="elementType" /> 为开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-815"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="31c36-816"><paramref name="lengths" /> 中的任何值都小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-816">Any value in <paramref name="lengths" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="31c36-817">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-817">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lengths"><span data-ttu-id="31c36-818">一个 64 位整数数组，它表示要创建的 <see cref="T:System.Array" /> 中每个维度的大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-818">An array of 64-bit integers that represent the size of each dimension of the <see cref="T:System.Array" /> to create.</span></span> <span data-ttu-id="31c36-819">数组中的每个整数都必须介于零和 <see cref="F:System.Int32.MaxValue" /> 之间，（包括零和 System.Int32.MaxValue）。</span><span class="sxs-lookup"><span data-stu-id="31c36-819">Each integer in the array must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</span></span></param>
        <summary><span data-ttu-id="31c36-820">创建索引从零开始、具有指定 <see cref="T:System.Type" /> 和维长的多维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-820">Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span> <span data-ttu-id="31c36-821">维的长度在一个 64 位整数数组中指定。</span><span class="sxs-lookup"><span data-stu-id="31c36-821">The dimension lengths are specified in an array of 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="31c36-822">指定 <see cref="T:System.Type" /> 的新多维 <see cref="T:System.Array" />，该数组每个维具有指定长度，且使用从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-822">A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-823">与大多数类时，不同<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="31c36-823">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="31c36-824">中的元素数`lengths`数组必须等于在新的维度数<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-824">The number of elements in the `lengths` array must equal the number of dimensions in the new <xref:System.Array>.</span></span> <span data-ttu-id="31c36-825">每个元素`lengths`数组必须在新中指定的相应维度的长度<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-825">Each element of the `lengths` array must specify the length of the corresponding dimension in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-826">引用类型元素将初始化为`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-826">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="31c36-827">值类型的元素将初始化为零。</span><span class="sxs-lookup"><span data-stu-id="31c36-827">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="31c36-828">此方法为 O (`n`) 操作，其中`n`是中的所有值的乘积`lengths`。</span><span class="sxs-lookup"><span data-stu-id="31c36-828">This method is an O(`n`) operation, where `n` is the product of all values in `lengths`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-829">下面的代码示例演示如何创建和初始化的多维<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-829">The following code example shows how to create and initialize a multidimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-830"><paramref name="elementType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-830"><paramref name="elementType" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-831">或</span><span class="sxs-lookup"><span data-stu-id="31c36-831">-or-</span></span>  
  
 <span data-ttu-id="31c36-832"><paramref name="lengths" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-832"><paramref name="lengths" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-833"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-833"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span>  
  
 <span data-ttu-id="31c36-834">或</span><span class="sxs-lookup"><span data-stu-id="31c36-834">-or-</span></span>  
  
 <span data-ttu-id="31c36-835"><paramref name="lengths" /> 数组包含的元素少于一个。</span><span class="sxs-lookup"><span data-stu-id="31c36-835">The <paramref name="lengths" /> array contains less than one element.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="31c36-836">不支持 <paramref name="elementType" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-836"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="31c36-837">例如，不支持 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-837">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="31c36-838">或</span><span class="sxs-lookup"><span data-stu-id="31c36-838">-or-</span></span>  
  
 <span data-ttu-id="31c36-839"><paramref name="elementType" /> 为开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-839"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="31c36-840"><paramref name="lengths" /> 中的所有值都小于零或大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-840">Any value in <paramref name="lengths" /> is less than zero or greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="31c36-841">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-841">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length1"><span data-ttu-id="31c36-842">要创建的 <see cref="T:System.Array" /> 的第一维的大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-842">The size of the first dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length2"><span data-ttu-id="31c36-843">要创建的 <see cref="T:System.Array" /> 的第二维的大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-843">The size of the second dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="31c36-844">创建使用从零开始的索引、具有指定 <see cref="T:System.Array" /> 和维长的二维 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-844">Creates a two-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span></summary>
        <returns><span data-ttu-id="31c36-845">使用从零开始的索引、具有指定 <see cref="T:System.Array" /> 的新的二维 <see cref="T:System.Type" />，其每个维度都为指定的长度。</span><span class="sxs-lookup"><span data-stu-id="31c36-845">A new two-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-846">与大多数类时，不同<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="31c36-846">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="31c36-847">引用类型元素将初始化为`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-847">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="31c36-848">值类型的元素将初始化为零。</span><span class="sxs-lookup"><span data-stu-id="31c36-848">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="31c36-849">此方法为 O (`n`) 操作，其中`n`是产品`length1`和`length2`。</span><span class="sxs-lookup"><span data-stu-id="31c36-849">This method is an O(`n`) operation, where `n` is the product of `length1` and `length2`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-850">下面的代码示例演示如何创建和初始化的二维<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-850">The following code example shows how to create and initialize a two-dimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-851"><paramref name="elementType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-851"><paramref name="elementType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-852"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-852"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="31c36-853">不支持 <paramref name="elementType" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-853"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="31c36-854">例如，不支持 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-854">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="31c36-855">或</span><span class="sxs-lookup"><span data-stu-id="31c36-855">-or-</span></span>  
  
 <span data-ttu-id="31c36-856"><paramref name="elementType" /> 为开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-856"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-857"><paramref name="length1" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-857"><paramref name="length1" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-858">或</span><span class="sxs-lookup"><span data-stu-id="31c36-858">-or-</span></span>  
  
 <span data-ttu-id="31c36-859"><paramref name="length2" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-859"><paramref name="length2" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="31c36-860">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-860">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lengths"><span data-ttu-id="31c36-861">一维数组，它包含要创建的 <see cref="T:System.Array" /> 的每个维度的大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-861">A one-dimensional array that contains the size of each dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lowerBounds"><span data-ttu-id="31c36-862">一维数组，它包含要创建的 <see cref="T:System.Array" /> 的每个维度的下限（起始索引）。</span><span class="sxs-lookup"><span data-stu-id="31c36-862">A one-dimensional array that contains the lower bound (starting index) of each dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="31c36-863">创建具有指定下限、指定 <see cref="T:System.Array" /> 和维长的多维 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-863">Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with the specified lower bounds.</span></span></summary>
        <returns><span data-ttu-id="31c36-864">新的指定 <see cref="T:System.Array" /> 的多维 <see cref="T:System.Type" />，每个维度都有指定的长度和下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-864">A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length and lower bound for each dimension.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-865">与大多数类时，不同<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="31c36-865">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="31c36-866">`lengths`和`lowerBounds`数组必须具有相同数量的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-866">The `lengths` and `lowerBounds` arrays must have the same number of elements.</span></span> <span data-ttu-id="31c36-867">中的元素数`lengths`数组必须等于在新的维度数<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-867">The number of elements in the `lengths` array must equal the number of dimensions in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-868">每个元素`lengths`数组必须在新中指定的相应维度的长度<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-868">Each element of the `lengths` array must specify the length of the corresponding dimension in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-869">每个元素`lowerBounds`数组必须在新中指定的相应维度的下限<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-869">Each element of the `lowerBounds` array must specify the lower bound of the corresponding dimension in the new <xref:System.Array>.</span></span> <span data-ttu-id="31c36-870">通常情况下，.NET Framework 类库和许多编程语言不处理非零下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-870">Generally, the .NET Framework class library and many programming languages do not handle nonzero lower bounds.</span></span>  
  
 <span data-ttu-id="31c36-871">引用类型元素将初始化为`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-871">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="31c36-872">值类型的元素将初始化为零。</span><span class="sxs-lookup"><span data-stu-id="31c36-872">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="31c36-873">此方法为 O (`n`) 操作，其中`n`是中的所有值的乘积`lengths`。</span><span class="sxs-lookup"><span data-stu-id="31c36-873">This method is an O(`n`) operation, where `n` is the product of all values in `lengths`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-874">下面的代码示例演示如何创建和初始化的多维<xref:System.Array>具有指定的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-874">The following code example shows how to create and initialize a multidimensional <xref:System.Array> with specified lower bounds.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-875"><paramref name="elementType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-875"><paramref name="elementType" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-876">或</span><span class="sxs-lookup"><span data-stu-id="31c36-876">-or-</span></span>  
  
 <span data-ttu-id="31c36-877"><paramref name="lengths" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-877"><paramref name="lengths" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-878">或</span><span class="sxs-lookup"><span data-stu-id="31c36-878">-or-</span></span>  
  
 <span data-ttu-id="31c36-879"><paramref name="lowerBounds" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-879"><paramref name="lowerBounds" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-880"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-880"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span>  
  
 <span data-ttu-id="31c36-881">或</span><span class="sxs-lookup"><span data-stu-id="31c36-881">-or-</span></span>  
  
 <span data-ttu-id="31c36-882"><paramref name="lengths" /> 数组包含的元素少于一个。</span><span class="sxs-lookup"><span data-stu-id="31c36-882">The <paramref name="lengths" /> array contains less than one element.</span></span>  
  
 <span data-ttu-id="31c36-883">或</span><span class="sxs-lookup"><span data-stu-id="31c36-883">-or-</span></span>  
  
 <span data-ttu-id="31c36-884"><paramref name="lengths" /> 和 <paramref name="lowerBounds" /> 数组包含的元素数不同。</span><span class="sxs-lookup"><span data-stu-id="31c36-884">The <paramref name="lengths" /> and <paramref name="lowerBounds" /> arrays do not contain the same number of elements.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="31c36-885">不支持 <paramref name="elementType" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-885"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="31c36-886">例如，不支持 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-886">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="31c36-887">或</span><span class="sxs-lookup"><span data-stu-id="31c36-887">-or-</span></span>  
  
 <span data-ttu-id="31c36-888"><paramref name="elementType" /> 为开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-888"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="31c36-889"><paramref name="lengths" /> 中的任何值都小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-889">Any value in <paramref name="lengths" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-890">或</span><span class="sxs-lookup"><span data-stu-id="31c36-890">-or-</span></span>  
  
 <span data-ttu-id="31c36-891"><paramref name="lowerBounds" /> 中的任意一个值都很大，因此，维的下限和长度的和大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-891">Any value in <paramref name="lowerBounds" /> is very large, such that the sum of a dimension's lower bound and length is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="31c36-892">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-892">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length1"><span data-ttu-id="31c36-893">要创建的 <see cref="T:System.Array" /> 的第一维的大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-893">The size of the first dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length2"><span data-ttu-id="31c36-894">要创建的 <see cref="T:System.Array" /> 的第二维的大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-894">The size of the second dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length3"><span data-ttu-id="31c36-895">要创建的 <see cref="T:System.Array" /> 的第三维的大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-895">The size of the third dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="31c36-896">创建使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和维长的三维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-896">Creates a three-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span></summary>
        <returns><span data-ttu-id="31c36-897">每个维具有指定长度、使用从零开始的索引的指定 <see cref="T:System.Type" /> 的新三维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-897">A new three-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-898">与大多数类时，不同<xref:System.Array>提供<xref:System.Array.CreateInstance%2A>方法，而不是公共构造函数，以允许后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="31c36-898">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="31c36-899">引用类型元素将初始化为`null`。</span><span class="sxs-lookup"><span data-stu-id="31c36-899">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="31c36-900">值类型的元素将初始化为零。</span><span class="sxs-lookup"><span data-stu-id="31c36-900">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="31c36-901">此方法为 O (`n`) 操作，其中`n`是产品`length1`， `length2`，和`length3`。</span><span class="sxs-lookup"><span data-stu-id="31c36-901">This method is an O(`n`) operation, where `n` is the product of `length1`, `length2`, and `length3`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-902">下面的代码示例演示如何创建和初始化三维<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-902">The following code example shows how to create and initialize a three-dimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-903"><paramref name="elementType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-903"><paramref name="elementType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-904"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-904"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="31c36-905">不支持 <paramref name="elementType" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-905"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="31c36-906">例如，不支持 <see cref="T:System.Void" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-906">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="31c36-907">或</span><span class="sxs-lookup"><span data-stu-id="31c36-907">-or-</span></span>  
  
 <span data-ttu-id="31c36-908"><paramref name="elementType" /> 为开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-908"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-909"><paramref name="length1" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-909"><paramref name="length1" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-910">或</span><span class="sxs-lookup"><span data-stu-id="31c36-910">-or-</span></span>  
  
 <span data-ttu-id="31c36-911"><paramref name="length2" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-911"><paramref name="length2" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-912">或</span><span class="sxs-lookup"><span data-stu-id="31c36-912">-or-</span></span>  
  
 <span data-ttu-id="31c36-913"><paramref name="length3" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-913"><paramref name="length3" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-914">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-914">The type of the elements of the array.</span></span></typeparam>
        <summary><span data-ttu-id="31c36-915">返回一个空数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-915">Returns an empty array.</span></span></summary>
        <returns><span data-ttu-id="31c36-916">返回一个空 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-916">Returns an empty <see cref="T:System.Array" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-917">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-917">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-918">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-918">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="31c36-919"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="31c36-919">The <see cref="T:System.Predicate`1" /> that defines the conditions of the elements to search for.</span></span></param>
        <summary><span data-ttu-id="31c36-920">确定指定数组包含的元素是否与指定谓词定义的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-920">Determines whether the specified array contains elements that match the conditions defined by the specified predicate.</span></span></summary>
        <returns>
          <span data-ttu-id="31c36-921">如果 <paramref name="array" /> 包含一个或多个与指定谓词所定义的条件相匹配的元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-921"><see langword="true" /> if <paramref name="array" /> contains one or more elements that match the conditions defined by the specified predicate; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-922"><xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-922">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="31c36-923">元素`array`单独传递给<xref:System.Predicate%601>，并且当找到匹配项时停止处理。</span><span class="sxs-lookup"><span data-stu-id="31c36-923">The elements of `array` are individually passed to the <xref:System.Predicate%601>, and processing is stopped when a match is found.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-924">在 C# 和 Visual Basic 中，它不需要创建<xref:System.Predicate%601>显式委托。</span><span class="sxs-lookup"><span data-stu-id="31c36-924">In C# and Visual Basic, it is not necessary to create the <xref:System.Predicate%601> delegate explicitly.</span></span> <span data-ttu-id="31c36-925">这些语言推断从上下文正确的委托，并自动创建。</span><span class="sxs-lookup"><span data-stu-id="31c36-925">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="31c36-926">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-926">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-927">下面的示例指定的匹配条件<xref:System.Array.Exists%2A>方法 usinglambda 表达式来检查是否世界各地给定的字母开头，或是否在世界各地找到上给定数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-927">The following example specifies the match conditions for the <xref:System.Array.Exists%2A> method usinglambda expressions to check whether a planet starts with a given letter or whether the planet is found on the given array.</span></span>  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 <span data-ttu-id="31c36-928">下面的示例使用<xref:System.Array.Exists%2A>方法，以指示是否使用指定的字符开始的字符串数组中的任何名称。</span><span class="sxs-lookup"><span data-stu-id="31c36-928">The following example uses the <xref:System.Array.Exists%2A> method to indicate whether any names in a string array begin with a specified character.</span></span> <span data-ttu-id="31c36-929">该示例实例化`StringSearcher`通过传递给其类构造函数搜索的字符串对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-929">The example instantiates a `StringSearcher` object by passing the string to search for to its class constructor.</span></span> <span data-ttu-id="31c36-930">`StringSearcher.StartsWith`方法具有相同的签名<xref:System.Predicate%601>委托。</span><span class="sxs-lookup"><span data-stu-id="31c36-930">The `StringSearcher.StartsWith` method has same signature as the <xref:System.Predicate%601> delegate.</span></span> <span data-ttu-id="31c36-931">当<xref:System.Array.Exists%2A>方法调用，该数组的每个成员传递给委托，直到它返回`true`或循环访问数组中的所有元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-931">When the <xref:System.Array.Exists%2A> method is called, each member of the array is passed to the delegate until it returns `true` or iterates all the elements in the array.</span></span>  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 <span data-ttu-id="31c36-932">可以还使用 lambda 表达式，而不是显式定义其签名相对应的方法的委托。</span><span class="sxs-lookup"><span data-stu-id="31c36-932">You can also use a lambda expression rather than explicitly define a method whose signature corresponds to that of the delegate.</span></span> <span data-ttu-id="31c36-933">下面的示例替换`StringSearcher`类并将其`StartsWith`使用 lambda 表达式的方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-933">The following example replaces the `StringSearcher` class and its `StartsWith` method with a lambda expression.</span></span>  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-934"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-934"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-935">或</span><span class="sxs-lookup"><span data-stu-id="31c36-935">-or-</span></span>  
  
 <span data-ttu-id="31c36-936"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-936"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-937">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-937">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-938">要搜索的从零开始的一维数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-938">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="match"><span data-ttu-id="31c36-939">用于定义要搜索的元素的条件的谓词。</span><span class="sxs-lookup"><span data-stu-id="31c36-939">The predicate that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="31c36-940">搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中的第一个匹配元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-940">Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="31c36-941">如果找到与指定谓词定义的条件匹配的第一个元素，则为该元素；否则为类型 <paramref name="T" /> 的默认值。</span><span class="sxs-lookup"><span data-stu-id="31c36-941">The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-942"><xref:System.Predicate%601>是对的方法或 lambda 表达式返回一个委托`true`如果该对象传递给委托或 lambda 表达式中定义的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-942">The <xref:System.Predicate%601> is a delegate to a method or a lambda expression that returns `true` if the object passed to it matches the conditions defined in the delegate or lambda expression.</span></span>  <span data-ttu-id="31c36-943">元素`array`单独传递给<xref:System.Predicate%601>，从第一个元素开始和结束的最后一个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-943">The elements of `array` are individually passed to the <xref:System.Predicate%601>, starting with the first element and ending with the last element.</span></span>  <span data-ttu-id="31c36-944">找到匹配项，已停止处理。</span><span class="sxs-lookup"><span data-stu-id="31c36-944">Processing is stopped when a match is found.</span></span>  
  
 <span data-ttu-id="31c36-945">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-945">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-946">下面的示例使用<xref:System.Predicate%601>委托以及<xref:System.Array.Find%2A>泛型方法搜索的数组<xref:System.Drawing.Point>结构。</span><span class="sxs-lookup"><span data-stu-id="31c36-946">The following example uses a <xref:System.Predicate%601> delegate with the <xref:System.Array.Find%2A> generic method to search an array of <xref:System.Drawing.Point> structures.</span></span> <span data-ttu-id="31c36-947">表示委托，该方法`ProductGT10`，返回`true`是否大于 100,000 的 X 和 Y 字段的产品。</span><span class="sxs-lookup"><span data-stu-id="31c36-947">The method the delegate represents, `ProductGT10`, returns `true` if the product of the X and Y fields is greater than 100,000.</span></span> <span data-ttu-id="31c36-948"><xref:System.Array.Find%2A>方法返回满足测试条件的第一个点的数组的每个元素调用委托。</span><span class="sxs-lookup"><span data-stu-id="31c36-948">The <xref:System.Array.Find%2A> method calls the delegate for each element of the array, returning the first point that meets the test condition.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-949">Visual Basic 和 C# 用户不需要显式创建委托，或者指定泛型方法的类型自变量。</span><span class="sxs-lookup"><span data-stu-id="31c36-949">Visual Basic and C# users do not have to create the delegate explicitly or specify the type argument of the generic method.</span></span> <span data-ttu-id="31c36-950">编译器确定必需你提供的方法自变量的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-950">The compilers determine the necessary types from the method arguments you supply.</span></span>  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 <span data-ttu-id="31c36-951">而不是显式定义具有必要的签名的方法实例化<xref:System.Predicate%601>委托，并将传递到委托<xref:System.Array.Find%2A>方法，它是通常使用 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="31c36-951">Rather than explicitly defining a method with the necessary signature, instantiating a <xref:System.Predicate%601> delegate, and passing the delegate to the <xref:System.Array.Find%2A> method, it is customary to use a lambda expression.</span></span> <span data-ttu-id="31c36-952">下面的示例是上一，相同，但它使用 lambda 表达式作为`match`自变量。</span><span class="sxs-lookup"><span data-stu-id="31c36-952">The following example is identical to the previous one, except that it uses a lambda expression as the `match` argument.</span></span>  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-953"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-953"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-954">或</span><span class="sxs-lookup"><span data-stu-id="31c36-954">-or-</span></span>  
  
 <span data-ttu-id="31c36-955"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-955"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-956">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-956">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-957">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-957">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="31c36-958"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="31c36-958">The <see cref="T:System.Predicate`1" /> that defines the conditions of the elements to search for.</span></span></param>
        <summary><span data-ttu-id="31c36-959">检索与指定谓词定义的条件匹配的所有元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-959">Retrieves all the elements that match the conditions defined by the specified predicate.</span></span></summary>
        <returns><span data-ttu-id="31c36-960">如果找到一个其中所有元素均与指定谓词定义的条件匹配的 <see cref="T:System.Array" />，则为该数组；否则为一个空 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-960">An <see cref="T:System.Array" /> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-961"><xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-961">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="31c36-962">元素`array`单独传递给<xref:System.Predicate%601>，和的条件相匹配的元素保存在返回的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-962">The elements of `array` are individually passed to the <xref:System.Predicate%601>, and the elements that match the conditions are saved in the returned array.</span></span>  
  
 <span data-ttu-id="31c36-963">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-963">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-964">下面的示例使用范围可以从 0 到 1000 的值创建 50 的随机数的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-964">The following example creates an array of 50 random numbers with values that can range from 0 to 1,000.</span></span> <span data-ttu-id="31c36-965">然后，它调用<xref:System.Array.FindAll%2A>方法返回的值，范围从 300 为 600 的 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="31c36-965">It then calls the <xref:System.Array.FindAll%2A> method with a lambda expression that returns the values that range from 300 to 600.</span></span> <span data-ttu-id="31c36-966">请注意，lambda 表达式将传递一个名为参数`x`; 这表示传递给单个数组成员<xref:System.Predicate%601>。</span><span class="sxs-lookup"><span data-stu-id="31c36-966">Note that the lambda expression is passed a parameter named `x`;  this represents the individual array member that is passed to the <xref:System.Predicate%601>.</span></span> <span data-ttu-id="31c36-967">另请注意，本地`lBound`和`uBound`变量是在 lambda 表达式中访问。</span><span class="sxs-lookup"><span data-stu-id="31c36-967">Also note that the local `lBound` and `uBound` variables are accessible within the lambda expression.</span></span>  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 <span data-ttu-id="31c36-968">下面的代码示例演示<xref:System.Array.Find%2A>， <xref:System.Array.FindLast%2A>，和<xref:System.Array.FindAll%2A>泛型方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-968">The following code example demonstrates the <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, and <xref:System.Array.FindAll%2A> generic methods.</span></span> <span data-ttu-id="31c36-969">创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-969">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="31c36-970">该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。</span><span class="sxs-lookup"><span data-stu-id="31c36-970">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="31c36-971"><xref:System.Array.Find%2A>泛型方法的开头，将每个元素传递给反过来遍历数组`EndsWithSaurus`方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-971">The <xref:System.Array.Find%2A> generic method traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="31c36-972">搜索将停止时`EndsWithSaurus`方法返回`true`元素"Amargasaurus"。</span><span class="sxs-lookup"><span data-stu-id="31c36-972">The search stops when the `EndsWithSaurus` method returns `true` for the element "Amargasaurus".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-973">在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。</span><span class="sxs-lookup"><span data-stu-id="31c36-973">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="31c36-974">这些语言推断从上下文正确的委托，并自动创建。</span><span class="sxs-lookup"><span data-stu-id="31c36-974">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="31c36-975"><xref:System.Array.FindLast%2A>泛型方法用于搜索向后结尾的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-975">The <xref:System.Array.FindLast%2A> generic method is used to search the array backward from the end.</span></span> <span data-ttu-id="31c36-976">它找到的元素"Dilophosaurus"在位置 5。</span><span class="sxs-lookup"><span data-stu-id="31c36-976">It finds the element "Dilophosaurus" at position 5.</span></span> <span data-ttu-id="31c36-977"><xref:System.Array.FindAll%2A>泛型方法用于返回数组，其中包含以"saurus"结尾的所有元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-977">The <xref:System.Array.FindAll%2A> generic method is used to return an array containing all the elements that end in "saurus".</span></span> <span data-ttu-id="31c36-978">元素的显示。</span><span class="sxs-lookup"><span data-stu-id="31c36-978">The elements are displayed.</span></span>  
  
 <span data-ttu-id="31c36-979">代码示例还演示<xref:System.Array.Exists%2A>和<xref:System.Array.TrueForAll%2A>泛型方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-979">The code example also demonstrates the <xref:System.Array.Exists%2A> and <xref:System.Array.TrueForAll%2A> generic methods.</span></span>  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-980"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-980"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-981">或</span><span class="sxs-lookup"><span data-stu-id="31c36-981">-or-</span></span>  
  
 <span data-ttu-id="31c36-982"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-982"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31c36-983">搜索与指定谓词定义的条件匹配的元素，然后返回 <see cref="T:System.Array" /> 或其某个部分中第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-983">Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the first occurrence within an <see cref="T:System.Array" /> or a portion of it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-984">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-984">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-985">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-985">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="31c36-986"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="31c36-986">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="31c36-987">搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中第一个匹配元素的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-987">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="31c36-988">如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="31c36-988">The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-989"><xref:System.Array>搜索向前从第一个元素开始和结束时间的最后一个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-989">The <xref:System.Array> is searched forward starting at the first element and ending at the last element.</span></span>  
  
 <span data-ttu-id="31c36-990"><xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-990">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="31c36-991">元素`array`单独传递给<xref:System.Predicate%601>。</span><span class="sxs-lookup"><span data-stu-id="31c36-991">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="31c36-992">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-992">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-993">下面的代码示例演示的所有三个重载<xref:System.Array.FindIndex%2A>泛型方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-993">The following code example demonstrates all three overloads of the <xref:System.Array.FindIndex%2A> generic method.</span></span> <span data-ttu-id="31c36-994">创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-994">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="31c36-995">该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。</span><span class="sxs-lookup"><span data-stu-id="31c36-995">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="31c36-996"><xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从开始时，将每个元素传递给反过来遍历数组`EndsWithSaurus`方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-996">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="31c36-997">搜索将停止时`EndsWithSaurus`方法返回`true`位于位置 1 处的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-997">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-998">在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。</span><span class="sxs-lookup"><span data-stu-id="31c36-998">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="31c36-999">这些语言推断从上下文正确的委托，并自动创建。</span><span class="sxs-lookup"><span data-stu-id="31c36-999">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="31c36-1000"><xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索位置 2 处开始并一直到数组末尾的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1000">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</span></span> <span data-ttu-id="31c36-1001">它找到位置 5 处的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1001">It finds the element at position 5.</span></span> <span data-ttu-id="31c36-1002">最后，<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的位置 2 处开始的三个元素的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1002">Finally, the <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 2.</span></span> <span data-ttu-id="31c36-1003">它返回 – 1，因为没有在该范围内不复存在名以"saurus"结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-1003">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1004"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1004"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-1005">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1005">-or-</span></span>  
  
 <span data-ttu-id="31c36-1006"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1006"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-1007">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1007">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-1008">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1008">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="31c36-1009">从零开始的搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1009">The zero-based starting index of the search.</span></span></param>
        <param name="match"><span data-ttu-id="31c36-1010"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="31c36-1010">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="31c36-1011">搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Array" /> 中从指定索引到最后一个元素的元素范围内第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1011">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the specified index to the last element.</span></span></summary>
        <returns><span data-ttu-id="31c36-1012">如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1012">The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1013"><xref:System.Array>处开始向前搜索`startIndex`和结束时间的最后一个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1013">The <xref:System.Array> is searched forward starting at `startIndex` and ending at the last element.</span></span>  
  
 <span data-ttu-id="31c36-1014"><xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-1014">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="31c36-1015">元素`array`单独传递给<xref:System.Predicate%601>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1015">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="31c36-1016">此方法为 O (`n`) 操作，其中`n`是中的元素数`startIndex`到末尾`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1016">This method is an O(`n`) operation, where `n` is the number of elements from `startIndex` to the end of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1017">下面的代码示例演示的所有三个重载<xref:System.Array.FindIndex%2A>泛型方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1017">The following code example demonstrates all three overloads of the <xref:System.Array.FindIndex%2A> generic method.</span></span> <span data-ttu-id="31c36-1018">创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-1018">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="31c36-1019">该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。</span><span class="sxs-lookup"><span data-stu-id="31c36-1019">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="31c36-1020"><xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从开始时，将每个元素传递给反过来遍历数组`EndsWithSaurus`方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1020">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="31c36-1021">搜索将停止时`EndsWithSaurus`方法返回`true`位于位置 1 处的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1021">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-1022">在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。</span><span class="sxs-lookup"><span data-stu-id="31c36-1022">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="31c36-1023">这些语言推断从上下文正确的委托，并自动创建。</span><span class="sxs-lookup"><span data-stu-id="31c36-1023">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="31c36-1024"><xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索位置 2 处开始并一直到数组末尾的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1024">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</span></span> <span data-ttu-id="31c36-1025">它找到位置 5 处的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1025">It finds the element at position 5.</span></span> <span data-ttu-id="31c36-1026">最后，<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的位置 2 处开始的三个元素的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1026">Finally, the <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 2.</span></span> <span data-ttu-id="31c36-1027">它返回 – 1，因为没有在该范围内不复存在名以"saurus"结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-1027">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1028"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1028"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-1029">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1029">-or-</span></span>  
  
 <span data-ttu-id="31c36-1030"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1030"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1031"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1031"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-1032">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1032">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-1033">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1033">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="31c36-1034">从零开始的搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1034">The zero-based starting index of the search.</span></span></param>
        <param name="count"><span data-ttu-id="31c36-1035">要搜索的部分中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1035">The number of elements in the section to search.</span></span></param>
        <param name="match"><span data-ttu-id="31c36-1036"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="31c36-1036">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="31c36-1037">搜索与指定谓词所定义的条件相匹配的一个元素，并返回 <see cref="T:System.Array" /> 中从指定的索引开始、包含指定元素个数的元素范围内第一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1037">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Array" /> that starts at the specified index and contains the specified number of elements.</span></span></summary>
        <returns><span data-ttu-id="31c36-1038">如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1038">The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1039"><xref:System.Array>处开始向前搜索`startIndex`结束`startIndex`加上`count`减 1，如果`count`大于 0。</span><span class="sxs-lookup"><span data-stu-id="31c36-1039">The <xref:System.Array> is searched forward starting at `startIndex` and ending at `startIndex` plus `count` minus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="31c36-1040"><xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-1040">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="31c36-1041">元素`array`单独传递给<xref:System.Predicate%601>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1041">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="31c36-1042">此方法为 O (`n`) 操作，其中`n`是`count`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1042">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1043">下面的代码示例演示的所有三个重载<xref:System.Array.FindIndex%2A>泛型方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1043">The following code example demonstrates all three overloads of the <xref:System.Array.FindIndex%2A> generic method.</span></span> <span data-ttu-id="31c36-1044">创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-1044">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="31c36-1045">该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。</span><span class="sxs-lookup"><span data-stu-id="31c36-1045">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="31c36-1046"><xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从开始时，将每个元素传递给反过来遍历数组`EndsWithSaurus`方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1046">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="31c36-1047">搜索将停止时`EndsWithSaurus`方法返回`true`位于位置 1 处的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1047">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-1048">在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。</span><span class="sxs-lookup"><span data-stu-id="31c36-1048">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="31c36-1049">这些语言推断从上下文正确的委托，并自动创建。</span><span class="sxs-lookup"><span data-stu-id="31c36-1049">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="31c36-1050"><xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索位置 2 处开始并一直到数组末尾的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1050">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</span></span> <span data-ttu-id="31c36-1051">它找到位置 5 处的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1051">It finds the element at position 5.</span></span> <span data-ttu-id="31c36-1052">最后，<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的位置 2 处开始的三个元素的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1052">Finally, the <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 2.</span></span> <span data-ttu-id="31c36-1053">它返回 – 1，因为没有在该范围内不复存在名以"saurus"结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-1053">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1054"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1054"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-1055">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1055">-or-</span></span>  
  
 <span data-ttu-id="31c36-1056"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1056"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1057"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1057"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-1058">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1058">-or-</span></span>  
  
 <span data-ttu-id="31c36-1059"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1059"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-1060">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1060">-or-</span></span>  
  
 <span data-ttu-id="31c36-1061"><paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</span><span class="sxs-lookup"><span data-stu-id="31c36-1061"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-1062">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1062">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-1063">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1063">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="31c36-1064"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="31c36-1064">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="31c36-1065">搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中的最后一个匹配元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1065">Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="31c36-1066">如果找到，则为与指定谓词所定义的条件相匹配的最后一个元素；否则为类型 <paramref name="T" /> 的默认值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1066">The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1067"><xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-1067">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="31c36-1068">元素`array`单独传递给<xref:System.Predicate%601>、 移动中向后<xref:System.Array>，从最后一个元素开始和结束的第一个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1068">The elements of `array` are individually passed to the <xref:System.Predicate%601>, moving backward in the <xref:System.Array>, starting with the last element and ending with the first element.</span></span>  <span data-ttu-id="31c36-1069">找到匹配项，已停止处理。</span><span class="sxs-lookup"><span data-stu-id="31c36-1069">Processing is stopped when a match is found.</span></span>  
  
 <span data-ttu-id="31c36-1070">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1070">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1071">下面的代码示例演示<xref:System.Array.Find%2A>， <xref:System.Array.FindLast%2A>，和<xref:System.Array.FindAll%2A>泛型方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1071">The following code example demonstrates the <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, and <xref:System.Array.FindAll%2A> generic methods.</span></span> <span data-ttu-id="31c36-1072">创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-1072">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="31c36-1073">该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。</span><span class="sxs-lookup"><span data-stu-id="31c36-1073">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="31c36-1074"><xref:System.Array.Find%2A>泛型方法的开头，将每个元素传递给反过来遍历数组`EndsWithSaurus`方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1074">The <xref:System.Array.Find%2A> generic method traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="31c36-1075">搜索将停止时`EndsWithSaurus`方法返回`true`元素"Amargasaurus"。</span><span class="sxs-lookup"><span data-stu-id="31c36-1075">The search stops when the `EndsWithSaurus` method returns `true` for the element "Amargasaurus".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-1076">在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。</span><span class="sxs-lookup"><span data-stu-id="31c36-1076">In C# and Visual Basic, it is not necessary to create the`Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="31c36-1077">这些语言推断从上下文正确的委托，并自动创建。</span><span class="sxs-lookup"><span data-stu-id="31c36-1077">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="31c36-1078"><xref:System.Array.FindLast%2A>泛型方法用于搜索向后结尾的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1078">The <xref:System.Array.FindLast%2A> generic method is used to search the array backward from the end.</span></span> <span data-ttu-id="31c36-1079">它找到的元素"Dilophosaurus"在位置 5。</span><span class="sxs-lookup"><span data-stu-id="31c36-1079">It finds the element "Dilophosaurus" at position 5.</span></span> <span data-ttu-id="31c36-1080"><xref:System.Array.FindAll%2A>泛型方法用于返回数组，其中包含以"saurus"结尾的所有元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1080">The <xref:System.Array.FindAll%2A> generic method is used to return an array containing all the elements that end in "saurus".</span></span> <span data-ttu-id="31c36-1081">元素的显示。</span><span class="sxs-lookup"><span data-stu-id="31c36-1081">The elements are displayed.</span></span>  
  
 <span data-ttu-id="31c36-1082">代码示例还演示<xref:System.Array.Exists%2A>和<xref:System.Array.TrueForAll%2A>泛型方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1082">The code example also demonstrates the <xref:System.Array.Exists%2A> and <xref:System.Array.TrueForAll%2A> generic methods.</span></span>  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1083"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1083"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-1084">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1084">-or-</span></span>  
  
 <span data-ttu-id="31c36-1085"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1085"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31c36-1086">搜索与指定谓词定义的条件匹配的元素，然后返回 <see cref="T:System.Array" /> 或其某个部分中最后一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1086">Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the last occurrence within an <see cref="T:System.Array" /> or a portion of it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-1087">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1087">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-1088">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1088">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="31c36-1089"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="31c36-1089">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="31c36-1090">搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中最后一个匹配元素的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1090">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="31c36-1091">如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1091">The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1092"><xref:System.Array>向后搜索的最后一个元素开始，在第一个元素结束。</span><span class="sxs-lookup"><span data-stu-id="31c36-1092">The <xref:System.Array> is searched backward starting at the last element and ending at the first element.</span></span>  
  
 <span data-ttu-id="31c36-1093"><xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-1093">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="31c36-1094">元素`array`单独传递给<xref:System.Predicate%601>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1094">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="31c36-1095">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1095">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1096">下面的代码示例演示的所有三个重载<xref:System.Array.FindLastIndex%2A>泛型方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1096">The following code example demonstrates all three overloads of the <xref:System.Array.FindLastIndex%2A> generic method.</span></span> <span data-ttu-id="31c36-1097">创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-1097">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="31c36-1098">该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。</span><span class="sxs-lookup"><span data-stu-id="31c36-1098">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="31c36-1099"><xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从结束时，将每个元素传递给反过来遍历数组向后`EndsWithSaurus`方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1099">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array backward from the end, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="31c36-1100">搜索将停止时`EndsWithSaurus`方法返回`true`位于位置 5 处的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1100">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 5.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-1101">在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。</span><span class="sxs-lookup"><span data-stu-id="31c36-1101">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="31c36-1102">这些语言推断从上下文正确的委托，并自动创建。</span><span class="sxs-lookup"><span data-stu-id="31c36-1102">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="31c36-1103"><xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索数组开始位置 4 并向数组的开头后继续。</span><span class="sxs-lookup"><span data-stu-id="31c36-1103">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</span></span> <span data-ttu-id="31c36-1104">它找到位置 1 处的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1104">It finds the element at position 1.</span></span> <span data-ttu-id="31c36-1105">最后，<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的三个元素从位置 4 开始，向回查找 （即，元素 4、 3 和 2） 的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1105">Finally, the <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</span></span> <span data-ttu-id="31c36-1106">它返回 – 1，因为没有在该范围内不复存在名以"saurus"结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-1106">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1107"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1107"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-1108">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1108">-or-</span></span>  
  
 <span data-ttu-id="31c36-1109"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1109"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-1110">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1110">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-1111">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1111">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="31c36-1112">向后搜索的从零开始的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1112">The zero-based starting index of the backward search.</span></span></param>
        <param name="match"><span data-ttu-id="31c36-1113"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="31c36-1113">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="31c36-1114">搜索与由指定谓词定义的条件相匹配的元素，并返回 <see cref="T:System.Array" /> 中从第一个元素到指定索引的元素范围内最后一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1114">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the first element to the specified index.</span></span></summary>
        <returns><span data-ttu-id="31c36-1115">如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1115">The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1116"><xref:System.Array>是搜索向后开始`startIndex`和结束的第一个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1116">The <xref:System.Array> is searched backward starting at `startIndex` and ending at the first element.</span></span>  
  
 <span data-ttu-id="31c36-1117"><xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-1117">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="31c36-1118">元素`array`单独传递给<xref:System.Predicate%601>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1118">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="31c36-1119">此方法为 O (`n`) 操作，其中`n`是从开始处的元素数目`array`到`startIndex`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1119">This method is an O(`n`) operation, where `n` is the number of elements from the beginning of `array` to `startIndex`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1120">下面的代码示例演示的所有三个重载<xref:System.Array.FindLastIndex%2A>泛型方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1120">The following code example demonstrates all three overloads of the <xref:System.Array.FindLastIndex%2A> generic method.</span></span> <span data-ttu-id="31c36-1121">创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-1121">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="31c36-1122">该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。</span><span class="sxs-lookup"><span data-stu-id="31c36-1122">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="31c36-1123"><xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从结束时，将每个元素传递给反过来遍历数组向后`EndsWithSaurus`方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1123">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array backward from the end, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="31c36-1124">搜索将停止时`EndsWithSaurus`方法返回`true`位于位置 5 处的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1124">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 5.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-1125">在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。</span><span class="sxs-lookup"><span data-stu-id="31c36-1125">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="31c36-1126">这些语言推断从上下文正确的委托，并自动创建。</span><span class="sxs-lookup"><span data-stu-id="31c36-1126">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="31c36-1127"><xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索数组开始位置 4 并向数组的开头后继续。</span><span class="sxs-lookup"><span data-stu-id="31c36-1127">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</span></span> <span data-ttu-id="31c36-1128">它找到位置 1 处的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1128">It finds the element at position 1.</span></span> <span data-ttu-id="31c36-1129">最后，<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的三个元素从位置 4 开始，向回查找 （即，元素 4、 3 和 2） 的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1129">Finally, the <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</span></span> <span data-ttu-id="31c36-1130">它返回 – 1，因为没有在该范围内不复存在名以"saurus"结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-1130">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1131"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1131"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-1132">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1132">-or-</span></span>  
  
 <span data-ttu-id="31c36-1133"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1133"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1134"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1134"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-1135">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1135">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-1136">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1136">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="31c36-1137">向后搜索的从零开始的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1137">The zero-based starting index of the backward search.</span></span></param>
        <param name="count"><span data-ttu-id="31c36-1138">要搜索的部分中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1138">The number of elements in the section to search.</span></span></param>
        <param name="match"><span data-ttu-id="31c36-1139"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</span><span class="sxs-lookup"><span data-stu-id="31c36-1139">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="31c36-1140">搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Array" /> 中包含指定元素个数、到指定索引结束的元素范围内最后一个匹配项的从零开始的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1140">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</span></span></summary>
        <returns><span data-ttu-id="31c36-1141">如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1141">The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1142"><xref:System.Array>是搜索向后开始`startIndex`结束`startIndex`减`count`加上 1，如果`count`大于 0。</span><span class="sxs-lookup"><span data-stu-id="31c36-1142">The <xref:System.Array> is searched backward starting at `startIndex` and ending at `startIndex` minus `count` plus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="31c36-1143"><xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-1143">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="31c36-1144">元素`array`单独传递给<xref:System.Predicate%601>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1144">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="31c36-1145">此方法为 O (`n`) 操作，其中`n`是`count`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1145">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1146">下面的代码示例演示的所有三个重载<xref:System.Array.FindLastIndex%2A>泛型方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1146">The following code example demonstrates all three overloads of the <xref:System.Array.FindLastIndex%2A> generic method.</span></span> <span data-ttu-id="31c36-1147">创建一个字符串数组，其中包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-1147">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="31c36-1148">该代码示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。</span><span class="sxs-lookup"><span data-stu-id="31c36-1148">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="31c36-1149"><xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>方法重载从结束时，将每个元素传递给反过来遍历数组向后`EndsWithSaurus`方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1149">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array backward from the end, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="31c36-1150">搜索将停止时`EndsWithSaurus`方法返回`true`位于位置 5 处的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1150">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 5.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-1151">在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。</span><span class="sxs-lookup"><span data-stu-id="31c36-1151">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="31c36-1152">这些语言推断从上下文正确的委托，并自动创建。</span><span class="sxs-lookup"><span data-stu-id="31c36-1152">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="31c36-1153"><xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索数组开始位置 4 并向数组的开头后继续。</span><span class="sxs-lookup"><span data-stu-id="31c36-1153">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</span></span> <span data-ttu-id="31c36-1154">它找到位置 1 处的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1154">It finds the element at position 1.</span></span> <span data-ttu-id="31c36-1155">最后，<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于搜索的三个元素从位置 4 开始，向回查找 （即，元素 4、 3 和 2） 的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1155">Finally, the <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</span></span> <span data-ttu-id="31c36-1156">它返回 – 1，因为没有在该范围内不复存在名以"saurus"结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-1156">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1157"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1157"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-1158">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1158">-or-</span></span>  
  
 <span data-ttu-id="31c36-1159"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1159"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1160"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1160"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-1161">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1161">-or-</span></span>  
  
 <span data-ttu-id="31c36-1162"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1162"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-1163">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1163">-or-</span></span>  
  
 <span data-ttu-id="31c36-1164"><paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</span><span class="sxs-lookup"><span data-stu-id="31c36-1164"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-1165">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1165">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-1166">从零开始的一维 <see cref="T:System.Array" />，要对其元素执行操作。</span><span class="sxs-lookup"><span data-stu-id="31c36-1166">The one-dimensional, zero-based <see cref="T:System.Array" /> on whose elements the action is to be performed.</span></span></param>
        <param name="action"><span data-ttu-id="31c36-1167">要对 <c>array</c> 的每个元素执行的 <see cref="T:System.Action`1" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1167">The <see cref="T:System.Action`1" /> to perform on each element of <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="31c36-1168">对指定数组的每个元素执行指定操作。</span><span class="sxs-lookup"><span data-stu-id="31c36-1168">Performs the specified action on each element of the specified array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1169"><xref:System.Action%601>向其传递对对象执行的操作方法的委托。</span><span class="sxs-lookup"><span data-stu-id="31c36-1169">The <xref:System.Action%601> is a delegate to a method that performs an action on the object passed to it.</span></span>  <span data-ttu-id="31c36-1170">元素`array`单独传递给<xref:System.Action%601>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1170">The elements of `array` are individually passed to the <xref:System.Action%601>.</span></span>  
  
 <span data-ttu-id="31c36-1171">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1171">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1172">下面的示例演示如何使用<xref:System.Array.ForEach%2A>要在整数数组中显示的每个元素的平方。</span><span class="sxs-lookup"><span data-stu-id="31c36-1172">The following example shows how to use <xref:System.Array.ForEach%2A> to display the squares of each element in an integer array.</span></span>  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1173"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1173"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-1174">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1174">-or-</span></span>  
  
 <span data-ttu-id="31c36-1175"><paramref name="action" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1175"><paramref name="action" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31c36-1176">返回 <see cref="T:System.Collections.IEnumerator" /> 的 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1176">Returns an <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="31c36-1177"><see cref="T:System.Collections.IEnumerator" /> 的一个 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1177">An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1178">[Visual Basic、 C#]</span><span class="sxs-lookup"><span data-stu-id="31c36-1178">[Visual Basic, C#]</span></span>  
  
 <span data-ttu-id="31c36-1179">`foreach` C# 语言的语句 (`for each` c + + 中`For Each`在 Visual Basic 中) 隐藏了枚举数的复杂性。</span><span class="sxs-lookup"><span data-stu-id="31c36-1179">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of the enumerators.</span></span> <span data-ttu-id="31c36-1180">因此，建议使用 `foreach`，而不是直接操作枚举数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1180">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="31c36-1181">枚举器可用于读取集合中的数据，但不能用于修改基础集合。</span><span class="sxs-lookup"><span data-stu-id="31c36-1181">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="31c36-1182">最初，枚举数定位在集合中第一个元素的前面。</span><span class="sxs-lookup"><span data-stu-id="31c36-1182">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="31c36-1183"><xref:System.Collections.IEnumerator.Reset%2A> 也会将枚举器放回此位置。</span><span class="sxs-lookup"><span data-stu-id="31c36-1183"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span>  <span data-ttu-id="31c36-1184">在此位置上，未定义 <xref:System.Collections.IEnumerator.Current%2A>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1184">At this position, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="31c36-1185">因此，在读取 <xref:System.Collections.IEnumerator.MoveNext%2A> 的值之前，必须调用 <xref:System.Collections.IEnumerator.Current%2A> 将枚举器向前移动到集合的第一个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1185">Therefore, you must call <xref:System.Collections.IEnumerator.MoveNext%2A> to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="31c36-1186">在调用 <xref:System.Collections.IEnumerator.Current%2A> 或 <xref:System.Collections.IEnumerator.MoveNext%2A> 之前，<xref:System.Collections.IEnumerator.Reset%2A> 返回同一对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1186"><xref:System.Collections.IEnumerator.Current%2A> returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="31c36-1187"><xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.IEnumerator.Current%2A> 设置为下一个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1187"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="31c36-1188">如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过的末尾的集合，枚举数定位在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1188">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="31c36-1189">当枚举器位于此位置上，后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1189">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="31c36-1190">如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1190">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="31c36-1191">若要再次将 <xref:System.Collections.IEnumerator.Current%2A> 设置为集合的第一个元素，可以调用 <xref:System.Collections.IEnumerator.Reset%2A> 并接着调用 <xref:System.Collections.IEnumerator.MoveNext%2A>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1191">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="31c36-1192">只要集合保持不变，枚举数就保持有效。</span><span class="sxs-lookup"><span data-stu-id="31c36-1192">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="31c36-1193">如果对集合进行更改（如添加、修改或删除元素），则枚举数将失效且不可恢复，而且其行为是不确定的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1193">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="31c36-1194">该枚举数不具有独占访问集合的权限；因此，枚举整个集合本质上不是一个线程安全的过程。</span><span class="sxs-lookup"><span data-stu-id="31c36-1194">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</span></span>  <span data-ttu-id="31c36-1195">若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。</span><span class="sxs-lookup"><span data-stu-id="31c36-1195">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="31c36-1196">若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。</span><span class="sxs-lookup"><span data-stu-id="31c36-1196">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="31c36-1197">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1197">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1198">下面的代码示例演示如何使用<xref:System.Array.GetEnumerator%2A>列出数组的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1198">The following code example shows how to use <xref:System.Array.GetEnumerator%2A> to list the elements of an array.</span></span>  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="31c36-1199"><see cref="T:System.Array" /> 的从零开始的维度，其长度需要确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-1199">A zero-based dimension of the <see cref="T:System.Array" /> whose length needs to be determined.</span></span></param>
        <summary><span data-ttu-id="31c36-1200">获取一个 32 位整数，该整数表示 <see cref="T:System.Array" /> 的指定维中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1200">Gets a 32-bit integer that represents the number of elements in the specified dimension of the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="31c36-1201">一个 32 位整数，它表示指定维中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1201">A 32-bit integer that represents the number of elements in the specified dimension.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1202">一个示例<xref:System.Array.GetLength%2A>是`GetLength(0)`，其返回的第一个维度中的元素数<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1202">An example of <xref:System.Array.GetLength%2A> is `GetLength(0)`, which returns the number of elements in the first dimension of the <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-1203">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1203">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1204">下面的示例演示如何使用<xref:System.Array.GetLength%2A>以显示两个具有不同的秩的数组的维度。</span><span class="sxs-lookup"><span data-stu-id="31c36-1204">The following example shows how to use <xref:System.Array.GetLength%2A> to display the dimensions of two arrays with different ranks.</span></span>  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="31c36-1205"><paramref name="dimension" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1205"><paramref name="dimension" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-1206">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1206">-or-</span></span>  
  
 <span data-ttu-id="31c36-1207"><paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1207"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="31c36-1208"><see cref="T:System.Array" /> 的从零开始的维度，其长度需要确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-1208">A zero-based dimension of the <see cref="T:System.Array" /> whose length needs to be determined.</span></span></param>
        <summary><span data-ttu-id="31c36-1209">获取一个 64 位整数，该整数表示 <see cref="T:System.Array" /> 的指定维中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1209">Gets a 64-bit integer that represents the number of elements in the specified dimension of the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="31c36-1210">一个 64 位整数，它表示指定维中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1210">A 64-bit integer that represents the number of elements in the specified dimension.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1211">一个示例<xref:System.Array.GetLongLength%2A>是`GetLongLength(0)`，其返回的第一个维度中的元素数<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1211">An example of <xref:System.Array.GetLongLength%2A> is `GetLongLength(0)`, which returns the number of elements in the first dimension of the <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-1212">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1212">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="31c36-1213"><paramref name="dimension" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1213"><paramref name="dimension" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-1214">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1214">-or-</span></span>  
  
 <span data-ttu-id="31c36-1215"><paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1215"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="31c36-1216">数组的从零开始的维度，其起始索引需要确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-1216">A zero-based dimension of the array whose starting index needs to be determined.</span></span></param>
        <summary><span data-ttu-id="31c36-1217">获取数组中指定维度第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1217">Gets the index of the first element of the specified dimension in the array.</span></span></summary>
        <returns><span data-ttu-id="31c36-1218">数组中指定维度第一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1218">The index of the first element of the specified dimension in the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1219">`GetLowerBound(0)` 返回数组的第一个维度的起始索引和`GetLowerBound(Rank - 1)`返回数组的最后一个维度的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1219">`GetLowerBound(0)` returns the starting index of the first dimension of the array, and `GetLowerBound(Rank - 1)` returns the starting index of the last dimension of the array.</span></span>  
  
 <span data-ttu-id="31c36-1220"><xref:System.Array.GetLowerBound%2A>方法始终返回一个值，指示该数组的下限的索引，即使数组为空。</span><span class="sxs-lookup"><span data-stu-id="31c36-1220">The <xref:System.Array.GetLowerBound%2A> method always returns a value that indicates the index of the lower bound of the array, even if the array is empty.</span></span>  
  
 <span data-ttu-id="31c36-1221">请注意，虽然大多数.NET Framework 中的数组是从零开始 (即，<xref:System.Array.GetLowerBound%2A>方法将返回每个维度的数组的 0)，.NET Framework 支持不从零开始的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1221">Note that, although most arrays in the .NET Framework are zero-based (that is, the <xref:System.Array.GetLowerBound%2A> method returns zero for each dimension of an array), the .NET Framework does support arrays that are not zero-based.</span></span> <span data-ttu-id="31c36-1222">可用于创建此类阵列<xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29>方法，并还可以从非托管代码返回。</span><span class="sxs-lookup"><span data-stu-id="31c36-1222">Such arrays can be created with the <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> method, and can also be returned from unmanaged code.</span></span>  
  
 <span data-ttu-id="31c36-1223">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1223">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1224">下面的示例使用<xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法以显示一维数组与二维数组的边界并显示其数组元素的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1224">The following example uses the <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</span></span>  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="31c36-1225"><paramref name="dimension" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1225"><paramref name="dimension" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-1226">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1226">-or-</span></span>  
  
 <span data-ttu-id="31c36-1227"><paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1227"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="31c36-1228">数组的从零开始的维度，其上限需要确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-1228">A zero-based dimension of the array whose upper bound needs to be determined.</span></span></param>
        <summary><span data-ttu-id="31c36-1229">获取数组中指定维度最后一个元素的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1229">Gets the index of the last element of the specified dimension in the array.</span></span></summary>
        <returns><span data-ttu-id="31c36-1230">数组中指定维度最后一个元素的索引，或 -1（如果指定维度为空）。</span><span class="sxs-lookup"><span data-stu-id="31c36-1230">The index of the last element of the specified dimension in the array, or -1 if the specified dimension is empty.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1231">`GetUpperBound(0)` 返回数组的第一个维度中的最后一个索引和`GetUpperBound(Rank - 1)`返回数组的最后一个维度的最后一个索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1231">`GetUpperBound(0)` returns the last index in the first dimension of the array, and `GetUpperBound(Rank - 1)` returns the last index of the last dimension of the array.</span></span>  
  
 <span data-ttu-id="31c36-1232">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1232">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1233">下面的示例使用<xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法以显示一维数组与二维数组的边界并显示其数组元素的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1233">The following example uses the <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</span></span>  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="31c36-1234"><paramref name="dimension" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1234"><paramref name="dimension" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-1235">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1235">-or-</span></span>  
  
 <span data-ttu-id="31c36-1236"><paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1236"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31c36-1237">获取当前 <see cref="T:System.Array" /> 中指定元素的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1237">Gets the value of the specified element in the current <see cref="T:System.Array" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="31c36-1238">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的位置。</span><span class="sxs-lookup"><span data-stu-id="31c36-1238">A 32-bit integer that represents the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="31c36-1239">获取一维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1239">Gets the value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1240">索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1240">The index is specified as a 32-bit integer.</span></span></summary>
        <returns><span data-ttu-id="31c36-1241">一维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1241">The value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1242"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定是否的值`index`超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1242">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1243">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1243">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1244">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1244">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1245">当前的 <see cref="T:System.Array" /> 不是正好有一维。</span><span class="sxs-lookup"><span data-stu-id="31c36-1245">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="31c36-1246"><paramref name="index" /> 超出当前 <see cref="T:System.Array" /> 的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1246"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices"><span data-ttu-id="31c36-1247">32 位整数的一维数组，它表示用于指定要获取的 <see cref="T:System.Array" /> 元素的位置的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1247">A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="31c36-1248">获取多维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1248">Gets the value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1249">索引指定为一个 32 位整数数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1249">The indexes are specified as an array of 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="31c36-1250">多维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1250">The value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1251">中的元素数`indices`必须等于的中的维数<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1251">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="31c36-1252">中的所有元素`indices`数组必须共同指定所需元素的位置，在多维<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1252">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-1253"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1253">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1254">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1254">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1255">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1255">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1256"><paramref name="indices" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1256"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1257">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1257">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="31c36-1258"><paramref name="indices" /> 中的任何元素都超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1258">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="31c36-1259">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的位置。</span><span class="sxs-lookup"><span data-stu-id="31c36-1259">A 64-bit integer that represents the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="31c36-1260">获取一维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1260">Gets the value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1261">索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1261">The index is specified as a 64-bit integer.</span></span></summary>
        <returns><span data-ttu-id="31c36-1262">一维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1262">The value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1263"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定是否的值`index`超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1263">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1264">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1264">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1265">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1265">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1266">当前的 <see cref="T:System.Array" /> 不是正好有一维。</span><span class="sxs-lookup"><span data-stu-id="31c36-1266">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1267"><paramref name="index" /> 超出当前 <see cref="T:System.Array" /> 的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1267"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices"><span data-ttu-id="31c36-1268">一个 64 位整数的一维数组，它表示指定要获取的 <see cref="T:System.Array" /> 元素的位置的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1268">A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="31c36-1269">获取多维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1269">Gets the value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1270">索引指定为一个 64 位整数数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1270">The indexes are specified as an array of 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="31c36-1271">多维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1271">The value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1272">中的元素数`indices`必须等于的中的维数<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1272">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="31c36-1273">中的所有元素`indices`数组必须共同指定所需元素的位置，在多维<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1273">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-1274"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1274">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1275">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1275">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1276">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1276">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1277"><paramref name="indices" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1277"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1278">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1278">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="31c36-1279"><paramref name="indices" /> 中的任何元素都超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1279">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="31c36-1280">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1280">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="31c36-1281">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1281">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="31c36-1282">获取二维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1282">Gets the value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1283">索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1283">The indexes are specified as 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="31c36-1284">二维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1284">The value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1285"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1285">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1286">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1286">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1287">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1287">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1288">当前的 <see cref="T:System.Array" /> 不是正好有两维。</span><span class="sxs-lookup"><span data-stu-id="31c36-1288">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="31c36-1289"><paramref name="index1" /> 或 <paramref name="index2" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1289">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="31c36-1290">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1290">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="31c36-1291">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1291">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="31c36-1292">获取二维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1292">Gets the value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1293">索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1293">The indexes are specified as 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="31c36-1294">二维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1294">The value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1295"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1295">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1296">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1296">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1297">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1297">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1298">当前的 <see cref="T:System.Array" /> 不是正好有两维。</span><span class="sxs-lookup"><span data-stu-id="31c36-1298">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="31c36-1299"><paramref name="index1" /> 或 <paramref name="index2" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1299">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="31c36-1300">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1300">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="31c36-1301">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1301">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index3"><span data-ttu-id="31c36-1302">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第三维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1302">A 32-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="31c36-1303">获取三维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1303">Gets the value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1304">索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1304">The indexes are specified as 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="31c36-1305">三维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1305">The value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1306"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1306">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1307">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1307">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1308">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1308">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1309">当前的 <see cref="T:System.Array" /> 不是正好有三维。</span><span class="sxs-lookup"><span data-stu-id="31c36-1309">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="31c36-1310"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1310"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="31c36-1311">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1311">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="31c36-1312">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1312">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index3"><span data-ttu-id="31c36-1313">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第三维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1313">A 64-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="31c36-1314">获取三维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1314">Gets the value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1315">索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1315">The indexes are specified as 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="31c36-1316">三维 <see cref="T:System.Array" /> 中指定位置的值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1316">The value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1317"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1317">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1318">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1318">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1319">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1319">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1320">当前的 <see cref="T:System.Array" /> 不是正好有三维。</span><span class="sxs-lookup"><span data-stu-id="31c36-1320">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1321"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1321"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31c36-1322">在一个一维数组或该数组的一系列元素中搜索指定对象，并返回其首个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1322">Searches for the specified object and returns the index of its first occurrence in a one-dimensional array or in a range of elements in the array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-1323">要搜索的一维数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1323">The one-dimensional array to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-1324">要在 <c>array</c> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1324">The object to locate in <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="31c36-1325">在一个一维数组中搜索指定对象，并返回其首个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1325">Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</span></span></summary>
        <returns><span data-ttu-id="31c36-1326">如果找到，则为 <paramref name="array" /> 中 <paramref name="value" /> 的第一个匹配项的索引；否则为该数组的下限减 1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1326">The index of the first occurrence of <paramref name="value" /> in <paramref name="array" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1327">此方法搜索的一维 arrayfor 的所有元素`value`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1327">This method searches all the elements of a one-dimensional arrayfor `value`.</span></span> <span data-ttu-id="31c36-1328">若要确定是否`value`中存在`array`，该方法通过调用每个元素执行的相等比较`Equals`方法，直到它找到的匹配项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1328">To determine whether `value` exists in `array`, the method performs an equality comparison by calling each element's `Equals` method until it finds a match.</span></span> <span data-ttu-id="31c36-1329">这意味着，如果元素会替代<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，重写方法调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-1329">This means that if the element overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, that override is called.</span></span>  
  
 <span data-ttu-id="31c36-1330">因为大多数数组具有下限为零，此方法通常返回 – 1 如果`value`找不到。</span><span class="sxs-lookup"><span data-stu-id="31c36-1330">Because most arrays have a lower bound of zero, this method generally returns –1 if`value` isn’t found.</span></span> <span data-ttu-id="31c36-1331">数组的下限是等于的罕见情况<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) 和`value`找不到，此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF)。</span><span class="sxs-lookup"><span data-stu-id="31c36-1331">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) and `value` isn’t found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span></span>  
  
 <span data-ttu-id="31c36-1332">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1332">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1333">该示例将调用以下三个重载的<xref:System.Array.IndexOf%2A>方法以字符串数组中查找的字符串的索引：</span><span class="sxs-lookup"><span data-stu-id="31c36-1333">The example calls the following three overloads of the <xref:System.Array.IndexOf%2A> method to find the index of a string in a string array:</span></span>  
  
-   <span data-ttu-id="31c36-1334"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>以确定第一个匹配项的字符串"the"中的字符串数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1334"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, to determine the first occurrence of the string "the" in a string array.</span></span>  
  
-   <span data-ttu-id="31c36-1335"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>以确定第一个匹配项的字符串"the"中的字符串数组的最后一个元素的第四个。</span><span class="sxs-lookup"><span data-stu-id="31c36-1335"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</span></span>  
  
-   <span data-ttu-id="31c36-1336"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>以确定第一个匹配项的字符串"the"在一个字符串数组之后到数组末尾之间的最后一个成功匹配的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1336"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</span></span>  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1337"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1337"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-1338"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1338"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-1339">要搜索的一维数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1339">The one-dimensional array to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-1340">要在 <c>array</c> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1340">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="31c36-1341">搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1341">The starting index of the search.</span></span> <span data-ttu-id="31c36-1342">空数组中 0（零）为有效值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1342">0 (zero) is valid in an empty array.</span></span></param>
        <summary><span data-ttu-id="31c36-1343">在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1343">Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</span></span> <span data-ttu-id="31c36-1344">该元素系列的范围为从指定索引到该数组结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-1344">The range extends from a specified index to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="31c36-1345">如果在从 <paramref name="startIndex" /> 到最后一个元素的 <paramref name="array" /> 中的元素范围中找到了 <paramref name="value" /> 的第一个匹配项的索引，则为该索引；否则为数组的下限减 1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1345">The index of the first occurrence of <paramref name="value" />, if it’s found, within the range of elements in <paramref name="array" /> that extends from <paramref name="startIndex" /> to the last element; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1346">此方法搜索索引处的元素从一维数组`startIndex`中最后一个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1346">This method searches a one-dimensional array from the element at index `startIndex` to the last element.</span></span> <span data-ttu-id="31c36-1347">若要确定是否`value`中存在`array`，该方法通过调用执行的相等比较`Equals`的每个元素，直到它找到的匹配项的方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1347">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `Equals` method of every element until it finds a match.</span></span> <span data-ttu-id="31c36-1348">这意味着，如果元素会替代<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，重写方法调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-1348">This means that if the element overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, that override is called.</span></span>  
  
 <span data-ttu-id="31c36-1349">因为大多数数组具有下限为零，此方法通常返回 – 1 如果`value`找不到。</span><span class="sxs-lookup"><span data-stu-id="31c36-1349">Because most arrays have a lower bound of zero, this method generally returns –1 if `value` isn’t found.</span></span> <span data-ttu-id="31c36-1350">数组的下限是等于的罕见情况<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) 和`value`找不到，此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF)。</span><span class="sxs-lookup"><span data-stu-id="31c36-1350">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) and `value` isn’t found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span></span>  
  
 <span data-ttu-id="31c36-1351">如果`startIndex`等于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法返回-1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1351">If `startIndex` equals <xref:System.Array.Length%2A?displayProperty=nameWithType>,the method returns -1.</span></span> <span data-ttu-id="31c36-1352">如果`startIndex`大于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法将引发<xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1352">If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="31c36-1353">此方法为 O (`n`) 操作，其中`n`是中的元素数`startIndex`到末尾`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1353">This method is an O(`n`) operation, where `n` is the number of elements from `startIndex` to the end of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1354">该示例将调用以下三个重载的<xref:System.Array.IndexOf%2A>方法以字符串数组中查找的字符串的索引：</span><span class="sxs-lookup"><span data-stu-id="31c36-1354">The example calls the following three overloads of the <xref:System.Array.IndexOf%2A> method to find the index of a string in a string array:</span></span>  
  
-   <span data-ttu-id="31c36-1355"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>以确定第一个匹配项的字符串"the"中的字符串数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1355"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, to determine the first occurrence of the string "the" in a string array.</span></span>  
  
-   <span data-ttu-id="31c36-1356"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>以确定第一个匹配项的字符串"the"中的字符串数组的最后一个元素的第四个。</span><span class="sxs-lookup"><span data-stu-id="31c36-1356"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</span></span>  
  
-   <span data-ttu-id="31c36-1357"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>以确定第一个匹配项的字符串"the"在一个字符串数组之后到数组末尾之间的最后一个成功匹配的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1357"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</span></span>  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1358"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1358"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1359"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1359"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-1360"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1360"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-1361">要搜索的一维数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1361">The one-dimensional array to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-1362">要在 <c>array</c> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1362">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="31c36-1363">搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1363">The starting index of the search.</span></span> <span data-ttu-id="31c36-1364">空数组中 0（零）为有效值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1364">0 (zero) is valid in an empty array.</span></span></param>
        <param name="count"><span data-ttu-id="31c36-1365">要搜索的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1365">The number of elements to search.</span></span></param>
        <summary><span data-ttu-id="31c36-1366">在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1366">Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of ifs first occurrence.</span></span> <span data-ttu-id="31c36-1367">该元素系列的范围从指定数量的元素的指定索引开始。</span><span class="sxs-lookup"><span data-stu-id="31c36-1367">The range extends from a specified index for a specified number of elements.</span></span></summary>
        <returns><span data-ttu-id="31c36-1368">如果在从索引 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> - 1 的 <paramref name="array" /> 中找到了 <paramref name="value" /> 的第一个匹配项的索引，则为该索引；否则为该数组的下限减 1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1368">The index of the first occurrence of <paramref name="value" />, if it’s found in the <paramref name="array" /> from index <paramref name="startIndex" /> to <paramref name="startIndex" /> + <paramref name="count" /> - 1; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1369">此方法搜索的一维 arrayfrom 元素`startIndex`到`startIndex`加上`count`减 1，如果`count`大于 0。</span><span class="sxs-lookup"><span data-stu-id="31c36-1369">This method searches the elements of a one-dimensional arrayfrom `startIndex` to `startIndex` plus `count` minus 1, if `count` is greater than 0.</span></span> <span data-ttu-id="31c36-1370">若要确定是否`value`中存在`array`，该方法通过调用执行的相等比较`Equals`的每个元素，直到它找到的匹配项的方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1370">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `Equals` method of every element until it finds a match.</span></span> <span data-ttu-id="31c36-1371">这意味着，如果元素会替代<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法，重写方法调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-1371">This means that if the element overrides the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method, that override is called.</span></span>  
  
 <span data-ttu-id="31c36-1372">Becausemost 数组具有下限为零，则此方法通常返回 – 1 在`value`找不到。</span><span class="sxs-lookup"><span data-stu-id="31c36-1372">Becausemost arrays have a lower bound of zero, this method generally returns –1 when `value` isn’t found.</span></span> <span data-ttu-id="31c36-1373">数组的下限是等于的罕见情况<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) 和`value`找不到，此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>(0x7FFFFFFF)。</span><span class="sxs-lookup"><span data-stu-id="31c36-1373">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) and `value` isn’t found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span></span>  
  
 <span data-ttu-id="31c36-1374">如果`startindex`等于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法返回-1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1374">If `startindex` equals <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method returns -1.</span></span> <span data-ttu-id="31c36-1375">如果`startIndex`大于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法将引发<xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1375">If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="31c36-1376">此方法为 O (`n`) 操作，其中`n`是`count`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1376">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1377">该示例将调用以下三个重载的<xref:System.Array.IndexOf%2A>方法以字符串数组中查找的字符串的索引：</span><span class="sxs-lookup"><span data-stu-id="31c36-1377">The example calls the following three overloads of the <xref:System.Array.IndexOf%2A> method to find the index of a string in a string array:</span></span>  
  
-   <span data-ttu-id="31c36-1378"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>以确定第一个匹配项的字符串"the"中的字符串数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1378"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, to determine the first occurrence of the string "the" in a string array.</span></span>  
  
-   <span data-ttu-id="31c36-1379"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>以确定第一个匹配项的字符串"the"中的字符串数组的最后一个元素的第四个。</span><span class="sxs-lookup"><span data-stu-id="31c36-1379"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</span></span>  
  
-   <span data-ttu-id="31c36-1380"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>以确定第一个匹配项的字符串"the"在一个字符串数组之后到数组末尾之间的最后一个成功匹配的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1380"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</span></span> <span data-ttu-id="31c36-1381">若要确定其值的`count`自变量，它减去从的起始索引数组的上限，并添加一个。</span><span class="sxs-lookup"><span data-stu-id="31c36-1381">To determine the value of the `count` argument, it subtracts the upper bound of the array from the starting index and adds one.</span></span>  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1382"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1382"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1383"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1383"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-1384">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1384">-or-</span></span>  
  
 <span data-ttu-id="31c36-1385"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1385"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-1386">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1386">-or-</span></span>  
  
 <span data-ttu-id="31c36-1387"><paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</span><span class="sxs-lookup"><span data-stu-id="31c36-1387"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-1388"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1388"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-1389">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1389">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-1390">要搜索的从零开始的一维数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1390">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-1391">要在 <c>array</c> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1391">The object to locate in <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="31c36-1392">在一个一维数组中搜索指定对象，并返回其首个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1392">Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</span></span></summary>
        <returns><span data-ttu-id="31c36-1393">如果在整个 <paramref name="array" /> 中找到 <paramref name="value" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1393">The zero-based index of the first occurrence of <paramref name="value" /> in the entire <paramref name="array" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1394">此方法搜索的一维数组的所有元素`value`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1394">This method searches all the elements of a one-dimensional array for `value`.</span></span> <span data-ttu-id="31c36-1395">若要确定是否`value`中存在`array`，该方法通过调用执行的相等比较`T.Equals`对每个元素的方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1395">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `T.Equals` method on every element.</span></span> <span data-ttu-id="31c36-1396">这意味着，如果`T`重写<xref:System.Object.Equals%2A>方法，重写方法调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-1396">This means that if `T` overrides the <xref:System.Object.Equals%2A> method, that override is called.</span></span>  
  
 <span data-ttu-id="31c36-1397">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1397">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1398">下面的示例演示的所有三个泛型重载<xref:System.Array.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1398">The following example demonstrates all three generic overloads of the <xref:System.Array.IndexOf%2A> method.</span></span> <span data-ttu-id="31c36-1399">创建一个字符串数组，其中有一项显示两次，在索引位置 0 和索引位置 5。</span><span class="sxs-lookup"><span data-stu-id="31c36-1399">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="31c36-1400"><xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从开始，数组中搜索并查找字符串的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1400">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the array from the beginning, and finds the first occurrence of the string.</span></span> <span data-ttu-id="31c36-1401"><xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载可用于搜索索引位置 3 开头的数组，直至到数组末尾之间的并查找字符串的第二个匹配项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1401">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</span></span> <span data-ttu-id="31c36-1402">最后，<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置两处开头的两个条目范围; 它将返回 – 1，因为没有在该范围内的搜索字符串的实例。</span><span class="sxs-lookup"><span data-stu-id="31c36-1402">Finally, the <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1403"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1403"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-1404">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1404">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-1405">要搜索的从零开始的一维数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1405">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-1406">要在 <c>array</c> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1406">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="31c36-1407">从零开始的搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1407">The zero-based starting index of the search.</span></span> <span data-ttu-id="31c36-1408">空数组中 0（零）为有效值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1408">0 (zero) is valid in an empty array.</span></span></param>
        <summary><span data-ttu-id="31c36-1409">在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1409">Searches for the specified object in a range of elements of a one dimensional array, and returns the index of its first occurrence.</span></span> <span data-ttu-id="31c36-1410">该元素系列的范围为从指定索引到该数组结尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-1410">The range extends from a specified index to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="31c36-1411">如果在 <paramref name="value" /> 中从 <paramref name="array" /> 到最后一个元素这部分元素中找到 <paramref name="startIndex" /> 的匹配项，则为第一个匹配项的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1411">The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from <paramref name="startIndex" /> to the last element, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1412">此方法搜索处的元素从一维数组`startIndex`到数组末尾。</span><span class="sxs-lookup"><span data-stu-id="31c36-1412">This method searches a one-dimensional array from the element at `startIndex` to the end of the array.</span></span> <span data-ttu-id="31c36-1413">若要确定是否`value`中存在`array`，该方法通过调用执行的相等比较`T.Equals`对每个元素的方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1413">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `T.Equals` method on every element.</span></span> <span data-ttu-id="31c36-1414">这意味着，如果`T`重写<xref:System.Object.Equals%2A>方法，重写方法调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-1414">This means that if `T` overrides the <xref:System.Object.Equals%2A> method, that override is called.</span></span>  
  
 <span data-ttu-id="31c36-1415">如果`startIndex`等于<xref:System.Array.Length%2A>，该方法返回-1.If`startIndex`大于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法将引发<xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1415">If `startIndex` equals <xref:System.Array.Length%2A>,the method returns -1.If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="31c36-1416">此方法为 O (`n`) 操作，其中`n`是中的元素数`startIndex`到末尾`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1416">This method is an O(`n`) operation, where `n` is the number of elements from `startIndex` to the end of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1417">下面的示例演示的所有三个泛型重载<xref:System.Array.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1417">The following example demonstrates all three generic overloads of the <xref:System.Array.IndexOf%2A> method.</span></span> <span data-ttu-id="31c36-1418">创建一个字符串数组，其中有一项显示两次，在索引位置 0 和索引位置 5。</span><span class="sxs-lookup"><span data-stu-id="31c36-1418">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="31c36-1419"><xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从开始，数组中搜索并查找字符串的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1419">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the array from the beginning, and finds the first occurrence of the string.</span></span> <span data-ttu-id="31c36-1420"><xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载可用于搜索索引位置 3 开头的数组，直至到数组末尾之间的并查找字符串的第二个匹配项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1420">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</span></span> <span data-ttu-id="31c36-1421">最后，<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置两处开头的两个条目范围; 它将返回 – 1，因为没有在该范围内的搜索字符串的实例。</span><span class="sxs-lookup"><span data-stu-id="31c36-1421">Finally, the <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1422"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1422"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1423"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1423"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-1424">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1424">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-1425">要搜索的从零开始的一维数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1425">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-1426">要在 <c>array</c> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1426">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="31c36-1427">从零开始的搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1427">The zero-based starting index of the search.</span></span> <span data-ttu-id="31c36-1428">空数组中 0（零）为有效值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1428">0 (zero) is valid in an empty array.</span></span></param>
        <param name="count"><span data-ttu-id="31c36-1429">要搜索的部分中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1429">The number of elements in the section to search.</span></span></param>
        <summary><span data-ttu-id="31c36-1430">在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1430">Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</span></span> <span data-ttu-id="31c36-1431">该元素系列的范围从指定数量的元素的指定索引开始。</span><span class="sxs-lookup"><span data-stu-id="31c36-1431">The range extends from a specified index for a specified number of elements.</span></span></summary>
        <returns><span data-ttu-id="31c36-1432">如果在 <paramref name="value" /> 中从 <paramref name="array" /> 开始、包含 <paramref name="startIndex" /> 所指定的元素个数的这部分元素中，找到 <paramref name="count" /> 的匹配项，则为第一个匹配项的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1432">The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that starts at <paramref name="startIndex" /> and contains the number of elements specified in <paramref name="count" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1433">此方法 searchesthe 元素从一维数组的`startIndex`到`startIndex`加上`count`减 1，如果`count`大于 0。</span><span class="sxs-lookup"><span data-stu-id="31c36-1433">This method searchesthe elements of a one-dimensional array from `startIndex` to `startIndex` plus `count` minus 1, if `count` is greater than 0.</span></span> <span data-ttu-id="31c36-1434">若要确定是否`value`中存在`array`，该方法通过调用执行的相等比较`T.Equals`对每个元素的方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1434">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `T.Equals` method on every element.</span></span> <span data-ttu-id="31c36-1435">这意味着，如果`T`重写<xref:System.Object.Equals%2A>方法，重写方法调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-1435">This means that if `T` overrides the <xref:System.Object.Equals%2A> method, that override is called.</span></span>  
  
 <span data-ttu-id="31c36-1436">如果`startIndex`等于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法返回-1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1436">If `startIndex` equals <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method returns -1.</span></span>  <span data-ttu-id="31c36-1437">如果`startIndex`大于<xref:System.Array.Length%2A?displayProperty=nameWithType>，该方法将引发<xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1437">If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="31c36-1438">此方法为 O (`n`) 操作，其中`n`是`count`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1438">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1439">下面的示例演示的所有三个泛型重载<xref:System.Array.IndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1439">The following example demonstrates all three generic overloads of the <xref:System.Array.IndexOf%2A> method.</span></span> <span data-ttu-id="31c36-1440">创建一个字符串数组，其中有一项显示两次，在索引位置 0 和索引位置 5。</span><span class="sxs-lookup"><span data-stu-id="31c36-1440">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="31c36-1441"><xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从开始，数组中搜索并查找字符串的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1441">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the array from the beginning, and finds the first occurrence of the string.</span></span> <span data-ttu-id="31c36-1442"><xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载可用于搜索索引位置 3 开头的数组，直至到数组末尾之间的并查找字符串的第二个匹配项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1442">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</span></span> <span data-ttu-id="31c36-1443">最后，<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置两处开头的两个条目范围; 它将返回 – 1，因为没有在该范围内的搜索字符串的实例。</span><span class="sxs-lookup"><span data-stu-id="31c36-1443">Finally, the <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1444"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1444"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1445"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1445"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-1446">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1446">-or-</span></span>  
  
 <span data-ttu-id="31c36-1447"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1447"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-1448">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1448">-or-</span></span>  
  
 <span data-ttu-id="31c36-1449"><paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</span><span class="sxs-lookup"><span data-stu-id="31c36-1449"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31c36-1450">通过调用值类型的默认构造函数，初始化值类型 <see cref="T:System.Array" /> 的每一个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1450">Initializes every element of the value-type <see cref="T:System.Array" /> by calling the default constructor of the value type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1451">此方法旨在帮助编译器支持值类型数组;大多数用户不需要使用此方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1451">This method is designed to help compilers support value-type arrays; most users do not need this method.</span></span> <span data-ttu-id="31c36-1452">它必须不使用引用类型数组中。</span><span class="sxs-lookup"><span data-stu-id="31c36-1452">It must not be used on reference-type arrays.</span></span>  
  
 <span data-ttu-id="31c36-1453">如果<xref:System.Array>不是值类型<xref:System.Array>或值类型不具有默认构造函数，如果<xref:System.Array>则不会修改。</span><span class="sxs-lookup"><span data-stu-id="31c36-1453">If the <xref:System.Array> is not a value-type <xref:System.Array> or if the value type does not have a default constructor, the <xref:System.Array> is not modified.</span></span>  
  
 <span data-ttu-id="31c36-1454">值类型<xref:System.Array>可以具有任何下限和任意数量的维度。</span><span class="sxs-lookup"><span data-stu-id="31c36-1454">The value-type <xref:System.Array> can have any lower bound and any number of dimensions.</span></span>  
  
 <span data-ttu-id="31c36-1455">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1455">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="31c36-1456">你可以仅在具有构造函数; 的值类型上使用此方法但是，值类型都向 C# 本机没有构造函数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1456">You can use this method only on value types that have constructors; however, value types that are native to C# do not have constructors.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31c36-1457">获取一个值，该值指示 <see cref="T:System.Array" /> 是否具有固定大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-1457">Gets a value indicating whether the <see cref="T:System.Array" /> has a fixed size.</span></span></summary>
        <value><span data-ttu-id="31c36-1458">此属性对于所有数组总是 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1458">This property is always <see langword="true" /> for all arrays.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1459"><xref:System.Array> 实现<xref:System.Array.IsFixedSize%2A>属性因为它必需的<xref:System.Collections.IList?displayProperty=nameWithType>接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-1459"><xref:System.Array> implements the <xref:System.Array.IsFixedSize%2A> property because it is required by the <xref:System.Collections.IList?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="31c36-1460">具有固定大小的数组不允许添加或移除元素，该数组在创建之后，且它允许修改现有元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1460">An array with a fixed size does not allow the addition or removal of elements after the array is created, but it allows the modification of existing elements.</span></span>  
  
 <span data-ttu-id="31c36-1461">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="31c36-1461">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31c36-1462">获取一个值，该值指示 <see cref="T:System.Array" /> 是否为只读。</span><span class="sxs-lookup"><span data-stu-id="31c36-1462">Gets a value indicating whether the <see cref="T:System.Array" /> is read-only.</span></span></summary>
        <value><span data-ttu-id="31c36-1463">此属性对于所有数组总是 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1463">This property is always <see langword="false" /> for all arrays.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1464"><xref:System.Array> 实现<xref:System.Array.IsReadOnly%2A>属性因为它必需的<xref:System.Collections.IList?displayProperty=nameWithType>接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-1464"><xref:System.Array> implements the <xref:System.Array.IsReadOnly%2A> property because it is required by the <xref:System.Collections.IList?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="31c36-1465">数组类型的值是只读的不允许添加、 移除或修改元素，创建数组后。</span><span class="sxs-lookup"><span data-stu-id="31c36-1465">An array that is read-only does not allow the addition, removal, or modification of elements after the array is created.</span></span>  
  
 <span data-ttu-id="31c36-1466">如果你需要只读集合，使用<xref:System.Collections>类，该类实现<xref:System.Collections.IList?displayProperty=nameWithType>接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-1466">If you require a read-only collection, use a <xref:System.Collections> class that implements the <xref:System.Collections.IList?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="31c36-1467">如果强制转换或转换到的数组<xref:System.Collections.IList>接口对象<xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType>属性返回`false`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1467">If you cast or convert an array to an <xref:System.Collections.IList> interface object, the <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> property returns `false`.</span></span> <span data-ttu-id="31c36-1468">但是，如果强制转换或转换到的数组<xref:System.Collections.Generic.IList%601>接口，`IsReadOnly`属性返回`true`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1468">However, if you cast or convert an array to a <xref:System.Collections.Generic.IList%601> interface, the `IsReadOnly` property returns `true`.</span></span>  
  
 <span data-ttu-id="31c36-1469">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="31c36-1469">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31c36-1470">获取一个值，该值指示是否同步对 <see cref="T:System.Array" /> 的访问（线程安全）。</span><span class="sxs-lookup"><span data-stu-id="31c36-1470">Gets a value indicating whether access to the <see cref="T:System.Array" /> is synchronized (thread safe).</span></span></summary>
        <value><span data-ttu-id="31c36-1471">此属性对于所有数组总是 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1471">This property is always <see langword="false" /> for all arrays.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1472"><xref:System.Array> 实现<xref:System.Array.IsSynchronized%2A>属性因为它必需的<xref:System.Collections.ICollection?displayProperty=nameWithType>接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-1472"><xref:System.Array> implements the <xref:System.Array.IsSynchronized%2A> property because it is required by the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="31c36-1473">.NET framework 类基于<xref:System.Array>提供其自己的同步的版本的集合使用<xref:System.Array.SyncRoot%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="31c36-1473">.NET Framework classes based on <xref:System.Array> provide their own synchronized version of the collection using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 <span data-ttu-id="31c36-1474">使用数组的类还可以实现自己的同步使用<xref:System.Array.SyncRoot%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="31c36-1474">Classes that use arrays can also implement their own synchronization using the <xref:System.Array.SyncRoot%2A> property.</span></span> <span data-ttu-id="31c36-1475">同步代码必须在执行操作`SyncRoot`不是直接对集合的集合。</span><span class="sxs-lookup"><span data-stu-id="31c36-1475">The synchronizing code must perform operations on the `SyncRoot` of the collection, not directly on the collection.</span></span> <span data-ttu-id="31c36-1476">这样可确保对从其他对象派生的集合正确地执行操作。</span><span class="sxs-lookup"><span data-stu-id="31c36-1476">This ensures proper operation of collections that are derived from other objects.</span></span> <span data-ttu-id="31c36-1477">具体地说，这样可保持正确的同步，与可能同时修改集合的其他线程。</span><span class="sxs-lookup"><span data-stu-id="31c36-1477">Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</span></span> <span data-ttu-id="31c36-1478">请注意，某些实现的<xref:System.Array.SyncRoot%2A>可能会返回<xref:System.Array>本身。</span><span class="sxs-lookup"><span data-stu-id="31c36-1478">Note that some implementations of <xref:System.Array.SyncRoot%2A> might return the <xref:System.Array> itself.</span></span>  
  
 <span data-ttu-id="31c36-1479">枚举整个集合本质上不是线程安全的过程。</span><span class="sxs-lookup"><span data-stu-id="31c36-1479">Enumerating through a collection is intrinsically not a thread safe procedure.</span></span> <span data-ttu-id="31c36-1480">即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-1480">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="31c36-1481">若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-1481">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="31c36-1482">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="31c36-1482">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1483">下面的代码示例演示如何通过使用在整个枚举过程中锁定数组<xref:System.Array.SyncRoot%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="31c36-1483">The following code example shows how to lock an array during the entire enumeration by using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31c36-1484">返回一维 <see cref="T:System.Array" /> 或部分 <see cref="T:System.Array" /> 中某个值的最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1484">Returns the index of the last occurrence of a value in a one-dimensional <see cref="T:System.Array" /> or in a portion of the <see cref="T:System.Array" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-1485">要搜索的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1485">The one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-1486">要在 <c>array</c> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1486">The object to locate in <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="31c36-1487">搜索指定的对象，并返回整个一维 <see cref="T:System.Array" /> 中最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1487">Searches for the specified object and returns the index of the last occurrence within the entire one-dimensional <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="31c36-1488">如果在整个 <paramref name="value" /> 中找到 <paramref name="array" /> 的匹配项，则为最后一个匹配项的索引；否则为该数组的下限减 1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1488">The index of the last occurrence of <paramref name="value" /> within the entire <paramref name="array" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1489">一维<xref:System.Array>向后搜索的最后一个元素开始，在第一个元素结束。</span><span class="sxs-lookup"><span data-stu-id="31c36-1489">The one-dimensional <xref:System.Array> is searched backward starting at the last element and ending at the first element.</span></span>  
  
 <span data-ttu-id="31c36-1490">对元素进行比较到指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1490">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="31c36-1491">如果元素类型是内部的 （用户定义的） 类型，`Equals`使用该类型的实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1491">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="31c36-1492">由于大多数数组将具有下限为零，因此此方法通常将返回 – 1 在`value`找不到。</span><span class="sxs-lookup"><span data-stu-id="31c36-1492">Since most arrays will have a lower bound of zero, this method would generally return –1 when `value` is not found.</span></span> <span data-ttu-id="31c36-1493">数组的下限是等于的罕见情况<xref:System.Int32.MinValue?displayProperty=nameWithType>和`value`未找到，则此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>，即`System.Int32.MinValue - 1`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1493">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> and `value` is not found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType>, which is `System.Int32.MinValue - 1`.</span></span>  
  
 <span data-ttu-id="31c36-1494">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1494">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 <span data-ttu-id="31c36-1495">在.NET Framework 2.0 版中，此方法使用<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法<xref:System.Array>以确定是否<xref:System.Object>指定的`value`参数存在。</span><span class="sxs-lookup"><span data-stu-id="31c36-1495">In the .NET Framework version 2.0, this method uses the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the <xref:System.Array> to determine whether the <xref:System.Object> specified by the `value` parameter exists.</span></span> <span data-ttu-id="31c36-1496">在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`value`<xref:System.Object>本身。</span><span class="sxs-lookup"><span data-stu-id="31c36-1496">In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the `value`<xref:System.Object> itself.</span></span>  
  
 <span data-ttu-id="31c36-1497"><xref:System.IComparable.CompareTo%2A> 方法的`item`参数的集合中的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1497"><xref:System.IComparable.CompareTo%2A> methods of the `item` parameter on the objects in the collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1498">下面的代码示例演示如何确定数组中指定的元素的最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1498">The following code example shows how to determine the index of the last occurrence of a specified element in an array.</span></span>  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1499"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1499"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-1500"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1500"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-1501">要搜索的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1501">The one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-1502">要在 <c>array</c> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1502">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="31c36-1503">向后搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1503">The starting index of the backward search.</span></span></param>
        <summary><span data-ttu-id="31c36-1504">搜索指定的对象，并返回一维 <see cref="T:System.Array" /> 中从第一个元素到指定索引这部分元素中最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1504">Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <see cref="T:System.Array" /> that extends from the first element to the specified index.</span></span></summary>
        <returns><span data-ttu-id="31c36-1505">如果在 <paramref name="value" /> 中从第一个元素到 <paramref name="array" /> 这部分元素中找到 <paramref name="startIndex" /> 的匹配项，则为最后一个匹配项的索引；否则为该数组的下限减 1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1505">The index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from the first element to <paramref name="startIndex" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1506">一维<xref:System.Array>是搜索向后开始`startIndex`和结束的第一个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1506">The one-dimensional <xref:System.Array> is searched backward starting at `startIndex` and ending at the first element.</span></span>  
  
 <span data-ttu-id="31c36-1507">对元素进行比较到指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1507">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="31c36-1508">如果元素类型是内部的 （用户定义的） 类型，`Equals`使用该类型的实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1508">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="31c36-1509">由于大多数数组将具有下限为零，因此此方法通常将返回 – 1 在`value`找不到。</span><span class="sxs-lookup"><span data-stu-id="31c36-1509">Since most arrays will have a lower bound of zero, this method would generally return –1 when `value` is not found.</span></span> <span data-ttu-id="31c36-1510">数组的下限是等于的罕见情况<xref:System.Int32.MinValue?displayProperty=nameWithType>和`value`未找到，则此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>，即`System.Int32.MinValue - 1`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1510">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> and `value` is not found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType>, which is `System.Int32.MinValue - 1`.</span></span>  
  
 <span data-ttu-id="31c36-1511">此方法为 O (`n`) 操作，其中`n`是从开始处的元素数目`array`到`startIndex`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1511">This method is an O(`n`) operation, where `n` is the number of elements from the beginning of `array` to `startIndex`.</span></span>  
  
 <span data-ttu-id="31c36-1512">在.NET Framework 2.0 版中，此方法使用<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法<xref:System.Array>以确定是否<xref:System.Object>指定的`value`参数存在。</span><span class="sxs-lookup"><span data-stu-id="31c36-1512">In the .NET Framework version 2.0, this method uses the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the <xref:System.Array> to determine whether the <xref:System.Object> specified by the `value` parameter exists.</span></span> <span data-ttu-id="31c36-1513">在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`value`<xref:System.Object>本身。</span><span class="sxs-lookup"><span data-stu-id="31c36-1513">In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the `value`<xref:System.Object> itself.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1514">下面的代码示例演示如何确定数组中指定的元素的最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1514">The following code example shows how to determine the index of the last occurrence of a specified element in an array.</span></span>  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1515"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1515"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1516"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1516"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-1517"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1517"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-1518">要搜索的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1518">The one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-1519">要在 <c>array</c> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1519">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="31c36-1520">向后搜索的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1520">The starting index of the backward search.</span></span></param>
        <param name="count"><span data-ttu-id="31c36-1521">要搜索的部分中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1521">The number of elements in the section to search.</span></span></param>
        <summary><span data-ttu-id="31c36-1522">搜索指定的对象，并返回一维 <see cref="T:System.Array" /> 中到指定索引为止包含指定个元素的这部分元素中最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1522">Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</span></span></summary>
        <returns><span data-ttu-id="31c36-1523">如果在 <paramref name="value" /> 中到 <paramref name="array" /> 为止并且包含的元素个数为在 <paramref name="count" /> 中指定的个数的这部分元素中找到 <paramref name="startIndex" /> 的匹配项，则为最后一个匹配项的索引；否则为该数组的下限减 1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1523">The index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that contains the number of elements specified in <paramref name="count" /> and ends at <paramref name="startIndex" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1524">一维<xref:System.Array>是搜索向后开始`startIndex`结束`startIndex`减`count`加上 1，如果`count`大于 0。</span><span class="sxs-lookup"><span data-stu-id="31c36-1524">The one-dimensional <xref:System.Array> is searched backward starting at `startIndex` and ending at `startIndex` minus `count` plus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="31c36-1525">对元素进行比较到指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1525">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="31c36-1526">如果元素类型是内部的 （用户定义的） 类型，`Equals`使用该类型的实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1526">If the element type is a nonintrinsic (user-defined) type, the`Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="31c36-1527">由于大多数数组将具有下限为零，因此此方法通常将返回 – 1 在`value`找不到。</span><span class="sxs-lookup"><span data-stu-id="31c36-1527">Since most arrays will have a lower bound of zero, this method would generally return –1 when `value` is not found.</span></span> <span data-ttu-id="31c36-1528">数组的下限是等于的罕见情况<xref:System.Int32.MinValue?displayProperty=nameWithType>和`value`未找到，则此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>，即`System.Int32.MinValue - 1`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1528">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> and `value` is not found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType>, which is `System.Int32.MinValue - 1`.</span></span>  
  
 <span data-ttu-id="31c36-1529">此方法为 O (`n`) 操作，其中`n`是`count`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1529">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
 <span data-ttu-id="31c36-1530">在.NET Framework 2.0 版中，此方法使用<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法<xref:System.Array>以确定是否<xref:System.Object>指定的`value`参数存在。</span><span class="sxs-lookup"><span data-stu-id="31c36-1530">In the .NET Framework version 2.0, this method uses the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the <xref:System.Array> to determine whether the <xref:System.Object> specified by the `value` parameter exists.</span></span> <span data-ttu-id="31c36-1531">在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`value`<xref:System.Object>本身。</span><span class="sxs-lookup"><span data-stu-id="31c36-1531">In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the `value`<xref:System.Object> itself.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1532">下面的代码示例演示如何确定数组中指定的元素的最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1532">The following code example shows how to determine the index of the last occurrence of a specified element in an array.</span></span> <span data-ttu-id="31c36-1533">请注意，<xref:System.Array.LastIndexOf%2A>方法是向后搜索; 因此，`count`必须小于或等于 (`startIndex`减零下限的数组加 1)。</span><span class="sxs-lookup"><span data-stu-id="31c36-1533">Note that the <xref:System.Array.LastIndexOf%2A> method is a backward search; therefore, `count` must be less than or equal to (`startIndex` minus the lower bound of the array plus 1).</span></span>  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1534"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1534"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1535"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1535"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-1536">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1536">-or-</span></span>  
  
 <span data-ttu-id="31c36-1537"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1537"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-1538">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1538">-or-</span></span>  
  
 <span data-ttu-id="31c36-1539"><paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</span><span class="sxs-lookup"><span data-stu-id="31c36-1539"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-1540"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1540"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-1541">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1541">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-1542">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1542">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-1543">要在 <c>array</c> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1543">The object to locate in <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="31c36-1544">搜索指定的对象，并返回整个 <see cref="T:System.Array" /> 中最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1544">Searches for the specified object and returns the index of the last occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="31c36-1545">如果在整个 <paramref name="value" /> 中找到 <paramref name="array" /> 的匹配项，则为最后一个匹配项的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1545">The zero-based index of the last occurrence of <paramref name="value" /> within the entire <paramref name="array" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1546"><xref:System.Array>向后搜索的最后一个元素开始，在第一个元素结束。</span><span class="sxs-lookup"><span data-stu-id="31c36-1546">The <xref:System.Array> is searched backward starting at the last element and ending at the first element.</span></span>  
  
 <span data-ttu-id="31c36-1547">对元素进行比较到指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1547">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="31c36-1548">如果元素类型是内部的 （用户定义的） 类型，`Equals`使用该类型的实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1548">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="31c36-1549">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1549">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1550">下面的代码示例演示的所有三个泛型重载<xref:System.Array.LastIndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1550">The following code example demonstrates all three generic overloads of the <xref:System.Array.LastIndexOf%2A> method.</span></span> <span data-ttu-id="31c36-1551">创建一个字符串数组，其中有一项显示两次，在索引位置 0 和索引位置 5。</span><span class="sxs-lookup"><span data-stu-id="31c36-1551">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="31c36-1552"><xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从结束时，整个数组中搜索并查找字符串的第二个匹配项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1552">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the entire array from the end, and finds the second occurrence of the string.</span></span> <span data-ttu-id="31c36-1553"><xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载可用于搜索数组向后开头的索引位置 3，直至到该数组的开头，并查找字符串的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1553">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</span></span> <span data-ttu-id="31c36-1554">最后，<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置 4 处开始并扩展向后的四个条目范围 （即，搜索位置 4、 3、 2 和 1 处的项）; 此搜索返回 – 1，因为没有的搜索的实例在该范围内的字符串。</span><span class="sxs-lookup"><span data-stu-id="31c36-1554">Finally, the <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1555"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1555"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-1556">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1556">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-1557">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1557">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-1558">要在 <c>array</c> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1558">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="31c36-1559">向后搜索的从零开始的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1559">The zero-based starting index of the backward search.</span></span></param>
        <summary><span data-ttu-id="31c36-1560">搜索指定的对象，并返回 <see cref="T:System.Array" /> 中从第一个元素到指定索引这部分元素中最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1560">Searches for the specified object and returns the index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the first element to the specified index.</span></span></summary>
        <returns><span data-ttu-id="31c36-1561">如果在 <paramref name="value" /> 中从第一个元素到 <paramref name="array" /> 这部分元素中找到 <paramref name="startIndex" /> 的匹配项，则为最后一个匹配项的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1561">The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from the first element to <paramref name="startIndex" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1562"><xref:System.Array>是搜索向后开始`startIndex`和结束的第一个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1562">The <xref:System.Array> is searched backward starting at `startIndex` and ending at the first element.</span></span>  
  
 <span data-ttu-id="31c36-1563">对元素进行比较到指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1563">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="31c36-1564">如果元素类型是内部的 （用户定义的） 类型，`Equals`使用该类型的实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1564">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="31c36-1565">此方法为 O (`n`) 操作，其中`n`是从开始处的元素数目`array`到`startIndex`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1565">This method is an O(`n`) operation, where `n` is the number of elements from the beginning of `array` to `startIndex`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1566">下面的代码示例演示的所有三个泛型重载<xref:System.Array.LastIndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1566">The following code example demonstrates all three generic overloads of the <xref:System.Array.LastIndexOf%2A> method.</span></span> <span data-ttu-id="31c36-1567">创建一个字符串数组，其中有一项显示两次，在索引位置 0 和索引位置 5。</span><span class="sxs-lookup"><span data-stu-id="31c36-1567">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="31c36-1568"><xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从结束时，整个数组中搜索并查找字符串的第二个匹配项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1568">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the entire array from the end, and finds the second occurrence of the string.</span></span> <span data-ttu-id="31c36-1569"><xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载可用于搜索数组向后开头的索引位置 3，直至到该数组的开头，并查找字符串的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1569">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</span></span> <span data-ttu-id="31c36-1570">最后，<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置 4 处开始并扩展向后的四个条目范围 （即，搜索位置 4、 3、 2 和 1 处的项）; 此搜索返回 – 1，因为没有的搜索的实例在该范围内的字符串。</span><span class="sxs-lookup"><span data-stu-id="31c36-1570">Finally, the <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1571"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1571"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1572"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1572"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-1573">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1573">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-1574">要搜索的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1574">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-1575">要在 <c>array</c> 中查找的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1575">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="31c36-1576">向后搜索的从零开始的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1576">The zero-based starting index of the backward search.</span></span></param>
        <param name="count"><span data-ttu-id="31c36-1577">要搜索的部分中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1577">The number of elements in the section to search.</span></span></param>
        <summary><span data-ttu-id="31c36-1578">搜索指定的对象，并返回 <see cref="T:System.Array" /> 中到指定索引为止包含指定个元素的这部分元素中最后一个匹配项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1578">Searches for the specified object and returns the index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</span></span></summary>
        <returns><span data-ttu-id="31c36-1579">如果在 <paramref name="value" /> 中到 <paramref name="array" /> 为止、包含 <paramref name="count" /> 所指定的元素个数的这部分元素中，找到 <paramref name="startIndex" /> 的匹配项，则为最后一个匹配项的从零开始的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1579">The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that contains the number of elements specified in <paramref name="count" /> and ends at <paramref name="startIndex" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1580"><xref:System.Array>是搜索向后开始`startIndex`结束`startIndex`减`count`加上 1，如果`count`大于 0。</span><span class="sxs-lookup"><span data-stu-id="31c36-1580">The <xref:System.Array> is searched backward starting at `startIndex` and ending at `startIndex` minus `count` plus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="31c36-1581">对元素进行比较到指定的值使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1581">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="31c36-1582">如果元素类型是内部的 （用户定义的） 类型，`Equals`使用该类型的实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1582">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="31c36-1583">此方法为 O (`n`) 操作，其中`n`是`count`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1583">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1584">下面的代码示例演示的所有三个泛型重载<xref:System.Array.LastIndexOf%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1584">The following code example demonstrates all three generic overloads of the <xref:System.Array.LastIndexOf%2A> method.</span></span> <span data-ttu-id="31c36-1585">创建一个字符串数组，其中有一项显示两次，在索引位置 0 和索引位置 5。</span><span class="sxs-lookup"><span data-stu-id="31c36-1585">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="31c36-1586"><xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从结束时，整个数组中搜索并查找字符串的第二个匹配项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1586">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the entire array from the end, and finds the second occurrence of the string.</span></span> <span data-ttu-id="31c36-1587"><xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载可用于搜索数组向后开头的索引位置 3，直至到该数组的开头，并查找字符串的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1587">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</span></span> <span data-ttu-id="31c36-1588">最后，<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置 4 处开始并扩展向后的四个条目范围 （即，搜索位置 4、 3、 2 和 1 处的项）; 此搜索返回 – 1，因为没有的搜索的实例在该范围内的字符串。</span><span class="sxs-lookup"><span data-stu-id="31c36-1588">Finally, the <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1589"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1589"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1590"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1590"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-1591">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1591">-or-</span></span>  
  
 <span data-ttu-id="31c36-1592"><paramref name="count" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1592"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-1593">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1593">-or-</span></span>  
  
 <span data-ttu-id="31c36-1594"><paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</span><span class="sxs-lookup"><span data-stu-id="31c36-1594"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31c36-1595">获取 <see cref="T:System.Array" /> 的所有维度中的元素总数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1595">Gets the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="31c36-1596">所有维数中元素的总数<see cref="T:System.Array" />; 零如果数组中没有的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1596">The total number of elements in all the dimensions of the <see cref="T:System.Array" />; zero if there are no elements in the array.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1597">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="31c36-1597">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1598">下面的示例使用<xref:System.Array.Length%2A>属性来获取数组中的元素总数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1598">The following example uses the                                 <xref:System.Array.Length%2A> property to get the total number of elements in an array.</span></span> <span data-ttu-id="31c36-1599">它还使用<xref:System.Array.GetUpperBound%2A>方法来确定每个维度的多维数组中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1599">It also uses the                                 <xref:System.Array.GetUpperBound%2A> method to determine the number of elements in each dimension of a multidimensional array.</span></span>  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="31c36-1600">数组是多维的，并且包括多于 <see cref="F:System.Int32.MaxValue" /> 个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1600">The array is multidimensional and contains more than <see cref="F:System.Int32.MaxValue" /> elements.</span></span></exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31c36-1601">获取一个 64 位整数，该整数表示 <see cref="T:System.Array" /> 的所有维数中元素的总数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1601">Gets a 64-bit integer that represents the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="31c36-1602">一个 64 位整数，表示 <see cref="T:System.Array" /> 的所有维数中元素的总数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1602">A 64-bit integer that represents the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1603">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="31c36-1603">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31c36-1604">获取 <see cref="T:System.Array" /> 的秩（维数）。</span><span class="sxs-lookup"><span data-stu-id="31c36-1604">Gets the rank (number of dimensions) of the <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1605">例如，一维数组返回 1，二维数组返回 2，依次类推。</span><span class="sxs-lookup"><span data-stu-id="31c36-1605">For example, a one-dimensional array returns 1, a two-dimensional array returns 2, and so on.</span></span></summary>
        <value><span data-ttu-id="31c36-1606">该 <see cref="T:System.Array" /> 的秩（维数）。</span><span class="sxs-lookup"><span data-stu-id="31c36-1606">The rank (number of dimensions) of the <see cref="T:System.Array" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1607">例如，Visual Basic 代码</span><span class="sxs-lookup"><span data-stu-id="31c36-1607">For example, the Visual Basic code</span></span>  
  
```  
Dim TDArray(0,0,0) As Integer  
```  
  
 <span data-ttu-id="31c36-1608">和 C# 代码</span><span class="sxs-lookup"><span data-stu-id="31c36-1608">and the C# code</span></span>  
  
```  
int[,,] TDArray = new int[1,1,1];  
```  
  
 <span data-ttu-id="31c36-1609">创建一个具有三个维度的数组<xref:System.Array.Rank%2A>其值为 3 的属性。</span><span class="sxs-lookup"><span data-stu-id="31c36-1609">create an array of three dimensions with a <xref:System.Array.Rank%2A> property whose value is 3.</span></span>  
  
 <span data-ttu-id="31c36-1610">交错的数组 （由数组的数组） 是一维数组中;值其<xref:System.Array.Rank%2A>属性为 1。</span><span class="sxs-lookup"><span data-stu-id="31c36-1610">A jagged array (an array of arrays) is a one-dimensional array; the value of its <xref:System.Array.Rank%2A> property is 1.</span></span>  
  
 <span data-ttu-id="31c36-1611">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="31c36-1611">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1612">下面的示例将初始化一个一维数组、 一个二维数组和交错的数组，并检索<xref:System.Array.Rank%2A>每个属性。</span><span class="sxs-lookup"><span data-stu-id="31c36-1612">The following example initializes a one-dimensional array, a two-dimensional array, and a jagged array, and retrieves the <xref:System.Array.Rank%2A> property of each.</span></span>  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]&amp;" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-1613">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1613">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-1614">要调整大小的一维数组，该数组从零开始；如果为 <see langword="null" />，则新建具有指定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1614">The one-dimensional, zero-based array to resize, or <see langword="null" /> to create a new array with the specified size.</span></span></param>
        <param name="newSize"><span data-ttu-id="31c36-1615">新数组的大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-1615">The size of the new array.</span></span></param>
        <summary><span data-ttu-id="31c36-1616">将一维数组的元素数更改为指定的新大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-1616">Changes the number of elements of a one-dimensional array to the specified new size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1617">此方法分配指定大小的新数组，将元素从旧的数组复制到新，然后使用新替换旧的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1617">This method allocates a new array with the specified size, copies elements from the old array to the new one, and then replaces the old array with the new one.</span></span> <span data-ttu-id="31c36-1618">`array` 必须是一个一维数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1618">`array` must be a one-dimensional array.</span></span>  
  
 <span data-ttu-id="31c36-1619">如果`array`是`null`，此方法具有指定大小创建一个新数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1619">If `array` is `null`, this method creates a new array with the specified size.</span></span>  
  
 <span data-ttu-id="31c36-1620">如果`newSize`大于<xref:System.Array.Length%2A>的旧的数组中，分配一个新数组，且所有元素从旧的数组都复制到新。</span><span class="sxs-lookup"><span data-stu-id="31c36-1620">If `newSize` is greater than the <xref:System.Array.Length%2A> of the old array, a new array is allocated and all the elements are copied from the old array to the new one.</span></span>  <span data-ttu-id="31c36-1621">如果`newSize`是小于<xref:System.Array.Length%2A>的旧的数组中，分配一个新数组和元素从旧数组复制到新直到填充新的; 旧的数组中的元素的其余部分将被忽略。</span><span class="sxs-lookup"><span data-stu-id="31c36-1621">If `newSize` is less than the <xref:System.Array.Length%2A> of the old array, a new array is allocated and elements are copied from the old array to the new one until the new one is filled; the rest of the elements in the old array are ignored.</span></span>  <span data-ttu-id="31c36-1622">如果`newSize`等同于<xref:System.Array.Length%2A>的旧的数组，此方法不执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="31c36-1622">If `newSize` is equal to the <xref:System.Array.Length%2A> of the old array, this method does nothing.</span></span>  
  
 <span data-ttu-id="31c36-1623">此方法为 O (`n`) 操作，其中`n`是`newSize`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1623">This method is an O(`n`) operation, where `n` is `newSize`.</span></span>  
  
 <span data-ttu-id="31c36-1624"><xref:System.Array.Resize%2A>方法调整大小的一维数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1624">The <xref:System.Array.Resize%2A> method resizes a one-dimensional array only.</span></span> <span data-ttu-id="31c36-1625"><xref:System.Array>类不包括用于调整大小多维数组的方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1625">The <xref:System.Array> class does not include a method for resizing multi-dimensional arrays.</span></span> <span data-ttu-id="31c36-1626">若要执行此操作，你必须提供您自己的代码或调用的第三方库中的特殊用途方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1626">To do this, you must either provide your own code or call a special-purpose method in a third-party library.</span></span> <span data-ttu-id="31c36-1627">下面的代码演示调整大小的数组的方法的一种可能实现*n*维度。</span><span class="sxs-lookup"><span data-stu-id="31c36-1627">The following code illustrates one possible implementation for a method that resizes an array of *n* dimensions.</span></span>  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1628">下面的示例演示如何调整大小影响数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1628">The following example shows how resizing affects the array.</span></span>  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1629"><paramref name="newSize" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1629"><paramref name="newSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31c36-1630">反转一维 <see cref="T:System.Array" /> 或部分 <see cref="T:System.Array" /> 中元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1630">Reverses the order of the elements in a one-dimensional <see cref="T:System.Array" /> or in a portion of the <see cref="T:System.Array" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-1631">要反转的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1631">The one-dimensional <see cref="T:System.Array" /> to reverse.</span></span></param>
        <summary><span data-ttu-id="31c36-1632">反转整个一维 <see cref="T:System.Array" /> 中元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1632">Reverses the sequence of the elements in the entire one-dimensional <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1633">在这种方法，处的元素调用`myArray[i]`，其中`i`是数组中的任何索引，将移动到`myArray[j]`，其中`j`等于`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1633">After a call to this method, the element at `myArray[i]`, where `i` is any index in the array, moves to `myArray[j]`, where `j` equals `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.</span></span>  
  
 <span data-ttu-id="31c36-1634">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1634">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 <span data-ttu-id="31c36-1635">如下面的示例所示，<xref:System.Array.Reverse%2A>方法可以用于反向交错的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1635">As the following example shows, the <xref:System.Array.Reverse%2A> method can be used to reverse a jagged array.</span></span> <span data-ttu-id="31c36-1636">它将初始化为当前区域性的日历中的当前年份的每个月交错的数组包含一个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1636">It initializes a jagged array with one element for each month of the current year in the current culture's calendar.</span></span> <span data-ttu-id="31c36-1637">每个元素包含与该月有天数的所有元素的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1637">Each element contains an array with as many elements as that month has days.</span></span> <span data-ttu-id="31c36-1638">该示例显示数组，调用的内容<xref:System.Array.Reverse%2A>方法，然后显示反向数组的内容。</span><span class="sxs-lookup"><span data-stu-id="31c36-1638">The example displays the contents of the array, calls the <xref:System.Array.Reverse%2A> method, and then displays the contents of the reversed array.</span></span>  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1639">下面的代码示例演示如何反向中的值排序<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1639">The following code example shows how to reverse the sort of the values in an <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1640"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1640"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-1641"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1641"><paramref name="array" /> is multidimensional.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-1642">要反转的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1642">The one-dimensional <see cref="T:System.Array" /> to reverse.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-1643">要反转的部分的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1643">The starting index of the section to reverse.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-1644">要反转的部分中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1644">The number of elements in the section to reverse.</span></span></param>
        <summary><span data-ttu-id="31c36-1645">反转一维 <see cref="T:System.Array" /> 中某部分元素的元素顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1645">Reverses the sequence of the elements in a range of elements in the one-dimensional <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1646">在这种方法，处的元素调用`myArray[i]`，其中`i`是数组中的任何索引，将移动到`myArray[j]`，其中`j`等于`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1646">After a call to this method, the element at `myArray[i]`, where `i` is any index in the array, moves to `myArray[j]`, where `j` equals `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.</span></span>  
  
 <span data-ttu-id="31c36-1647"><xref:System.Array.Reverse%2A>方法可以用于反向交错的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1647">The <xref:System.Array.Reverse%2A> method can be used to reverse a jagged array.</span></span>  
  
 <span data-ttu-id="31c36-1648">此方法为 O (`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1648">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1649">下面的代码示例演示如何反向中的元素范围中的值的排序<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1649">The following code example shows how to reverse the sort of the values in a range of elements in an <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1650"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1650"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-1651"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1651"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1652"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1652"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-1653">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1653">-or-</span></span>  
  
 <span data-ttu-id="31c36-1654"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1654"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-1655"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1655"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31c36-1656">将当前 <see cref="T:System.Array" /> 中的指定元素设置为指定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1656">Sets the specified element in the current <see cref="T:System.Array" /> to the specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="31c36-1657">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1657">The new value for the specified element.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-1658">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的位置。</span><span class="sxs-lookup"><span data-stu-id="31c36-1658">A 32-bit integer that represents the position of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="31c36-1659">将某值设置给一维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1659">Sets a value to the element at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1660">索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1660">The index is specified as a 32-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1661"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定是否的值`index`超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1661">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1662">有关转换的详细信息，请参阅<xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1662">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="31c36-1663">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1663">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-1664">如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1664">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="31c36-1665">元素的值不是 null 引用，并无法找到所搜索的 null 引用。</span><span class="sxs-lookup"><span data-stu-id="31c36-1665">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1666">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1666">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1667">当前的 <see cref="T:System.Array" /> 不是正好有一维。</span><span class="sxs-lookup"><span data-stu-id="31c36-1667">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="31c36-1668"><paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1668"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="31c36-1669"><paramref name="index" /> 超出当前 <see cref="T:System.Array" /> 的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1669"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="31c36-1670">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1670">The new value for the specified element.</span></span></param>
        <param name="indices"><span data-ttu-id="31c36-1671">32 位整数的一维数组，它表示用于指定要设置的元素的位置的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1671">A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the element to set.</span></span></param>
        <summary><span data-ttu-id="31c36-1672">将某值设置给多维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1672">Sets a value to the element at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1673">索引指定为一个 32 位整数数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1673">The indexes are specified as an array of 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1674">中的元素数`indices`必须等于的中的维数<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1674">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="31c36-1675">中的所有元素`indices`数组必须共同指定所需元素的位置，在多维<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1675">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-1676"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定是否有任何中的值`indices`数组是超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1676">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the values in the `indices` array is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1677">有关转换的详细信息，请参阅<xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1677">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="31c36-1678">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1678">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-1679">如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1679">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="31c36-1680">元素的值不是 null 引用，并无法找到所搜索的 null 引用。</span><span class="sxs-lookup"><span data-stu-id="31c36-1680">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1681">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1681">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1682"><paramref name="indices" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1682"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1683">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1683">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="31c36-1684"><paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1684"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="31c36-1685"><paramref name="indices" /> 中的任何元素都超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1685">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="31c36-1686">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1686">The new value for the specified element.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-1687">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的位置。</span><span class="sxs-lookup"><span data-stu-id="31c36-1687">A 64-bit integer that represents the position of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="31c36-1688">将某值设置给一维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1688">Sets a value to the element at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1689">索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1689">The index is specified as a 64-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1690"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定是否的值`index`超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1690">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1691">有关转换的详细信息，请参阅<xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1691">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="31c36-1692">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1692">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-1693">如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1693">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="31c36-1694">元素的值不是 null 引用，并无法找到所搜索的 null 引用。</span><span class="sxs-lookup"><span data-stu-id="31c36-1694">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1695">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1695">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1696">当前的 <see cref="T:System.Array" /> 不是正好有一维。</span><span class="sxs-lookup"><span data-stu-id="31c36-1696">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="31c36-1697"><paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1697"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1698"><paramref name="index" /> 超出当前 <see cref="T:System.Array" /> 的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1698"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="31c36-1699">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1699">The new value for the specified element.</span></span></param>
        <param name="indices"><span data-ttu-id="31c36-1700">64 位整数的一维数组，它表示用于指定要设置的元素的位置的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1700">A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the element to set.</span></span></param>
        <summary><span data-ttu-id="31c36-1701">将某值设置给多维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1701">Sets a value to the element at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1702">索引指定为一个 64 位整数数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1702">The indexes are specified as an array of 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1703">中的元素数`indices`必须等于的中的维数<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1703">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="31c36-1704">中的所有元素`indices`数组必须共同指定所需元素的位置，在多维<xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1704">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-1705"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定是否有任何中的值`indices`数组是超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1705">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the values in the `indices` array is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1706">有关转换的详细信息，请参阅<xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1706">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="31c36-1707">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1707">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-1708">如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1708">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="31c36-1709">元素的值不是 null 引用，并无法找到所搜索的 null 引用。</span><span class="sxs-lookup"><span data-stu-id="31c36-1709">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1710">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1710">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1711"><paramref name="indices" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1711"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1712">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1712">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="31c36-1713"><paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1713"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="31c36-1714"><paramref name="indices" /> 中的任何元素都超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1714">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="31c36-1715">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1715">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="31c36-1716">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1716">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="31c36-1717">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1717">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="31c36-1718">将某值设置给二维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1718">Sets a value to the element at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1719">索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1719">The indexes are specified as 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1720"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1720">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1721">有关转换的详细信息，请参阅<xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1721">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="31c36-1722">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1722">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-1723">如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1723">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="31c36-1724">元素的值不是 null 引用，并无法找到所搜索的 null 引用。</span><span class="sxs-lookup"><span data-stu-id="31c36-1724">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1725">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1725">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1726">当前的 <see cref="T:System.Array" /> 不是正好有两维。</span><span class="sxs-lookup"><span data-stu-id="31c36-1726">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="31c36-1727"><paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1727"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="31c36-1728"><paramref name="index1" /> 或 <paramref name="index2" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1728">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="31c36-1729">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1729">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="31c36-1730">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1730">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="31c36-1731">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1731">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="31c36-1732">将某值设置给二维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1732">Sets a value to the element at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1733">索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1733">The indexes are specified as 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1734"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1734">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1735">有关转换的详细信息，请参阅<xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1735">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="31c36-1736">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1736">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-1737">如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1737">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="31c36-1738">元素的值不是 null 引用，并无法找到所搜索的 null 引用。</span><span class="sxs-lookup"><span data-stu-id="31c36-1738">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1739">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1739">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1740">当前的 <see cref="T:System.Array" /> 不是正好有两维。</span><span class="sxs-lookup"><span data-stu-id="31c36-1740">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="31c36-1741"><paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1741"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="31c36-1742"><paramref name="index1" /> 或 <paramref name="index2" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1742">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="31c36-1743">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1743">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="31c36-1744">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1744">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="31c36-1745">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1745">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index3"><span data-ttu-id="31c36-1746">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第三维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1746">A 32-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="31c36-1747">将某值设置给三维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1747">Sets a value to the element at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1748">索引指定为 32 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1748">The indexes are specified as 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1749"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1749">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1750">有关转换的详细信息，请参阅<xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1750">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="31c36-1751">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1751">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-1752">如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1752">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="31c36-1753">元素的值不是 null 引用，并无法找到所搜索的 null 引用。</span><span class="sxs-lookup"><span data-stu-id="31c36-1753">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1754">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1754">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1755">当前的 <see cref="T:System.Array" /> 不是正好有三维。</span><span class="sxs-lookup"><span data-stu-id="31c36-1755">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="31c36-1756"><paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1756"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="31c36-1757"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1757"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="31c36-1758">指定元素的新值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1758">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="31c36-1759">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1759">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="31c36-1760">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1760">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index3"><span data-ttu-id="31c36-1761">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第三维索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1761">A 64-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="31c36-1762">将某值设置给三维 <see cref="T:System.Array" /> 中指定位置的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-1762">Sets a value to the element at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="31c36-1763">索引指定为 64 位整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1763">The indexes are specified as 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1764"><xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1764">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="31c36-1765">有关转换的详细信息，请参阅<xref:System.Convert>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1765">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="31c36-1766">此方法为 o （1） 运算。</span><span class="sxs-lookup"><span data-stu-id="31c36-1766">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-1767">如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素，该元素的所有字段都初始化为零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1767">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="31c36-1768">元素的值不是 null 引用，并无法找到所搜索的 null 引用。</span><span class="sxs-lookup"><span data-stu-id="31c36-1768">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1769">下面的代码示例演示如何设置和获取一维或多维数组中的特定值。</span><span class="sxs-lookup"><span data-stu-id="31c36-1769">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1770">当前的 <see cref="T:System.Array" /> 不是正好有三维。</span><span class="sxs-lookup"><span data-stu-id="31c36-1770">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="31c36-1771"><paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-1771"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1772"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1772"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31c36-1773">对一维数组中的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1773">Sorts the elements in a one-dimensional array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-1774">要排序的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1774">The one-dimensional <see cref="T:System.Array" /> to sort.</span></span></param>
        <summary><span data-ttu-id="31c36-1775">使用 <see cref="T:System.Array" /> 中每个元素的 <see cref="T:System.IComparable" /> 实现，对整个一维 <see cref="T:System.Array" /> 中的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1775">Sorts the elements in an entire one-dimensional <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1776">每个元素`array`必须实现<xref:System.IComparable>接口，才能与中的每个其他元素的比较`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1776">Each element of `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="31c36-1777">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-1777">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-1778">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-1778">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-1779">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1779">If the partition size is fewer than 16 elements, it uses an[insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-1780">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1780">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-1781">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1781">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-1782">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1782">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-1783">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1783">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-1784">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1784">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1785">下面的代码示例演示如何进行排序中的值<xref:System.Array>使用默认比较器和将反转排序顺序的自定义比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-1785">The following code example shows how to sort the values in an <xref:System.Array> using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="31c36-1786">请注意，结果可能有所不同具体取决于当前<xref:System.Globalization.CultureInfo>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1786">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1787"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1787"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-1788"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1788"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31c36-1789"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-1789">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="31c36-1790">一维 <see cref="T:System.Array" />，它包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="31c36-1790">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="31c36-1791">一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c><see cref="T:System.Array" /> 中每个关键字对应的项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1791">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="31c36-1792">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1792">-or-</span></span>  
  
 <span data-ttu-id="31c36-1793">如果为 <see langword="null" />，则只对 <c>keys</c><see cref="T:System.Array" /> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1793"><see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</span></span></param>
        <summary><span data-ttu-id="31c36-1794">基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.Array" /> 实现，对两个一维 <see cref="T:System.IComparable" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1794">Sorts a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1795">在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1795">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="31c36-1796">在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。</span><span class="sxs-lookup"><span data-stu-id="31c36-1796">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="31c36-1797">因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1797">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-1798">在每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable>接口，才能与每个其他键的比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-1798">Each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="31c36-1799">如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1799">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="31c36-1800">如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1800">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="31c36-1801">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-1801">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-1802">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-1802">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-1803">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1803">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-1804">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1804">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-1805">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1805">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-1806">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1806">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-1807">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1807">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-1808">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`keys`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1808">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `keys`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1809">下面的示例演示如何对两个关联的数组的第一个数组包含的键，其中第二个数组包含的值进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1809">The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="31c36-1810">完成排序使用的默认比较器和将反转排序顺序的自定义比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-1810">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="31c36-1811">请注意，结果可能有所不同具体取决于当前<xref:System.Globalization.CultureInfo>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1811">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1812"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1812"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="31c36-1813"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1813">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="31c36-1814">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1814">-or-</span></span>  
  
 <span data-ttu-id="31c36-1815"><paramref name="items" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1815">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-1816"><paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="31c36-1816"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31c36-1817"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-1817">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-1818">要排序的一维数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1818">The one-dimensional array to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="31c36-1819">比较元素时要使用的实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1819">The implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="31c36-1820">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1820">-or-</span></span>  
  
 <span data-ttu-id="31c36-1821">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1821"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="31c36-1822">使用指定的 <see cref="T:System.Array" />，对一维 <see cref="T:System.Collections.IComparer" /> 中的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1822">Sorts the elements in a one-dimensional <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1823">如果`comparer`是`null`的每个元素`array`必须实现<xref:System.IComparable>接口，才能与中的每个其他元素的比较`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1823">If `comparer` is `null`, each element of `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="31c36-1824">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-1824">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-1825">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-1825">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-1826">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1826">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-1827">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1827">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-1828">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1828">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-1829">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1829">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-1830">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1830">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-1831">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1831">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 <span data-ttu-id="31c36-1832">.NET Framework 包括预定义<xref:System.Collections.IComparer>下表中列出的实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1832">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="31c36-1833">实现</span><span class="sxs-lookup"><span data-stu-id="31c36-1833">Implementation</span></span>|<span data-ttu-id="31c36-1834">描述</span><span class="sxs-lookup"><span data-stu-id="31c36-1834">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="31c36-1835">比较任意两个对象，但执行不区分大小写的字符串比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-1835">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="31c36-1836">使用当前区域性的排序约定比较任意两个对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1836">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="31c36-1837">使用固定区域性的排序约定比较任意两个对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1837">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="31c36-1838">比较两个对象类型的`T`通过使用该类型的默认排序顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1838">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="31c36-1839">此外可以通过提供你自己的实例来支持自定义比较<xref:System.Collections.IComparer>实现`comparer`参数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1839">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="31c36-1840">该示例执行这通过定义`ReverseComparer`反转的默认排序顺序的类类型的实例和执行不区分大小写的字符串比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-1840">The example does this by defining a `ReverseComparer` class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1841">下面的示例对使用默认比较器字符串 arrayby 中的值进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1841">The following example sorts the values in a string arrayby using the default comparer.</span></span> <span data-ttu-id="31c36-1842">它还定义一个自定义<xref:System.Collections.IComparer>实现名为`ReverseComparer`，反转同时执行不区分大小写的字符串比较的对象的默认排序顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1842">It also defines a custom <xref:System.Collections.IComparer> implementation named `ReverseComparer` that reverses an object's default sort order while performing a case-insensitive string comparison.</span></span> <span data-ttu-id="31c36-1843">请注意，输出根据当前区域性可能有所不同。</span><span class="sxs-lookup"><span data-stu-id="31c36-1843">Note that the output might vary depending on the current culture.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1844"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1844"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-1845"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1845"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-1846"><paramref name="comparer" /> 为 <see langword="null" />，<paramref name="array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-1846"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-1847"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="31c36-1847">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="31c36-1848">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="31c36-1848">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="31c36-1849">.NET Framework 4 和更早版本使用仅快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1849">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="31c36-1850">快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。</span><span class="sxs-lookup"><span data-stu-id="31c36-1850">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="31c36-1851">从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-1851">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="31c36-1852">大多数情况下，这适用于具有少于 16 个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1852">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="31c36-1853">一维 <see cref="T:System.Array" />，它包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="31c36-1853">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="31c36-1854">一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c><see cref="T:System.Array" /> 中每个关键字对应的项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1854">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="31c36-1855">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1855">-or-</span></span>  
  
 <span data-ttu-id="31c36-1856">如果为 <see langword="null" />，则只对 <c>keys</c><see cref="T:System.Array" /> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1856"><see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</span></span></param>
        <param name="comparer"><span data-ttu-id="31c36-1857">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1857">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="31c36-1858">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1858">-or-</span></span>  
  
 <span data-ttu-id="31c36-1859">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1859"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="31c36-1860">基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Array" />，对两个一维 <see cref="T:System.Collections.IComparer" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1860">Sorts a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1861">在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1861">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="31c36-1862">在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。</span><span class="sxs-lookup"><span data-stu-id="31c36-1862">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="31c36-1863">因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1863">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-1864">如果`comparer`是`null`，每个密钥中`keys`<xref:System.Array>必须实现<xref:System.IComparable>接口，才能与每个其他键的比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-1864">If `comparer` is `null`, each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="31c36-1865">如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1865">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="31c36-1866">如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1866">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="31c36-1867">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-1867">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-1868">.NET Framework 包括预定义<xref:System.Collections.IComparer>下表中列出的实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1868">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="31c36-1869">实现</span><span class="sxs-lookup"><span data-stu-id="31c36-1869">Implementation</span></span>|<span data-ttu-id="31c36-1870">描述</span><span class="sxs-lookup"><span data-stu-id="31c36-1870">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="31c36-1871">比较任意两个对象，但执行不区分大小写的字符串比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-1871">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="31c36-1872">使用当前区域性的排序约定比较任意两个对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1872">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="31c36-1873">使用固定区域性的排序约定比较任意两个对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1873">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="31c36-1874">比较两个对象类型的`T`通过使用该类型的默认排序顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1874">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="31c36-1875">此外可以通过提供你自己的实例来支持自定义比较<xref:System.Collections.IComparer>实现`comparer`参数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1875">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="31c36-1876">该示例执行这通过定义<xref:System.Collections.IComparer>反转默认的排序顺序和执行不区分大小写的字符串比较的实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1876">The example does this by defining an <xref:System.Collections.IComparer> implementation that reverses the default sort order and performs case-insensitive string comparison.</span></span>  
  
 <span data-ttu-id="31c36-1877">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-1877">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-1878">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1878">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-1879">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1879">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-1880">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1880">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-1881">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1881">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-1882">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1882">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-1883">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`keys`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1883">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `keys`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1884">下面的示例演示如何对两个关联的数组的第一个数组包含的键，其中第二个数组包含的值进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1884">The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="31c36-1885">完成排序使用的默认比较器和将反转排序顺序的自定义比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-1885">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="31c36-1886">请注意，结果可能有所不同具体取决于当前<xref:System.Globalization.CultureInfo>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1886">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1887"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1887"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="31c36-1888"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1888">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="31c36-1889">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1889">-or-</span></span>  
  
 <span data-ttu-id="31c36-1890"><paramref name="items" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1890">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-1891"><paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="31c36-1891"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="31c36-1892">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1892">-or-</span></span>  
  
 <span data-ttu-id="31c36-1893"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="31c36-1893">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="31c36-1894">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="31c36-1894">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-1895"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-1895"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="31c36-1896">.NET Framework 4 和更早版本使用仅快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1896">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="31c36-1897">快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。</span><span class="sxs-lookup"><span data-stu-id="31c36-1897">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="31c36-1898">从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，它是可能的排序操作该 previouslythrew<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-1898">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previouslythrew <see cref="T:System.ArgumentException" /> will not throw an exception, becausethe insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="31c36-1899">大多数情况下，这适用于具有少于 16 个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1899">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-1900">要排序的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1900">The one-dimensional <see cref="T:System.Array" /> to sort.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-1901">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1901">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-1902">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1902">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="31c36-1903">使用 <see cref="T:System.Array" /> 中每个元素的 <see cref="T:System.IComparable" /> 实现，对一维 <see cref="T:System.Array" /> 中某部分元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1903">Sorts the elements in a range of elements in a one-dimensional <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1904">指定范围中的元素内的每个元素`array`必须实现<xref:System.IComparable>接口，才能与中的每个其他元素的比较`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1904">Each element within the specified range of elements in `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="31c36-1905">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-1905">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-1906">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-1906">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-1907">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1907">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-1908">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1908">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-1909">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1909">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-1910">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1910">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-1911">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1911">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-1912">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1912">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1913">下面的代码示例演示如何进行排序中的值<xref:System.Array>使用默认比较器和将反转排序顺序的自定义比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-1913">The following code example shows how to sort the values in an <xref:System.Array> using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="31c36-1914">请注意，结果可能有所不同具体取决于当前<xref:System.Globalization.CultureInfo>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1914">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1915"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1915"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-1916"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1916"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1917"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1917"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-1918">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1918">-or-</span></span>  
  
 <span data-ttu-id="31c36-1919"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1919"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-1920"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1920"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31c36-1921"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-1921">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="31c36-1922">一维 <see cref="T:System.Array" />，它包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="31c36-1922">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="31c36-1923">一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c><see cref="T:System.Array" /> 中每个关键字对应的项。</span><span class="sxs-lookup"><span data-stu-id="31c36-1923">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="31c36-1924">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1924">-or-</span></span>  
  
 <span data-ttu-id="31c36-1925">如果为 <see langword="null" />，则只对 <c>keys</c><see cref="T:System.Array" /> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1925"><see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-1926">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1926">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-1927">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1927">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="31c36-1928">基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.Array" /> 实现，对两个一维 <see cref="T:System.IComparable" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1928">Sorts a range of elements in a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1929">在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1929">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="31c36-1930">在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。</span><span class="sxs-lookup"><span data-stu-id="31c36-1930">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="31c36-1931">因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1931">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-1932">指定范围中的元素内的每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable>接口，才能与每个其他键的比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-1932">Each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="31c36-1933">如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1933">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="31c36-1934">如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1934">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="31c36-1935">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-1935">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-1936">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-1936">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-1937">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1937">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-1938">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1938">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-1939">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1939">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-1940">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1940">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-1941">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1941">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-1942">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1942">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1943">下面的代码示例演示如何对两个关联的数组的第一个数组包含的键，其中第二个数组包含的值进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1943">The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="31c36-1944">完成排序使用的默认比较器和将反转排序顺序的自定义比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-1944">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="31c36-1945">请注意，结果可能有所不同具体取决于当前<xref:System.Globalization.CultureInfo>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1945">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1946"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1946"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="31c36-1947"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1947">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="31c36-1948">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1948">-or-</span></span>  
  
 <span data-ttu-id="31c36-1949"><paramref name="items" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1949">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1950"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1950"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
 <span data-ttu-id="31c36-1951">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1951">-or-</span></span>  
  
 <span data-ttu-id="31c36-1952"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1952"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-1953"><paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="31c36-1953"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="31c36-1954">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1954">-or-</span></span>  
  
 <span data-ttu-id="31c36-1955"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1955"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="31c36-1956">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1956">-or-</span></span>  
  
 <span data-ttu-id="31c36-1957"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1957"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31c36-1958"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-1958">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="31c36-1959">要排序的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1959">The one-dimensional <see cref="T:System.Array" /> to sort.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-1960">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-1960">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-1961">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1961">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="31c36-1962">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1962">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="31c36-1963">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1963">-or-</span></span>  
  
 <span data-ttu-id="31c36-1964">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1964"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="31c36-1965">使用指定的 <see cref="T:System.Array" />，对一维 <see cref="T:System.Collections.IComparer" /> 的部分元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1965">Sorts the elements in a range of elements in a one-dimensional <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-1966">如果`comparer`是`null`，每个元素中的元素指定的范围内`array`必须实现<xref:System.IComparable>接口，才能与中的每个其他元素的比较`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1966">If `comparer` is `null`, each element within the specified range of elements in `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="31c36-1967">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-1967">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-1968">.NET Framework 包括预定义<xref:System.Collections.IComparer>下表中列出的实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-1968">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="31c36-1969">实现</span><span class="sxs-lookup"><span data-stu-id="31c36-1969">Implementation</span></span>|<span data-ttu-id="31c36-1970">描述</span><span class="sxs-lookup"><span data-stu-id="31c36-1970">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="31c36-1971">比较任意两个对象，但执行不区分大小写的字符串比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-1971">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="31c36-1972">使用当前区域性的排序约定比较任意两个对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1972">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="31c36-1973">使用固定区域性的排序约定比较任意两个对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-1973">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="31c36-1974">比较两个对象类型的`T`通过使用该类型的默认排序顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1974">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="31c36-1975">此外可以通过提供你自己的实例来支持自定义比较<xref:System.Collections.IComparer>实现`comparer`参数。</span><span class="sxs-lookup"><span data-stu-id="31c36-1975">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="31c36-1976">该示例执行这通过定义`ReverseComparer`反转的默认排序顺序的类类型的实例和执行不区分大小写的字符串比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-1976">The example does this by defining a `ReverseComparer` class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</span></span>  
  
 <span data-ttu-id="31c36-1977">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-1977">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-1978">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1978">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-1979">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1979">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-1980">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1980">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-1981">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1981">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-1982">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-1982">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-1983">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-1983">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-1984">下面的代码示例演示如何进行排序中的值<xref:System.Array>使用默认比较器和将反转排序顺序的自定义比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-1984">The following code example shows how to sort the values in an <xref:System.Array> using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="31c36-1985">请注意，结果可能有所不同具体取决于当前<xref:System.Globalization.CultureInfo>。</span><span class="sxs-lookup"><span data-stu-id="31c36-1985">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-1986"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-1986"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="31c36-1987"><paramref name="array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-1987"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-1988"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-1988"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-1989">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1989">-or-</span></span>  
  
 <span data-ttu-id="31c36-1990"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-1990"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-1991"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-1991"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-1992">或</span><span class="sxs-lookup"><span data-stu-id="31c36-1992">-or-</span></span>  
  
 <span data-ttu-id="31c36-1993"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="31c36-1993">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="31c36-1994">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="31c36-1994">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-1995"><paramref name="comparer" /> 为 <see langword="null" />，<paramref name="array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-1995"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="31c36-1996">.NET Framework 4 和更早版本使用仅快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-1996">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="31c36-1997">快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。</span><span class="sxs-lookup"><span data-stu-id="31c36-1997">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="31c36-1998">从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-1998">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="31c36-1999">大多数情况下，这适用于具有少于 16 个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-1999">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="31c36-2000">一维 <see cref="T:System.Array" />，它包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="31c36-2000">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="31c36-2001">一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c><see cref="T:System.Array" /> 中每个关键字对应的项。</span><span class="sxs-lookup"><span data-stu-id="31c36-2001">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="31c36-2002">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2002">-or-</span></span>  
  
 <span data-ttu-id="31c36-2003">如果为 <see langword="null" />，则只对 <c>keys</c><see cref="T:System.Array" /> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2003"><see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-2004">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-2004">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-2005">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-2005">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="31c36-2006">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2006">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="31c36-2007">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2007">-or-</span></span>  
  
 <span data-ttu-id="31c36-2008">若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2008"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="31c36-2009">基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Array" />，对两个一维 <see cref="T:System.Collections.IComparer" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2009">Sorts a range of elements in a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2010">在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2010">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="31c36-2011">在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。</span><span class="sxs-lookup"><span data-stu-id="31c36-2011">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="31c36-2012">因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2012">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-2013">如果`comparer`是`null`中的元素指定的范围内的每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable>接口，才能与每个其他键的比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-2013">If `comparer` is `null`, each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="31c36-2014">如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2014">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="31c36-2015">如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2015">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="31c36-2016">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-2016">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-2017">.NET Framework 包括预定义<xref:System.Collections.IComparer>下表中列出的实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2017">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="31c36-2018">实现</span><span class="sxs-lookup"><span data-stu-id="31c36-2018">Implementation</span></span>|<span data-ttu-id="31c36-2019">描述</span><span class="sxs-lookup"><span data-stu-id="31c36-2019">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="31c36-2020">比较任意两个对象，但执行不区分大小写的字符串比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-2020">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="31c36-2021">使用当前区域性的排序约定比较任意两个对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-2021">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="31c36-2022">使用固定区域性的排序约定比较任意两个对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-2022">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="31c36-2023">比较两个对象类型的`T`通过使用该类型的默认排序顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2023">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="31c36-2024">此外可以通过提供你自己的实例来支持自定义比较<xref:System.Collections.IComparer>实现`comparer`参数。</span><span class="sxs-lookup"><span data-stu-id="31c36-2024">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="31c36-2025">该示例执行这通过定义一个自定义<xref:System.Collections.IComparer>反转默认的排序顺序和执行不区分大小写的字符串比较的实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2025">The example does this by defining a custom <xref:System.Collections.IComparer> implementation that reverses the default sort order and performs case-insensitive string comparison.</span></span>  
  
 <span data-ttu-id="31c36-2026">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-2026">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-2027">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2027">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2028">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2028">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2029">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2029">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-2030">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2030">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-2031">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2031">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-2032">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2032">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-2033">下面的代码示例演示如何对两个关联的数组的第一个数组包含的键，其中第二个数组包含的值进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2033">The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="31c36-2034">完成排序使用的默认比较器和将反转排序顺序的自定义比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-2034">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="31c36-2035">请注意，结果可能有所不同具体取决于当前<xref:System.Globalization.CultureInfo>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2035">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-2036"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2036"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="31c36-2037"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-2037">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="31c36-2038">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2038">-or-</span></span>  
  
 <span data-ttu-id="31c36-2039"><paramref name="items" /><see cref="T:System.Array" /> 是多维的。</span><span class="sxs-lookup"><span data-stu-id="31c36-2039">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-2040"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-2040"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
 <span data-ttu-id="31c36-2041">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2041">-or-</span></span>  
  
 <span data-ttu-id="31c36-2042"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-2042"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-2043"><paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-2043"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="31c36-2044">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2044">-or-</span></span>  
  
 <span data-ttu-id="31c36-2045"><paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="31c36-2045"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="31c36-2046">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2046">-or-</span></span>  
  
 <span data-ttu-id="31c36-2047"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-2047"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="31c36-2048">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2048">-or-</span></span>  
  
 <span data-ttu-id="31c36-2049"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-2049"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="31c36-2050">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2050">-or-</span></span>  
  
 <span data-ttu-id="31c36-2051"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="31c36-2051">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="31c36-2052">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="31c36-2052">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-2053"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2053"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="31c36-2054">.NET Framework 4 和更早版本使用仅快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2054">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="31c36-2055">快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。</span><span class="sxs-lookup"><span data-stu-id="31c36-2055">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="31c36-2056">从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-2056">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="31c36-2057">大多数情况下，这适用于具有少于 16 个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-2057">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-2058">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2058">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-2059">要排序的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2059">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort.</span></span></param>
        <summary><span data-ttu-id="31c36-2060">使用 <see cref="T:System.Array" /> 的每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现，对整个 <see cref="T:System.Array" /> 中的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2060">Sorts the elements in an entire <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2061">每个元素`array`必须实现<xref:System.IComparable%601>泛型接口，才能与中的每个其他元素的比较`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2061">Each element of `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="31c36-2062">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-2062">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-2063">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-2063">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-2064">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2064">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2065">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2065">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2066">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2066">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-2067">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2067">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-2068">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2068">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-2069">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2069">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-2070">下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>泛型方法重载与<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>泛型方法重载。</span><span class="sxs-lookup"><span data-stu-id="31c36-2070">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload.</span></span> <span data-ttu-id="31c36-2071">创建一个字符串数组，顺序不分先后。</span><span class="sxs-lookup"><span data-stu-id="31c36-2071">An array of strings is created, in no particular order.</span></span>  
  
 <span data-ttu-id="31c36-2072">数组是显示、 排序，并且再次显示。</span><span class="sxs-lookup"><span data-stu-id="31c36-2072">The array is displayed, sorted, and displayed again.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-2073">对调用<xref:System.Array.Sort%2A>和<xref:System.Array.BinarySearch%2A>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2073">The calls to the <xref:System.Array.Sort%2A> and <xref:System.Array.BinarySearch%2A> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="31c36-2074">如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2074">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="31c36-2075"><xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>泛型方法重载然后用于两个字符串搜索，另一个不在使用数组和一个，是。</span><span class="sxs-lookup"><span data-stu-id="31c36-2075">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="31c36-2076">数组和返回值的<xref:System.Array.BinarySearch%2A>方法传递给`ShowWhere`泛型方法，如果找到该字符串，而且否则元素的搜索字符串将介于像它是数组中显示的索引值。</span><span class="sxs-lookup"><span data-stu-id="31c36-2076">The array and the return value of the <xref:System.Array.BinarySearch%2A> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="31c36-2077">索引是如果字符串不是 n 负数组，因此`ShowWhere`方法采用的按位求补 (~ 中 C# 和 Visual c + + 中，运算符`Xor`在 Visual Basic 中的为-1) 若要获取大于搜索 stri 列表中的第一个元素的索引ng。</span><span class="sxs-lookup"><span data-stu-id="31c36-2077">The index is negative if the string is not n the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-2078"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2078"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31c36-2079"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2079">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-2080">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2080">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-2081">要排序的从零开始的一维 <see cref="T:System.Array" /></span><span class="sxs-lookup"><span data-stu-id="31c36-2081">The one-dimensional, zero-base <see cref="T:System.Array" /> to sort</span></span></param>
        <param name="comparer"><span data-ttu-id="31c36-2082">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2082">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="31c36-2083">使用指定的 <see cref="T:System.Array" /> 泛型接口，对 <see cref="T:System.Collections.Generic.IComparer`1" /> 中的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2083">Sorts the elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2084">如果`comparer`是`null`的每个元素`array`必须实现<xref:System.IComparable%601>泛型接口，才能与中的每个其他元素的比较`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2084">If `comparer` is `null`, each element of `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="31c36-2085">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-2085">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-2086">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-2086">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-2087">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2087">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2088">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2088">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2089">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2089">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-2090">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2090">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-2091">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2091">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-2092">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2092">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-2093">下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载与<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载。</span><span class="sxs-lookup"><span data-stu-id="31c36-2093">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload.</span></span>  
  
 <span data-ttu-id="31c36-2094">代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2094">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="31c36-2095">比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。</span><span class="sxs-lookup"><span data-stu-id="31c36-2095">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="31c36-2096">数组是显示、 排序，并且再次显示。</span><span class="sxs-lookup"><span data-stu-id="31c36-2096">The array is displayed, sorted, and displayed again.</span></span> <span data-ttu-id="31c36-2097">数组必须进行排序以便使用<xref:System.Array.BinarySearch%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2097">Arrays must be sorted in order to use the <xref:System.Array.BinarySearch%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-2098">对调用<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2098">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="31c36-2099">如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2099">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="31c36-2100"><xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载然后用于两个字符串搜索，另一个不在使用数组和一个，是。</span><span class="sxs-lookup"><span data-stu-id="31c36-2100">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="31c36-2101">数组和返回值的<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>方法传递给`ShowWhere`泛型方法，如果找到该字符串，而且否则元素的搜索字符串将介于像它是数组中显示的索引值。</span><span class="sxs-lookup"><span data-stu-id="31c36-2101">The array and the return value of the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="31c36-2102">索引是如果字符串不是 n 负数组，因此`ShowWhere`方法采用的按位求补 (~ 中 C# 和 Visual c + + 中，运算符`Xor`在 Visual Basic 中的为-1) 若要获取大于搜索 stri 列表中的第一个元素的索引ng。</span><span class="sxs-lookup"><span data-stu-id="31c36-2102">The index is negative if the string is not n the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-2103"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2103"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-2104"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2104"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-2105"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="31c36-2105">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="31c36-2106">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="31c36-2106">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="31c36-2107">.NET Framework 4 和更早版本使用仅快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2107">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="31c36-2108">快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。</span><span class="sxs-lookup"><span data-stu-id="31c36-2108">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="31c36-2109">从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-2109">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="31c36-2110">大多数情况下，这适用于具有少于 16 个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-2110">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-2111">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2111">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-2112">要排序的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2112">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort</span></span></param>
        <param name="comparison"><span data-ttu-id="31c36-2113">比较元素时要使用的 <see cref="T:System.Comparison`1" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2113">The <see cref="T:System.Comparison`1" /> to use when comparing elements.</span></span></param>
        <summary><span data-ttu-id="31c36-2114">使用指定的 <see cref="T:System.Array" /> 对 <see cref="T:System.Comparison`1" /> 中的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2114">Sorts the elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Comparison`1" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2115">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-2115">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-2116">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-2116">This method uses introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-2117">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2117">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2118">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2118">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2119">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2119">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-2120">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2120">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-2121">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2121">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-2122">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2122">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-2123">下面的代码示例演示<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="31c36-2123">The following code example demonstrates the <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> method overload.</span></span>  
  
 <span data-ttu-id="31c36-2124">代码示例定义了命名的字符串替换比较方法`CompareDinosByLength`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2124">The code example defines an alternative comparison method for strings, named `CompareDinosByLength`.</span></span> <span data-ttu-id="31c36-2125">此方法的工作方式如下： 首先，comparandsare 测试为`null`，并为空引用被视为小于非空。</span><span class="sxs-lookup"><span data-stu-id="31c36-2125">This method works as follows: First, the comparandsare tested for`null`, and a null reference is treated as less than a non-null.</span></span> <span data-ttu-id="31c36-2126">其次，比较字符串的长度，和较长的字符串被认为更高版本。</span><span class="sxs-lookup"><span data-stu-id="31c36-2126">Second, the string lengths are compared, and the longer string is deemed to be greater.</span></span> <span data-ttu-id="31c36-2127">第三，如果长度相等，则使用普通字符串比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-2127">Third, if the lengths are equal, ordinary string comparison is used.</span></span>  
  
 <span data-ttu-id="31c36-2128">创建并填充了四个字符串，顺序不分先后字符串的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-2128">A array of strings is created and populated with four strings, in no particular order.</span></span> <span data-ttu-id="31c36-2129">列表还包括一个空字符串和 null 引用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2129">The list also includes an empty string and a null reference.</span></span> <span data-ttu-id="31c36-2130">显示的列表，使用排序<xref:System.Comparison%601>泛型委托表示`CompareDinosByLength`方法，然后再次显示。</span><span class="sxs-lookup"><span data-stu-id="31c36-2130">The list is displayed, sorted using a <xref:System.Comparison%601> generic delegate representing the `CompareDinosByLength` method, and displayed again.</span></span>  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-2131"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2131"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-2132">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2132">-or-</span></span>  
  
 <span data-ttu-id="31c36-2133"><paramref name="comparison" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2133"><paramref name="comparison" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-2134"><paramref name="comparison" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="31c36-2134">The implementation of <paramref name="comparison" /> caused an error during the sort.</span></span> <span data-ttu-id="31c36-2135">例如，将某个项与其自身比较时，<paramref name="comparison" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="31c36-2135">For example, <paramref name="comparison" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="31c36-2136">.NET Framework 4 和更早版本使用仅快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2136">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="31c36-2137">快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。</span><span class="sxs-lookup"><span data-stu-id="31c36-2137">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="31c36-2138">从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-2138">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="31c36-2139">大多数情况下，这适用于具有少于 16 个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-2139">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-2140">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2140">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-2141">要排序的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2141">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort</span></span></param>
        <param name="index"><span data-ttu-id="31c36-2142">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-2142">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-2143">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-2143">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="31c36-2144">使用 <see cref="T:System.Array" /> 的每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现，对 <see cref="T:System.Array" /> 中某个元素范围内的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2144">Sorts the elements in a range of elements in an <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2145">指定范围中的元素内的每个元素`array`必须实现<xref:System.IComparable%601>泛型接口，才能与中的每个其他元素的比较`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2145">Each element within the specified range of elements in `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="31c36-2146">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-2146">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-2147">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-2147">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-2148">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2148">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2149">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2149">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2150">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2150">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-2151">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2151">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-2152">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2152">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-2153">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2153">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-2154">下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>泛型方法重载与<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>数组中的范围进行排序的泛型方法重载。</span><span class="sxs-lookup"><span data-stu-id="31c36-2154">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload and the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload for sorting a range in an array.</span></span>  
  
 <span data-ttu-id="31c36-2155">代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2155">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="31c36-2156">比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。</span><span class="sxs-lookup"><span data-stu-id="31c36-2156">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="31c36-2157">下面的代码示例创建并显示不复存在名称，三个草食跟三个食肉恐龙 (tyrannosaurids，使之精确) 所组成的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-2157">The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</span></span> <span data-ttu-id="31c36-2158"><xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用泛型方法重载的数组，随后显示的最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2158">The <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload is used to sort the last three elements of the array, which is then displayed.</span></span> <span data-ttu-id="31c36-2159"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>与使用泛型方法重载`ReverseCompare`以按相反顺序进行排序的最后三个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-2159">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is used with `ReverseCompare` to sort the last three elements in reverse order.</span></span> <span data-ttu-id="31c36-2160">全面混淆历史舞台再次显示。</span><span class="sxs-lookup"><span data-stu-id="31c36-2160">The thoroughly confused dinosaurs are displayed again.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-2161">对调用<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2161">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="31c36-2162">如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2162">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-2163"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2163"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-2164"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-2164"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-2165">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2165">-or-</span></span>  
  
 <span data-ttu-id="31c36-2166"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-2166"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-2167"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-2167"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31c36-2168"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2168">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-2169">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2169">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-2170">要排序的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2170">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-2171">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-2171">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-2172">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-2172">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="31c36-2173">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2173">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="31c36-2174">使用指定的 <see cref="T:System.Array" /> 泛型接口，对 <see cref="T:System.Collections.Generic.IComparer`1" /> 中某个元素范围内的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2174">Sorts the elements in a range of elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2175">如果`comparer`是`null`，每个元素中的元素指定的范围内`array`必须实现<xref:System.IComparable%601>泛型接口，才能与中的每个其他元素的比较`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2175">If `comparer` is `null`, each element within the specified range of elements in `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="31c36-2176">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-2176">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-2177">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-2177">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-2178">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2178">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2179">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2179">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2180">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2180">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-2181">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2181">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-2182">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2182">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-2183">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2183">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-2184">下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>泛型方法重载与<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>数组中的范围进行排序的泛型方法重载。</span><span class="sxs-lookup"><span data-stu-id="31c36-2184">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload and the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload for sorting a range in an array.</span></span>  
  
 <span data-ttu-id="31c36-2185">代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2185">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="31c36-2186">比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。</span><span class="sxs-lookup"><span data-stu-id="31c36-2186">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="31c36-2187">下面的代码示例创建并显示不复存在名称，三个草食跟三个食肉恐龙 (tyrannosaurids，使之精确) 所组成的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-2187">The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</span></span> <span data-ttu-id="31c36-2188"><xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用泛型方法重载的数组，随后显示的最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2188">The <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload is used to sort the last three elements of the array, which is then displayed.</span></span> <span data-ttu-id="31c36-2189"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>与使用泛型方法重载`ReverseCompare`以按相反顺序进行排序的最后三个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-2189">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is used with `ReverseCompare` to sort the last three elements in reverse order.</span></span> <span data-ttu-id="31c36-2190">全面混淆历史舞台再次显示。</span><span class="sxs-lookup"><span data-stu-id="31c36-2190">The thoroughly confused dinosaurs are displayed again.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-2191">对调用<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法不查找任何不同于调用其非泛型对应项，因为 Visual Basic、 C# 和 c + + 来推断从第一个参数的类型的泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2191">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="31c36-2192">如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2192">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-2193"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2193"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-2194"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-2194"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-2195">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2195">-or-</span></span>  
  
 <span data-ttu-id="31c36-2196"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-2196"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-2197"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-2197"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="31c36-2198">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2198">-or-</span></span>  
  
 <span data-ttu-id="31c36-2199"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="31c36-2199">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="31c36-2200">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="31c36-2200">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-2201"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2201"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="31c36-2202">.NET Framework 4 和更早版本使用仅快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2202">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="31c36-2203">快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。</span><span class="sxs-lookup"><span data-stu-id="31c36-2203">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="31c36-2204">从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-2204">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="31c36-2205">大多数情况下，这适用于具有少于 16 个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-2205">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="31c36-2206">关键字数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2206">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="31c36-2207">项数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2207">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="31c36-2208">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="31c36-2208">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="31c36-2209">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <c>keys</c> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2209">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</span></span></param>
        <summary><span data-ttu-id="31c36-2210">基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.Array" /> 泛型接口实现，对两个 <see cref="T:System.IComparable`1" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2210">Sorts a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2211">在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2211">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="31c36-2212">在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。</span><span class="sxs-lookup"><span data-stu-id="31c36-2212">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="31c36-2213">因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2213">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-2214">在每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable%601>泛型接口，才能与每个其他键的比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-2214">Each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="31c36-2215">如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2215">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="31c36-2216">如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2216">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="31c36-2217">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-2217">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-2218">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-2218">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-2219">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2219">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2220">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2220">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2221">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2221">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-2222">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2222">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-2223">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2223">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-2224">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2224">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-2225">下面的代码示例演示<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>，和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的重载，对表示键和值的数组进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2225">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="31c36-2226">代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2226">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="31c36-2227">比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。</span><span class="sxs-lookup"><span data-stu-id="31c36-2227">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="31c36-2228">下面的代码示例创建并显示不复存在头名 （关键字） 的数组和数组表示每个不复存在以米为单位 （值） 的最大长度的整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-2228">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="31c36-2229">然后，数组进行排序和显示几次：</span><span class="sxs-lookup"><span data-stu-id="31c36-2229">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="31c36-2230"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于对这两个数组中的第一个数组中的不复存在名称顺序进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2230">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="31c36-2231"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载与实例`ReverseCompare`用于反转排序顺序的成对的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-2231">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="31c36-2232"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用重载的两个数组的最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2232">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="31c36-2233"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载用于按相反顺序进行排序的两个数组的最后三个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-2233">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-2234">因为 Visual Basic、 C# 和 c + + 来推断与前两个参数的类型的泛型类型参数的类型对泛型方法的调用不查找从其非泛型对应项，对调用任何不同。</span><span class="sxs-lookup"><span data-stu-id="31c36-2234">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="31c36-2235">如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2235">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-2236"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2236"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-2237"><paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-2237"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="31c36-2238">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2238">-or-</span></span>  
  
 <span data-ttu-id="31c36-2239"><paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="31c36-2239"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31c36-2240"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2240">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="31c36-2241">关键字数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2241">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="31c36-2242">项数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2242">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="31c36-2243">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="31c36-2243">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="31c36-2244">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <c>keys</c> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2244">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</span></span></param>
        <param name="comparer"><span data-ttu-id="31c36-2245">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2245">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="31c36-2246">基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Array" /> 泛型接口，对两个 <see cref="T:System.Collections.Generic.IComparer`1" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2246">Sorts a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2247">在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2247">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="31c36-2248">在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。</span><span class="sxs-lookup"><span data-stu-id="31c36-2248">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="31c36-2249">因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2249">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-2250">如果`comparer`是`null`，每个密钥中`keys`<xref:System.Array>必须实现<xref:System.IComparable%601>泛型接口，才能与每个其他键的比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-2250">If `comparer` is `null`, each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="31c36-2251">如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2251">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="31c36-2252">如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2252">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="31c36-2253">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-2253">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-2254">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-2254">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-2255">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2255">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2256">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2256">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2257">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2257">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-2258">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2258">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-2259">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2259">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-2260">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2260">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-2261">下面的代码示例演示<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>，[\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >，<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>，和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法的重载，对表示键和值的数组进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2261">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="31c36-2262">代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2262">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="31c36-2263">比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。</span><span class="sxs-lookup"><span data-stu-id="31c36-2263">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="31c36-2264">下面的代码示例创建并显示不复存在头名 （关键字） 的数组和数组表示每个不复存在以米为单位 （值） 的最大长度的整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-2264">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="31c36-2265">然后，数组进行排序和显示几次：</span><span class="sxs-lookup"><span data-stu-id="31c36-2265">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="31c36-2266"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于对这两个数组中的第一个数组中的不复存在名称顺序进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2266">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="31c36-2267">[\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > 重载与实例`ReverseCompare`用于反转排序顺序成对的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-2267">The [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="31c36-2268"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用重载的两个数组的最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2268">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="31c36-2269"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载用于按相反顺序进行排序的两个数组的最后三个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-2269">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-2270">因为 Visual Basic、 C# 和 c + + 来推断与前两个参数的类型的泛型类型参数的类型对泛型方法的调用不查找从其非泛型对应项，对调用任何不同。</span><span class="sxs-lookup"><span data-stu-id="31c36-2270">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="31c36-2271">如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2271">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-2272"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2272"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-2273"><paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-2273"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="31c36-2274">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2274">-or-</span></span>  
  
 <span data-ttu-id="31c36-2275"><paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="31c36-2275"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="31c36-2276">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2276">-or-</span></span>  
  
 <span data-ttu-id="31c36-2277"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="31c36-2277">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="31c36-2278">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="31c36-2278">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-2279"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2279"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="31c36-2280">.NET Framework 4 和更早版本使用仅快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2280">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="31c36-2281">快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。</span><span class="sxs-lookup"><span data-stu-id="31c36-2281">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="31c36-2282">从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-2282">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="31c36-2283">大多数情况下，这适用于具有少于 16 个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-2283">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="31c36-2284">关键字数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2284">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="31c36-2285">项数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2285">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="31c36-2286">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="31c36-2286">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="31c36-2287">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <c>keys</c> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2287">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-2288">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-2288">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-2289">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-2289">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="31c36-2290">基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.Array" /> 泛型接口实现，对两个 <see cref="T:System.IComparable`1" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2290">Sorts a range of elements in a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2291">在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2291">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="31c36-2292">在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。</span><span class="sxs-lookup"><span data-stu-id="31c36-2292">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="31c36-2293">因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2293">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-2294">指定范围中的元素内的每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable%601>泛型接口，才能与每个其他键的比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-2294">Each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="31c36-2295">如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2295">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="31c36-2296">如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2296">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="31c36-2297">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-2297">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-2298">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-2298">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-2299">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2299">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2300">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2300">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2301">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2301">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-2302">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2302">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-2303">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2303">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-2304">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2304">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-2305">下面的代码示例演示<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>，[\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >，和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载，对表示键和值的数组进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2305">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="31c36-2306">代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2306">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="31c36-2307">比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。</span><span class="sxs-lookup"><span data-stu-id="31c36-2307">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="31c36-2308">下面的代码示例创建并显示不复存在头名 （关键字） 的数组和数组表示每个不复存在以米为单位 （值） 的最大长度的整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-2308">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="31c36-2309">然后，数组进行排序和显示几次：</span><span class="sxs-lookup"><span data-stu-id="31c36-2309">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="31c36-2310"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于对这两个数组中的第一个数组中的不复存在名称顺序进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2310">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="31c36-2311"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载与实例`ReverseCompare`用于反转排序顺序的成对的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-2311">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="31c36-2312">[\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > 使用重载的两个数组的最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2312">The [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="31c36-2313"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载用于按相反顺序进行排序的两个数组的最后三个元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-2313">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-2314">因为 Visual Basic、 C# 和 c + + 来推断与前两个参数的类型的泛型类型参数的类型对泛型方法的调用不查找从其非泛型对应项，对调用任何不同。</span><span class="sxs-lookup"><span data-stu-id="31c36-2314">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="31c36-2315">如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2315">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-2316"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2316"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-2317"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-2317"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
 <span data-ttu-id="31c36-2318">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2318">-or-</span></span>  
  
 <span data-ttu-id="31c36-2319"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-2319"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-2320"><paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-2320"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="31c36-2321">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2321">-or-</span></span>  
  
 <span data-ttu-id="31c36-2322"><paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="31c36-2322"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="31c36-2323">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2323">-or-</span></span>  
  
 <span data-ttu-id="31c36-2324"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-2324"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="31c36-2325">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2325">-or-</span></span>  
  
 <span data-ttu-id="31c36-2326"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-2326"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31c36-2327"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2327">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="31c36-2328">关键字数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2328">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="31c36-2329">项数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2329">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="31c36-2330">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</span><span class="sxs-lookup"><span data-stu-id="31c36-2330">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="31c36-2331">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <c>keys</c> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <c>keys</c> 进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2331">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</span></span></param>
        <param name="index"><span data-ttu-id="31c36-2332">排序范围的起始索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-2332">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="31c36-2333">排序范围内的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-2333">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="31c36-2334">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2334">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="31c36-2335">基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Array" /> 泛型接口，对两个 <see cref="T:System.Collections.Generic.IComparer`1" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2335">Sorts a range of elements in a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2336">在每个键`keys`<xref:System.Array>都有对应项`items` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2336">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="31c36-2337">在排序中的相应项过程时重新定位密钥`items`<xref:System.Array>同样重新定位。</span><span class="sxs-lookup"><span data-stu-id="31c36-2337">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="31c36-2338">因此， `items` <xref:System.Array>根据中对应键的排列方式排序`keys` <xref:System.Array>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2338">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="31c36-2339">如果`comparer`是`null`中的元素指定的范围内的每个键`keys`<xref:System.Array>必须实现<xref:System.IComparable%601>泛型接口，才能与每个其他键的比较。</span><span class="sxs-lookup"><span data-stu-id="31c36-2339">If `comparer` is `null`, each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="31c36-2340">如果有多个项与键，但具有没有对应的键的项将不会进行排序，您可以进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2340">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="31c36-2341">如果有多个项与项; 您不能进行排序这样做这会引发<xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="31c36-2341">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="31c36-2342">如果未成功完成排序，结果不确定。</span><span class="sxs-lookup"><span data-stu-id="31c36-2342">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="31c36-2343">此方法使用反省排序 (introsort) 算法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="31c36-2343">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="31c36-2344">分区大小是否少于 16 个元素，它使用[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2344">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2345">如果分区数超过 2 \* 日志<sup>N</sup>，其中*N*是范围的输入数组，它使用[Heapsort](http://en.wikipedia.org/wiki/Heapsort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2345">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="31c36-2346">否则，它使用[快速排序](http://en.wikipedia.org/wiki/Quicksort)算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2346">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="31c36-2347">此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2347">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="31c36-2348">与此相反，一个稳定排序保留相等的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2348">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="31c36-2349">对于在最坏情况下使用 Heapsort 和快速排序算法排过序的数组，此方法为 O (`n`日志`n`) 操作，其中`n`是`length`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2349">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-2350">下面的代码示例演示<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>， <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>，和 [\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > 泛型方法的重载，对表示键和值的数组进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2350">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="31c36-2351">代码示例定义了将可选的比较器字符串，名为`ReverseCompare`，该类实现`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2351">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>`(`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="31c36-2352">比较器调用<xref:System.String.CompareTo%28System.String%29>方法，以便字符串排序高到低而不是低到高数比较字的顺序反转。</span><span class="sxs-lookup"><span data-stu-id="31c36-2352">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="31c36-2353">下面的代码示例创建并显示不复存在头名 （关键字） 的数组和数组表示每个不复存在以米为单位 （值） 的最大长度的整数。</span><span class="sxs-lookup"><span data-stu-id="31c36-2353">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="31c36-2354">然后，数组进行排序和显示几次：</span><span class="sxs-lookup"><span data-stu-id="31c36-2354">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="31c36-2355"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于对这两个数组中的第一个数组中的不复存在名称顺序进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2355">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="31c36-2356"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载与实例`ReverseCompare`用于反转排序顺序的成对的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-2356">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="31c36-2357"><xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用重载的两个数组的最后三个元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2357">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="31c36-2358">[\]，TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > 使用重载进行排序最后三个这两个元素的数组按相反的顺序。</span><span class="sxs-lookup"><span data-stu-id="31c36-2358">The [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-2359">因为 Visual Basic、 C# 和 c + + 来推断与前两个参数的类型的泛型类型参数的类型对泛型方法的调用不查找从其非泛型对应项，对调用任何不同。</span><span class="sxs-lookup"><span data-stu-id="31c36-2359">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="31c36-2360">如果你使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要检查的 Microsoft 中间语言 (MSIL)，你可以看到泛型方法正被调用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2360">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-2361"><paramref name="keys" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2361"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-2362"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。</span><span class="sxs-lookup"><span data-stu-id="31c36-2362"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
 <span data-ttu-id="31c36-2363">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2363">-or-</span></span>  
  
 <span data-ttu-id="31c36-2364"><paramref name="length" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-2364"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="31c36-2365"><paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-2365"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="31c36-2366">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2366">-or-</span></span>  
  
 <span data-ttu-id="31c36-2367"><paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="31c36-2367"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="31c36-2368">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2368">-or-</span></span>  
  
 <span data-ttu-id="31c36-2369"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-2369"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="31c36-2370">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2370">-or-</span></span>  
  
 <span data-ttu-id="31c36-2371"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。</span><span class="sxs-lookup"><span data-stu-id="31c36-2371"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="31c36-2372">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2372">-or-</span></span>  
  
 <span data-ttu-id="31c36-2373"><paramref name="comparer" /> 的实现导致排序时出现错误。</span><span class="sxs-lookup"><span data-stu-id="31c36-2373">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="31c36-2374">例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</span><span class="sxs-lookup"><span data-stu-id="31c36-2374">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="31c36-2375"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2375"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="31c36-2376">.NET Framework 4 和更早版本使用仅快速排序算法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2376">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="31c36-2377">快速排序标识无效的比较器，在某些情况下，排序操作会引发<see cref="T:System.IndexOutOfRangeException" />异常，并且将引发<see cref="T:System.ArgumentException" />异常向调用方。</span><span class="sxs-lookup"><span data-stu-id="31c36-2377">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="31c36-2378">从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，则可能引发以前排序操作，<see cref="T:System.ArgumentException" />将不会引发异常，因为插入排序和 heapsort 算法不检测到无效的比较器。</span><span class="sxs-lookup"><span data-stu-id="31c36-2378">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="31c36-2379">大多数情况下，这适用于具有少于 16 个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-2379">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31c36-2380">获取可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-2380">Gets an object that can be used to synchronize access to the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="31c36-2381">可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-2381">An object that can be used to synchronize access to the <see cref="T:System.Array" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2382">此属性实现<xref:System.Collections.ICollection?displayProperty=nameWithType>接口。</span><span class="sxs-lookup"><span data-stu-id="31c36-2382">This property implements the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="31c36-2383">.NET framework 类基于<xref:System.Array>提供其自己的同步的版本的集合使用<xref:System.Array.SyncRoot%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="31c36-2383">.NET Framework classes based on <xref:System.Array> provide their own synchronized version of the collection using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 <span data-ttu-id="31c36-2384">使用数组的类还可以实现自己的同步使用<xref:System.Array.SyncRoot%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="31c36-2384">Classes that use arrays can also implement their own synchronization using the <xref:System.Array.SyncRoot%2A> property.</span></span> <span data-ttu-id="31c36-2385">同步代码必须在执行操作`SyncRoot`不是直接对集合的集合。</span><span class="sxs-lookup"><span data-stu-id="31c36-2385">The synchronizing code must perform operations on the `SyncRoot` of the collection, not directly on the collection.</span></span> <span data-ttu-id="31c36-2386">这样可确保对从其他对象派生的集合正确地执行操作。</span><span class="sxs-lookup"><span data-stu-id="31c36-2386">This ensures proper operation of collections that are derived from other objects.</span></span> <span data-ttu-id="31c36-2387">具体地说，这样可保持正确的同步，与可能同时修改集合的其他线程。</span><span class="sxs-lookup"><span data-stu-id="31c36-2387">Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</span></span> <span data-ttu-id="31c36-2388">请注意，某些实现的<xref:System.Array.SyncRoot%2A>可能会返回<xref:System.Array>本身。</span><span class="sxs-lookup"><span data-stu-id="31c36-2388">Note that some implementations of <xref:System.Array.SyncRoot%2A> might return the <xref:System.Array> itself.</span></span>  
  
 <span data-ttu-id="31c36-2389">枚举整个集合本质上不是线程安全的过程。</span><span class="sxs-lookup"><span data-stu-id="31c36-2389">Enumerating through a collection is intrinsically not a thread safe procedure.</span></span> <span data-ttu-id="31c36-2390">即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-2390">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="31c36-2391">若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-2391">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="31c36-2392">检索此属性的值的运算复杂度为 O(1)。</span><span class="sxs-lookup"><span data-stu-id="31c36-2392">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-2393">下面的代码示例演示如何通过使用在整个枚举过程中锁定数组<xref:System.Array.SyncRoot%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="31c36-2393">The following code example shows how to lock an array during the entire enumeration by using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System.Collections.ICollection.Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31c36-2394">获取 <see cref="T:System.Array" /> 中包含的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-2394">Gets the number of elements contained in the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="31c36-2395">集合中包含的元素数。</span><span class="sxs-lookup"><span data-stu-id="31c36-2395">The number of elements contained in the collection.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2396">此成员是显式的接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2396">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="31c36-2397">它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.ICollection> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2397">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.ICollection> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="31c36-2398">要添加到 <see cref="T:System.Collections.IList" /> 的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-2398">The object to be added to the <see cref="T:System.Collections.IList" />.</span></span></param>
        <summary><span data-ttu-id="31c36-2399">调用此方法始终会引发 <see cref="T:System.NotSupportedException" /> 异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-2399">Calling this method always throws a <see cref="T:System.NotSupportedException" /> exception.</span></span></summary>
        <returns><span data-ttu-id="31c36-2400">不支持向数组添加值。</span><span class="sxs-lookup"><span data-stu-id="31c36-2400">Adding a value to an array is not supported.</span></span> <span data-ttu-id="31c36-2401">不返回任何值。</span><span class="sxs-lookup"><span data-stu-id="31c36-2401">No value is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2402">通常，<xref:System.Collections.IList.Add%2A?displayProperty=nameWithType>实现将成员添加到集合。</span><span class="sxs-lookup"><span data-stu-id="31c36-2402">Ordinarily, an <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> implementation adds a member to a collection.</span></span> <span data-ttu-id="31c36-2403">但是，因为数组具有固定的大小 (<xref:System.Array.IsFixedSize%2A>属性始终返回`true`)，此方法始终引发<xref:System.NotSupportedException>异常。</span><span class="sxs-lookup"><span data-stu-id="31c36-2403">However, because arrays have a fixed size (the <xref:System.Array.IsFixedSize%2A> property always returns `true`), this method always throws a <xref:System.NotSupportedException> exception.</span></span>  
  
 <span data-ttu-id="31c36-2404">此成员是显式的接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2404">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="31c36-2405">它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2405">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31c36-2406"><see cref="T:System.Collections.IList" /> 具有固定的大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-2406">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31c36-2407">从 <see cref="T:System.Collections.IList" /> 中移除所有项。</span><span class="sxs-lookup"><span data-stu-id="31c36-2407">Removes all items from the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2408">此成员是显式的接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2408">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="31c36-2409">它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2409">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31c36-2410"><see cref="T:System.Collections.IList" /> 为只读。</span><span class="sxs-lookup"><span data-stu-id="31c36-2410">The <see cref="T:System.Collections.IList" /> is read-only.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="31c36-2411">要在当前列表中定位的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-2411">The object to locate in the current list.</span></span> <span data-ttu-id="31c36-2412">要定位的元素对于引用类型可以是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2412">The element to locate can be <see langword="null" /> for reference types.</span></span></param>
        <summary><span data-ttu-id="31c36-2413">确定某元素是否在 <see cref="T:System.Collections.IList" /> 中。</span><span class="sxs-lookup"><span data-stu-id="31c36-2413">Determines whether an element is in the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <returns>
          <span data-ttu-id="31c36-2414">如果在 <see langword="true" /> 中找到 <paramref name="value" />，则为 <see cref="T:System.Collections.IList" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2414"><see langword="true" /> if <paramref name="value" /> is found in the <see cref="T:System.Collections.IList" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2415">此成员是显式的接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2415">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="31c36-2416">它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2416">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="31c36-2417">要在当前列表中定位的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-2417">The object to locate in the current list.</span></span></param>
        <summary><span data-ttu-id="31c36-2418">确定 <see cref="T:System.Collections.IList" /> 中特定项的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-2418">Determines the index of a specific item in the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <returns><span data-ttu-id="31c36-2419">如果在列表中找到，则为值的索引；否则为 -1。</span><span class="sxs-lookup"><span data-stu-id="31c36-2419">The index of value if found in the list; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2420">此成员是显式的接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2420">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="31c36-2421">它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2421">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="31c36-2422">应插入 <c>value</c> 的索引位置。</span><span class="sxs-lookup"><span data-stu-id="31c36-2422">The index at which <c>value</c> should be inserted.</span></span></param>
        <param name="value"><span data-ttu-id="31c36-2423">要插入的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-2423">The object to insert.</span></span></param>
        <summary><span data-ttu-id="31c36-2424">在 <see cref="T:System.Collections.IList" /> 中的指定索引处插入一个项。</span><span class="sxs-lookup"><span data-stu-id="31c36-2424">Inserts an item to the <see cref="T:System.Collections.IList" /> at the specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2425">此成员是显式的接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2425">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="31c36-2426">它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2426">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-2427"><paramref name="index" /> 不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-2427"><paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.IList" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31c36-2428"><see cref="T:System.Collections.IList" /> 为只读。</span><span class="sxs-lookup"><span data-stu-id="31c36-2428">The <see cref="T:System.Collections.IList" /> is read-only.</span></span>  
  
 <span data-ttu-id="31c36-2429">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2429">-or-</span></span>  
  
 <span data-ttu-id="31c36-2430"><see cref="T:System.Collections.IList" /> 具有固定的大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-2430">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="31c36-2431"><paramref name="value" /> 在 <see cref="T:System.Collections.IList" /> 中是 null 引用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2431"><paramref name="value" /> is null reference in the <see cref="T:System.Collections.IList" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="31c36-2432">要获取或设置的元素的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-2432">The index of the element to get or set.</span></span></param>
        <summary><span data-ttu-id="31c36-2433">获取或设置指定索引处的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-2433">Gets or sets the element at the specified index.</span></span></summary>
        <value><span data-ttu-id="31c36-2434">指定索引处的元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-2434">The element at the specified index.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2435">此成员是显式的接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2435">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="31c36-2436">它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2436">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31c36-2437"><paramref name="index" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="31c36-2437"><paramref name="index" /> is less than zero.</span></span>  
  
 <span data-ttu-id="31c36-2438">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2438">-or-</span></span>  
  
 <span data-ttu-id="31c36-2439"><paramref name="index" /> 等于或大于 <see cref="P:System.Collections.ICollection.Count" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2439"><paramref name="index" /> is equal to or greater than <see cref="P:System.Collections.ICollection.Count" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31c36-2440">当前的 <see cref="T:System.Array" /> 不是正好有一维。</span><span class="sxs-lookup"><span data-stu-id="31c36-2440">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="31c36-2441">要从 <see cref="T:System.Collections.IList" /> 中删除的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-2441">The object to remove from the <see cref="T:System.Collections.IList" />.</span></span></param>
        <summary><span data-ttu-id="31c36-2442">从 <see cref="T:System.Collections.IList" /> 中移除特定对象的第一个匹配项。</span><span class="sxs-lookup"><span data-stu-id="31c36-2442">Removes the first occurrence of a specific object from the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2443">此成员是显式的接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2443">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="31c36-2444">它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2444">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31c36-2445"><see cref="T:System.Collections.IList" /> 为只读。</span><span class="sxs-lookup"><span data-stu-id="31c36-2445">The <see cref="T:System.Collections.IList" /> is read-only.</span></span>  
  
 <span data-ttu-id="31c36-2446">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2446">-or-</span></span>  
  
 <span data-ttu-id="31c36-2447"><see cref="T:System.Collections.IList" /> 具有固定的大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-2447">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="31c36-2448">要移除的元素的索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-2448">The index of the element to remove.</span></span></param>
        <summary><span data-ttu-id="31c36-2449">移除位于指定索引处的 <see cref="T:System.Collections.IList" /> 项。</span><span class="sxs-lookup"><span data-stu-id="31c36-2449">Removes the <see cref="T:System.Collections.IList" /> item at the specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2450">此成员是显式的接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2450">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="31c36-2451">它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IList> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2451">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="31c36-2452">索引不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</span><span class="sxs-lookup"><span data-stu-id="31c36-2452">index is not a valid index in the <see cref="T:System.Collections.IList" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31c36-2453"><see cref="T:System.Collections.IList" /> 为只读。</span><span class="sxs-lookup"><span data-stu-id="31c36-2453">The <see cref="T:System.Collections.IList" /> is read-only.</span></span>  
  
 <span data-ttu-id="31c36-2454">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2454">-or-</span></span>  
  
 <span data-ttu-id="31c36-2455"><see cref="T:System.Collections.IList" /> 具有固定的大小。</span><span class="sxs-lookup"><span data-stu-id="31c36-2455">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="31c36-2456">要与当前实例进行比较的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-2456">The object to compare with the current instance.</span></span></param>
        <param name="comparer"><span data-ttu-id="31c36-2457">一个将当前对象与 <c>other</c> 进行比较的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-2457">An object that compares the current object and <c>other</c>.</span></span></param>
        <summary><span data-ttu-id="31c36-2458">确定当前集合对象在排序顺序中的位置是位于另一个对象之前、之后还是与其位置相同。</span><span class="sxs-lookup"><span data-stu-id="31c36-2458">Determines whether the current collection object precedes, occurs in the same position as, or follows another object in the sort order.</span></span></summary>
        <returns><span data-ttu-id="31c36-2459">一个指示当前集合对象与其他对象的关系的整数，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="31c36-2459">An integer that indicates the relationship of the current collection object to other, as shown in the following table.</span></span>  
  
 <span data-ttu-id="31c36-2460"><list type="table"><listheader><term> 返回值</span><span class="sxs-lookup"><span data-stu-id="31c36-2460"><list type="table"><listheader><term> Return value</span></span>  
  
 <span data-ttu-id="31c36-2461"></term><description> 描述</span><span class="sxs-lookup"><span data-stu-id="31c36-2461"></term><description> Description</span></span>  
  
 <span data-ttu-id="31c36-2462"></description></listheader><item><term> -1</span><span class="sxs-lookup"><span data-stu-id="31c36-2462"></description></listheader><item><term> -1</span></span>  
  
 <span data-ttu-id="31c36-2463"></term><description> 当前实例位于 <paramref name="other" /> 之前。</span><span class="sxs-lookup"><span data-stu-id="31c36-2463"></term><description> The current instance precedes <paramref name="other" />.</span></span>  
  
 <span data-ttu-id="31c36-2464"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="31c36-2464"></description></item><item><term> 0</span></span>  
  
 <span data-ttu-id="31c36-2465"></term><description> 当前实例和 <paramref name="other" /> 相等。</span><span class="sxs-lookup"><span data-stu-id="31c36-2465"></term><description> The current instance and <paramref name="other" /> are equal.</span></span>  
  
 <span data-ttu-id="31c36-2466"></description></item><item><term> 1</span><span class="sxs-lookup"><span data-stu-id="31c36-2466"></description></item><item><term> 1</span></span>  
  
 <span data-ttu-id="31c36-2467"></term><description> 当前实例位于 <paramref name="other" /> 之后。</span><span class="sxs-lookup"><span data-stu-id="31c36-2467"></term><description> The current instance follows <paramref name="other" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2468">此成员是显式的接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2468">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="31c36-2469">它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IStructuralComparable> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2469">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IStructuralComparable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="31c36-2470">要与当前实例进行比较的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-2470">The object to compare with the current instance.</span></span></param>
        <param name="comparer"><span data-ttu-id="31c36-2471">一个可确定当前实例与 <c>other</c> 是否相等的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-2471">An object that determines whether the current instance and <c>other</c> are equal.</span></span></param>
        <summary><span data-ttu-id="31c36-2472">确定某个对象与当前实例是否相等。</span><span class="sxs-lookup"><span data-stu-id="31c36-2472">Determines whether an object is equal to the current instance.</span></span></summary>
        <returns>
          <span data-ttu-id="31c36-2473">如果两个对象相等，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2473"><see langword="true" /> if the two objects are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2474">此成员是显式的接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2474">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="31c36-2475">它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IStructuralEquatable> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2475">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IStructuralEquatable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer"><span data-ttu-id="31c36-2476">一个计算当前对象的哈希代码的对象。</span><span class="sxs-lookup"><span data-stu-id="31c36-2476">An object that computes the hash code of the current object.</span></span></param>
        <summary><span data-ttu-id="31c36-2477">返回当前实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="31c36-2477">Returns a hash code for the current instance.</span></span></summary>
        <returns><span data-ttu-id="31c36-2478">当前实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="31c36-2478">The hash code for the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2479">此成员是显式的接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="31c36-2479">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="31c36-2480">它只能在 <xref:System.Array> 实例强制转换为 <xref:System.Collections.IStructuralEquatable> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="31c36-2480">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IStructuralEquatable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="31c36-2481">数组元素的类型。</span><span class="sxs-lookup"><span data-stu-id="31c36-2481">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="31c36-2482">要对照条件进行检查的从零开始的一维 <see cref="T:System.Array" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2482">The one-dimensional, zero-based <see cref="T:System.Array" /> to check against the conditions.</span></span></param>
        <param name="match"><span data-ttu-id="31c36-2483">用于定义检查元素时要对照的条件的谓词。</span><span class="sxs-lookup"><span data-stu-id="31c36-2483">The predicate that defines the conditions to check against the elements.</span></span></param>
        <summary><span data-ttu-id="31c36-2484">确定数组中的每个元素是否都与指定谓词定义的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-2484">Determines whether every element in the array matches the conditions defined by the specified predicate.</span></span></summary>
        <returns>
          <span data-ttu-id="31c36-2485">如果 <paramref name="array" /> 中的每个元素都与指定谓词定义的条件匹配，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2485"><see langword="true" /> if every element in <paramref name="array" /> matches the conditions defined by the specified predicate; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="31c36-2486">如果数组中没有元素，则返回值为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2486">If there are no elements in the array, the return value is <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31c36-2487"><xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。</span><span class="sxs-lookup"><span data-stu-id="31c36-2487">The <xref:System.Predicate%601> is a delegate to a method that returns`true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="31c36-2488">元素`array`单独传递给<xref:System.Predicate%601>，并且在委托返回时停止处理`false`任何元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-2488">The elements of `array` are individually passed to the <xref:System.Predicate%601>, and processing is stopped when the delegate returns `false` for any element.</span></span>  
  
 <span data-ttu-id="31c36-2489">此方法为 O (`n`) 操作，其中`n`是<xref:System.Array.Length%2A>的`array`。</span><span class="sxs-lookup"><span data-stu-id="31c36-2489">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31c36-2490">下面的示例确定字符串数组中每个元素的最后一个字符是否是一个数字。</span><span class="sxs-lookup"><span data-stu-id="31c36-2490">The following example determines whether the last character of each element in a string array is a number.</span></span> <span data-ttu-id="31c36-2491">它将创建两个字符串数组。</span><span class="sxs-lookup"><span data-stu-id="31c36-2491">It creates two string arrays.</span></span> <span data-ttu-id="31c36-2492">第一个 arrayincludes 同时字符串结尾字母字符和字符串以数字字符结尾。第二个数组只能包含数字字符结尾的字符串。</span><span class="sxs-lookup"><span data-stu-id="31c36-2492">The first arrayincludes both strings that end with alphabetic characters and strings that end with numeric characters.The second array consists only of strings that end with numeric characters.</span></span> <span data-ttu-id="31c36-2493">该示例还定义`EndWithANumber`其签名与匹配的方法<xref:System.Predicate%601>委托。</span><span class="sxs-lookup"><span data-stu-id="31c36-2493">The example also defines an `EndWithANumber` method whose signature matches the <xref:System.Predicate%601> delegate.</span></span> <span data-ttu-id="31c36-2494">该示例将传递到每个数组<xref:System.Array.TrueForAll%2A>方法以及一个委托，表示`EndsWithANumber`方法。</span><span class="sxs-lookup"><span data-stu-id="31c36-2494">The example passes each array to the <xref:System.Array.TrueForAll%2A> method along with a delegate that represents the `EndsWithANumber` method.</span></span>  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 <span data-ttu-id="31c36-2495">下面的示例是类似于第一个，只不过它将传递到的字符串数组<xref:System.Array.TrueForAll%2A>方法以及确定是否将特定的数组元素结尾的数字的字符串表示的 lambda 表达式。</span><span class="sxs-lookup"><span data-stu-id="31c36-2495">The following example is similar to the first, except that it passes the string array to the <xref:System.Array.TrueForAll%2A> method along with  a lambda expression that determines whether a particular array element ends with the string representation of a number.</span></span>  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 <span data-ttu-id="31c36-2496">在这两种情况下，<xref:System.Array.TrueForAll%2A>方法返回`false`只要它遇到第一个不是一个数字以结尾的数组元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-2496">In both cases, the <xref:System.Array.TrueForAll%2A> method returns `false` as soon as it encounters the first array element that does not end in a number.</span></span> <span data-ttu-id="31c36-2497">否则，它将返回`true`后循环访问数组中的所有元素。</span><span class="sxs-lookup"><span data-stu-id="31c36-2497">Otherwise, it returns `true` after iterating all the elements in the array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31c36-2498">这两个示例所示，在 C# 和 Visual Basic 中，不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。</span><span class="sxs-lookup"><span data-stu-id="31c36-2498">As both examples show, in C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="31c36-2499">这些语言推断从上下文正确的委托，并自动创建。</span><span class="sxs-lookup"><span data-stu-id="31c36-2499">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31c36-2500"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2500"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="31c36-2501">或</span><span class="sxs-lookup"><span data-stu-id="31c36-2501">-or-</span></span>  
  
 <span data-ttu-id="31c36-2502"><paramref name="match" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31c36-2502"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>