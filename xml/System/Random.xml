<Type Name="Random" FullName="System.Random">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c495a3f66b3c69ecf66c5486200d8593af023e9b" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48675052" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示伪随机数生成器，这是一种能够产生满足某些随机性统计需求的数字序列的设备。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 伪随机数字从一组有限的数字选择以相同的概率。 所选的数字不是完全随机的因为使用数学算法来选择它们，但它们是足够随机实用的角度而言。 当前实现<xref:System.Random>类基于 Donald E.Knuth 删减随机数生成器算法的修改版本。 有关详细信息，请参阅 D.e。 Knuth。 *计算机编程，卷 2 艺术： Seminumerical 算法*。 Addison-wesley，Reading，MA，第三个版本，1997年。  
  
 若要生成安全加密的随机数字，例如适用于创建随机密码，使用<xref:System.Security.Cryptography.RNGCryptoServiceProvider>类或派生一个类从<xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>。  
  
 本主题内容：  
  
 [实例化的随机数生成器](#Instantiate)   
 [避免多个实例化](#Multiple)   
 [System.Random 类和线程安全](#ThreadSafety)   
 [生成不同类型的随机数字](#Functionality)   
 [替换为自己的算法](#Overriding)   
 [如何使用 System.Random 到...](#Operations)   
 [检索相同的随机值序列](#Same)  
 [检索唯一的随机值序列](#Unique)  
 [检索指定范围内的整数](#Range)  
 [检索具有指定位数的整数](#Digits)  
 [检索指定范围中的浮点值](#Floats)  
 [生成随机的布尔值](#Boolean)  
 [生成随机的 64 位整数](#Long)  
 [检索指定范围中的字节数](#Bytes)  
 [随机从数组或集合检索某个元素](#Array)  
 [从数组或集合中检索的唯一元素](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>实例化的随机数生成器  
 随机数生成器种子值 （伪随机数字生成算法的起始值），从而实例化为<xref:System.Random.%23ctor%2A>类构造函数。  您可以显式或隐式提供种子值：  
  
-   <xref:System.Random.%23ctor%28System.Int32%29>构造函数使用您提供一个显式的种子值。  
  
-   <xref:System.Random.%23ctor>构造函数使用系统时钟提供种子值。 这是实例化的随机数生成器的最常见的方法。  
  
 如果针对单独使用同一个种子<xref:System.Random>对象，它们会生成相同的一系列随机数字。 这可用于创建测试套件，以处理随机值，或者用于重播从随机数字派生其数据的游戏。 但请注意，<xref:System.Random>在不同版本的.NET Framework 下运行的进程中的对象可能会返回不同系列的随机数字，即使它们使用相同的种子值实例化。  
  
 若要生成不同的随机数字序列，可在种子值依赖于时间，从而生成包含的每个新实例的不同序列<xref:System.Random>。 参数化<xref:System.Random.%23ctor%28System.Int32%29>构造函数可以采用<xref:System.Int32>值基于计时周期数中的当前时间，而无参数<xref:System.Random.%23ctor>构造函数使用系统时钟生成种子值。 不过，由于时钟具有有限的解决方法，使用无参数构造函数来创建不同<xref:System.Random>关闭连续对象创建生成的随机数的相同序列生成器。 下面的示例演示了两个<xref:System.Random>关闭连续实例化的对象生成的随机数的相同序列。 在大多数 Windows 系统中，<xref:System.Random>的另一个 15 毫秒内创建的对象很可能会有相同的种子值。  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 若要避免此问题，请创建一个<xref:System.Random>对象而不是多个对象。  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>避免多个实例化  
 初始化在紧凑循环中或在短期内的两个随机数字生成器将创建两个随机数字生成器可能会产生相同的随机数字序列。 在大多数情况下，这不是开发人员的意图，可能会导致性能问题，因为实例化和初始化随机数生成器是一个代价相对较大的过程。  
  
 同时以提高性能并避免无意中创建单独的随机数生成器生成相同的数字序列的我们建议创建一个<xref:System.Random>对象随着时间推移，而不是创建生成很多随机数字新<xref:System.Random>对象生成一个随机数字。  
  
 但是，<xref:System.Random>类不是线程安全。 如果调用<xref:System.Random>方法从多个线程，请按照下一节中介绍的指导方针。  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>System.Random 类和线程安全  
 而不是实例化个人<xref:System.Random>对象，我们建议创建单个<xref:System.Random>实例来生成你的应用程序所需的所有随机数字。 但是，<xref:System.Random>对象不是线程安全。 如果您的应用程序调用<xref:System.Random>从多个线程的方法，您必须使用同步对象来确保只有一个线程可以访问一次的随机数生成器。 如果您不确保<xref:System.Random>线程安全的方式访问对象，对返回随机数字的方法的调用将返回 0。  
  
 下面的示例使用 C# [lock 语句](~/docs/csharp/language-reference/keywords/lock-statement.md)和 Visual Basic [SyncLock 语句](~/docs/visual-basic/language-reference/statements/synclock-statement.md)以确保单个随机数生成器的 11 个线程访问以线程安全的方式。 每个线程生成 2 亿个随机数字、 随机数字生成的计数和计算其总和，并执行完后，然后更新所有线程的总计值。  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 该示例按以下方式将确保线程安全：  
  
-   <xref:System.ThreadStaticAttribute>属性用于定义跟踪生成的随机数字和其总和为每个线程的总数的线程本地变量。  
  
-   锁 ( `lock` C# 中的语句和`SyncLock`在 Visual Basic 中的语句) 来保护对变量的总计数和所有在所有线程上生成的随机数字的总和的访问。  
  
-   信号量 (<xref:System.Threading.CountdownEvent>对象) 用于确保主线程阻止，直到所有其他线程完成执行。  
  
-   该示例将检查是否随机数字生成器遭到破坏通过确定是否为随机数字生成方法的两个连续调用将返回 0。 如果检测到损坏情况，该示例使用<xref:System.Threading.CancellationTokenSource>对象发出信号，应取消所有线程。  
  
-   在生成之前每个随机数字，每个线程检查状态<xref:System.Threading.CancellationToken>对象。 如果请求取消，则示例将调用<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>方法来取消线程。  
  
 下面的示例等同于第一个，只不过它使用<xref:System.Threading.Tasks.Task>对象和 lambda 表达式而不是<xref:System.Threading.Thread>对象。  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 它不同于第一个示例通过以下方式：  
  
-   变量来跟踪生成的随机数字数和每个任务中的其总和是本地的任务，这样就无需使用<xref:System.ThreadStaticAttribute>属性。  
  
-   静态<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>方法用于确保主线程未完成之前完成所有任务。 无需为<xref:System.Threading.CountdownEvent>对象。  
  
-   从任务取消生成的异常显示在<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>方法。 在上一示例中，它是由每个线程进行处理。  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>生成不同类型的随机数字  
 随机数生成器提供方法，可生成以下类型的随机数字：  
  
-   一系列<xref:System.Byte>值。 通过传递数组初始化为所需的方法以返回到的元素数确定的字节值的数目<xref:System.Random.NextBytes%2A>方法。 下面的示例生成 20 个字节。  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   一个整数。 可以选择是否想从 0 到最大值的整数 (<xref:System.Int32.MaxValue?displayProperty=nameWithType> – 1) 通过调用<xref:System.Random.Next>方法中，介于 0 和通过调用特定的值之间的整数<xref:System.Random.Next%28System.Int32%29>方法或通过调用值的范围内的整数<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法。 在参数化的重载，指定的最大值是独占;也就是说，生成的实际最大数目是其中一个小于指定值。  
  
     下面的示例调用<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法，以便生成 10 个随机数字介于-10 到 10 之间。 请注意该方法的第二个参数指定的方法返回的随机值的范围不含上限。 换而言之，该方法可返回一个的最大整数小于此值。  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   单个浮点值从 0.0 到小于 1.0 通过调用<xref:System.Random.NextDouble%2A>方法。 方法返回的随机数的独占上限为 1，因此其实际的上限是 0.99999999999999978。 下面的示例生成 10 个随机浮点数。  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法，可指定返回的随机数的范围。 但是，`maxValue`参数，指定上限范围返回数字，该参数是独占的、 不包含值。 这意味着，在方法调用`Next(0, 100)`返回一个值，介于 0 和 99 之间并不在 0 到 100 之间。  
  
 此外可以使用<xref:System.Random>作为生成此类任务的类[随机的布尔值](#Boolean)，生成[随机浮点值范围为 0 到 1 其他](#Floats)，生成[64 位的随机整数](#Long)，并[随机从数组或集合中检索的唯一元素](#UniqueArray)。 有关这些和其他常见任务，请参阅[如何使用 System.Random 到...](#Operations) 部分。  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>替换为自己的算法  
 您可以通过继承实现您自己的随机数字生成器<xref:System.Random>类并提供你随机数字生成算法。 若要提供您自己的算法，必须重写<xref:System.Random.Sample%2A>方法，实现随机数字生成算法。 您还应该重写<xref:System.Random.Next>， <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>，并<xref:System.Random.NextBytes%2A>方法，以确保它们调用被重写<xref:System.Random.Sample%2A>方法。 无需重写<xref:System.Random.Next%28System.Int32%29>和<xref:System.Random.NextDouble%2A>方法。  
  
 有关示例，派生自<xref:System.Random>类，并修改其默认的伪随机数生成器，请参阅<xref:System.Random.Sample%2A>参考页。  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>如何使用 System.Random 到...  
 以下各节讨论并提供了几种可能想要在应用中使用的随机数的示例代码。  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>检索相同的随机值序列  
 有时你想要在软件测试方案和玩游戏生成相同的随机数字序列。 使用相同的随机数字序列进行测试，可检测回归，并确认 bug 修复。 在游戏中使用相同的随机数字序列可以重播以前的游戏。  
  
 可以通过提供到相同的种子值生成相同的随机数字序列<xref:System.Random.%23ctor%28System.Int32%29>构造函数。 种子值为伪随机数字生成算法提供一个起始值。 下面的示例使用 100100 作为任意种子值来实例化<xref:System.Random>对象，显示 20 个随机浮点值，并且仍然存在种子值。 然后还原的种子值、 实例化新的随机数字生成器，并显示相同的 20 个随机浮点值。  请注意该示例可能会产生不同的随机数字序列，是否在不同版本的.NET Framework 上运行。  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>检索唯一的随机数字序列  
 提供不同的种子值的实例<xref:System.Random>类将导致每个随机数生成器以生成不同的值序列。 可以通过调用显式提供种子值<xref:System.Random.%23ctor%28System.Int32%29>构造函数，或隐式调用<xref:System.Random.%23ctor>构造函数。 大多数开发人员调用无参数构造函数中，它使用系统时钟。 下面的示例使用这种方法来实例化两个<xref:System.Random>实例。 每个实例将显示 10 个随机整数的一系列。  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 但是，由于其有限的分辨率，系统时钟不会检测是少于大约 15 毫秒的时间差异。 因此，如果你的代码调用<xref:System.Random.%23ctor>重载来实例化两个<xref:System.Random>中连续，您可能会无意中提供对象具有相同的种子值的对象。 若要查看这上一示例中，注释掉<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法调用时，并编译并再次运行该示例。  
  
 若要避免这种情况发生，我们建议您实例化一个<xref:System.Random>对象而不是多个数据库。 但是，由于<xref:System.Random>不是线程安全的如果您访问，则必须使用一些同步设备<xref:System.Random>实例从多个线程; 有关详细信息，请参阅[随机的类和线程安全](#ThreadSafety)在此早期本主题。 或者，可以使用延迟机制，如<xref:System.Threading.Thread.Sleep%2A>方法在上一示例中，用于确保在实例化发生相隔超过 15 毫秒。  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>检索指定范围内的整数  
 可以通过调用检索指定范围内的整数<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法中，从中可以指定你想要返回的随机数生成器的数的上限和较低。 上限是独占的、 不包含值。 也就是说，它不包括在由方法返回的值范围。 以下示例使用此方法来生成介于-10 到 10 之间的随机整数。 请注意，它指定 11，这是一个大于所需的值，该值的`maxValue`方法调用中的参数。  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>检索具有指定位数的整数  
 您可以调用<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法来检索具有指定位数的数字。 例如，若要检索具有四个数字 （即，从 1000年的范围到 9999 的数字） 的数字，则调用<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法替换`minValue`值为 1000年和`maxValue`10000，如以下示例所示的值。  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>检索指定范围中的浮点值  
 <xref:System.Random.NextDouble%2A>方法返回随机浮点值，范围从 0 到小于 1。 但是，您通常需要在另一个范围中生成随机值。  
  
 如果最小值和最大所需值之间的间隔为 1，则可以通过返回的数字添加所需的起始时间间隔和 0 之间的差异<xref:System.Random.NextDouble%2A>方法。 以下示例将执行此项以生成 10 个随机数字 0-1 之间。  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 生成随机浮点数其下限为 0，但上限是大于 1 （或者，对于负数，其下限为小于-1，上限为 0），再乘以非零值绑定的随机数字。 下面的示例这样做是为了生成 20 亿个随机浮点数，范围从 0 到<xref:System.Int64.MaxValue?displayProperty=nameWithType>。 中还显示由该方法生成的随机值的分布。  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 若要生成两个任意值之间的随机浮点数，喜欢<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法执行范围内的整数，请使用以下公式：  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 下面的示例生成 1 亿个随机数字，范围为从 10.0 为 11.0，并显示其分发。  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>生成随机的布尔值  
 <xref:System.Random>类不提供生成的方法<xref:System.Boolean>值。 但是，可以定义自己的类或方法来执行该操作。 下面的示例定义了一个类`BooleanGenerator`，使用单个方法`NextBoolean`。 `BooleanGenerator`类存储<xref:System.Random>对象作为私有变量。 `NextBoolean`方法调用<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法，并将传递到结果<xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType>方法。 请注意，使用 2 作为自变量指定的随机数的上限。 由于这是独占的值，方法调用将返回 0 或 1。  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 而不是创建一个单独的类生成随机<xref:System.Boolean>值，该示例可能只需定义一个方法。 在此情况下，但是，<xref:System.Random>对象应已定义为类级别变量，以避免实例化新<xref:System.Random>中每个方法调用的实例。 在 Visual Basic 中，Random 实例可以定义为[静态](~/docs/visual-basic/language-reference/modifiers/static.md)变量中`NextBoolean`方法。  下面的示例提供了实现。  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>生成随机的 64 位整数  
 重载<xref:System.Random.Next%2A>方法返回 32 位整数。 但是，在某些情况下，你可能想要使用 64 位整数。 你可以按如下所示进行操作：  
  
1.  调用<xref:System.Random.NextDouble%2A>方法来检索其中的双精度浮点点值。  
  
2.  将该值相乘， <xref:System.Int64.MaxValue?displayProperty=nameWithType>。  
  
 以下示例使用该技术来生成 20 亿个随机长整数，并在 10 个相等组中对其进行分类。 然后分布的随机数字计算方法是计算从 0 到每个组中的项数<xref:System.Int64.MaxValue?displayProperty=nameWithType>。 如示例输出所示，数字增加或减少均匀地分布在执行长整数的范围。  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 使用位操作的替代技术不会生成真正的随机数字。 此方法调用<xref:System.Random.Next>生成两个整数、 左移一个由 32 位和 ORs 它们组合在一起。 此方法具有两个限制：  
  
1.  由于第 31 位是符号位，在第 31 位所产生的长整数的值始终为 0。  这可通过生成随机 0 或 1，左移 31 位为单位和 or 操作来解决其与原始随机的长整型。  
  
2.  更严重，因为返回的值的概率<xref:System.Random.Next>将为 0，则如果有一些随机数字在范围内 0x0 0x00000000FFFFFFFF。  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>检索指定范围中的字节数  
 重载<xref:System.Random.Next%2A>方法允许您指定的随机数字，范围，但<xref:System.Random.NextBytes%2A>方法却没有。 下面的示例实现`NextBytes`方法，您可以指定返回的字节数的范围。 它定义`Random2`派生的类<xref:System.Random>并重载其`NextBytes`方法。  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 `NextBytes(Byte[], Byte, Byte)`方法包装对的调用<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法，并指定最小值和一个大于最大值 (在这种情况下，0 和 101) 我们要返回的字节数组中。 因为我们确信返回整数值<xref:System.Random.Next%2A>方法的范围内是<xref:System.Byte>数据类型，我们可以安全地将其强制转换 （在 C# 中) 或 （在 Visual Basic 中) 从整数转换为字节。  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>随机从数组或集合检索某个元素  
 随机数字通常用作要从数组或集合中检索值的索引。 若要检索随机索引值，可以调用<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>方法，并使用较低的值作为绑定数组的其`minValue`参数，另一个大于上限的数组的值作为其`maxValue`参数。 对于从零开始的数组，这等同于其<xref:System.Array.Length%2A>属性，或一个返回的值大于<xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType>方法。 下面的示例随机检索数组中的城市的美国城市的名称。  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>从数组或集合中检索的唯一元素  
 随机数生成器可以随时返回重复的值。 当变得更小的数字范围或生成的值的数量变得更大，就会增加重复项的概率。 如果随机值必须是唯一的其他号码会生成来补偿的重复项，从而越来越多地影响性能。  
  
 有多种方法来处理这种情况。 一个常见的解决方案是创建一个数组或集合，其中包含要检索的值和包含随机浮点数的并行数组。 在创建第一个数组，用一些随机数填充第二个数组和<xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>方法用于通过使用并行数组中的值排序的第一个数组。  
  
 例如，如果要开发一个纸牌游戏，您想要确保每个卡使用仅一次。 而不是生成随机数字，以检索数据卡和跟踪是否已处理该卡片，可以创建可用于排序的一副纸牌的随机数字的并行数组。 一副纸牌进行排序后，您的应用程序可以维护一个指针来指示上一副纸牌的下一步卡的索引。  
  
 下面的示例阐释了这种方法。 它定义`Card`类，它表示一个扑克牌的以及`Dealer`处理已打乱顺序的一副纸牌的类。 `Dealer`类构造函数填充两个数组：`deck`数组具有类范围，该值表示在一副纸牌; 和本地中的所有数据卡`order`数组，它具有相同数目的元素作为`deck`数组并填充使用随机生成的<xref:System.Double>值。  <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>然后调用方法进行排序`deck`数组中的值基于`order`数组。  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 下面的示例创建一个随机数生成器，并调用其<xref:System.Random.NextBytes%2A>， <xref:System.Random.Next%2A>，和<xref:System.Random.NextDouble%2A>要生成的在不同的范围内的随机数字序列的方法。  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 下面的示例生成一个随机整数，它用作索引来检索数组的字符串值。  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>在.NET Framework 1.0 和 1.1 中，类的最小实现派生自<see cref="T:System.Random" />所需重写<see cref="M:System.Random.Sample" />方法以定义使用新的或已修改的算法来生成随机数字。 在派生的类无法然后依赖于基类实现<see cref="M:System.Random.Next" />， <see cref="M:System.Random.Next(System.Int32)" />， <see cref="M:System.Random.Next(System.Int32,System.Int32)" />， <see cref="M:System.Random.NextBytes(System.Byte[])" />，并<see cref="M:System.Random.NextDouble" />方法来调用的派生的类实现<see cref="M:System.Random.Sample" />方法。  
  
在.NET Framework 2.0 及更高版本的行为<see cref="M:System.Random.Next" />， <see cref="M:System.Random.Next(System.Int32,System.Int32)" />，并<see cref="M:System.Random.NextBytes(System.Byte[])" />方法已更改，以便这些方法不一定是调用的派生的类实现<see cref="M:System.Random.Sample" />方法。 因此，类派生自<see cref="T:System.Random" />，面向.NET Framework 2.0 和更高版本还应该重写这三种方法。</para>
    </block>
    <block subset="none" type="usage">
      <para>中的随机数生成器的实现<see cref="T:System.Random" />类不能保证跨主版本的.NET Framework 将保持不变。 因此，不应认为同一个种子将导致不同版本的.NET Framework 中的同一个伪随机序列。</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Random" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>使用与时间相关的默认种子值，初始化 <see cref="T:System.Random" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认种子值派生自系统时钟，具有有限的分辨率。 因此，不同<xref:System.Random>关闭连续通过调用默认构造函数创建的对象将具有相同的默认种子值，并因此，将生成的随机数的相同集。 为避免此问题，只需使用单个<xref:System.Random>对象来生成所有的随机数字。 此外可以通过修改系统时钟返回的种子值，然后显式提供此新的种子值到变通解决它<xref:System.Random.%23ctor%28System.Int32%29>构造函数。 有关详细信息，请参阅<xref:System.Random.%23ctor%28System.Int32%29>构造函数。  
  
 如果你想在随机数生成器来生成一个随机数字序列，则调用此构造函数。 若要生成的随机数的将是相同的不同的随机数生成器固定的序列，请调用<xref:System.Random.%23ctor%28System.Int32%29>使用固定的种子值的构造函数。 这<xref:System.Random>测试使用的随机数的应用程序时，经常使用构造函数重载。  
  
 一旦已实例化的随机数生成器，就调用各个<xref:System.Random>方法，如<xref:System.Random.Next>或<xref:System.Random.NextDouble>、 生成随机数字。  
  
   
  
## Examples  
 下面的示例使用默认构造函数来实例化三个<xref:System.Random>对象，并为每个显示五个随机整数的序列。 因为前两个<xref:System.Random>关闭连续创建对象，使用基于系统时钟的完全相同的种子值实例化，并因此会生成相同的随机数字序列。 另一方面，第三个的默认构造函数<xref:System.Random>对象调用后通过调用而导致的两秒延迟<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法。 因为这将产生第三个不同的种子值<xref:System.Random>对象，它会生成不同的随机数字序列。  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">用来计算伪随机数序列起始值的数字。 如果指定的是负数，则使用其绝对值。</param>
        <summary>使用指定的种子值初始化 <see cref="T:System.Random" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供相同的种子值到不同<xref:System.Random>对象会导致产生相同的随机数字序列的每个实例。 通常这是测试依赖于随机数生成器应用时。  
  
 如果应用程序需要不同的随机数序列，则调用此构造函数重复用于不同的种子值。 生成唯一的种子值的一种方法是使其依赖于时间。 例如，从系统时钟派生的种子值，作为<xref:System.Random.%23ctor>重载 does。 但是，系统时钟可能没有足够的分辨率，以提供不同的种子值多次调用此构造函数。 这会导致生成的伪随机数字的相同序列生成器的前两个所示<xref:System.Random>下面的示例中的对象。 若要防止此情况，应用要区分每个调用或调用中的种子值的算法<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法，以确保使用不同的种子值提供每个构造函数。  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 另一个选项是实例化一个<xref:System.Random>对象，用于生成你的应用程序中所有的随机数字。 这会生成性能稍好，因为实例化的随机数生成器是相当昂贵。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Random>具有接受种子参数并生成随机整数和双精度型值的序列的类构造函数的对象。 该示例演示如何生成相同的序列时<xref:System.Random>使用构造函数和种子参数重新创建对象。  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个随机整数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个非负随机整数。</summary>
        <returns>大于或等于 0 且小于 <see cref="F:System.Int32.MaxValue" /> 的 32 位有符号整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> 生成随机数字的值的范围是从 0 到小于<xref:System.Int32.MaxValue?displayProperty=nameWithType>。 若要生成随机数字其值的范围是从 0 到某些其他正数，使用<xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType>方法重载。 若要生成不同的范围内的随机数，使用<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法重载。  
  
   
  
## Examples  
 以下示例使重复的调用<xref:System.Random.Next%2A>方法来生成特定数量的用户请求的随机数字。 <xref:System.Console.ReadLine%2A?displayProperty=nameWithType>方法用于获取客户意见。  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 以下示例从一个类从<xref:System.Random>若要从生成的均匀分布生成其分发不同的随机数字序列的<xref:System.Random.Sample%2A>基类的方法。 它将替代<xref:System.Random.Sample%2A>方法以提供的随机数字，并重写分发<xref:System.Random.Next%2A?displayProperty=nameWithType>方法要使用的随机数序列。  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>从.NET Framework 2.0 版中，如果派生的类从<see cref="T:System.Random" />并重写<see cref="M:System.Random.Sample" />方法中，由派生的类实现的提供的分布<see cref="M:System.Random.Sample" />对基类的调用中未使用方法实现<see cref="M:System.Random.Next" />方法。 相反，由基返回均匀分布<see cref="T:System.Random" />使用类。 此行为可提高整体性能的<see cref="T:System.Random" />类。 若要修改此行为，以调用<see cref="M:System.Random.Sample" />派生类中的方法，您还必须重写<see cref="M:System.Random.Next" />方法。</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">要生成的随机数的上限（随机数不能取该上限值）。 <c>maxValue</c> 值必须大于或等于 0。</param>
        <summary>返回一个小于所指定最大值的非负随机整数。</summary>
        <returns>大于或等于零且小于 <paramref name="maxValue" /> 的 32 位有符号整数，即：返回值的范围通常包括零但不包括 <paramref name="maxValue" />。 但是，如果 <paramref name="maxValue" /> 等于 0，则返回 <paramref name="maxValue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%29>重载方法返回随机整数的范围从 0 到`maxValue`– 1。 但是，如果`maxValue`为 0，则此方法返回 0。  
  
   
  
## Examples  
 下面的示例生成随机整数的各种重载<xref:System.Random.Next%2A>方法。  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 下面的示例生成一个随机整数，它用作索引来检索数组的字符串值。 因为数组的最高的索引是一个不会早于其长度的值<xref:System.Array.Length%2A?displayProperty=nameWithType>属性提供作为`maxValue`参数。  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxValue" /> 小于 0。</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">返回的随机数的下界（随机数可取该下界值）。</param>
        <param name="maxValue">返回的随机数的上界（随机数不能取该上界值）。 <c>maxValue</c> 必须大于或等于 <c>minValue</c>。</param>
        <summary>返回在指定范围内的任意整数。</summary>
        <returns>一个大于等于 <paramref name="minValue" /> 且小于 <paramref name="maxValue" /> 的 32 位带符号整数，即：返回的值范围包括 <paramref name="minValue" /> 但不包括 <paramref name="maxValue" />。 如果 <paramref name="minValue" /> 等于 <paramref name="maxValue" />，则返回 <paramref name="minValue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>重载方法返回随机整数的重量`minValue`到`maxValue`– 1。 但是，如果`maxValue`等于`minValue`，该方法将返回`minValue`。  
  
 与其他重载不同<xref:System.Random.Next%2A>方法，它返回仅非负值，此方法可返回一个负随机整数。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法生成三个不同范围的随机整数。 请注意，该示例的确切输出取决于系统提供种子值传递给<xref:System.Random>类构造函数。  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 下面的示例生成一个随机整数，它用作索引来检索数组的字符串值。 因为数组的最高的索引是一个不会早于其长度的值<xref:System.Array.Length%2A?displayProperty=nameWithType>属性提供作为`maxValue`参数。  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="minValue" /> 大于 <paramref name="maxValue" />。</exception>
        <block subset="none" type="overrides">
          <para>从.NET Framework 2.0 版中，如果派生的类从<see cref="T:System.Random" />并重写<see cref="M:System.Random.Sample" />方法中，由派生的类实现的提供的分布<see cref="M:System.Random.Sample" />对基类的调用中未使用方法实现<see cref="M:System.Random.Next(System.Int32,System.Int32)" />方法重载如果之间的差异<paramref name="minValue" />并<paramref name="maxValue" />参数大于<see cref="F:System.Int32.MaxValue" />。 相反，由基返回均匀分布<see cref="T:System.Random" />使用类。 此行为可提高整体性能的<see cref="T:System.Random" />类。 若要修改此行为，以调用<see cref="M:System.Random.Sample" />派生类中的方法，您还必须重写<see cref="M:System.Random.Next(System.Int32,System.Int32)" />方法重载。</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">包含随机数的字节数组。</param>
        <summary>用随机数填充指定字节数组的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字节数组的每个元素设置为随机数字大于或等于 0，且小于或等于<xref:System.Byte.MaxValue>。  
  
 例如，若要生成适用于创建随机密码的加密安全随机数字，请使用一种方法如<xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Random.NextBytes%2A>方法来使用随机字节值填充的字节数组。  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="overrides">
          <para>从.NET Framework 2.0 版中，如果派生的类从<see cref="T:System.Random" />并重写<see cref="M:System.Random.Sample" />方法中，由派生的类实现的提供的分布<see cref="M:System.Random.Sample" />对基类的调用中未使用方法实现<see cref="M:System.Random.NextBytes(System.Byte[])" />方法。 相反，由基返回均匀分布<see cref="T:System.Random" />使用类。 此行为可提高整体性能的<see cref="T:System.Random" />类。 若要修改此行为，以调用<see cref="M:System.Random.Sample" />派生类中的方法，您还必须重写<see cref="M:System.Random.NextBytes(System.Byte[])" />方法。</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个大于或等于 0.0 且小于 1.0 的随机浮点数。</summary>
        <returns>大于或等于 0.0 且小于 1.0 的双精度浮点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的实际的上限是随机数的 0.99999999999999978。  
  
 若要检索以外介于 0.0 到 1.0 范围内的随机浮点值，请参阅的"检索指定范围中的浮点值"部分<xref:System.Random>类主题。  
  
 此方法是受保护的方法的公共版本<xref:System.Random.Sample%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Random.NextDouble%2A>方法生成的随机双精度型值的序列。  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 下面的示例调用<xref:System.Random.NextDouble%2A>方法以生成 100 个随机数字，并显示其频率分发。  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个介于 0.0 和 1.0 之间的随机浮点数。</summary>
        <returns>大于或等于 0.0 且小于 1.0 的双精度浮点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要生成一个随机分布或不同的随机数字生成器原则，派生的类从<xref:System.Random>类并重写<xref:System.Random.Sample%2A>方法。  
  
> [!IMPORTANT]
>  <xref:System.Random.Sample%2A>方法是`protected`，这意味着它只能在内部访问<xref:System.Random>类和其派生的类。 若要生成一个介于 0 和 1 之间的随机数<xref:System.Random>实例时，调用<xref:System.Random.NextDouble%2A>方法。  
  
   
  
## Examples  
 以下示例从一个类从<xref:System.Random>并重写<xref:System.Random.Sample%2A>方法生成的随机数的分发。 此分布是不同于生成的均匀分布<xref:System.Random.Sample%2A>基类的方法。  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>从.NET Framework 2.0 版中，如果派生的类从<see cref="T:System.Random" />并重写<see cref="M:System.Random.Sample" />方法中，由派生的类实现的提供的分布<see cref="M:System.Random.Sample" />对基类的调用中未使用方法以下方法的实现： 
-   <see cref="M:System.Random.NextBytes(System.Byte[])" /> 方法。  
  
-   <see cref="M:System.Random.Next" /> 方法。  
  
-<see cref="M:System.Random.Next(System.Int32,System.Int32)" />方法中，如果 (<paramref name="maxValue" /> - <paramref name="minValue" />) 大于<see cref="F:System.Int32.MaxValue" />。  
  
相反，由基提供的统一分布<see cref="T:System.Random" />使用类。 此行为可提高整体性能的<see cref="T:System.Random" />类。 若要修改此行为，以调用的实现<see cref="M:System.Random.Sample" />方法在派生类中，您还必须重写这些三个成员的行为。 说明如示例所示。</para>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>