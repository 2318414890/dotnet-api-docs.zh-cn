<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Random.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5601795a307b1570fa0290d626c624db4c949b72e.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">601795a307b1570fa0290d626c624db4c949b72e</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Random">
          <source>Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.</source>
          <target state="translated">表示伪随机数生成器，这是一种能够产生满足某些随机性统计需求的数字序列的设备。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Pseudo-random numbers are chosen with equal probability from a finite set of numbers.</source>
          <target state="translated">伪随机数字从一组有限的数字选择以相同的概率。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes.</source>
          <target state="translated">因为数学算法用于选择它们，但它们是充分随机实用的角度而言，所选的数字不完全随机的。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The current implementation of the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm.</source>
          <target state="translated">当前实现<ph id="ph1">&lt;xref:System.Random&gt;</ph>类是否基于 Donald E.Knuth 减随机数生成器算法的修改版本。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For more information, see D. E.</source>
          <target state="translated">有关详细信息，请参阅 D.e。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Knuth.</source>
          <target state="translated">Knuth。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">*</bpt>The Art of Computer Programming, Volume 2: Seminumerical Algorithms<ept id="p1">*</ept>.</source>
          <target state="translated"><bpt id="p1">*</bpt>编程，卷 2 的计算机的技巧： Seminumerical 算法<ept id="p1">*</ept>。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Addison-Wesley, Reading, MA, third edition, 1997.</source>
          <target state="translated">Addison Wesley，读取，MA，第三个版本，1997年。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider&gt;</ph> class or derive a class from <ph id="ph2">&lt;xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">若要生成加密性极安全的随机数字，例如适用于创建随机密码，使用<ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider&gt;</ph>类或从派生类<ph id="ph2">&lt;xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In this topic:</source>
          <target state="translated">本主题内容：</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Instantiating the random number generator<ept id="p1">](#Instantiate)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>实例化的随机数生成器<ept id="p1">](#Instantiate)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Avoiding multiple instantiations<ept id="p1">](#Multiple)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>避免多个实例化<ept id="p1">](#Multiple)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>The System.Random class and thread safety<ept id="p1">](#ThreadSafety)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>System.Random 类和线程安全<ept id="p1">](#ThreadSafety)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Generating different types of random numbers<ept id="p1">](#Functionality)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>生成不同类型的随机数字<ept id="p1">](#Functionality)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Substituting your own algorithm<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>替换为您自己的算法<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>How do you use System.Random to…<ept id="p1">](#Operations)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>如何使用到 System.Random...<ept id="p1">](#Operations)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve the same sequence of random values<ept id="p1">](#Same)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>检索相同的随机值序列<ept id="p1">](#Same)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve unique sequences of random values<ept id="p1">](#Unique)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>检索随机值的唯一的序列<ept id="p1">](#Unique)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve integers in a specified range<ept id="p1">](#Range)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>检索指定的范围内的整数<ept id="p1">](#Range)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve integers with a specified number of digits<ept id="p1">](#Digits)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>检索与指定位数的数字的整数<ept id="p1">](#Digits)</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve floating-point values in a specified range<ept id="p1">](#Floats)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>检索指定范围中的浮点值<ept id="p1">](#Floats)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Generate random Boolean values<ept id="p1">](#Boolean)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>生成随机的布尔值<ept id="p1">](#Boolean)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Generate random 64-bit integers<ept id="p1">](#Long)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>生成随机的 64 位整数<ept id="p1">](#Long)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve bytes in a specified range<ept id="p1">](#Bytes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>检索指定范围中的字节数<ept id="p1">](#Bytes)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve an element from an array or collection at random<ept id="p1">](#Array)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>随机从数组或集合检索某个元素<ept id="p1">](#Array)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve a unique element from an array or collection<ept id="p1">](#UniqueArray)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>从数组或集合中检索的唯一元素<ept id="p1">](#UniqueArray)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instantiating the random number generator</source>
          <target state="translated">实例化的随机数生成器</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <ph id="ph1">&lt;xref:System.Random.%23ctor%2A&gt;</ph> class constructor.</source>
          <target state="translated">您通过实例化的随机数生成器提供的种子值 （的伪随机数生成算法的起始值） 到<ph id="ph1">&lt;xref:System.Random.%23ctor%2A&gt;</ph>类构造函数。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can supply the seed value either explicitly or implicitly:</source>
          <target state="translated">你可以显式或隐式提供的种子值：</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor uses an explicit seed value that you supply.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph>构造函数使用你提供一个显式的种子值。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> constructor uses the system clock to provide a seed value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph>构造函数使用的系统时钟提供的种子值。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This is the most common way of instantiating the random number generator.</source>
          <target state="translated">这是实例化的随机数生成器的最常见方法。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If the same seed is used for separate <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects, they will generate the same series of random numbers.</source>
          <target state="translated">如果相同的种子用于单独<ph id="ph1">&lt;xref:System.Random&gt;</ph>对象，则它们将生成相同的一系列随机数字。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers.</source>
          <target state="translated">这很有用，创建测试套件，以处理随机值，或重播派生随机数字，其数据的游戏。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, note that <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.</source>
          <target state="translated">但请注意，<ph id="ph1">&lt;xref:System.Random&gt;</ph>中在不同版本的.NET framework 下运行的进程的对象可能会返回不同系列的随机数字，即使它们在具有相同的种子值实例化。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <ph id="ph1">&lt;xref:System.Random&gt;</ph>.</source>
          <target state="translated">若要生成的随机数字的不同序列，你可以将种子值依赖于时间，从而生成具有每个新实例的不同系列<ph id="ph1">&lt;xref:System.Random&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The parameterized <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor can take an <ph id="ph2">&lt;xref:System.Int32&gt;</ph> value based on the number of ticks in the current time, whereas the parameterless <ph id="ph3">&lt;xref:System.Random.%23ctor&gt;</ph> constructor uses the system clock to generate its seed value.</source>
          <target state="translated">参数化<ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph>构造函数可以采用<ph id="ph2">&lt;xref:System.Int32&gt;</ph>值基于计时周期数中的当前时间，而无参数<ph id="ph3">&lt;xref:System.Random.%23ctor&gt;</ph>构造函数使用的系统时钟来生成其种子值。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, because the clock has finite resolution, using the parameterless constructor to create different <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects in close succession creates random number generators that produce identical sequences of random numbers.</source>
          <target state="translated">但是，由于时钟具有有限的解决方法，使用无参数构造函数创建不同<ph id="ph1">&lt;xref:System.Random&gt;</ph>关闭连续的对象创建随机数生成器生成相同序列的随机数字。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example illustrates how two <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects that are instantiated in close succession generate an identical series of random numbers.</source>
          <target state="translated">下面的示例演示了两个<ph id="ph1">&lt;xref:System.Random&gt;</ph>关闭连续中实例化的对象生成随机数的相同序列。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>On most Windows systems, <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects created within 15 milliseconds of one another are likely to have identical seed values.</source>
          <target state="translated">在大多数 Windows 系统，<ph id="ph1">&lt;xref:System.Random&gt;</ph>在相互之间的 15 毫秒内创建的对象很可能会有相同的种子值。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To avoid this problem, create a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object instead of multiple objects.</source>
          <target state="translated">若要避免此问题，创建单个<ph id="ph1">&lt;xref:System.Random&gt;</ph>对象而不是多个对象。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Avoiding multiple instantiations</source>
          <target state="translated">避免多个实例化</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers.</source>
          <target state="translated">初始化两个随机数生成器在紧凑循环中或在短期内创建两个随机数生成器可以生成相同序列的随机数字。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.</source>
          <target state="translated">在大多数情况下，这不是开发人员的意图并会导致性能问题，因为实例化和初始化的随机数生成器是一个代价相对较大的过程。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <ph id="ph1">&lt;xref:System.Random&gt;</ph> object to generate many random numbers over time, instead of creating new <ph id="ph2">&lt;xref:System.Random&gt;</ph> objects to generate one random number.</source>
          <target state="translated">同时若要提高性能并避免无意中创建单独生成相同的数字序列的随机数字生成器，我们建议你创建一个<ph id="ph1">&lt;xref:System.Random&gt;</ph>对象随着时间推移，而不是创建生成许多随机数新<ph id="ph2">&lt;xref:System.Random&gt;</ph>对象生成一个随机数。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class isn't thread safe.</source>
          <target state="translated">但是，<ph id="ph1">&lt;xref:System.Random&gt;</ph>类不是线程安全。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If you call <ph id="ph1">&lt;xref:System.Random&gt;</ph> methods from multiple threads, follow the guidelines discussed in the next section.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Random&gt;</ph>方法从多个线程，请遵循下一节所述的准则。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The System.Random class and thread safety</source>
          <target state="translated">System.Random 类和线程安全</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instead of instantiating individual <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects, we recommend that you create a single <ph id="ph2">&lt;xref:System.Random&gt;</ph> instance to generate all the random numbers needed by your app.</source>
          <target state="translated">而不是实例化单个<ph id="ph1">&lt;xref:System.Random&gt;</ph>对象，我们建议你创建单个<ph id="ph2">&lt;xref:System.Random&gt;</ph>实例生成你的应用程序所需的所有随机数。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects are not thread safe.</source>
          <target state="translated">但是，<ph id="ph1">&lt;xref:System.Random&gt;</ph>对象不是线程安全。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If your app calls <ph id="ph1">&lt;xref:System.Random&gt;</ph> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time.</source>
          <target state="translated">如果你的应用调用<ph id="ph1">&lt;xref:System.Random&gt;</ph>从多个线程的方法，你必须使用的同步对象以确保只有一个线程可以访问一次的随机数生成器。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If you don't ensure that the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.</source>
          <target state="translated">如果你不确保<ph id="ph1">&lt;xref:System.Random&gt;</ph>以线程安全的方式访问对象时，对返回随机数的方法的调用返回 0。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses the C# <bpt id="p1">[</bpt>lock Statement<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> and the Visual Basic <bpt id="p2">[</bpt>SyncLock statement<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner.</source>
          <target state="translated">下面的示例使用 C#<bpt id="p1">[</bpt>锁定语句<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept>和 Visual Basic <bpt id="p2">[</bpt>SyncLock 语句<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept>以确保单个随机数生成器由 11 线程访问以线程安全的方式。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.</source>
          <target state="translated">每个线程生成 200 万个随机数字、 对生成的随机数字的数量进行计数和计算其总和，并执行完后，然后更新的所有线程的总数。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The example ensures thread-safety in the following ways:</source>
          <target state="translated">该示例通过以下方式将确保线程安全性：</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph>属性用于定义用于跟踪生成的随机数字和其总和为每个线程的总数的线程本地变量。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A lock (the <ph id="ph1">`lock`</ph> statement in C# and the <ph id="ph2">`SyncLock`</ph> statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.</source>
          <target state="translated">锁 ( <ph id="ph1">`lock`</ph> C# 中的语句和<ph id="ph2">`SyncLock`</ph>在 Visual Basic 中的语句) 保护对变量的总计数和生成在所有线程上的所有随机数字之和的访问。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A semaphore (the <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object) is used to ensure that the main thread blocks until all other threads complete execution.</source>
          <target state="translated">信号量 (<ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph>对象) 用于确保主线程阻塞，直到所有其他线程完成执行。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0.</source>
          <target state="translated">该示例将检查是否随机数生成器已损坏通过确定是否对随机数字生成方法的两个连续调用返回 0。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If corruption is detected, the example uses the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> object to signal that all threads should be canceled.</source>
          <target state="translated">如果检测到损坏时，该示例使用<ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph>对象发出信号，应取消所有线程。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Before generating each random number, each thread checks the state of the <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> object.</source>
          <target state="translated">在生成之前每个随机数字，每个线程检查的状态<ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If cancellation is requested, the example calls the <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method to cancel the thread.</source>
          <target state="translated">如果请求取消，则该示例将调用<ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph>方法来取消线程。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example is identical to the first, except that it uses a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and a lambda expression instead of <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> objects.</source>
          <target state="translated">下面的示例是第一个，相同，但它使用<ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph>对象和而不是 lambda 表达式<ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It differs from the first example in the following ways:</source>
          <target state="translated">它在以下方面不同于第一个示例：</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute.</source>
          <target state="translated">跟踪生成的随机数字数和每个任务中的其结果相加值的变量仅用于该任务，因此无需使用<ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The static <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method is used to ensure that the main thread doesn't complete before all tasks have finished.</source>
          <target state="translated">静态<ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph>方法用于确保在所有任务都完成之前，不会完成主线程。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>There is no need for the <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object.</source>
          <target state="translated">有关无需<ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The exception that results from task cancellation is surfaced in the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">从任务取消生成的异常显示在<ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the previous example, it is handled by each thread.</source>
          <target state="translated">在前面的示例中，它是由每个线程进行处理。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Generating different types of random numbers</source>
          <target state="translated">生成不同类型的随机数字</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The random number generator provides methods that let you generate the following kinds of random numbers:</source>
          <target state="translated">随机数生成器提供了让你生成随机数的以下类型的方法：</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A series of <ph id="ph1">&lt;xref:System.Byte&gt;</ph> values.</source>
          <target state="translated">一系列<ph id="ph1">&lt;xref:System.Byte&gt;</ph>值。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method.</source>
          <target state="translated">通过将传递数组初始化为你想要返回到的方法的元素的数目确定字节值的数目<ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates 20 bytes.</source>
          <target state="translated">下面的示例生成 20 个字节。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A single integer.</source>
          <target state="translated">单个的整数。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can choose whether you want an integer from 0 to a maximum value (<ph id="ph1">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> – 1) by calling the <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> method, an integer between 0 and a specific value by calling the <ph id="ph3">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> method, or an integer within a range of values by calling the <ph id="ph4">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">你可以选择是否想从 0 到最大值的整数 (<ph id="ph1">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> – 1) 通过调用<ph id="ph2">&lt;xref:System.Random.Next&gt;</ph>方法、 0 到通过调用特定值之间的整数<ph id="ph3">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph>方法或通过调用的值的范围之内的整数<ph id="ph4">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.</source>
          <target state="translated">参数化的重载中的指定最大值是独占的;也就是说，生成的实际最大数目是小于指定值。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method to generate 10 random numbers between -10 and 10.</source>
          <target state="translated">下面的示例调用<ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>方法生成 10-10 到 10 之间的随机数。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method.</source>
          <target state="translated">请注意，该方法的第二个自变量指定的方法返回的随机值的范围不含上限。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In other words, the largest integer that the method can return is one less than this value.</source>
          <target state="translated">换而言之，该方法可以返回一个的最大整数少于此值。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A single floating-point value from 0.0 to less than 1.0 by calling the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.</source>
          <target state="translated">介于 0.0 和小于 1.0 通过调用的单个浮点值<ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978.</source>
          <target state="translated">方法返回的随机数字含上限为 1，因此其实际的上限是 0.99999999999999978。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates 10 random floating-point numbers.</source>
          <target state="translated">下面的示例生成 10 个随机浮点数。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method allows you to specify the range of the returned random number.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>方法允许你指定的返回随机数的范围。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, the <ph id="ph1">`maxValue`</ph> parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value.</source>
          <target state="translated">但是，<ph id="ph1">`maxValue`</ph>参数，指定的上限范围返回数字，该参数为排他，不含值。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This means that the method call <ph id="ph1">`Next(0, 100)`</ph> returns a value between 0 and 99, and not between 0 and 100.</source>
          <target state="translated">这意味着如果方法调用<ph id="ph1">`Next(0, 100)`</ph>返回一个值介于 0 和 99 之间，之间并不介于 0 和 100 之间。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class for such tasks as generating <bpt id="p1">[</bpt>random T:System.Boolean values<ept id="p1">](#Boolean)</ept>, generating <bpt id="p2">[</bpt>random floating point values with a range other than 0 to 1<ept id="p2">](#Floats)</ept>, generating <bpt id="p3">[</bpt>random 64-bit integers<ept id="p3">](#Long)</ept>, and <bpt id="p4">[</bpt>randomly retrieving a unique element from an array or collection<ept id="p4">](#UniqueArray)</ept>.</source>
          <target state="translated">你还可以使用<ph id="ph1">&lt;xref:System.Random&gt;</ph>任务，如生成的类<bpt id="p1">[</bpt>随机转换值<ept id="p1">](#Boolean)</ept>、 生成<bpt id="p2">[</bpt>随机浮点值的范围以外 0 到 1<ept id="p2">](#Floats)</ept>，生成<bpt id="p3">[</bpt>随机 64 位整数<ept id="p3">](#Long)</ept>，和<bpt id="p4">[</bpt>随机来自数组或集合中检索的唯一元素<ept id="p4">](#UniqueArray)</ept>。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For these and other common tasks, see the <bpt id="p1">[</bpt>How do you use System.Random to…<ept id="p1">](#Operations)</ept></source>
          <target state="translated">有关这些和其他常见任务，请参阅<bpt id="p1">[</bpt>如何使用到 System.Random...<ept id="p1">](#Operations)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>section.</source>
          <target state="translated">部分。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Substituting your own algorithm</source>
          <target state="translated">替换为您自己的算法</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can implement your own random number generator by inheriting from the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class and supplying your random number generation algorithm.</source>
          <target state="translated">你可以通过继承来实现你自己随机数生成器<ph id="ph1">&lt;xref:System.Random&gt;</ph>类并提供你随机数生成算法。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To supply your own algorithm, you must override the <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method, which implements the random number generation algorithm.</source>
          <target state="translated">若要提供您自己的算法，必须重写<ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph>方法，实现的随机数生成算法。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You should also override the <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Random.NextBytes%2A&gt;</ph> methods to ensure that they call your overridden <ph id="ph4">&lt;xref:System.Random.Sample%2A&gt;</ph> method.</source>
          <target state="translated">你还应重写<ph id="ph1">&lt;xref:System.Random.Next&gt;</ph>， <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>，和<ph id="ph3">&lt;xref:System.Random.NextBytes%2A&gt;</ph>方法以确保它们调用重写<ph id="ph4">&lt;xref:System.Random.Sample%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You don't have to override the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> methods.</source>
          <target state="translated">无需重写<ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph>和<ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For an example that derives from the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class and modifies its default pseudo-random number generator, see the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> reference page.</source>
          <target state="translated">有关示例，派生自<ph id="ph1">&lt;xref:System.Random&gt;</ph>类并修改其默认伪随机数生成器，请参阅<ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph>引用页。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>How do you use System.Random to…</source>
          <target state="translated">如何使用到 System.Random...</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.</source>
          <target state="translated">下列各节讨论，并提供几种你可能想要在应用中使用的随机数的示例代码。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve the same sequence of random values</source>
          <target state="translated">检索相同的随机值序列</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing.</source>
          <target state="translated">有时你想要在软件测试方案和玩游戏中生成相同的随机数字序列。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes.</source>
          <target state="translated">使用相同的随机数字序列进行测试，可检测回归，并确认 bug 修复。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Using the same sequence of random number in games allows you to replay previous games.</source>
          <target state="translated">在游戏中使用相同的随机数字序列，可重播以前的游戏。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can generate the same sequence of random numbers by providing the same seed value to the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">你可以通过提供相同的种子值生成相同的随机数字序列<ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The seed value provides a starting value for the pseudo-random number generation algorithm.</source>
          <target state="translated">种子值提供的伪随机数生成算法的起始值。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses 100100 as an arbitrary seed value to instantiate the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object, displays 20 random floating-point values, and persists the seed value.</source>
          <target state="translated">下面的示例使用 100100 作为任意种子值来实例化<ph id="ph1">&lt;xref:System.Random&gt;</ph>对象，显示 20 个的随机浮点值，并且仍然存在种子值。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.</source>
          <target state="translated">它然后还原种子值、 实例化新的随机数字生成器，并显示相同的 20 个随机浮点值。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.</source>
          <target state="translated">请注意，是否在不同版本的.NET Framework 上运行，该示例可能生成不同序列的随机数字。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve unique sequences of random numbers</source>
          <target state="translated">检索随机数的唯一的序列</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Providing different seed values to instances of the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class causes each random number generator to produce a different sequence of values.</source>
          <target state="translated">提供的实例的不同的种子值<ph id="ph1">&lt;xref:System.Random&gt;</ph>类将导致每个随机数生成器来生成的值不同的序列。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can provide a seed value either explicitly by calling the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor, or implicitly by calling the <ph id="ph2">&lt;xref:System.Random.%23ctor&gt;</ph> constructor.</source>
          <target state="translated">你可以提供的种子值显式通过调用<ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph>构造函数，或隐式调用<ph id="ph2">&lt;xref:System.Random.%23ctor&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Most developers call the parameterless constructor, which uses the system clock.</source>
          <target state="translated">大多数开发人员调用使用系统时钟的无参数构造函数。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses this approach to instantiate two <ph id="ph1">&lt;xref:System.Random&gt;</ph> instances.</source>
          <target state="translated">下面的示例使用这种方法来实例化两个<ph id="ph1">&lt;xref:System.Random&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Each instance displays a series of 10 random integers.</source>
          <target state="translated">每个实例显示一系列的 10 个随机整数。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds.</source>
          <target state="translated">但是，由于其有限的解决方法，系统时钟不会检测不到大约 15 毫秒的时间差异。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Therefore, if your code calls the <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> overload to instantiate two <ph id="ph2">&lt;xref:System.Random&gt;</ph> objects in succession, you might inadvertently be providing the objects with identical seed values.</source>
          <target state="translated">因此，如果你的代码调用<ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph>要实例化两个重载<ph id="ph2">&lt;xref:System.Random&gt;</ph>中连续，你可能会无意中提供的对象具有相同的种子值的对象。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To see this in the previous example, comment out the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method call, and compile and run the example again.</source>
          <target state="translated">若要查看此上一示例中，注释掉<ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph>方法调用时，和编译并再次运行该示例。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To prevent this from happening, we recommend that you instantiate a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object rather than multiple ones.</source>
          <target state="translated">若要防止此类情况发生，我们建议您实例化单个<ph id="ph1">&lt;xref:System.Random&gt;</ph>对象而不是多个快照。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, since <ph id="ph1">&lt;xref:System.Random&gt;</ph> isn't thread safe, you must use some synchronization device if you access a <ph id="ph2">&lt;xref:System.Random&gt;</ph> instance from multiple threads; for more information, see <bpt id="p1">[</bpt>The Random class and thread safety<ept id="p1">](#ThreadSafety)</ept> earlier in this topic.</source>
          <target state="translated">但是，由于<ph id="ph1">&lt;xref:System.Random&gt;</ph>不是线程安全的你必须使用某些同步设备，如果你访问<ph id="ph2">&lt;xref:System.Random&gt;</ph>实例从多个线程; 有关详细信息，请参阅<bpt id="p1">[</bpt>随机的类和线程安全<ept id="p1">](#ThreadSafety)</ept>前面的这主题。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Alternately, you can use a delay mechanism, such as the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.</source>
          <target state="translated">或者，可以使用延迟机制，如<ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph>使用在前面的示例中，以确保实例化会超过 15 毫秒相隔的方法。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve integers in a specified range</source>
          <target state="translated">检索指定的范围内的整数</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can retrieve integers in a specified range by calling the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return.</source>
          <target state="translated">你可以通过调用来检索指定的范围内的整数<ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>方法，可以指定你想要返回的随机数生成器的编号的上限和较低。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The upper bound is an exclusive, not an inclusive, value.</source>
          <target state="translated">上限为排他，不含值。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>That is, it isn't included in the range of values returned by the method.</source>
          <target state="translated">也就是说，不会包括在该方法返回的值的范围。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses this method to generate random integers between -10 and 10.</source>
          <target state="translated">下面的示例使用此方法来生成-10 到 10 之间的随机整数。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that it specifies 11, which is one greater than the desired value, as the value of the <ph id="ph1">`maxValue`</ph> argument in the method call.</source>
          <target state="translated">请注意，它指定 11 中，这是一个大于所需的值，作为值的<ph id="ph1">`maxValue`</ph>方法调用中的自变量。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve integers with a specified number of digits</source>
          <target state="translated">检索与指定位数的数字的整数</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can call the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method to retrieve numbers with a specified number of digits.</source>
          <target state="translated">你可以调用<ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>方法来检索具有指定位数的数字的数字。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method with a <ph id="ph2">`minValue`</ph> value of 1000 and a <ph id="ph3">`maxValue`</ph> value of 10000, as the following example shows.</source>
          <target state="translated">例如，若要检索具有四个数字 （也就是说，范围为 1000年至 9999 的数字） 的数字，你调用<ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>方法替换<ph id="ph2">`minValue`</ph>值为 1000年和<ph id="ph3">`maxValue`</ph>10000，如以下示例所示的值。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve floating-point values in a specified range</source>
          <target state="translated">检索指定范围中的浮点值</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method returns random floating-point values that range from 0 to less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph>方法返回随机浮点值的范围介于 0 到小于 1。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, you'll often want to generate random values in some other range.</source>
          <target state="translated">但是，你通常将想要在另一个范围中生成随机值。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.</source>
          <target state="translated">如果所需值最小和最大值之间的间隔为 1 时，可以将所需的起始间隔和 0 之间的差异添加到返回的版本号<ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example does this to generate 10 random numbers between -1 and 0.</source>
          <target state="translated">下面的示例这样做是为了生成 10 个随机数字之间-1 和 0。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound.</source>
          <target state="translated">要生成随机浮点数字，其下限为 0，但上限大于 1 （或者，对于负数，其下限为小于-1，上限为 0），再乘以非零值绑定的随机数字。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example does this to generate 20 million random floating-point numbers that range from 0 to <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">下面的示例这样做是为了生成 20 亿个随机浮点数该范围从 0 到<ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In also displays the distribution of the random values generated by the method.</source>
          <target state="translated">在还显示的方法生成的随机值的分布。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To generate random floating-point numbers between two arbitrary values, like the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method does for integers, use the following formula:</source>
          <target state="translated">若要生成两个的任意值之间的随机浮点数，如<ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>方法不为整数，可使用以下公式：</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.</source>
          <target state="translated">下面的示例为 11.0，从 10.0 生成范围的 100 万个随机数，并显示其分发。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Generate random Boolean values</source>
          <target state="translated">生成随机的布尔值</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random&gt;</ph> class doesn't provide methods that generate <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random&gt;</ph>类不提供生成的方法<ph id="ph2">&lt;xref:System.Boolean&gt;</ph>值。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, you can define your own class or method to do that.</source>
          <target state="translated">但是，你可以定义自己的类或方法来执行该操作。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example defines a class, <ph id="ph1">`BooleanGenerator`</ph>, with a single method, <ph id="ph2">`NextBoolean`</ph>.</source>
          <target state="translated">下面的示例定义了一个类<ph id="ph1">`BooleanGenerator`</ph>，与一个方法， <ph id="ph2">`NextBoolean`</ph>。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`BooleanGenerator`</ph> class stores a <ph id="ph2">&lt;xref:System.Random&gt;</ph> object as a private variable.</source>
          <target state="translated"><ph id="ph1">`BooleanGenerator`</ph>类存储<ph id="ph2">&lt;xref:System.Random&gt;</ph>对象作为私有变量。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`NextBoolean`</ph> method calls the <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method and passes the result to the <ph id="ph3">&lt;xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`NextBoolean`</ph>方法调用<ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph>方法，并将传递到结果<ph id="ph3">&lt;xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that 2 is used as the argument to specify the upper bound of the random number.</source>
          <target state="translated">请注意，使用 2 作为参数来指定随机数的上限。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Since this is an exclusive value, the method call returns either 0 or 1.</source>
          <target state="translated">由于这是独占的值，方法调用将返回 0 或 1。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instead of creating a separate class to generate random <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> values, the example could simply have defined a single method.</source>
          <target state="translated">而不是创建一个单独的类来生成随机<ph id="ph1">&lt;xref:System.Boolean&gt;</ph>值，则无法只需定义一种方法。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In that case, however, the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object should have been defined as a class-level variable to avoid instantiating a new <ph id="ph2">&lt;xref:System.Random&gt;</ph> instance in each method call.</source>
          <target state="translated">在此情况下，但是，<ph id="ph1">&lt;xref:System.Random&gt;</ph>对象应已定义为一个类级变量来避免实例化一个新<ph id="ph2">&lt;xref:System.Random&gt;</ph>中每个方法调用的实例。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In Visual Basic, the Random instance can be defined as a <bpt id="p1">[</bpt>Static<ept id="p1">](~/docs/visual-basic/language-reference/modifiers/static.md)</ept> variable in the <ph id="ph1">`NextBoolean`</ph> method.</source>
          <target state="translated">在 Visual Basic 中，随机实例可以定义为<bpt id="p1">[</bpt>静态<ept id="p1">](~/docs/visual-basic/language-reference/modifiers/static.md)</ept>变量中<ph id="ph1">`NextBoolean`</ph>方法。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example provides an implementation.</source>
          <target state="translated">下面的示例提供实现。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Generate random 64-bit integers</source>
          <target state="translated">生成随机的 64 位整数</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method return 32-bit integers.</source>
          <target state="translated">重载<ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph>方法返回 32 位整数。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, in some cases, you might want to work with 64-bit integers.</source>
          <target state="translated">但是，在某些情况下，你可能想要使用 64 位整数。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can do this as follows:</source>
          <target state="translated">你可以按如下所示进行操作：</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Call the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to retrieve a double-precision floating point value.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph>方法来检索双精度浮点点值。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Multiply that value by <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">该值相乘<ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups.</source>
          <target state="translated">下面的示例使用该技术来生成 20 亿个随机长整数，并对其进行分类 10 个相等组中。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">它随后通过计算从 0 到每个组中的数量计算分布的随机数字<ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.</source>
          <target state="translated">如示例输出所示，公式的长整数范围更多或更少均匀地分布的数字。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>An alternative technique that uses bit manipulation does not generate truly random numbers.</source>
          <target state="translated">使用位操作不会生成真正的随机数字另一种方法。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This technique calls <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> to generate two integers, left-shifts one by 32 bits, and ORs them together.</source>
          <target state="translated">此方法调用<ph id="ph1">&lt;xref:System.Random.Next&gt;</ph>生成两个整数、 左移一个由 32 位和 or 的情况下在一起。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This technique has two limitations:</source>
          <target state="translated">此方法具有两个限制：</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.</source>
          <target state="translated">由于第 31 位是符号位，在第 31 位所产生的长整数的值始终是 0。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.</source>
          <target state="translated">这可以通过生成随机的 0 或 1，左移 31 位为单位和监视寻址它与原始随机的长整型。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>More seriously, because the probability that the value returned by <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.</source>
          <target state="translated">更严格来讲，因为返回的值的概率<ph id="ph1">&lt;xref:System.Random.Next&gt;</ph>将为 0，则将随机数字，如果有几个范围 0x0 0x00000000FFFFFFFF 中。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve bytes in a specified range</source>
          <target state="translated">检索指定范围中的字节数</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method allow you to specify the range of random numbers, but the <ph id="ph2">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method does not.</source>
          <target state="translated">重载<ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph>方法允许你指定的随机数字范围但<ph id="ph2">&lt;xref:System.Random.NextBytes%2A&gt;</ph>方法不执行。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example implements a <ph id="ph1">`NextBytes`</ph> method that lets you specify the range of the returned bytes.</source>
          <target state="translated">下面的示例实现<ph id="ph1">`NextBytes`</ph>允许您指定的返回的字节范围的方法。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It defines a <ph id="ph1">`Random2`</ph> class that derives from <ph id="ph2">&lt;xref:System.Random&gt;</ph> and overloads its <ph id="ph3">`NextBytes`</ph> method.</source>
          <target state="translated">它定义<ph id="ph1">`Random2`</ph>派生自的类<ph id="ph2">&lt;xref:System.Random&gt;</ph>和重载其<ph id="ph3">`NextBytes`</ph>方法。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`NextBytes(Byte[], Byte, Byte)`</ph> method wraps a call to the <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array.</source>
          <target state="translated"><ph id="ph1">`NextBytes(Byte[], Byte, Byte)`</ph>方法包装对的调用<ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>方法并指定最小值和一个大于最大值 (在这种情况下，0 和 101) 我们希望返回的字节数组中。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Because we are sure that the integer values returned by the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method are within the range of the <ph id="ph2">&lt;xref:System.Byte&gt;</ph> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.</source>
          <target state="translated">因为我们可以确保返回的整数值<ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph>方法进入的范围<ph id="ph2">&lt;xref:System.Byte&gt;</ph>数据类型，我们可以安全地将其强制转换 （在 C# 中) 或将它们 （在 Visual Basic 中) 从整数转换为字节。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve an element from an array or collection at random</source>
          <target state="translated">随机从数组或集合检索某个元素</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Random numbers often serve as indexes to retrieve values from arrays or collections.</source>
          <target state="translated">随机数通常用作要从数组或集合中检索值的索引。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To retrieve a random index value, you can call the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method, and use the lower bound of the array as the value of its <ph id="ph2">`minValue`</ph> argument and one greater than the upper bound of the array as the value of its <ph id="ph3">`maxValue`</ph> argument.</source>
          <target state="translated">若要检索的随机索引值，你可以调用<ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>方法，并使用的下限数组的值作为其<ph id="ph2">`minValue`</ph>自变量和一个大于上限的数组的值作为其<ph id="ph3">`maxValue`</ph>自变量。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For a zero-based array, this is equivalent to its <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> property, or one greater than the value returned by the <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">从零开始的数组，它等效于其<ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph>属性，或一个返回的值大于<ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example randomly retrieves the name of a city in the United States from an array of cities.</source>
          <target state="translated">下面的示例随机从一个城市数组检索在美国国内的城市的名称。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve a unique element from an array or collection</source>
          <target state="translated">从数组或集合中检索的唯一元素</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A random number generator can always return duplicate values.</source>
          <target state="translated">随机数生成器始终可以返回重复值。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows.</source>
          <target state="translated">当的数字范围变得更小或生成的值的数目变得更大，就会增加重复项的概率。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.</source>
          <target state="translated">如果随机值必须是唯一的其他号码会生成来补偿重复项，导致越来越不佳的性能。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>There are a number of techniques to handle this scenario.</source>
          <target state="translated">有大量的技术，可解决这种情况。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers.</source>
          <target state="translated">一个常见的解决方案是创建数组或集合，其中包含要检索的值并包含随机浮点数的并行数组。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The second array is populated with random numbers at the time the first array is created, and the <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> method is used to sort the first array by using the values in the parallel array.</source>
          <target state="translated">在创建第一个数组，次使用随机数填充第二个数组和<ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph>方法用于通过使用并行数组中的值排序的第一个数组。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For example, if you're developing a Solitaire game, you want to ensure that each card is used only once.</source>
          <target state="translated">例如，如果你要开发纸牌游戏，你想要确保每个卡使用仅一次。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck.</source>
          <target state="translated">而不是生成随机数字，以检索卡和跟踪是否已处理该卡，你可以创建可用于排序牌的随机数的并行数组。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.</source>
          <target state="translated">一旦按的卡片组，你的应用程序可以维护一个指针来指示的卡片组上的下一步卡的索引。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example illustrates this approach.</source>
          <target state="translated">下面的示例阐释了这种方法。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It defines a <ph id="ph1">`Card`</ph> class that represents a playing card and a <ph id="ph2">`Dealer`</ph> class that deals a deck of shuffled cards.</source>
          <target state="translated">它定义<ph id="ph1">`Card`</ph>类表示一个游戏卡的和一的<ph id="ph2">`Dealer`</ph>处理一副牌组成无序的类。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`Dealer`</ph> class constructor populates two arrays: a <ph id="ph2">`deck`</ph> array that has class scope and that represents all the cards in the deck; and a local <ph id="ph3">`order`</ph> array that has the same number of elements as the <ph id="ph4">`deck`</ph> array and is populated with randomly generated <ph id="ph5">&lt;xref:System.Double&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">`Dealer`</ph>类构造函数填充两个数组：<ph id="ph2">`deck`</ph>数组具有类范围和表示牌; 和本地中的所有卡<ph id="ph3">`order`</ph>具有相同数量的元素作为数组的<ph id="ph4">`deck`</ph>数组并填充使用随机生成<ph id="ph5">&lt;xref:System.Double&gt;</ph>值。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> method is then called to sort the <ph id="ph2">`deck`</ph> array based on the values in the <ph id="ph3">`order`</ph> array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph>方法然后，调用排序<ph id="ph2">`deck`</ph>数组中的值基于<ph id="ph3">`order`</ph>数组。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example creates a single random number generator and calls its <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Random.NextDouble%2A&gt;</ph> methods to generate sequences of random numbers within different ranges.</source>
          <target state="translated">下面的示例创建单个随机数生成器，并调用其<ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Random.Next%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Random.NextDouble%2A&gt;</ph>方法来生成不同的范围内的随机数字序列。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates a random integer that it uses as an index to retrieve a string value from an array.</source>
          <target state="translated">下面的示例生成一个随机整数，它用作索引以检索数组的字符串值。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the .NET Framework 1.0 and 1.1, a minimum implementation of a class derived from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> required overriding the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method to define a new or modified algorithm for generating random numbers.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 中，类的一个最小实现派生自<ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>所需重写<ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph>方法以定义使用新的或已修改的算法来生成随机数字。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The derived class could then rely on the base class implementation of the <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32)" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>, and <ph id="ph5">&lt;see cref="M:System.Random.NextDouble" /&gt;</ph> methods to call the derived class implementation of the <ph id="ph6">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method.</source>
          <target state="translated">派生的类无法然后依赖于的基类实现<ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>， <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32)" /&gt;</ph>， <ph id="ph3">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>， <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>，和<ph id="ph5">&lt;see cref="M:System.Random.NextDouble" /&gt;</ph>方法来调用的派生的类实现<ph id="ph6">&lt;see cref="M:System.Random.Sample" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the .NET Framework 2.0 and later, the behavior of the <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, and <ph id="ph3">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> methods have changed so that these methods do not necessarily call the derived class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method.</source>
          <target state="translated">在.NET Framework 2.0 和更高版本的行为<ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>， <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>，和<ph id="ph3">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>方法已更改，以便这些方法不一定调用的派生的类实现<ph id="ph4">&lt;see cref="M:System.Random.Sample" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As a result, classes derived from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> that target the .NET Framework 2.0 and later should also override these three methods.</source>
          <target state="translated">因此，类派生自<ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>，面向.NET Framework 2.0 和更高版本应该还重写这三种方法。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The implementation of the random number generator in the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class isn't guaranteed to remain the same across major versions of the .NET Framework.</source>
          <target state="translated">中的随机数生成器的实现<ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>类并不能保证在.NET framework 的主版本之间保持不变。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As a result, you shouldn't assume that the same seed will result in the same pseudo-random sequence in different versions of the .NET Framework.</source>
          <target state="translated">因此，不应假定相同的种子将导致.NET Framework 的不同版本中相同的伪随机序列。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="T:System.Random">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class, using a time-dependent default seed value.</source>
          <target state="translated">使用与时间相关的默认种子值，初始化 <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>The default seed value is derived from the system clock and has finite resolution.</source>
          <target state="translated">默认种子值派生自系统时钟，具有有限的解决方法。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>As a result, different <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers.</source>
          <target state="translated">因此，不同<ph id="ph1">&lt;xref:System.Random&gt;</ph>的默认构造函数的调用在关闭连续中创建的对象将具有相同的默认种子值，并因此，将生成的随机数的相同集。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>This problem can be avoided by using a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object to generate all random numbers.</source>
          <target state="translated">可避免此问题，只需使用单个<ph id="ph1">&lt;xref:System.Random&gt;</ph>对象生成所有随机数。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">您还可以在其周围通过修改返回的系统时钟的种子值，然后显式提供此新的种子值改<ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">有关详细信息，请参阅<ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Call this constructor if you want your random number generator to generate a random sequence of numbers.</source>
          <target state="translated">如果你想要生成随机数字序列的你随机数生成器，请调用此构造函数。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor with a fixed seed value .</source>
          <target state="translated">若要生成固定的数字序列的随机将相同的不同随机数生成器，请调用<ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph>使用固定的种子值的构造函数。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>This <ph id="ph1">&lt;xref:System.Random&gt;</ph> constructor overload is frequently used when testing apps that use random numbers.</source>
          <target state="translated">这<ph id="ph1">&lt;xref:System.Random&gt;</ph>测试应用程序使用随机数字时，经常使用构造函数重载。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Once you've instantiated the random number generator, you call individual <ph id="ph1">&lt;xref:System.Random&gt;</ph> methods, such as <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> or <ph id="ph3">&lt;xref:System.Random.NextDouble&gt;</ph>, to generate random numbers.</source>
          <target state="translated">一旦你已实例化的随机数生成器，就调用单个<ph id="ph1">&lt;xref:System.Random&gt;</ph>方法，如<ph id="ph2">&lt;xref:System.Random.Next&gt;</ph>或<ph id="ph3">&lt;xref:System.Random.NextDouble&gt;</ph>，以便生成随机数字。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>The following example uses the default constructor to instantiate three <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects and displays a sequence of five random integers for each.</source>
          <target state="translated">下面的示例使用默认构造函数来实例化三个<ph id="ph1">&lt;xref:System.Random&gt;</ph>对象，并显示每个五个随机整数的序列。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Because the first two <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects are created in close succession, they are instantiated using identical seed values based on the system clock and, therefore, they produce an identical sequence of random numbers.</source>
          <target state="translated">由于前两个<ph id="ph1">&lt;xref:System.Random&gt;</ph>关闭连续创建对象，使用基于系统时钟的相同的种子值实例化，并因此，它们将生成相同的随机数字序列。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>On the other hand, the default constructor of the third <ph id="ph1">&lt;xref:System.Random&gt;</ph> object is called after a two-second delay caused by calling the <ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">另一方面，默认构造函数的第三个<ph id="ph1">&lt;xref:System.Random&gt;</ph>对象称为后通过调用导致了两个秒钟的延迟<ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Because this produces a different seed value for the third <ph id="ph1">&lt;xref:System.Random&gt;</ph> object, it produces a different sequence of random numbers.</source>
          <target state="translated">因为这将生成第三个不同的种子值<ph id="ph1">&lt;xref:System.Random&gt;</ph>对象，它会生成不同的随机数字序列。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor(System.Int32)">
          <source>A number used to calculate a starting value for the pseudo-random number sequence.</source>
          <target state="translated">用来计算伪随机数序列起始值的数字。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor(System.Int32)">
          <source>If a negative number is specified, the absolute value of the number is used.</source>
          <target state="translated">如果指定的是负数，则使用其绝对值。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class, using the specified seed value.</source>
          <target state="translated">使用指定的种子值初始化 <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>Providing an identical seed value to different <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects causes each instance to produce identical sequences of random numbers.</source>
          <target state="translated">提供相同的种子值到不同<ph id="ph1">&lt;xref:System.Random&gt;</ph>对象会导致每个实例以生成随机数的相同随机数序列。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>This is often done when testing apps that rely on random number generators.</source>
          <target state="translated">这通常是测试应用程序依赖于随机数生成器时。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>If your application requires different random number sequences, invoke this constructor repeatedly with different seed values.</source>
          <target state="translated">如果你的应用程序需要不同的随机数序列，则调用此构造函数重复用于不同的种子值。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>One way to produce a unique seed value is to make it time-dependent.</source>
          <target state="translated">为生成的唯一种子值的一种方法是使其依赖于时间。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>For example, derive the seed value from the system clock, as the <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> overload does.</source>
          <target state="translated">例如，作为派生自系统时钟的种子值<ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph>未重载。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value.</source>
          <target state="translated">但是，系统时钟可能没有足够的分辨率，以提供不同调用此构造函数使用不同的种子值。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects in the following example.</source>
          <target state="translated">这会导致生成相同序列的伪随机数字生成器所示的前两个<ph id="ph1">&lt;xref:System.Random&gt;</ph>下面的示例中的对象。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to ensure that you provide each constructor with a different seed value.</source>
          <target state="translated">若要防止此情况，应用某种算法来区分每个调用或调用中的种子值<ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph>方法，以确保为每个构造函数提供不同的种子值。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>Another option is to instantiate a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object that you use to generate all the random numbers in your application.</source>
          <target state="translated">另一个选项是实例化单个<ph id="ph1">&lt;xref:System.Random&gt;</ph>对象用于在你的应用程序中生成的随机数。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>This yields slightly better performance, since instantiating a random number generator is fairly expensive.</source>
          <target state="translated">这会生成略有更好的性能，因为实例化的随机数生成器是非常耗费资源。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>The following example creates <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects with the class constructor that takes a seed parameter and generates a sequence of random integers and doubles.</source>
          <target state="translated">下面的示例创建<ph id="ph1">&lt;xref:System.Random&gt;</ph>使用类构造函数，它接受种子参数并生成随机整数和双精度型值的序列的对象。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>The example illustrates that the same sequence is generated when the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object is created again with the constructor and seed parameter.</source>
          <target state="translated">此示例阐释了所生成相同的序列时<ph id="ph1">&lt;xref:System.Random&gt;</ph>使用构造函数和种子参数重新创建对象。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="T:System.Random">
          <source>Returns a random integer.</source>
          <target state="translated">返回一个随机整数。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Random.Next">
          <source>Returns a non-negative random integer.</source>
          <target state="translated">返回一个非负随机整数。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Random.Next">
          <source>A 32-bit signed integer that is greater than or equal to 0 and less than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">大于或等于 0 且小于 <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> 的 32 位有符号整数。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source><ph id="ph1">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> generates a random number whose value ranges from 0 to less than <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> 生成一个随机数字，其值范围从 0 到小于<ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>To generate a random number whose value ranges from 0 to some other positive number, use the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">若要生成随机数字其值范围从 0 到其他某个正数，使用<ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>To generate a random number within a different range, use the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">若要生成一个随机数不同范围内的，使用<ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>The following example makes repeated calls to the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method to generate a specific number of random numbers requested by the user.</source>
          <target state="translated">下面的示例调用重复<ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph>方法来生成特定数量的用户请求的随机数字。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>The <ph id="ph1">&lt;xref:System.Console.ReadLine%2A?displayProperty=nameWithType&gt;</ph> method is used to get customer input.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Console.ReadLine%2A?displayProperty=nameWithType&gt;</ph>方法用于获取客户输入。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>The following example derives a class from <ph id="ph1">&lt;xref:System.Random&gt;</ph> to generate a sequence of random numbers whose distribution differs from the uniform distribution generated by the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> method of the base class.</source>
          <target state="translated">下面的示例派生了从一个类<ph id="ph1">&lt;xref:System.Random&gt;</ph>从生成的均匀分布生成其分发不同的随机数字序列的<ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph>基本类的方法。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method to provide the distribution of random numbers, and overrides the <ph id="ph2">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> method to use series of random numbers.</source>
          <target state="translated">它将重写<ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph>方法以提供的随机数字，并重写分发<ph id="ph2">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph>要使用的随机数序列方法。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.Next" /&gt;</ph> method.</source>
          <target state="translated">从.NET Framework 2.0 版本开始，如果派生的类从<ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>，并重写<ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph>方法，提供的派生的类实现的分布<ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph>给基类的调用中不使用方法实现<ph id="ph4">&lt;see cref="M:System.Random.Next" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>Instead, the uniform distribution returned by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">均匀分布相反，返回由基<ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>使用类。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">此行为能改善的总体性能<ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>To modify this behavior to call the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the <ph id="ph2">&lt;see cref="M:System.Random.Next" /&gt;</ph> method.</source>
          <target state="translated">若要修改此行为，以调用<ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph>派生类中的方法，你还必须重写<ph id="ph2">&lt;see cref="M:System.Random.Next" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>The exclusive upper bound of the random number to be generated.</source>
          <target state="translated">要生成的随机数的上限（随机数不能取该上限值）。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> must be greater than or equal to 0.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> 值必须大于或等于 0。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>Returns a non-negative random integer that is less than the specified maximum.</source>
          <target state="translated">返回一个小于所指定最大值的非负随机整数。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>A 32-bit signed integer that is greater than or equal to 0, and less than <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph>; that is, the range of return values ordinarily includes 0 but not <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</source>
          <target state="translated">大于或等于零且小于 <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> 的 32 位有符号整数，即：返回值的范围通常包括零但不包括 <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>However, if <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> equals 0, <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph> is returned.</source>
          <target state="translated">但是，如果 <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> 等于 0，则返回 <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> overload returns random integers that range from 0 to <ph id="ph2">`maxValue`</ph> – 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph>重载方法返回随机整数该范围从 0 到<ph id="ph2">`maxValue`</ph>– 1。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>However, if <ph id="ph1">`maxValue`</ph> is 0, the method returns 0.</source>
          <target state="translated">但是，如果<ph id="ph1">`maxValue`</ph>为 0，则该方法返回 0。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>The following example generates random integers with various overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例生成使用的不同重载的随机整数<ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>The following example generates a random integer that it uses as an index to retrieve a string value from an array.</source>
          <target state="translated">下面的示例生成一个随机整数，它用作索引以检索数组的字符串值。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>Because the highest index of the array is one less than its length, the value of the <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> property is supplied as a the <ph id="ph2">`maxValue`</ph> parameter.</source>
          <target state="translated">因为数组的最高的索引是一个小于其长度、 的值<ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>作为提供属性<ph id="ph2">`maxValue`</ph>参数。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> 小于 0。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The inclusive lower bound of the random number returned.</source>
          <target state="translated">返回的随机数的下界（随机数可取该下界值）。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The exclusive upper bound of the random number returned.</source>
          <target state="translated">返回的随机数的上界（随机数不能取该上界值）。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> must be greater than or equal to <bpt id="p2">&lt;c&gt;</bpt>minValue<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> 必须大于或等于 <bpt id="p2">&lt;c&gt;</bpt>minValue<ept id="p2">&lt;/c&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Returns a random integer that is within a specified range.</source>
          <target state="translated">返回在指定范围内的任意整数。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>A 32-bit signed integer greater than or equal to <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> and less than <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>; that is, the range of return values includes <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph> but not <ph id="ph4">&lt;paramref name="maxValue" /&gt;</ph>.</source>
          <target state="translated">一个大于等于 <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> 且小于 <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph> 的 32 位带符号整数，即：返回的值范围包括 <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph> 但不包括 <ph id="ph4">&lt;paramref name="maxValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> equals <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>, <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph> is returned.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> 等于 <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>，则返回 <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> overload returns random integers that range from <ph id="ph2">`minValue`</ph> to <ph id="ph3">`maxValue`</ph> – 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>重载方法返回随机整数，频率范围介于<ph id="ph2">`minValue`</ph>到<ph id="ph3">`maxValue`</ph>– 1。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>However, if <ph id="ph1">`maxValue`</ph> equals <ph id="ph2">`minValue`</ph>, the method returns <ph id="ph3">`minValue`</ph>.</source>
          <target state="translated">但是，如果<ph id="ph1">`maxValue`</ph>等于<ph id="ph2">`minValue`</ph>，该方法返回<ph id="ph3">`minValue`</ph>。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Unlike the other overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method, which return only non-negative values, this method can return a negative random integer.</source>
          <target state="translated">与其他重载不同<ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph>方法，它返回仅非负值，此方法可以返回负随机整数。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to generate random integers with three distinct ranges.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph>方法来生成三个不同范围的随机整数。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Note that the exact output from the example depends on the system-supplied seed value passed to the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class constructor.</source>
          <target state="translated">请注意，该示例的确切输出取决于传递给的系统提供的种子值<ph id="ph1">&lt;xref:System.Random&gt;</ph>类构造函数。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The following example generates a random integer that it uses as an index to retrieve a string value from an array.</source>
          <target state="translated">下面的示例生成一个随机整数，它用作索引以检索数组的字符串值。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Because the highest index of the array is one less than its length, the value of the <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> property is supplied as a the <ph id="ph2">`maxValue`</ph> parameter.</source>
          <target state="translated">因为数组的最高的索引是一个小于其长度、 的值<ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>作为提供属性<ph id="ph2">`maxValue`</ph>参数。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> 大于 <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> method overload if the difference between the <ph id="ph5">&lt;paramref name="minValue" /&gt;</ph> and <ph id="ph6">&lt;paramref name="maxValue" /&gt;</ph> parameters is greater than <ph id="ph7">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">从.NET Framework 2.0 版本开始，如果派生的类从<ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>，并重写<ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph>方法，提供的派生的类实现的分布<ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph>给基类的调用中不使用方法实现<ph id="ph4">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>方法重载如果之间的差异<ph id="ph5">&lt;paramref name="minValue" /&gt;</ph>和<ph id="ph6">&lt;paramref name="maxValue" /&gt;</ph>参数大于<ph id="ph7">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Instead, the uniform distribution returned by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">均匀分布相反，返回由基<ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>使用类。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">此行为能改善的总体性能<ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>To modify this behavior to call the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> method overload.</source>
          <target state="translated">若要修改此行为，以调用<ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph>派生类中的方法，你还必须重写<ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>An array of bytes to contain random numbers.</source>
          <target state="translated">包含随机数的字节数组。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Fills the elements of a specified array of bytes with random numbers.</source>
          <target state="translated">用随机数填充指定字节数组的元素。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <ph id="ph1">&lt;xref:System.Byte.MaxValue&gt;</ph>.</source>
          <target state="translated">字节数组的每个元素设置为随机数字大于或等于 0，并且小于或等于<ph id="ph1">&lt;xref:System.Byte.MaxValue&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">例如，若要生成适用于创建随机密码加密型安全的随机数，请使用一种方法如<ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method to fill an array of bytes with random byte values.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph>方法以用随机字节值填充的字节数组。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Random.NextBytes(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> method.</source>
          <target state="translated">从.NET Framework 2.0 版本开始，如果派生的类从<ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>，并重写<ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph>方法，提供的派生的类实现的分布<ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph>给基类的调用中不使用方法实现<ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Instead, the uniform distribution returned by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">均匀分布相反，返回由基<ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>使用类。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">此行为能改善的总体性能<ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>To modify this behavior to call the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the <ph id="ph2">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> method.</source>
          <target state="translated">若要修改此行为，以调用<ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph>派生类中的方法，你还必须重写<ph id="ph2">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Random.NextDouble">
          <source>Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.</source>
          <target state="translated">返回一个大于或等于 0.0 且小于 1.0 的随机浮点数。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Random.NextDouble">
          <source>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</source>
          <target state="translated">大于或等于 0.0 且小于 1.0 的双精度浮点数。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>The actual upper bound of the random number returned by this method is 0.99999999999999978.</source>
          <target state="translated">此方法返回的随机数字实际上限是 0.99999999999999978。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>To retrieve random floating-point values within a range other than 0.0 and 1.0, see the "Retrieve floating-point values in a specified range" section of the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class topic.</source>
          <target state="translated">若要检索以外介于 0.0 和 1.0 范围内的随机浮点值，请参阅的"检索在指定范围中的浮点值"部分<ph id="ph1">&lt;xref:System.Random&gt;</ph>类主题。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>This method is the public version of the protected method, <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph>.</source>
          <target state="translated">此方法是受保护的方法的公共版本<ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to generate sequences of random doubles.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph>方法来生成的随机双精度型值的序列。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to generate 100 random numbers and displays their frequency distribution.</source>
          <target state="translated">下面的示例调用<ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph>方法以生成随机的 100 个数字并显示其频率分发。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Random.Sample">
          <source>Returns a random floating-point number between 0.0 and 1.0.</source>
          <target state="translated">返回一个介于 0.0 和 1.0 之间的随机浮点数。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Random.Sample">
          <source>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</source>
          <target state="translated">大于或等于 0.0 且小于 1.0 的双精度浮点数。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>To produce a different random distribution or a different random number generator principle, derive a class from the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class and override the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> method.</source>
          <target state="translated">若要生成一个随机分布或不同的随机数字生成器原则，从派生类<ph id="ph1">&lt;xref:System.Random&gt;</ph>类并重写<ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method is <ph id="ph2">`protected`</ph>, which means that it is accessible only within the <ph id="ph3">&lt;xref:System.Random&gt;</ph> class and its derived classes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph>方法是<ph id="ph2">`protected`</ph>，这意味着它是只能在内部访问<ph id="ph3">&lt;xref:System.Random&gt;</ph>类和派生的类。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>To generate a random number between 0 and 1 from a <ph id="ph1">&lt;xref:System.Random&gt;</ph> instance, call the <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.</source>
          <target state="translated">若要生成介于 0 和 1 之间的随机数<ph id="ph1">&lt;xref:System.Random&gt;</ph>实例时，调用<ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The following example derives a class from <ph id="ph1">&lt;xref:System.Random&gt;</ph> and overrides the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> method to generate a distribution of random numbers.</source>
          <target state="translated">下面的示例派生了从一个类<ph id="ph1">&lt;xref:System.Random&gt;</ph>和替代<ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph>方法以生成一个分布的随机数。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>This distribution is different than the uniform distribution generated by the <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method of the base class.</source>
          <target state="translated">此分布是不同于生成的均匀分布<ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph>基本类的方法。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the following methods:</source>
          <target state="translated">从.NET Framework 2.0 版本开始，如果派生的类从<ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>，并重写<ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph>方法，提供的派生的类实现的分布<ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph>给基类的调用中不使用方法以下方法实现：</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> method, if (<ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="minValue" /&gt;</ph>) is greater than <ph id="ph5">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>方法，如果 (<ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="minValue" /&gt;</ph>) 大于<ph id="ph5">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>Instead, the uniform distribution provided by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">相反，由基类提供的统一分布<ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>使用类。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">此行为能改善的总体性能<ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>To modify this behavior to call the implementation of the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the behavior of these three members.</source>
          <target state="translated">若要修改此行为，以调用的实现<ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph>方法在派生类中，你还必须重写这些三个成员的行为。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The example provides an illustration.</source>
          <target state="translated">说明如示例所示。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>