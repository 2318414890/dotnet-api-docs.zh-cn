<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="GC.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-567ae5a" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3cf4df88-236b-4f49-aebe-6184303eadc311996d97bef6121bce982a8368bef5e8197c8a44.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">11996d97bef6121bce982a8368bef5e8197c8a44</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1465f1a9bce3970cd9e95769eaa641b92a0a22d5</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/18/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Controls the system garbage collector, a service that automatically reclaims unused memory.</source>
          <target state="translated">控制系统垃圾回收器（一种自动回收未使用内存的服务）。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</source>
          <target state="translated">垃圾回收器控制的分配和释放的托管内存的公共语言运行时组件。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</source>
          <target state="translated">此类中的方法影响在对象上并释放资源对象分配了执行垃圾回收时。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</source>
          <target state="translated">此类中的属性提供有关可用的内存总量信息在系统和年龄类别中或生成，分配给对象的内存。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector tracks and reclaims objects allocated in managed memory.</source>
          <target state="translated">垃圾回收器跟踪并回收托管内存中分配的对象。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</source>
          <target state="translated">定期，垃圾回收器执行垃圾回收回收内存分配给没有有效的引用的对象。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</source>
          <target state="translated">当无法满足内存要求，使用可用的可用内存，垃圾回收时会自动发生。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Alternatively, an application can force garbage collection using the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">或者，应用程序可以强制使用垃圾收集<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Garbage collection consists of the following steps:</source>
          <target state="translated">垃圾回收包含以下步骤：</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector searches for managed objects that are referenced in managed code.</source>
          <target state="translated">垃圾回收器搜索的托管代码中引用的托管对象。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector tries to finalize objects that are not referenced.</source>
          <target state="translated">垃圾回收器尝试完成未引用的对象。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector frees objects that are not referenced and reclaims their memory.</source>
          <target state="translated">垃圾回收器释放未引用的对象，并回收其内存。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>This topic includes the following sections:</source>
          <target state="translated">本主题包括以下部分：</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source><bpt id="p1">[</bpt>The garbage collector and unmanaged resources<ept id="p1">](#unmanaged)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>垃圾回收器和非托管的资源<ept id="p1">](#unmanaged)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source><bpt id="p1">[</bpt>Object aging and generations<ept id="p1">](#generations)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>对象老化和代<ept id="p1">](#generations)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source><bpt id="p1">[</bpt>Disallowing garbage collection<ept id="p1">](#NoGCRegion)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>不允许垃圾回收<ept id="p1">](#NoGCRegion)</ept></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector and unmanaged resources</source>
          <target state="translated">垃圾回收器和非托管的资源</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</source>
          <target state="translated">在回收中，垃圾回收器将不会释放对象如果在托管代码中找到对对象的一个或多个引用。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</source>
          <target state="translated">但是，垃圾回收器不能识别对一个对象从非托管代码的引用，并且可能会释放正在使用非托管代码中以独占方式除非明确禁止执行此操作的对象。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph>方法提供了一种机制，防止垃圾回收器收集中非托管代码仍在使用的对象。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</source>
          <target state="translated">除了托管的内存分配，垃圾回收器的实现不维护有关对象，如文件句柄或数据库连接保持的资源的信息。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</source>
          <target state="translated">当类型使用该类型的实例进行回收之前，必须释放的非托管的资源时，该类型可以实现终结器。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In most cases, finalizers are implemented by overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <ph id="ph2">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">在大多数情况下，终结器实现的重写<ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>方法; 但是，在 C# 或 c + + 编写的类型实现析构函数，哪些编译器将转换为的重写<ph id="ph2">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</source>
          <target state="translated">在大多数情况下，如果对象具有终结器中，垃圾回收器调用它之前释放该对象。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>However, the garbage collector is not required to call finalizers in all situations; for example, the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method explicitly prevents an object's finalizer from being called.</source>
          <target state="translated">但是，垃圾回收器不需要在所有情况下; 调用终结器例如，<ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>方法显式阻止调用对象的终结器。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</source>
          <target state="translated">此外，垃圾回收器不需要使用一个特定的线程来完成对象，或确保用于相互引用，而是可用于垃圾回收的对象调用终结器的顺序。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In scenarios where resources must be released at a specific time, classes can implement the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface, which contains the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> method that performs resource management and cleanup tasks.</source>
          <target state="translated">在资源必须释放在特定时间的情况下，类可以实现<ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>接口，其中包含<ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph>执行资源管理和清理任务的方法。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Classes that implement <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</source>
          <target state="translated">类实现<ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>必须指定为它们的类协定中，如果类使用者调用方法，以清理该对象。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector does not, by default, call the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method; however, implementations of the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method can call methods in the <ph id="ph3">&lt;xref:System.GC&gt;</ph> class to customize the finalization behavior of the garbage collector.</source>
          <target state="translated">垃圾回收器不会默认情况下，调用<ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>方法; 但是，实现<ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>方法可以调用方法<ph id="ph3">&lt;xref:System.GC&gt;</ph>类自定义垃圾回收器的终止行为。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>For more information on object finalization and the dispose pattern, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">对象终止和的释放模式的详细信息，请参阅<bpt id="p1">[</bpt>清洗向上非托管资源<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Object aging and generations</source>
          <target state="translated">对象老化和代</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The garbage collector in the common language runtime supports object aging using generations.</source>
          <target state="translated">公共语言运行时在垃圾回收器支持使用代的对象期限。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>A generation is a unit of measure of the relative age of objects in memory.</source>
          <target state="translated">代次是一个内存中的对象的相对时间度量单位。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The generation number, or age, of an object indicates the generation to which an object belongs.</source>
          <target state="translated">生成编号或的对象的保留时间指示属于对象的代。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</source>
          <target state="translated">创建多个对象最近是一部分较新的代，并且具有较低的生成编号不是对象创建前面的应用程序生命周期。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Objects in the most recent generation are in generation 0.</source>
          <target state="translated">在最新生成的对象是第 0 代中。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</source>
          <target state="translated">此实现的垃圾回收器支持的对象的三代、 第 0、 1 和 2。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum generation number supported by the system.</source>
          <target state="translated">你可以检索的值<ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph>属性来确定系统支持的最大代数。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</source>
          <target state="translated">对象老化允许在一组特定的代，而无需需垃圾回收器评估所有代上的应用程序迁移到目标垃圾回收。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Overloads of the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method that include a <ph id="ph2">`generation`</ph> parameter allow you to specify the oldest generation to be garbage collected.</source>
          <target state="translated">重载的<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>方法包括<ph id="ph2">`generation`</ph>参数允许你指定最后一代进行垃圾回收。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Disallowing garbage collection</source>
          <target state="translated">不允许垃圾回收</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>，垃圾回收器支持无 GC 区域延迟模式，可以在垃圾回收如何产生负面影响应用的性能的关键路径执行期间使用。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</source>
          <target state="translated">无 GC 区域延迟模式要求您指定可由垃圾回收器不受干扰分配的内存量。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</source>
          <target state="translated">如果运行时可以分配的内存，运行时将不会执行垃圾回收，在关键路径中的代码执行时。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You define the beginning of the critical path of the no GC region by calling one of the overloads of the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>.</source>
          <target state="translated">通过调用的重载之一定义的无 GC 区域的关键路径的开头<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You specify the end of its critical path by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">通过调用中指定其关键路径的末尾<ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">无法将调用传给<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>方法，并且你应只调用<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>方法如果运行时当前处于无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">换而言之，不应调用<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>多次 （在第一个方法调用后，后续调用将不会成功），并且不应需要调用<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>成功只是因为第一次调用到<ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>成功。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</source>
          <target state="translated">下面的示例使用多个 GC 方法以获取生成和有关未使用的对象的块的内存信息并将其打印到控制台。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>The unused objects are then collected, and the resulting memory totals are displayed.</source>
          <target state="translated">然后收集未使用的对象，并显示生成的内存总量。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>The incremental amount of unmanaged memory that has been allocated.</source>
          <target state="translated">已分配的非托管内存的增量。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</source>
          <target state="translated">通知运行时在安排垃圾回收时应考虑分配大量的非托管内存。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</source>
          <target state="translated">确定何时安排垃圾回收时，运行时将考虑在内分配托管的内存量。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</source>
          <target state="translated">如果一个小的托管的对象分配大量的非托管内存，运行时仅托管的内存，将考虑在内，从而低估安排垃圾回收的紧急性。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method informs the runtime of this additional pressure on system memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph>方法通知运行时在系统内存此额外的压力。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the <ph id="ph1">`Dispose`</ph> or <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">在最简单的使用情况模式中，托管的对象分配构造函数中的非托管的内存和释放在<ph id="ph1">`Dispose`</ph>或<ph id="ph2">`Finalize`</ph>方法。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method after allocating the unmanaged memory, and call the <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method after releasing it.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph>方法之后分配非托管的内存中，并调用<ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph>方法之后将其释放。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> methods to communicate these incremental changes to the runtime.</source>
          <target state="translated">在更复杂的情况下，其中的非托管的内存分配非常大的变化的托管对象的生存期内，可以调用<ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph>方法进行通信的运行时对这些增量更改。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>You must ensure that you remove exactly the amount of pressure you add.</source>
          <target state="translated">你必须确保删除完全您添加的压力量。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</source>
          <target state="translated">如果不这样做可能会较长时间的时间运行的应用程序中的系统的性能产生负面影响。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is less than or equal to 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> 小于或等于 0。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>On a 32-bit computer, <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is larger than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">在 32 位的计算机上，<ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> 大于 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>for the ability to call unmanaged code when manipulating garbage-collection priority.</source>
          <target state="translated">在操作垃圾回收优先级时调用非托管的代码的功能。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.AddMemoryPressure(System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.GC.CancelFullGCNotification">
          <source>Cancels the registration of a garbage collection notification.</source>
          <target state="translated">取消注册垃圾回收通知。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This method cancels a garbage collection notification that was registered by using the <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">此方法用于取消使用已注册垃圾回收通知<ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">不需要调整阈值参数值在对后续调用之前调用此方法<ph id="ph1">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>The following example cancels a garbage collection registration.</source>
          <target state="translated">下面的示例取消垃圾回收注册。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This example is part of a larger example provided for the <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">此示例摘自更大的示例为提供<bpt id="p1">[</bpt>垃圾回收通知<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>主题。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.GC.CancelFullGCNotification">
          <source>This member is not available when concurrent garbage collection is enabled.</source>
          <target state="translated">此成员在启用并发垃圾回收时不可用。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.GC.CancelFullGCNotification">
          <source>See the <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>gcConcurrent<ph id="ph2">&amp;gt;</ph><ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)</ept> runtime setting for information about how to disable concurrent garbage collection.</source>
          <target state="translated">若要了解如何禁用并发垃圾回收，请参阅 <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>gcConcurrent<ph id="ph2">&amp;gt;</ph><ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)</ept> 运行时设置。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">直接调用方的完全信任。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">此成员不能由部分信任的代码使用。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CancelFullGCNotification">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Forces garbage collection.</source>
          <target state="translated">强制进行垃圾回收。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.GC.Collect">
          <source>Forces an immediate garbage collection of all generations.</source>
          <target state="translated">强制对所有代进行即时垃圾回收。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>Use this method to try to reclaim all memory that is inaccessible.</source>
          <target state="translated">使用此方法来尝试回收不可访问的全部内存。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>It performs a blocking garbage collection of all generations.</source>
          <target state="translated">它执行阻碍性垃圾回收对所有代。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</source>
          <target state="translated">所有对象，而不考虑多长时间已在内存中，被都视为集合;但是，不收集托管代码中引用的对象。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>Use this method to force the system to try to reclaim the maximum amount of available memory.</source>
          <target state="translated">此方法用于强制系统尝试回收最大可用内存量。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, you can compact the large object heap (LOH) by setting the <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> before calling the <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> method, as the following example illustrates.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>，您可以通过设置压缩大型对象堆 (LOH)<ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph>属性<ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>之前调用<ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph>方法，如下面的示例演示。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to perform a collection on all generations of memory.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>方法以在每一代的内存上执行回收。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect">
          <source>The code generates a number of unused objects, and then calls the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to clean them from memory.</source>
          <target state="translated">代码生成未使用的对象，一个数字，然后调用<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>方法以从内存中清除它们。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">最后一代进行垃圾回收次数。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32)">
          <source>Forces an immediate garbage collection from generation 0 through a specified generation.</source>
          <target state="translated">强制对 0 代到指定代进行即时垃圾回收。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>Use this method to try to reclaim memory that is inaccessible.</source>
          <target state="translated">使用此方法来尝试回收不可访问的内存。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</source>
          <target state="translated">但是，使用此方法不保证回收指定的代中的所有无法访问内存。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</source>
          <target state="translated">如果实现对象老化时，垃圾回收器不会回收对象生成编号大于指定的代。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</source>
          <target state="translated">如果未实现对象老化，垃圾回收器将在垃圾回收期间考虑的所有对象。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum valid value of the <ph id="ph2">`generation`</ph> parameter.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph>属性来确定的最大有效值<ph id="ph2">`generation`</ph>参数。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</source>
          <target state="translated">要考虑所有对象，而不管其代垃圾回收器，请使用此方法不采用参数的版本。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>To have the garbage collector reclaim objects based on a <ph id="ph1">&lt;xref:System.GCCollectionMode&gt;</ph> setting, use the <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">具有垃圾回收器回收对象基于<ph id="ph1">&lt;xref:System.GCCollectionMode&gt;</ph>设置，请使用<ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to perform a collection on individual layers of memory.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>方法以执行回收的内存的各个层上。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32)">
          <source>The code generates a number of unused objects, and then calls the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to clean them from memory.</source>
          <target state="translated">代码生成未使用的对象，一个数字，然后调用<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>方法以从内存中清除它们。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">最后一代进行垃圾回收次数。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>An enumeration value that specifies whether the garbage collection is forced (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) or optimized (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</source>
          <target state="translated">一个枚举值，指定垃圾回收是强制进行（<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> 或 <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>）还是优化 (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> value.</source>
          <target state="translated">强制在 <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> 值所指定的时间对 0 代到指定代进行垃圾回收。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Use the <ph id="ph1">`mode`</ph> parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</source>
          <target state="translated">使用<ph id="ph1">`mode`</ph>参数来指定是否垃圾回收应该立即进行还是仅时间是否最佳若要回收对象。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</source>
          <target state="translated">使用此方法不保证回收指定的代中的所有无法访问内存。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>To adjust the intrusiveness of garbage collection during critical periods in your application, set the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LatencyMode%2A&gt;</ph> property.</source>
          <target state="translated">若要调整你的应用程序中重要期间垃圾回收的侵入性，设置<ph id="ph1">&lt;xref:System.Runtime.GCSettings.LatencyMode%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>The garbage collector does not collect objects with a generation number higher than specified by the <ph id="ph1">`generation`</ph> parameter.</source>
          <target state="translated">垃圾回收器不会回收对象超过指定的更高版本生成编号<ph id="ph1">`generation`</ph>参数。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>Use the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum valid value of <ph id="ph2">`generation`</ph>.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph>属性来确定的最大有效值<ph id="ph2">`generation`</ph>。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</source>
          <target state="translated">要考虑所有对象，而不管其代垃圾回收器，请使用此方法不采用参数的版本。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>To have the garbage collector reclaim objects up to a specified generation of objects, use the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">若要让垃圾回收器回收到指定的代中的对象的对象，请使用<ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>When you specify the maximum generation, all objects are collected.</source>
          <target state="translated">指定最大代数，将收集所有对象。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>The following example forces a garbage collection for generation 2 objects with the <ph id="ph1">&lt;xref:System.GCCollectionMode.Optimized&gt;</ph> setting.</source>
          <target state="translated">下面的示例强制的第 2 代对象进行垃圾回收<ph id="ph1">&lt;xref:System.GCCollectionMode.Optimized&gt;</ph>设置。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">最后一代进行垃圾回收次数。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>An enumeration value that specifies whether the garbage collection is forced (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) or optimized (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</source>
          <target state="translated">一个枚举值，指定垃圾回收是强制进行（<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> 或 <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>）还是优化 (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a blocking garbage collection; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a background garbage collection where possible.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 执行阻碍性垃圾回收；<ph id="ph2">&lt;see langword="false" /&gt;</ph> 在可能的情况下执行后台垃圾回收。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> value, with a value specifying whether the collection should be blocking.</source>
          <target state="translated">在由 <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> 值指定的时间，强制对 0 代到指定代进行垃圾回收，另有数值指定回收是否应该为阻碍性。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The following table summarizes the interaction of the <ph id="ph1">`mode`</ph> and <ph id="ph2">`blocking`</ph> parameters:</source>
          <target state="translated">下表总结了<ph id="ph1">`mode`</ph>和<ph id="ph2">`blocking`</ph>参数：</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">`blocking`</ph> is <ph id="ph2">`true`</ph></source>
          <target state="translated"><ph id="ph1">`blocking`</ph> 为 <ph id="ph2">`true`</ph></target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">`blocking`</ph> is <ph id="ph2">`false`</ph></source>
          <target state="translated"><ph id="ph1">`blocking`</ph> 为 <ph id="ph2">`false`</ph></target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.GCCollectionMode.Forced&gt;</ph> or <ph id="ph2">&lt;xref:System.GCCollectionMode.Default&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GCCollectionMode.Forced&gt;</ph> 或 <ph id="ph2">&lt;xref:System.GCCollectionMode.Default&gt;</ph></target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A blocking collection is performed as soon as possible.</source>
          <target state="translated">尽快执行阻塞回收。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is in progress and <ph id="ph1">`generation`</ph> is 0 or 1, the <ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method immediately triggers a blocking collection and returns when the collection is finished.</source>
          <target state="translated">如果后台回收正在进行和<ph id="ph1">`generation`</ph>为 0 或 1，<ph id="ph2">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph>方法立即触发阻碍性回收，并在回收完成时返回。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is in progress and <ph id="ph1">`generation`</ph> is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</source>
          <target state="translated">如果后台回收正在进行和<ph id="ph1">`generation`</ph>为 2，方法等待后台回收完成，触发阻止第 2 代回收，然后返回。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A collection is performed as soon as possible.</source>
          <target state="translated">尽快执行回收。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> 方法请求执行后台回收，但这并没有保证；阻止式回收仍可执行，具体视环境而定。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is already in progress, the method returns immediately.</source>
          <target state="translated">如果后台回收正在进行，该方法将立即返回。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A blocking collection may be performed, depending on the state of the garbage collector and the <ph id="ph1">`generation`</ph> parameter.</source>
          <target state="translated">可能会执行阻止式回收，具体视垃圾回收器的状态和 <ph id="ph1">`generation`</ph> 参数而定。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The garbage collector tries to provide optimal performance.</source>
          <target state="translated">垃圾回收器会尽量提供最佳性能。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>A collection may be performed, depending on the state of the garbage collector.</source>
          <target state="translated">根据垃圾回收器的状态，有时可执行回收。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> 方法请求执行后台回收，但这并没有保证；阻止式回收仍可执行，具体视环境而定。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>The garbage collector tries to provide optimal performance.</source>
          <target state="translated">垃圾回收器会尽量提供最佳性能。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a background collection is already in progress, the method returns immediately.</source>
          <target state="translated">如果后台回收正在进行，该方法将立即返回。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>If a call to the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> before calling the <ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph>方法执行完整的阻碍性垃圾回收时，你还可以通过设置压缩大型对象堆<ph id="ph2">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph>属性<ph id="ph3">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>之前调用<ph id="ph4">&lt;xref:System.GC.Collect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>The number of the oldest generation to be garbage collected.</source>
          <target state="translated">最后一代进行垃圾回收次数。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>An enumeration value that specifies whether the garbage collection is forced (<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>) or optimized (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>).</source>
          <target state="translated">一个枚举值，指定垃圾回收是强制进行（<ph id="ph1">&lt;see cref="F:System.GCCollectionMode.Default" /&gt;</ph> 或 <ph id="ph2">&lt;see cref="F:System.GCCollectionMode.Forced" /&gt;</ph>）还是优化 (<ph id="ph3">&lt;see cref="F:System.GCCollectionMode.Optimized" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a blocking garbage collection; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a background garbage collection where possible.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 执行阻碍性垃圾回收；<ph id="ph2">&lt;see langword="false" /&gt;</ph> 在可能的情况下执行后台垃圾回收。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to compact the small object heap; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to sweep only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示压缩小对象堆；<ph id="ph2">&lt;see langword="false" /&gt;</ph> 表示仅进行清理。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> value, with values that specify whether the collection should be blocking and compacting.</source>
          <target state="translated">在由 <ph id="ph1">&lt;see cref="T:System.GCCollectionMode" /&gt;</ph> 值指定的时间，强制对 0 代到指定代进行垃圾回收，另有数值指定回收应该为阻碍性还是压缩性。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`blocking`</ph> is <ph id="ph2">`false`</ph>, the GC decides whether to perform a background or a blocking garbage collection.</source>
          <target state="translated">如果<ph id="ph1">`blocking`</ph>是<ph id="ph2">`false`</ph>，GC 决定是否执行后台或阻碍性垃圾回收。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`compacting`</ph> is <ph id="ph2">`true`</ph>, it performs a blocking garbage collection.</source>
          <target state="translated">如果<ph id="ph1">`compacting`</ph>是<ph id="ph2">`true`</ph>，它执行阻碍性垃圾回收。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`compacting`</ph> is <ph id="ph2">`true`</ph>, the runtime compacts the small object heap (SOH).</source>
          <target state="translated">如果<ph id="ph1">`compacting`</ph>是<ph id="ph2">`true`</ph>，运行时压缩小对象堆 (SOH)。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>The large object heap (LOH) is not compacted unless the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property is set to <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">除非不会压缩大型对象堆 (LOH)<ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph>属性设置为<ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Note that this includes all blocking garbage collections, not just full blocking garbage collections.</source>
          <target state="translated">请注意，这包括所有阻止垃圾回收，不只是完全阻止垃圾回收。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>You can call the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</source>
          <target state="translated">你可以调用<ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>方法来减少托管的堆大小可能的最小，如下面的代码段所示。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Specifying <ph id="ph1">`true`</ph> for the <ph id="ph2">`compacting`</ph> argument guarantees a compacting, full blocking garbage collection.</source>
          <target state="translated">指定<ph id="ph1">`true`</ph>为<ph id="ph2">`compacting`</ph>自变量可保证压缩、 完整的阻碍性垃圾回收。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)">
          <source>Setting the <ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph> ensures that both the LOH and SOH are compacted.</source>
          <target state="translated">设置<ph id="ph1">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType&gt;</ph>属性<ph id="ph2">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType&gt;</ph>可确保压缩的 LOH 和 SOH。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>The generation of objects for which the garbage collection count is to be determined.</source>
          <target state="translated">对象的代，将针对此代确定垃圾回收计数。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>Returns the number of times garbage collection has occurred for the specified generation of objects.</source>
          <target state="translated">返回已经对对象的指定代进行的垃圾回收次数。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>The number of times garbage collection has occurred for the specified generation since the process was started.</source>
          <target state="translated">自启动进程以来已经对指定代进行的垃圾回收次数。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>If you implement your own resource management, you might need to force garbage collection periodically by calling the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">如果你实现您自己的资源管理，你可能需要通过调用定期强制垃圾回收<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</source>
          <target state="translated">由于这是代价高昂的操作，你可以通过跳过该调用，最近发生垃圾回收时提高性能。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>Save the value returned by <ph id="ph1">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> immediately after calling <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>.</source>
          <target state="translated">保存返回的值<ph id="ph1">&lt;xref:System.GC.CollectionCount%2A&gt;</ph>后立即调用<ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>The next time you need to call <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>, compare the current value returned by <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> to the saved value.</source>
          <target state="translated">下次你需要调用<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>，比较返回的当前值<ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph>为保存的值。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.CollectionCount(System.Int32)">
          <source>If the two values are equal, no collection has occurred in the interim and it is reasonable to call <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> again.</source>
          <target state="translated">如果两个值相等，没有任何集合出现在此期间，它是合乎情理调用<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>试。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.GC.CollectionCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="generation" /&gt;</ph> 小于 0。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>Ends the no GC region latency mode.</source>
          <target state="translated">结束无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> if the garbage collector is not in no GC region latency mode.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>方法抛出异常<ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph>如果垃圾回收器不处于无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>This occurs under any of the following conditions:</source>
          <target state="translated">在任何以下情况下发生这种情况：</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method was not called previously.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>以前未调用方法。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The call to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method returned <ph id="ph2">`false`</ph>.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>方法返回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>The call to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method threw an exception.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>方法引发了异常。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.EndNoGCRegion">
          <source>You can prevent an exception for any of these reasons by using code such as the following:</source>
          <target state="translated">你可以通过使用类似以下的代码来防止任一这些原因的异常：</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>The garbage collector is not in no GC region latency mode.</source>
          <target state="translated">垃圾回收器不处于无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>The no GC region latency mode was ended previously because a garbage collection was induced.</source>
          <target state="translated">无 GC 区域延迟模式已结束，可能是因为已引发垃圾回收。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.GC.EndNoGCRegion">
          <source>A memory allocation exceeded the amount specified in the call to the <ph id="ph1">&lt;see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /&gt;</ph> method.</source>
          <target state="translated">内存分配超过了 <ph id="ph1">&lt;see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /&gt;</ph> 方法调用中指定的量。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Returns the current generation number of an object.</source>
          <target state="translated">返回对象的当前代数。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The object that generation information is retrieved for.</source>
          <target state="translated">检索其代信息的对象。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.Object)">
          <source>Returns the current generation number of the specified object.</source>
          <target state="translated">返回指定对象的当前代数。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The current generation number of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 的当前代数。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>Use this method to determine the age of an object, and then use that information with the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method to force the garbage collector to collect objects in the same generation.</source>
          <target state="translated">使用此方法来确定的一个对象，对象的保留时间，然后使用该信息与<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>方法，以强制垃圾回收器收集对象在相同的生成过程中。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</source>
          <target state="translated">当你有一组对象，将创建作为一个组，且在同一时间变为不可访问，例如，使用此方法。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> method to determine the age of an object.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph>方法来确定对象的保留时间。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.Object)">
          <source>The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</source>
          <target state="translated">此示例将执行垃圾回收来清理内存和比较预发布集合在控制台中的内存总量。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>A <ph id="ph1">&lt;see cref="T:System.WeakReference" /&gt;</ph> that refers to the target object whose generation number is to be determined.</source>
          <target state="translated">引用要确定其代数的目标对象的 <ph id="ph1">&lt;see cref="T:System.WeakReference" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>Returns the current generation number of the target of a specified weak reference.</source>
          <target state="translated">返回指定弱引用的目标的当前代数。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>The current generation number of the target of <ph id="ph1">&lt;paramref name="wo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="wo" /&gt;</ph> 的目标的当前代数。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph> method to determine the age of a weak reference object.</source>
          <target state="translated">下面的示例演示了利用<ph id="ph1">&lt;xref:System.GC.GetGeneration%2A&gt;</ph>方法来确定的弱引用对象的保留时间。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.GC.GetGeneration(System.WeakReference)">
          <source>Garbage collection has already been performed on <ph id="ph1">&lt;paramref name="wo" /&gt;</ph>.</source>
          <target state="translated">已经对 <ph id="ph1">&lt;paramref name="wo" /&gt;</ph> 执行了垃圾回收。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此方法可以在返回之前等待垃圾回收发生，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>Retrieves the number of bytes currently thought to be allocated.</source>
          <target state="translated">检索当前认为要分配的字节数。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</source>
          <target state="translated">一个参数，指示此方法是否可以等待较短间隔再返回，以便系统回收垃圾和终结对象。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>A number that is the best available approximation of the number of bytes currently allocated in managed memory.</source>
          <target state="translated">一个数字，它是托管内存中当前所分配字节数的可用的最佳近似值。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>If the <ph id="ph1">`forceFullCollection`</ph> parameter is <ph id="ph2">`true`</ph>, this method waits a short interval before returning while the system collects garbage and finalizes objects.</source>
          <target state="translated">如果<ph id="ph1">`forceFullCollection`</ph>参数是<ph id="ph2">`true`</ph>，此方法将时系统回收垃圾和终结对象在返回之前等待较短间隔。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</source>
          <target state="translated">间隔持续时间为内部指定的限制由已完成的垃圾回收的数量和恢复周期之间的内存量的更改。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>The garbage collector does not guarantee that all inaccessible memory is collected.</source>
          <target state="translated">收集所有不可访问的内存时，垃圾回收器不能保证。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.GetTotalMemory(System.Boolean)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph> method to get and display the number of bytes currently allocated in managed memory.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph>方法以获取并显示当前分配在托管内存中的字节数。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The object to reference.</source>
          <target state="translated">要引用的对象。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.GC.KeepAlive(System.Object)">
          <source>References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</source>
          <target state="translated">引用指定对象，使其从当前例程开始到调用此方法的那一刻为止均不符合进行垃圾回收的条件。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The purpose of the <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</source>
          <target state="translated">用途<ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph>方法是确保会遇到正在过早地垃圾回收器回收对象的引用是否存在。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.</source>
          <target state="translated">一个常见的方案，可能发生这种情况是当在托管的代码或数据，没有对对象的引用，但仍在使用的对象处于非托管代码如 Win32 Api，非托管 Dll，或者使用 COM 的方法</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>This method references the <ph id="ph1">`obj`</ph> parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</source>
          <target state="translated">此方法引用<ph id="ph1">`obj`</ph>参数，从而使该对象再次进行垃圾回收从例程开始到点，按执行顺序调用此方法。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>Code this method at the end, not the beginning, of the range of instructions where <ph id="ph1">`obj`</ph> must be available.</source>
          <target state="translated">在结束时，不范围的开始处，说明进行操作，此方法的代码其中<ph id="ph1">`obj`</ph>必须可用。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.KeepAlive%2A&gt;</ph>方法不执行任何操作并不生成扩展中作为参数传递的对象的生存期以外的任何副作用。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The following code example creates an object at the beginning of its <ph id="ph1">`Main`</ph> method and does not refer to the object again until the end, when the <ph id="ph2">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method is called.</source>
          <target state="translated">下面的代码示例的开始处创建一个其<ph id="ph1">`Main`</ph>方法并不是指该对象再次之前结束时，当<ph id="ph2">&lt;xref:System.GC.KeepAlive%2A&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.KeepAlive(System.Object)">
          <source>The object persists for the 30-second duration of the <ph id="ph1">`Main`</ph> method, despite calls to the <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> methods.</source>
          <target state="translated">对象仍然存在持续时间 30 秒的<ph id="ph1">`Main`</ph>方法，即使调用<ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>和<ph id="ph3">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="P:System.GC.MaxGeneration">
          <source>Gets the maximum number of generations that the system currently supports.</source>
          <target state="translated">获取系统当前支持的最大代数。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>A value that ranges from zero to the maximum number of supported generations.</source>
          <target state="translated">从零到所支持的最大代数间的一个值。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</source>
          <target state="translated">生成编号或年龄，对象是对象的生命周期的实现定义的相对度量。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property.</source>
          <target state="translated">最新创建的对象是第 0 代中，最旧的对象是小于或等于生成返回级别<ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</source>
          <target state="translated">垃圾回收器假定较新的内存是更有可能适合于较旧的内存比垃圾回收。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property value can grow over time.</source>
          <target state="translated">因此，垃圾回收器可以提高其性能通过调整它回收内存，每次的世代号和<ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph>属性值可以随时间增长。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>If object aging is implemented, the <ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property returns the maximum generation number used by the system; otherwise, this property returns zero.</source>
          <target state="translated">如果实现对象老化，<ph id="ph1">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph>属性返回系统使用的最大代数; 否则，此属性返回零。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.</source>
          <target state="translated">下面的示例演示如何 MaxGeneration 属性用于在使用中当前显示的最大代数。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>For this implementation, the value returned by the <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> property is guaranteed to remain constant for the lifetime of an executing application.</source>
          <target state="translated">对于此实现，返回的值<ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph>属性一定正在执行的应用程序的生存期内保持不变。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.GC.MaxGeneration">
          <source>Use the <ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph> property to determine the maximum value you can specify when calling the <ph id="ph2">&lt;see cref="M:System.GC.Collect(System.Int32)" /&gt;</ph> method that takes a generation parameter.</source>
          <target state="translated">使用<ph id="ph1">&lt;see cref="P:System.GC.MaxGeneration" /&gt;</ph>属性来确定在调用时可以指定的最大值<ph id="ph2">&lt;see cref="M:System.GC.Collect(System.Int32)" /&gt;</ph>采用生成参数的方法。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</source>
          <target state="translated">一个介于 1 和 99 之间的数字，指定根据在第 2 代中分配的对象，应何时引发通知。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</source>
          <target state="translated">一个介于 1 和 99 之间的数字，指定根据大对象堆中分配的对象，应何时引发通知。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</source>
          <target state="translated">指定当条件支持完整垃圾回收以及回收完成时，应引发垃圾回收通知。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For each generation, the garbage collector sets a threshold for allocations into that generation.</source>
          <target state="translated">为每一代垃圾回收器设置到该代的分配阈值。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</source>
          <target state="translated">分配的大小超过此阈值，将该代上触发垃圾回收。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For example, if generation 2’s threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</source>
          <target state="translated">有关示例中，如果生成 2 的阈值为 20 MB （这意味着 20 MB 存在第 1 代集合和提升到第 2 代），超过 20 MB 后仍存在第 1 代和提示到第 2 代，将尝试下一个垃圾回收作为第 2 代回收。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</source>
          <target state="translated">同样，如果大型对象堆 (LOH) 的阈值为 20 MB 和你的应用程序已经分配了多个 20 MB 的大型对象下, 一次垃圾回收将还尝试为第 2 代回收 （因为 gen2 垃圾回收中，才会收集 LOH）。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`maxGenerationThreshold`</ph> and <ph id="ph2">`largeObjectHeapThreshold`</ph> thresholds control how much in advance you are notified before a full garbage collection occurs.</source>
          <target state="translated"><ph id="ph1">`maxGenerationThreshold`</ph>和<ph id="ph2">`largeObjectHeapThreshold`</ph>阈值控制你多少提前通知完整的垃圾回收发生前。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</source>
          <target state="translated">阈值越大，之间通知和下一次完整的垃圾回收可能发生的多个分配。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph> method) when conditions are still favorable.</source>
          <target state="translated">如果必须由公共语言运行库的完整垃圾回收会对你的应用程序性能产生负面影响的情况下，你可以要求时运行时即将会进行完整的垃圾回收和绕过该集合由通知自行引发集合 (使用<ph id="ph1">&lt;xref:System.GC.Collect%2A&gt;</ph>方法) 仍有利条件时。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</source>
          <target state="translated">除了更改自己的垃圾收集计划，完整 GC 通知适合以下方案中：</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</source>
          <target state="translated">有关完整的垃圾回收的方法监视，并当系统通知你该正在接近，减小实时数据的大小 （例如，通过释放某些缓存条目）。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>As a result, when the garbage collection occurs, it is able to reclaim more memory.</source>
          <target state="translated">因此，当垃圾回收发生时，它就可以以回收更多内存。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>You monitor for the completion of a full garbage collection so that you can collect some statistics.</source>
          <target state="translated">你的监视器的完整垃圾回收完成，以便你可以收集一些统计信息。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</source>
          <target state="translated">例如，你可能想要度量在 GC 完成堆的大小，以便你了解实时数据的大小。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>(After a full GC, the heap is at its smallest size.)</source>
          <target state="translated">（完整 GC，堆后在其最小大小。）</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>For more information about what represents a full garbage collection, see <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>.</source>
          <target state="translated">有关什么表示完整的垃圾回收的详细信息，请参阅<bpt id="p1">[</bpt>垃圾回收通知<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</source>
          <target state="translated">当你注册垃圾回收通知时，通知您可以接近完整垃圾回收时，完成后。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This pattern resembles how the operating system monitors for low memory notifications.</source>
          <target state="translated">此模式类似于操作系统如何监视低内存通知。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>Use the following guidelines for specifying the <ph id="ph1">`maxGenerationThreshold`</ph> and <ph id="ph2">`largeObjectHeapThreshold`</ph> parameters:</source>
          <target state="translated">使用以下准则来指定<ph id="ph1">`maxGenerationThreshold`</ph>和<ph id="ph2">`largeObjectHeapThreshold`</ph>参数：</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</source>
          <target state="translated">阈值值越大，更多的分配将发生之间的通知和完整垃圾回收。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</source>
          <target state="translated">更大的阈值值提供更多运行时便会检查接近集合的机会。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This increases the likelihood that you will be notified.</source>
          <target state="translated">这会增加将通知您的可能性。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</source>
          <target state="translated">但是，因为那样会导致多个分配运行时引发的下次回收之前，不应设置过高的阈值。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</source>
          <target state="translated">当你自己引发回收收到通知使用较高阈值的值后时，不是运行时的下一次回收将回收进行回收更少的对象。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</source>
          <target state="translated">越小阈值、 通知和完整垃圾回收之间的更少分配。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</source>
          <target state="translated">下面的示例演示如何注册垃圾回收通知并启动的线程来监视垃圾回收通知的状态。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<bpt id="p1">[</bpt>垃圾回收通知<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>主题。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxGenerationThreshold" /&gt;</ph> or <ph id="ph2">&lt;paramref name="largeObjectHeapThreshold" /&gt;</ph> is not between 1 and 99.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxGenerationThreshold" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="largeObjectHeapThreshold" /&gt;</ph> 不在 1 和 99 之间。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">直接调用方的完全信任。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">此成员不能由部分信任的代码使用。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>The amount of unmanaged memory that has been released.</source>
          <target state="translated">已释放的非托管内存量。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</source>
          <target state="translated">通知运行时已释放非托管内存，在安排垃圾回收时不需要再考虑它。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</source>
          <target state="translated">确定何时安排垃圾回收时，运行时将考虑在内分配托管的内存量。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</source>
          <target state="translated">如果一个小的托管的对象分配大量的非托管内存，运行时仅托管的内存，将考虑在内，从而低估安排垃圾回收的紧急性。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method informs the runtime of this additional pressure on system memory, and the <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method informs the runtime that the additional pressure has been released.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph>方法通知运行时在系统内存，此额外的压力和<ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph>方法将通知运行时已释放额外的压力。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the <ph id="ph1">`Dispose`</ph> or <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">在最简单的使用情况模式中，托管的对象分配构造函数中的非托管的内存和释放在<ph id="ph1">`Dispose`</ph>或<ph id="ph2">`Finalize`</ph>方法。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method after allocating the unmanaged memory, and call the <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method after releasing it.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph>方法之后分配非托管的内存中，并调用<ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph>方法之后将其释放。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> methods to communicate these incremental changes to the runtime.</source>
          <target state="translated">在更复杂的情况下，其中的非托管的内存分配非常大的变化的托管对象的生存期内，可以调用<ph id="ph1">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph>方法进行通信的运行时对这些增量更改。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>You must ensure that you remove exactly the amount of pressure you add.</source>
          <target state="translated">你必须确保删除完全您添加的压力量。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</source>
          <target state="translated">如果不这样做可能会较长时间的时间运行的应用程序中的系统的性能产生负面影响。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is less than or equal to 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> 小于或等于 0。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>On a 32-bit computer, <ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> is larger than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">在 32 位的计算机上，<ph id="ph1">&lt;paramref name="bytesAllocated" /&gt;</ph> 大于 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>for the ability to call unmanaged code when manipulating garbage-collection priority.</source>
          <target state="translated">在操作垃圾回收优先级时调用非托管的代码的功能。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.RemoveMemoryPressure(System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The object that a finalizer must be called for.</source>
          <target state="translated">必须为其调用终结器的对象。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>Requests that the system call the finalizer for the specified object for which <ph id="ph1">&lt;see cref="M:System.GC.SuppressFinalize(System.Object)" /&gt;</ph> has previously been called.</source>
          <target state="translated">请求系统调用指定对象的终结器，此前已为该对象调用 <ph id="ph1">&lt;see cref="M:System.GC.SuppressFinalize(System.Object)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> method adds the <ph id="ph2">`obj`</ph> parameter to the list of objects that request finalization before the garbage collector frees the object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph>方法将添加<ph id="ph2">`obj`</ph>参数的垃圾回收器释放对象前会请求终止的对象的列表。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The <ph id="ph1">`obj`</ph> parameter must be the caller of this method.</source>
          <target state="translated"><ph id="ph1">`obj`</ph>参数必须是此方法的调用方。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> method does not guarantee that the garbage collector will call an object's finalizer.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph>方法并不保证垃圾回收器将调用对象的终结器。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method.</source>
          <target state="translated">默认情况下，实现终结器的所有对象都添加到需要终止; 的对象的列表但是，对象可能已终止，或者可能已通过调用禁用终止<ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>A finalizer can use this method to resurrect itself or an object that it references.</source>
          <target state="translated">终结器可以使用此方法使重新起用自己或它所引用的对象。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source>The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.</source>
          <target state="translated">下面的示例演示如何使用 ReRegisterForFinalize 方法以完成第二个对象垃圾回收后的时间。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.GC.ReRegisterForFinalize(System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>The object whose finalizer must not be executed.</source>
          <target state="translated">不得执行其终结器的对象。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>Requests that the common language runtime not call the finalizer for the specified object.</source>
          <target state="translated">请求公共语言运行时不要调用指定对象的终结器。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>This method sets a bit in the object header of <ph id="ph1">`obj`</ph>, which the runtime checks when calling finalizers.</source>
          <target state="translated">此方法的对象标头中该位设置设置<ph id="ph1">`obj`</ph>，在调用终结器时将运行时检查。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>A finalizer, which is represented by the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method, is used to release unmanaged resources before an object is garbage-collected.</source>
          <target state="translated">终结器中，表示<ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>方法，用于在一个对象进行垃圾回收之前，释放非托管的资源。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>If <ph id="ph1">`obj`</ph> does not have a finalizer, the call to the <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method has no effect.</source>
          <target state="translated">如果<ph id="ph1">`obj`</ph>没有终结器中，调用<ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>方法不起作用。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>Objects that implement the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface can call this method from the object's <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation to prevent the garbage collector from calling <ph id="ph3">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> on an object that does not require it.</source>
          <target state="translated">对象实现<ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>接口可以从对象的调用此方法<ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph>实现以防止垃圾回收器调用<ph id="ph3">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>对不需要它的对象。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">通常情况下，这样做是为了防止终结器释放非托管的资源，已释放了<ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph>实现。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method in a resource class to prevent a redundant garbage collection from being called.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>在资源类，以防止从调用冗余垃圾回收中的方法。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source>The example uses the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> to free both managed resources (that is, objects that implement <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>) and unmanaged resources.</source>
          <target state="translated">该示例使用<bpt id="p1">[</bpt>释放模式<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>同时释放托管资源 (即对象实现<ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>) 和非托管资源。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.GC.SuppressFinalize(System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Attempts to disallow garbage collection during the execution of a critical path.</source>
          <target state="translated">在关键路径执行期间尝试禁止垃圾回收。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">无法将调用传给<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>方法，并且你应只调用<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>方法如果运行时当前处于无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.GC">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">换而言之，不应调用<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>多次 （在第一个方法调用后，后续调用将不会成功），并且不应需要调用<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>成功只是因为第一次调用到<ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>成功。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>It must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated">它必须小于或等于临时段的大小。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">有关暂时段大小的信息，请参阅<bpt id="p1">[</bpt>垃圾回收基础知识<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>一文中“暂时代和暂时段”一节。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</source>
          <target state="translated">如果指定数量的内存可用，则在关键路径执行期间尝试禁止垃圾回收。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%29&gt;</ph>方法尝试将垃圾回收器放在应用程序执行代码的关键区域的同时，不允许垃圾回收无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</source>
          <target state="translated">如果无法最初分配请求的内存量运行时，垃圾回收器尝试释放更多的内存中执行完整的阻碍性垃圾回收。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * <ph id="ph1">`totalSize`</ph> bytes (it attempts to allocate <ph id="ph2">`totalSize`</ph> bytes for the small object heap and <ph id="ph3">`totalSize`</ph> bytes for the large object heap).</source>
          <target state="translated">垃圾回收器进入无 GC 区域延迟模式，如果无法分配所需的数量的内存，在这种情况下为实际 2 *<ph id="ph1">`totalSize`</ph>字节 (它将尝试分配<ph id="ph2">`totalSize`</ph>小对象堆的字节数和<ph id="ph3">`totalSize`</ph>大型对象堆的字节数)。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source><ph id="ph1">`totalSize`</ph> must be large enough to handle all memory allocations that occur in the critical path.</source>
          <target state="translated"><ph id="ph1">`totalSize`</ph> 必须足够大，以处理在关键路径中发生的所有内存分配。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">这包括分配的应用程序中，以及运行时使应用程序的代表的分配。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">无法将调用传给<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>方法，并且你应只调用<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>方法如果运行时当前处于无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">换而言之，不应调用<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>多次 （在第一个方法调用后，后续调用将不会成功），并且不应需要调用<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>成功只是因为第一次调用到<ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>成功。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">通过调用退出无 GC 区域延迟模式<ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> 超出了暂时段大小。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">进程已进入无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>It must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated">它必须小于或等于临时段的大小。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">有关暂时段大小的信息，请参阅<bpt id="p1">[</bpt>垃圾回收基础知识<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>一文中“暂时代和暂时段”一节。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> bytes; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示如果垃圾回收器最初无法分配 <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> 字节，则忽略完整的阻碍性垃圾回收；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</source>
          <target state="translated">如果指定数量的内存可用，则在关键路径执行期间尝试禁止垃圾回收；并在初始没有足够内存可用的情况下，控制垃圾回收器是否进行完整的阻碍性垃圾回收。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29&gt;</ph>方法尝试将垃圾回收器放在应用程序执行代码的关键区域的同时，不允许垃圾回收无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>If the runtime is unable to initially allocate the requested amount of memory and the <ph id="ph1">`disallowFullBlockingGC`</ph> argument is <ph id="ph2">`false`</ph>, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">如果运行时无法最初分配请求的内存量和<ph id="ph1">`disallowFullBlockingGC`</ph>自变量是<ph id="ph2">`false`</ph>、 垃圾回收器尝试释放更多的内存中执行完整的阻碍性垃圾回收; 否则为分配失败，并且该方法返回<ph id="ph3">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * <ph id="ph1">`totalSize`</ph> (it attempts to allocate <ph id="ph2">`totalSize`</ph> for the small object heap and <ph id="ph3">`totalSize`</ph> for the large object heap).</source>
          <target state="translated">垃圾回收器进入无 GC 区域延迟模式，如果无法分配所需的数量的内存，在这种情况下为实际 2 * <ph id="ph1">`totalSize`</ph> (它将尝试分配<ph id="ph2">`totalSize`</ph>针对小型对象堆和<ph id="ph3">`totalSize`</ph>为大型对象堆)。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">`totalSize`</ph> must be large enough to handle all memory allocations that occur in the critical path.</source>
          <target state="translated"><ph id="ph1">`totalSize`</ph> 必须足够大，以处理在关键路径中发生的所有内存分配。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">这包括分配的应用程序中，以及运行时使应用程序的代表的分配。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>Setting <ph id="ph1">`disallowFullBlockingGC`</ph> to <ph id="ph2">`true`</ph> to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns <ph id="ph3">`true`</ph>, and have the load balancer redirect requests to other systems if it returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">设置<ph id="ph1">`disallowFullBlockingGC`</ph>到<ph id="ph2">`true`</ph>以防止完整的阻碍性垃圾回收集合最初可用没有足够的内存是否是在负载平衡方案中最有用： 一个系统可以调用此方法，并报告本身为准备好接受请求，如果它返回<ph id="ph3">`true`</ph>，并且具有负载平衡器将请求重定向到其他系统，如果它返回<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>It can then do a full blocking garbage collection when it's not handling requests by calling the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">它可以进行完整的阻碍性垃圾回收时不处理请求通过调用<ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">无法将调用传给<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>方法，并且你应只调用<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>方法如果运行时当前处于无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">换而言之，不应调用<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>多次 （在第一个方法调用后，后续调用将不会成功），并且不应需要调用<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>成功只是因为第一次调用到<ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>成功。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">通过调用退出无 GC 区域延迟模式<ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> 超出了暂时段大小。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">进程已进入无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> –<bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> –<bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> 必须小于或等于暂时段的大小。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">有关暂时段大小的信息，请参阅<bpt id="p1">[</bpt>垃圾回收基础知识<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>一文中“暂时代和暂时段”一节。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The number of bytes in <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> to use for large object heap (LOH) allocations.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> 中用于大对象堆 (LOH) 分配的字节数。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</source>
          <target state="translated">如果指定数量的内存可用于大对象堆和小对象堆，则在关键路径执行期间尝试禁止垃圾回收。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29&gt;</ph>方法尝试将垃圾回收器放在应用程序执行代码的关键区域的同时，不允许垃圾回收无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</source>
          <target state="translated">如果无法最初分配请求的内存量运行时，垃圾回收器尝试释放更多的内存中执行完整的阻碍性垃圾回收。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate <ph id="ph1">`lohSize`</ph> for the LOH and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> for the small object heap (SOH).</source>
          <target state="translated">垃圾回收器进入无 GC 区域延迟模式，如果能够分配<ph id="ph1">`lohSize`</ph>为 LOH 和<ph id="ph2">`totalSize`</ph>–<ph id="ph3">`lohSize`</ph>针对小型对象堆 (SOH)。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><ph id="ph1">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the LOH, and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the SOH.</source>
          <target state="translated"><ph id="ph1">`lohSize`</ph> 必须具有足够大小以处理有关 LOH，发生在关键路径中的所有内存分配和<ph id="ph2">`totalSize`</ph>–<ph id="ph3">`lohSize`</ph>必须足够大，无法都处理的 SOH 发生在关键路径中的所有内存分配。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">这包括分配的应用程序中，以及运行时使应用程序的代表的分配。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">无法将调用传给<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>方法，并且你应只调用<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>方法如果运行时当前处于无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">换而言之，不应调用<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>多次 （在第一个方法调用后，后续调用将不会成功），并且不应需要调用<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>成功只是因为第一次调用到<ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>成功。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">通过调用退出无 GC 区域延迟模式<ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> 超出了暂时段大小。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">进程已进入无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The amount of memory in bytes to allocate without triggering a garbage collection.</source>
          <target state="translated">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> –<bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> must be less than or equal to the size of an ephemeral segment.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> –<bpt id="p2">&lt;c&gt;</bpt>lohSize<ept id="p2">&lt;/c&gt;</ept> 必须小于或等于暂时段的大小。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the <bpt id="p1">[</bpt>Fundamentals of Garbage Collection<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.</source>
          <target state="translated">有关暂时段大小的信息，请参阅<bpt id="p1">[</bpt>垃圾回收基础知识<ept id="p1">](~/docs/standard/garbage-collection/fundamentals.md)</ept>一文中“暂时代和暂时段”一节。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The number of bytes in <bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> to use for large object heap (LOH) allocations.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>totalSize<ept id="p1">&lt;/c&gt;</ept> 中用于大对象堆 (LOH) 分配的字节数。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示如果垃圾回收器初始无法分配小对象堆 (SOH) 和 LOH 上的指定内存，则忽略完整的阻碍性垃圾回收；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</source>
          <target state="translated">如果指定数量的内存可用大对象堆和小对象堆，则在关键路径执行期间尝试禁止垃圾回收；并在初始没有足够内存可用的情况下，控制垃圾回收器是否进行完整的阻碍性垃圾回收。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29&gt;</ph>方法尝试将垃圾回收器放在应用程序执行代码的关键区域的同时，不允许垃圾回收无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>If the runtime is unable to initially allocate the requested amount of memory and the <ph id="ph1">`disallowFullBlockingGC`</ph> argument is <ph id="ph2">`false`</ph>, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">如果运行时无法最初分配请求的内存量和<ph id="ph1">`disallowFullBlockingGC`</ph>自变量是<ph id="ph2">`false`</ph>、 垃圾回收器尝试释放更多的内存中执行完整的阻碍性垃圾回收; 否则为分配失败，并且该方法返回<ph id="ph3">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The garbage collector enters no GC region latency mode if it is able to allocate <ph id="ph1">`lohSize`</ph> for the LOH and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> for the small object heap (SOH).</source>
          <target state="translated">垃圾回收器进入无 GC 区域延迟模式，如果能够分配<ph id="ph1">`lohSize`</ph>为 LOH 和<ph id="ph2">`totalSize`</ph>–<ph id="ph3">`lohSize`</ph>针对小型对象堆 (SOH)。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the LOH, and <ph id="ph2">`totalSize`</ph> – <ph id="ph3">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the SOH.</source>
          <target state="translated"><ph id="ph1">`lohSize`</ph> 必须具有足够大小以处理有关 LOH，发生在关键路径中的所有内存分配和<ph id="ph2">`totalSize`</ph>–<ph id="ph3">`lohSize`</ph>必须足够大，无法都处理的 SOH 发生在关键路径中的所有内存分配。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</source>
          <target state="translated">这包括分配的应用程序中，以及运行时使应用程序的代表的分配。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>Setting <ph id="ph1">`disallowFullBlockingGC`</ph> to <ph id="ph2">`true`</ph> to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns <ph id="ph3">`true`</ph>, and have the load balancer redirect requests to other systems if it returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">设置<ph id="ph1">`disallowFullBlockingGC`</ph>到<ph id="ph2">`true`</ph>以防止完整的阻碍性垃圾回收集合最初可用没有足够的内存是否是在负载平衡方案中最有用： 一个系统可以调用此方法，并报告本身为准备好接受请求，如果它返回<ph id="ph3">`true`</ph>，并且具有负载平衡器将请求重定向到其他系统，如果它返回<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>It can then do a full blocking garbage collection when it's not handling requests by calling the <ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">它可以进行完整的阻碍性垃圾回收时不处理请求通过调用<ph id="ph1">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>You cannot nest calls to the <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.</source>
          <target state="translated">无法将调用传给<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>方法，并且你应只调用<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>方法如果运行时当前处于无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>In other words, you should not call <ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.</source>
          <target state="translated">换而言之，不应调用<ph id="ph1">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>多次 （在第一个方法调用后，后续调用将不会成功），并且不应需要调用<ph id="ph2">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>成功只是因为第一次调用到<ph id="ph3">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>成功。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>You exit the no GC region latency mode by calling the <ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.</source>
          <target state="translated">通过调用退出无 GC 区域延迟模式<ph id="ph1">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> exceeds the ephemeral segment size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="totalSize" /&gt;</ph> – <ph id="ph2">&lt;paramref name="lohSize" /&gt;</ph> 超出了暂时段大小。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)">
          <source>The process is already in no GC region latency mode.</source>
          <target state="translated">进程已进入无 GC 区域延迟模式。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</source>
          <target state="translated">返回已注册通知的状态，用于确定公共语言运行时是否即将引发完整、阻碍性垃圾回收。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</source>
          <target state="translated">返回已注册通知的状态，用于确定公共语言运行时是否即将引发完整、阻碍性垃圾回收。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">已注册垃圾回收通知的状态。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph>返回此方法以确定当前已由使用注册的垃圾回收通知的状态的枚举<ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to determine whether the full garbage collection has completed.</source>
          <target state="translated">你还可以使用<ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph>方法来确定完整的垃圾回收是否已完成。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">当在枚举返回<ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>，你可以执行任务，例如阻止分配和使用自行引发回收其他对象<ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</source>
          <target state="translated">请注意通知不保证完整的垃圾回收会发生，仅保证条件已达到阈值，支持完整垃圾回收发生。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This method waits indefinitely for a garbage collection notification to be obtained.</source>
          <target state="translated">无限期地等待垃圾回收通知要从中获取此方法。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">如果你想要指定要返回如果无法获得通知的方法的超时期限，使用<ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>If you call this method without specifying a time-out, you can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method if you are waiting longer than preferred.</source>
          <target state="translated">如果不指定超时情况下调用此方法，则可以调用<ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph>如果你在等待时间超过首选的方法。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>You should follow this method with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">你应遵循通过调用此方法<ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph>方法以确保已进行过完整的垃圾回收。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Calling this method alone causes indeterminate results.</source>
          <target state="translated">单独调用此方法会导致不确定结果。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</source>
          <target state="translated">下面的示例演示如何使用此方法来确定是否正在接近的完整、 阻碍性垃圾回收。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>Whenever the status of the notification is <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, the user method <ph id="ph2">`OnFullGCApproachNotify`</ph> is called to perform actions in response to the approaching collection.</source>
          <target state="translated">每当通知的状态是<ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>，用户方法<ph id="ph2">`OnFullGCApproachNotify`</ph>调用以执行操作以响应接近的集合。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This code example is part of a larger example provided for <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<bpt id="p1">[</bpt>垃圾回收通知<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>主题。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">直接调用方的完全信任。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">此成员不能由部分信任的代码使用。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>The length of time to wait before a notification status can be obtained.</source>
          <target state="translated">在获取通知状态前等待的时间长度。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Specify -1 to wait indefinitely.</source>
          <target state="translated">指定 -1 表示无限期等待。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</source>
          <target state="translated">在指定的超时期限内，返回已注册通知的状态，用于确定公共语言运行时是否即将引发完整、阻碍性垃圾回收。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">已注册垃圾回收通知的状态。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph>返回此方法以确定当前已由使用注册的垃圾回收通知的状态的枚举<ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to determine whether the full garbage collection has completed.</source>
          <target state="translated">你还可以使用<ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph>方法来确定完整的垃圾回收是否已完成。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by <ph id="ph1">`millisecondsTimeout`</ph>.</source>
          <target state="translated">请注意，此方法返回立即每当获取垃圾回收通知状态，而不考虑指定的值<ph id="ph1">`millisecondsTimeout`</ph>。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>If a garbage collection notification status is not obtained before <ph id="ph1">`millisecondsTimeout`</ph> times out, this method returns <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.</source>
          <target state="translated">如果垃圾回收通知状态前未获取<ph id="ph1">`millisecondsTimeout`</ph>时间 out，此方法返回<ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph> method.</source>
          <target state="translated">当在枚举返回<ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>，你可以执行任务，例如阻止分配和使用自行引发回收其他对象<ph id="ph2">&lt;xref:System.GC.Collect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</source>
          <target state="translated">请注意通知不保证完整的垃圾回收会发生，仅保证条件已达到阈值，支持完整垃圾回收发生。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>You can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method when you cannot wait for the time-out period to elapse.</source>
          <target state="translated">你可以调用<ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph>方法时不能等待超时周期结束。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>You should follow this method with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">你应遵循通过调用此方法<ph id="ph1">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph>方法以确保已进行过完整的垃圾回收。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>Calling this method alone causes indeterminate results.</source>
          <target state="translated">单独调用此方法会导致不确定结果。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> must be either non-negative or less than or equal to <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> or -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> 必须为非负数或小于或等于 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> 或 -1。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">直接调用方的完全信任。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">此成员不能由部分信任的代码使用。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCApproach(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="T:System.GC">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</source>
          <target state="translated">返回已注册通知的状态，用于确定公共语言运行时引发的完整、阻碍性垃圾回收是否已完成。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete">
          <source>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</source>
          <target state="translated">返回已注册通知的状态，用于确定公共语言运行时引发的完整、阻碍性垃圾回收是否已完成。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">已注册垃圾回收通知的状态。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph>返回此方法以确定当前已由使用注册的垃圾回收通知的状态的枚举<ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to determine whether a full garbage collection is imminent.</source>
          <target state="translated">你还可以使用<ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph>方法来确定是否即将引发完整的垃圾回收。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as resuming work and obtaining a collection count with the <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> property.</source>
          <target state="translated">当在枚举返回<ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>，你可以执行任务，例如继续处理并获取集合计数与<ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This method waits indefinitely for a garbage collection notification to be obtained.</source>
          <target state="translated">无限期地等待垃圾回收通知要从中获取此方法。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">如果你想要指定要返回如果无法获得通知的方法的超时期限，使用<ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>If you call this method without specifying a time-out, you can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method if you are waiting longer than preferred.</source>
          <target state="translated">如果不指定超时情况下调用此方法，则可以调用<ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph>如果你在等待时间超过首选的方法。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This method call should be preceded with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">此方法调用之前应该通过调用<ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph>方法以确保已进行过完整的垃圾回收。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>Calling this method alone can produce indeterminate results.</source>
          <target state="translated">单独调用此方法可能产生不确定结果。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>The following example shows how to use this method to determine whether a full garbage collection has completed.</source>
          <target state="translated">下面的示例演示如何使用此方法来确定完整的垃圾回收是否已完成。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>Whenever the status of the notification is <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, the user method <ph id="ph2">`OnFullGCCompletedNotify`</ph> is called to perform actions in response to the completed collection.</source>
          <target state="translated">每当通知的状态是<ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>，用户方法<ph id="ph2">`OnFullGCCompletedNotify`</ph>调用以执行操作以响应已完成的集合。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This code example is part of a larger example provided for <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept> topic.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<bpt id="p1">[</bpt>垃圾回收通知<ept id="p1">](~/docs/standard/garbage-collection/notifications.md)</ept>主题。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">直接调用方的完全信任。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">此成员不能由部分信任的代码使用。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>The length of time to wait before a notification status can be obtained.</source>
          <target state="translated">在获取通知状态前等待的时间长度。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Specify -1 to wait indefinitely.</source>
          <target state="translated">指定 -1 表示无限期等待。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</source>
          <target state="translated">在指定的超时期限内，返回已注册通知的状态，用于确定公共语言运行时引发的完整、阻碍性垃圾回收是否已完成。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>The status of the registered garbage collection notification.</source>
          <target state="translated">已注册垃圾回收通知的状态。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.GCNotificationStatus&gt;</ph>返回此方法以确定当前已由使用注册的垃圾回收通知的状态的枚举<ph id="ph2">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to determine whether a full garbage collection is imminent.</source>
          <target state="translated">你还可以使用<ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph>方法来确定是否即将引发完整的垃圾回收。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by <ph id="ph1">`millisecondsTimeout`</ph>.</source>
          <target state="translated">请注意，此方法返回立即每当获取垃圾回收通知状态，而不考虑指定的值<ph id="ph1">`millisecondsTimeout`</ph>。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>If a garbage collection notification status is not obtained before <ph id="ph1">`millisecondsTimeout`</ph> times out, this method returns <ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.</source>
          <target state="translated">如果垃圾回收通知状态前未获取<ph id="ph1">`millisecondsTimeout`</ph>时间 out，此方法返回<ph id="ph2">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>When the enumeration returns <ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as resuming work and obtaining a collection count with the <ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> property.</source>
          <target state="translated">当在枚举返回<ph id="ph1">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>，你可以执行任务，例如继续处理并获取集合计数与<ph id="ph2">&lt;xref:System.GC.CollectionCount%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>You can call the <ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method when you cannot wait for the time-out period to elapse.</source>
          <target state="translated">你可以调用<ph id="ph1">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph>方法时不能等待超时周期结束。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>This method call should be preceded with a call to the <ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to make sure that you have had a full garbage collection.</source>
          <target state="translated">此方法调用之前应该通过调用<ph id="ph1">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph>方法以确保已进行过完整的垃圾回收。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>Calling this method alone can produce indeterminate results.</source>
          <target state="translated">单独调用此方法可能产生不确定结果。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> must be either non-negative or less than or equal to <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> or -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> 必须为非负数或小于或等于 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> 或 -1。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>for full trust for the immediate caller.</source>
          <target state="translated">直接调用方的完全信任。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>This member cannot be used by partially trusted code.</source>
          <target state="translated">此成员不能由部分信任的代码使用。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForFullGCComplete(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.GC.WaitForPendingFinalizers">
          <source>Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</source>
          <target state="translated">挂起当前线程，直到处理终结器队列的线程清空该队列为止。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</source>
          <target state="translated">当垃圾回收器发现可以回收的对象时，它会检查以确定对象的终止要求每个对象。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>If an object implements a finalizer and has not disabled finalization by calling <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>, the object is placed in a list of objects that are marked as ready for finalization.</source>
          <target state="translated">如果对象实现终结器，并通过调用未禁用终止<ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>，该对象被放置在标记为准备好进行终结的对象的列表。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>The garbage collector calls the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> methods for the objects in this list and removes the entries from the list.</source>
          <target state="translated">垃圾回收器调用<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>此列表和中移除这些项从列表中的对象的方法。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>This method blocks until all finalizers have run to completion.</source>
          <target state="translated">此方法阻止，直到所有的终结器已完成运行。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</source>
          <target state="translated">对其运行的终结器线程未指定，因此不能保证此方法将终止。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>However, this thread can be interrupted by another thread while the <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> method is in progress.</source>
          <target state="translated">但是，可以由其他线程时中断此线程<ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph>方法正在进行。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</source>
          <target state="translated">例如，你可以等待一段时间内，如果此线程仍然挂起则中断此线程的另一个线程。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.GC.WaitForPendingFinalizers">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> method to suspend the current thread until finalization of all the collected objects is complete.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph>方法挂起当前线程，直到终止所有收集的对象的已完成。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>