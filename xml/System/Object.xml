<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0499b9ab8b5160fa80acdb83902087541206252e" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36429207" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>支持 .NET Framework 类层次结构中的所有类，并为派生类提供低级别服务。 这是 .NET Framework 中所有类的最终基类；它是类型层次结构的根。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 语言通常不需要类来声明从继承<xref:System.Object>因为继承是隐式。  
  
 因为.NET Framework 中的所有类都派生自<xref:System.Object>中, 定义的每个方法<xref:System.Object>类是可用于所有对象系统中。 派生类可以和重写其中的某些方法，包括：  
  
-   <xref:System.Object.Equals%2A> -支持对象之间的比较。  
  
-   <xref:System.Object.Finalize%2A> -在对象被自动回收之前，请执行清理操作。  
  
-   <xref:System.Object.GetHashCode%2A> -生成与对象的值对应一个数字，以支持使用哈希表。  
  
-   <xref:System.Object.ToString%2A> — 生成描述类的实例的用户可读文本字符串。  
  
## <a name="performance-considerations"></a>性能注意事项  
 如果您正在设计的类，如的集合，必须在处理任何类型的对象，你可以创建接受的实例的类成员<xref:System.Object>类。 但是，装箱和取消装箱类型的过程会带来的性能开销。 如果你知道新类将经常处理某些值类型可以使用两个策略之一装箱的成本降到最低。  
  
-   创建接受的常规方法<xref:System.Object>类型，以及接受希望你的类以经常处理每个值类型的特定类型的方法重载的一组。 如果特定类型的方法存在，以接受调用的参数类型，没有值类型装箱发生，并且会调用特定类型的方法。 如果没有任何与调用的参数类型匹配的方法自变量，该参数进行装箱，并调用常规方法。  
  
-   设计你的类型和其成员来使用泛型。 在创建您的类的实例和指定泛型类型参数时，公共语言运行时创建封闭式泛型类型。 泛型方法是特定类型和可以调用而无需装箱调用的参数。  
  
 尽管，有时需要开发通用类，接受并返回<xref:System.Object>类型，通过提供特定类型的类来处理常用的类型上，你可以提高性能。 例如，提供特定于设置和获取布尔值的类消除了装箱和取消装箱的布尔值的成本。  
  
   
  
## Examples  
 下面的示例定义一个派生自类型<xref:System.Object>类并重写的虚方法的多种<xref:System.Object>类。 此外，该示例演示如何调用许多静态和实例方法的<xref:System.Object>类。  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>公共静态 (<see langword="Shared" />在 Visual Basic 中) 的此类型的成员都是线程安全。 不保证实例成员都是线程安全。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Object" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在派生类中，构造函数将调用此构造函数，但它还可以用于直接创建的实例<xref:System.Object>类。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定两个对象实例是否相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与当前对象进行比较的对象。</param>
        <summary>确定指定的对象是否等于当前对象。</summary>
        <returns>如果指定的对象等于当前对象，则为 <see langword="true" />，否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前实例进行比较的类型和`obj`参数取决于当前实例是否为引用类型或值类型。  
  
-   如果当前实例是引用类型，<xref:System.Object.Equals%28System.Object%29>方法测试引用相等性，并调用<xref:System.Object.Equals%28System.Object%29>方法等效于调用<xref:System.Object.ReferenceEquals%2A>方法。 引用相等性意味着进行比较的对象变量引用同一个对象。 下面的示例阐释了这种比较的结果。 它定义`Person`类，该类是引用类型，并调用`Person`类构造函数来实例化两个新`Person`对象，`person1a`和`person2`，其中具有相同的值。 它还会将分配`person1a`给另一个对象变量， `person1b`。 如示例所示，输出`person1a`和`person1b`由于它们都引用同一个对象是否相等。 但是，`person1a`和`person2`是否不相等，尽管它们具有相同的值。  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   如果当前实例是值类型，<xref:System.Object.Equals%28System.Object%29>方法测试值是否相等。 值相等性意味着：  
  
    -   两个对象均为相同的类型。 如下面的示例所示，<xref:System.Byte>的值为 12 的对象不等于<xref:System.Int32>具有其值为 12，因为两个对象具有不同的运行时类型的对象。  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   两个对象的公共和私有字段的值相等。 下面的示例测试的值相等。 它定义`Person`结构，这是值类型，并调用`Person`类构造函数来实例化两个新`Person`对象，`person1`和`person2`，其中具有相同的值。 如示例输出所示，虽然两个对象变量引用不同的对象，但`person1`和`person2`是否相等的因为它们具有相同的值为私有`personName`字段。  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 因为<xref:System.Object>类是.NET Framework 中的所有类型的基类<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法提供对于所有其他类型的默认相等比较。 但是，类型通常替代<xref:System.Object.Equals%2A>方法来实现值是否相等。 有关详细信息，请参阅说明调用方和说明的继承者节。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>说明 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 当调用<xref:System.Object.Equals%28System.Object%29>中的类上的方法重载[!INCLUDE[wrt](~/includes/wrt-md.md)]，它不会覆盖的类提供的默认行为<xref:System.Object.Equals%28System.Object%29>。 这是.NET Framework 提供的支持的一部分[!INCLUDE[wrt](~/includes/wrt-md.md)](请参阅[.NET Framework 支持为 Windows 应用商店应用和 Windows 运行时](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。 中的类[!INCLUDE[wrt](~/includes/wrt-md.md)]不继承<xref:System.Object>，并且不要实施<xref:System.Object.Equals%28System.Object%29>方法。 但是，它们会显示为具有<xref:System.Object.ToString%2A>， <xref:System.Object.Equals%28System.Object%29>，和<xref:System.Object.GetHashCode%2A>方法在 C# 或 Visual Basic 代码中，使用它们以及.NET Framework 为这些方法提供的默认行为时。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] 用 C# 或 Visual Basic 编写的类可以重写<xref:System.Object.Equals%28System.Object%29>方法重载。  
  
## <a name="notes-for-callers"></a>调用方的说明  
 经常重写派生的类<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法来实现值是否相等。 此外，类型也经常提供到另一个强类型的重载`Equals`方法，通常通过实现<xref:System.IEquatable%601>接口。 当调用`Equals`方法来测试相等性，你应知道的当前实例是否替代<xref:System.Object.Equals%2A?displayProperty=nameWithType>并了解如何对特定调用`Equals`方法处于已解决状态。 否则为你可能不同于你预期的相等性执行测试，并且该方法可能返回了意外的值。  
  
 下面的示例进行了这方面的演示。 它实例化三个<xref:System.Text.StringBuilder>使用相同的字符串对象，然后在将四个调用`Equals`方法。 第一种方法调用返回`true`，和剩余的三个返回`false`。  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 在第一个的情况下，强类型化<xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType>调用方法重载，它的值是否相等，测试。 因为字符串分配给两个<xref:System.Text.StringBuilder>对象是否相等，则该方法返回`true`。 但是，<xref:System.Text.StringBuilder>不重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>。 因此，当<xref:System.Text.StringBuilder>对象强制转换为<xref:System.Object>，当<xref:System.Text.StringBuilder>实例分配给类型的变量的<xref:System.Object>，以及何时<xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>方法传递两个<xref:System.Text.StringBuilder>的对象，默认<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>调用方法。 因为<xref:System.Text.StringBuilder>是引用类型，该属性等同于传递两个<xref:System.Text.StringBuilder>对象添加到<xref:System.Object.ReferenceEquals%2A>方法。 尽管所有三个<xref:System.Text.StringBuilder>对象包含相同的字符串，则指三个不同的对象。 因此，这些三个方法调用返回`false`。  
  
 你可以通过调用比较当前对象与另一个对象引用相等性<xref:System.Object.ReferenceEquals%2A>方法。 在 Visual Basic 中，你还可以使用`is`关键字 (例如， `If Me Is otherObject Then ...`)。  
  
## <a name="notes-for-inheritors"></a>对继承者的说明  
 当你定义你自己的类型时，该类型继承定义的功能`Equals`方法与其基类型。 下表列出的默认实现`Equals`为主要类别的.NET Framework 中的类型的方法。  
  
|类型类别|所定义的相等|注释|  
|-------------------|-------------------------|--------------|  
|直接从派生类 <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|引用相等性;等效于调用<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>。|  
|结构|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|值相等。直接逐字节比较或按字段比较使用反射。|  
|枚举|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|值必须具有相同的枚举类型和相同的基础值。|  
|委托|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|委托必须具有相同的调用列表的相同类型。|  
|接口|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|引用相等性。|  
  
 对于值类型，则应始终重写<xref:System.Object.Equals%2A>，因为测试是否相等依赖于反射提供性能不佳。 此外可以重写的默认实现<xref:System.Object.Equals%2A>对于引用类型来测试而不是引用相等性的值是否相等并定义值相等性的精确意义。 此类实现<xref:System.Object.Equals%2A>返回`true`如果两个对象具有相同的值，即使它们不是同一个实例。 该类型的实施者决定构成对象的值，但它通常是部分或全部存储的数据的对象的实例变量中。 例如，值为<xref:System.String>对象所基于的字符字符串;<xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType>方法重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法以返回`true`任何两个字符串包含相同的顺序中的相同字符的实例。  
  
 下面的示例演示如何重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法来测试的值是否相等。 它将重写<xref:System.Object.Equals%2A>方法`Person`类。 如果`Person`接受相等性，其基类实现两个`Person`对象将引用单个对象，它们才相等。 但是，在这种情况下，两个`Person`对象是否相等，如果它们具有相同的值`Person.Id`属性。  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 除了重写<xref:System.Object.Equals%2A>，你可以实现<xref:System.IEquatable%601>接口，以提供强类型化的测试相等性。  
  
 以下语句必须为 true 的所有实现<xref:System.Object.Equals%28System.Object%29>方法。 在列表中， `x`， `y`，和`z`表示不是对象引用**null**。  
  
-   `x.Equals(x)` 返回`true`，涉及浮点类型的情况除外。 请参阅 ISO/IEC/IEEE 60559:2011，信息技术-微处理器系统-浮点运算。  
  
-   `x.Equals(y)` 返回值与相同`y.Equals(x)`。  
  
-   `x.Equals(y)` 返回`true`如果这两个`x`和`y`是`NaN`。  
  
-   如果`(x.Equals(y) && y.Equals(z))`返回`true`，然后`x.Equals(z)`返回`true`。  
  
-   对连续调用`x.Equals(y)`返回相同的值，只要引用对象`x`和`y`不会修改。  
  
-   `x.Equals(null)` 返回 `false`。  
  
 实现<xref:System.Object.Equals%2A>必须不引发异常; 它们应始终会返回值。 例如，如果`obj`是`null`、<xref:System.Object.Equals%2A>方法应返回`false`而不是引发<xref:System.ArgumentNullException>。  
  
 重写时，请遵循以下准则<xref:System.Object.Equals%28System.Object%29>:  
  
-   类型实现<xref:System.IComparable>必须重写<xref:System.Object.Equals%28System.Object%29>。  
  
-   类型重写<xref:System.Object.Equals%28System.Object%29>还必须重写<xref:System.Object.GetHashCode%2A>; 否则为哈希表可能无法正常工作。  
  
-   你应该考虑实施<xref:System.IEquatable%601>接口以支持强类型化测试是否相等。 你<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>实现应返回与相一致的结果<xref:System.Object.Equals%2A>。  
  
-   如果您的编程语言支持运算符重载，并且重载相等运算符对于给定的类型，还必须重写<xref:System.Object.Equals%28System.Object%29>方法以返回与相等运算符相同的结果。 这有助于确保使用的类库代码<xref:System.Object.Equals%2A>(如<xref:System.Collections.ArrayList>和<xref:System.Collections.Hashtable>) 中运作的方式与应用程序代码使用相等运算符的方法一致。  
  
### <a name="guidelines-for-reference-types"></a>对于引用类型的准则  
 以下准则适用于重写<xref:System.Object.Equals%28System.Object%29>对于引用类型：  
  
-   请考虑重写<xref:System.Object.Equals%2A>的类型语义是否基于这一事实的类型表示某些值。  
  
-   大多数引用类型必须不能重载相等运算符，即使它们将覆盖<xref:System.Object.Equals%2A>。 但是，如果你要实现引用类型，用于具有值语义，如复杂的数字类型，你必须重写相等运算符。  
  
-   不应覆盖<xref:System.Object.Equals%2A>上可变的引用类型。 这是因为在重写<xref:System.Object.Equals%2A>需要，还可以覆盖<xref:System.Object.GetHashCode%2A>方法上, 一节中所述。 这意味着，可变的引用类型的实例的哈希代码可以更改在其生存期内，这可能导致哈希表中的对象会丢失。  
  
### <a name="guidelines-for-value-types"></a>值类型的原则  
 以下准则适用于重写<xref:System.Object.Equals%28System.Object%29>对于值类型：  
  
-   如果你正在定义包括一个或多个字段的值类型其值是引用类型，则应重写<xref:System.Object.Equals%28System.Object%29>。 <xref:System.Object.Equals%28System.Object%29>由提供实现<xref:System.ValueType>执行逐字节比较的值类型字段是所有的值类型，但它使用反射来执行其字段包括引用类型的值类型的字段的比较。  
  
-   如果你重写<xref:System.Object.Equals%2A>和你的开发语言支持运算符重载，因此您必须重载相等运算符。  
  
-   应实现<xref:System.IEquatable%601>接口。 调用的强类型化<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>方法可避免装箱`obj`自变量。  
  
   
  
## Examples  
 下面的示例演示`Point`类，并重写<xref:System.Object.Equals%2A>方法以提供值是否相等和`Point3D`派生自的类`Point`。 因为`Point`重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>来测试值相等性<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>不调用方法。 但是，`Point3D.Equals`调用`Point.Equals`因为`Point`实现<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>提供值是否相等的方式。  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 `Point.Equals`方法进行检查以确保`obj`参数不是**null** ，并且它引用与此对象相同的类型的实例。 如果任一检查失败，该方法返回`false`。  
  
 `Point.Equals`方法调用<xref:System.Object.GetType%2A>方法来确定两个对象的运行时类型是否相同。 如果该方法使用的检查的窗体`obj is Point`在 C# 或`TryCast(obj, Point)`在 Visual Basic 中，检查将返回`true`在情况下其中`obj`是派生的类的实例`Point`，即使`obj`和当前实例并不属于相同的运行时类型。 验证这两个对象是否相同类型，方法强制转换`obj`类型`Point`并返回结果的比较两个对象的实例字段。  
  
 在`Point3D.Equals`，继承`Point.Equals`方法，这将覆盖<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>，任何其他操作完成之前调用。 因为`Point3D`是一个密封的类 (`NotInheritable`在 Visual Basic 中)，在窗体中的检查`obj is Point`在 C# 或`TryCast(obj, Point)`在 Visual Basic 中是足够用于确保`obj`是`Point3D`对象。 如果它是`Point3D`对象，它被强制转换为`Point`对象并传递到基类实现<xref:System.Object.Equals%2A>。 仅当继承`Point.Equals`方法返回`true`没有方法比较`z`实例在派生类中引入的字段。  
  
 下面的示例定义`Rectangle`内部实现作为两个矩形类`Point`对象。 `Rectangle`类还将重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>提供的值是否相等。  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 某些语言中的如 C# 和 Visual Basic 支持运算符重载。 当某个类型重载相等运算符时，它还必须重写<xref:System.Object.Equals%28System.Object%29>方法以提供相同的功能。 这通常通过编写实现<xref:System.Object.Equals%28System.Object%29>方面重载的相等运算符，如以下示例所示的方法。  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 因为`Complex`是值类型，它不能从派生。  因此，替代<xref:System.Object.Equals%28System.Object%29>方法无需调用<xref:System.Object.GetType%2A>以确定精确的运行时类型的每个对象，但可以改为使用`is`C# 中的运算符或`TypeOf`Visual basic 中检查的类型的运算符`obj`参数。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">要比较的第一个对象。</param>
        <param name="objB">要比较的第二个对象。</param>
        <summary>确定指定的对象实例是否被视为相等。</summary>
        <returns>如果对象被视为相等，则为 <see langword="true" />，否则为 <see langword="false" />。 如果 <paramref name="objA" /> 和 <paramref name="objB" /> 均为 null，此方法返回 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 静态<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>方法指示两个对象是否，`objA`和`objB`，是否相等。 它还可用于测试的对象，其值是**null**是否相等。 它将进行比较`objA`和`objB`相等性，如下所示：  
  
-   它确定两个对象是否表示相同的对象引用。 如果他们这样做，则此方法返回`true`。 此测试等效于调用<xref:System.Object.ReferenceEquals%2A>方法。 此外，如果这两个`objA`和`objB`是**null**，该方法返回`true`。  
  
-   它确定是否是`objA`或`objB`是**null**。 如果因此，它返回`false`。  
  
-   如果两个对象不表示相同的对象引用，并且二者均**null**，它调用`objA`。`Equals`(`objB`) 并返回结果。 这意味着，如果`objA`重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，调用此重写。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Object.Equals%28System.Object%2CSystem.Object%29>方法，并将其与<xref:System.Object.ReferenceEquals%2A>方法。  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在垃圾回收将某一对象回收前允许该对象尝试释放资源并执行其他清理操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.Finalize%2A>方法用于执行之前对象被销毁当前对象持有的非托管资源的清理操作。 该方法受保护，并且因此仅通过此类或派生类可访问。  
  
 本节内容：  
  
-   [终止的工作原理](#How)  
  
-   [实施者注意事项](#Notes)  
  
-   [SafeHandle 备用方法](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>终止的工作原理  
 <xref:System.Object>类提供的实现不<xref:System.Object.Finalize%2A>方法和垃圾回收器将派生的类型不标记<xref:System.Object>终止除非它们将覆盖<xref:System.Object.Finalize%2A>方法。  
  
 如果类型未重写<xref:System.Object.Finalize%2A>方法，则垃圾回收器会将类型的每个实例的条目添加到调用终止队列中的内部结构。 终止队列中包含垃圾回收器才能回收其内存之前，必须运行其终止代码托管堆中的所有对象的条目。 然后，垃圾回收器调用<xref:System.Object.Finalize%2A>在以下情况下自动的方法：  
  
-   垃圾回收器发现，一个对象不可访问，除非您通过调用从终止豁免已对象后<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。  
  
-   在关闭应用程序域中，除非该对象是免于终止的对象。 在关闭期间，终止甚至仍是可访问的对象。  
  
 <xref:System.Object.Finalize%2A> 将自动调用一次在给定实例中，除非的对象重新注册通过使用一种机制，如<xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType>和<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>尚未随后调用方法。  
  
 <xref:System.Object.Finalize%2A> 操作具有以下限制：  
  
-   终结器执行时的确切时间不确定。 若要确保确定性释放资源，对你的类的实例实现`Close`方法，或者提供<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>实现。  
  
-   两个对象的终结器不保证任何特定顺序运行即使另一个对象引用。 也就是说，如果对象 A 具有对对象 B 的引用，并且二者的终结器，对象 B 可能已经被终结的对象 A 终结器启动时。  
  
-   终结器运行的线程未指定。  
  
 <xref:System.Object.Finalize%2A>方法可能无法运行完成，或可能根本不运行下列异常情况下：  
  
-   如果另一个终结器会无限期阻止 （进入无限循环，尝试获取的锁，它可以永远不会获取，等等）。 运行时尝试运行终结器来完成，因为其他终结器可能不会调用终结器块如果无限期。  
  
-   如果不提供机会清理的运行时，进程将终止。 在这种情况下，运行时的第一个通知的进程是终止的一个 DLL_PROCESS_DETACH 通知。  
  
 运行时将继续完成在关闭过程的对象，仅当可终结对象数目继续减少。  
  
 如果<xref:System.Object.Finalize%2A>或的重写<xref:System.Object.Finalize%2A>引发异常，并且运行时不承载的应用程序将替代默认策略，运行时终止进程，且无活动`try` / `finally`块或执行终结器。 如果终结器无法释放或销毁资源，则此行为确保处理完整性。  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>重写 Finalize 方法 
 应重写<xref:System.Object.Finalize%2A>使用非托管的资源，如文件句柄或必须在垃圾回收期间放弃使用它们的托管的对象时释放的数据库连接的类。 不应实现<xref:System.Object.Finalize%2A>方法托管对象，因为垃圾回收器自动释放托管的资源。  
  
> [!IMPORTANT]
>  如果<xref:System.Runtime.InteropServices.SafeHandle>可用对象，则包装非托管的资源，建议的替代项是实现使用安全句柄的释放模式并不会覆盖<xref:System.Object.Finalize%2A>。 有关详细信息，请参阅[SafeHandle 备用方法](#SafeHandle)部分。  
  
 <xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法不执行任何操作默认情况下，但应重写<xref:System.Object.Finalize%2A>仅当有必要，且仅释放非托管的资源。 回收内存倾向于长得多如果运行终止操作，因为它需要至少两个垃圾回收。 此外，你应该重写<xref:System.Object.Finalize%2A>仅类型引用的方法。 公共语言运行时仅完成引用类型。 它将忽略有关值类型的终结器。  

作用域<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法是`protected`。 在你的类中重写该方法时，应保持此受限制的作用域。 通过让<xref:System.Object.Finalize%2A>受保护的方法，你可以阻止从调用对象的应用程序的用户<xref:System.Object.Finalize%2A>直接的方法。
  
 每个实现<xref:System.Object.Finalize%2A>派生类型中，则必须调用其基类型实现<xref:System.Object.Finalize%2A>。 这是其中的应用程序代码可以调用仅用例<xref:System.Object.Finalize%2A>。 对象的<xref:System.Object.Finalize%2A>方法不应在其基本类之外的任何对象上调用方法。 这是因为被调用的其他对象可能在被回收在同一时间调用的对象，如公共语言运行时关闭这种情况。 
  
> [!NOTE]
>  C# 编译器不允许你重写<xref:System.Object.Finalize%2A>方法。 相反，通过实现提供了终结器[析构函数](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)为您的类。 C# 析构函数自动调用其基类的析构函数。  
>   
>  Visual c + + 还提供了其自己的语法，用于实现<xref:System.Object.Finalize%2A>方法。 有关详细信息，请参阅的"析构函数和终结器"部分[如何： 定义和使用类和结构 (C + + /cli CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)。  
  
 垃圾回收是不确定的因为你不知道确切地说时垃圾回收器执行终止。 若要释放资源立即，你还可以选择实现[释放模式](~/docs/standard/design-guidelines/dispose-pattern.md)和<xref:System.IDisposable>接口。 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>实现可由使用者在类的释放非托管的资源，并且你可以使用<xref:System.Object.Finalize%2A>方法释放非托管的资源的事件中<xref:System.IDisposable.Dispose%2A>不调用方法。  
  
 <xref:System.Object.Finalize%2A> 后它已被清除在垃圾回收期间，能够执行几乎任何操作，包括再现的对象 （即，使该对象可访问再次）。 但是，该对象还能够仅重新一次;<xref:System.Object.Finalize%2A>在垃圾回收期间不能在复活对象上调用。 一个操作，你实现<xref:System.Object.Finalize%2A>应永远不会采取： 它应永远不会引发异常。 如果从调用的方法引发的任何异常<xref:System.Object.Finalize%2A>处理方法<xref:System.Object.Finalize%2A>方法，运行时假设<xref:System.Object.Finalize%2A>方法返回，并且继续调用<xref:System.Object.Finalize%2A>其他对象的方法。 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>SafeHandle 备用方法  
 创建可靠的终结器是通常难以进行，因为无法有关你的应用程序的状态作出假设以及因为未经处理的系统异常，如<xref:System.OutOfMemoryException>和<xref:System.StackOverflowException>终止终结器。 而非实现终结器为您的类释放非托管的资源，你可以使用派生自的对象<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>类来包装非托管的资源，，然后实现而无需终结器的释放模式。 .NET Framework 提供了中的以下类<xref:Microsoft.Win32?displayProperty=nameWithType>派生自的命名空间<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> 是的文件句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> 为内存映射文件句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> 是指向非托管内存块的指针的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle><xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>，和<xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle>是加密的句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> 是管道句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> 是用于注册表项的句柄的包装类。  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 是用于的等待句柄的包装类。  
  
 下面的示例使用[释放模式](~/docs/standard/design-guidelines/dispose-pattern.md)而不是重写的安全句柄<xref:System.Object.Finalize%2A>方法。 它定义`FileAssociation`包装的应用程序处理具有特定文件扩展名的文件的注册表信息的类。 作为返回两个注册表句柄`out`参数由 Windows [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)函数调用传递到<xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>构造函数。 类型的受保护`Dispose`方法然后调用`SafeRegistryHandle.Dispose`方法释放这些两个控点。  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 下面的示例验证<xref:System.Object.Finalize%2A>对象可重写时，调用方法<xref:System.Object.Finalize%2A>被销毁。 请注意，在生产应用程序，<xref:System.Object.Finalize%2A>将重写方法，以释放由对象拥有的非托管的资源。 另请注意，C# 示例提供了析构函数而不是重写<xref:System.Object.Finalize%2A>方法。  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 有关其他示例重写<xref:System.Object.Finalize%2A>方法，请参阅<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>作为默认哈希函数。</summary>
        <returns>当前对象的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 哈希代码是一个数字值，用于插入和标识基于哈希的集合中的对象，例如<xref:System.Collections.Generic.Dictionary%602>类，<xref:System.Collections.Hashtable>类或派生自类型<xref:System.Collections.DictionaryBase>类。 <xref:System.Object.GetHashCode%2A>方法为需要的对象相等性的快速检查的算法提供此哈希代码。  
  
> [!NOTE]
>  有关如何在哈希表中使用哈希代码的信息以及一些其他的哈希代码算法，请参阅[哈希函数](https://en.wikipedia.org/wiki/Hash_function)Wikipedia 中的条目。  
  
 是相等的相等的返回哈希代码的两个对象。 但是，反过来并不成立： 相等的哈希代码并不表示对象相等性，因为不同 （不相等） 的对象可以具有相同的哈希代码。 此外，.NET Framework 并不保证的默认实现<xref:System.Object.GetHashCode%2A>方法和此方法所返回的.NET Framework 版本和平台，例如，32 位和 64 位平台之间可能不同的值。 出于这些原因，请不用作此方法的默认实现的唯一对象标识符哈希的目的。 从此请按照以下两种结果操作：  
  
-   不应假定相等的哈希代码表示对象是否相等。  
  
-   永远不应将存在，或者在其中创建它，在应用程序域使用的哈希代码，因为相同的对象可能哈希处理跨应用程序域、 过程和平台。  
  
> [!WARNING]
>  哈希代码旨在高效插入和基于哈希表的集合中查找。 哈希代码不是永久的值。 出于此原因：  
>   
>  -   不序列化哈希代码值或将它们存储在数据库中。  
> -   不使用的哈希代码作为键从是键控集合中检索对象。  
> -   不要跨应用程序域或进程发送的哈希代码。 在某些情况下，可能会基于每个进程或每个应用程序域计算哈希代码。  
> -   不要使用而不是返回的加密哈希函数，如果你需要加密型强哈希值的哈希代码。 对于加密哈希，使用派生自的类<xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType>或<xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType>类。  
> -   先不要测试相等的哈希代码，以确定两个对象是否相等。 （不相等的对象可以具有相同的哈希代码。）若要测试相等性，调用<xref:System.Object.ReferenceEquals%2A>或<xref:System.Object.Equals%2A>方法。  
  
 <xref:System.Object.GetHashCode%2A>派生类型可以重写方法。 如果<xref:System.Object.GetHashCode%2A>是不重写，哈希代码为引用类型计算通过调用<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>的基类，计算哈希代码的方法基于对象的引用; 有关详细信息，请参阅<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>。 换而言之，两个对象为其<xref:System.Object.ReferenceEquals%2A>方法返回`true`具有相同的哈希代码。 如果值类型不会重写<xref:System.Object.GetHashCode%2A>、<xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType>基本类的方法使用反射来计算基于该类型的字段的值的哈希代码。 换而言之，其字段具有相等的值的值类型具有相等的哈希代码。 有关重写<xref:System.Object.GetHashCode%2A>，请参阅"对继承者的说明"部分。  
  
> [!WARNING]
>  如果你重写<xref:System.Object.GetHashCode%2A>方法，则应重写<xref:System.Object.Equals%2A>，反之亦然。 如果你重写<xref:System.Object.Equals%2A>方法返回`true`两个对象是否相等，重写的测试时<xref:System.Object.GetHashCode%2A>方法必须返回两个对象相同的值。  
  
 如果用作哈希表中的键的对象未提供的有用实现<xref:System.Object.GetHashCode%2A>，你可以指定哈希代码提供程序通过提供<xref:System.Collections.IEqualityComparer>实现的重载之一<xref:System.Collections.Hashtable>类构造函数。  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>说明 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 当调用<xref:System.Object.GetHashCode%2A>中类方法[!INCLUDE[wrt](~/includes/wrt-md.md)]，它不会覆盖的类提供的默认行为<xref:System.Object.GetHashCode%2A>。 这是.NET Framework 提供的支持的一部分[!INCLUDE[wrt](~/includes/wrt-md.md)](请参阅[.NET Framework 支持为 Windows 应用商店应用和 Windows 运行时](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。 中的类[!INCLUDE[wrt](~/includes/wrt-md.md)]不继承<xref:System.Object>，并且不要实施<xref:System.Object.GetHashCode%2A>。 但是，它们会显示为具有<xref:System.Object.ToString%2A>， <xref:System.Object.Equals%28System.Object%29>，和<xref:System.Object.GetHashCode%2A>方法在 C# 或 Visual Basic 代码中，使用它们以及.NET Framework 为这些方法提供的默认行为时。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] 用 C# 或 Visual Basic 编写的类可以重写<xref:System.Object.GetHashCode%2A>方法。  
  
   
  
## Examples  
 计算具有相同或比范围较小的数字值的哈希代码的最简单方法之一<xref:System.Int32>类型是只需返回该值。 下面的示例演示此类的实现`Number`结构。  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 通常情况下，类型具有多个可以参与生成的哈希代码的数据字段。 生成的哈希代码的一种方法是组合使用这些字段`XOR (eXclusive OR)`操作，如下面的示例中所示。  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 前面的示例返回 (n1，n2) 的同一哈希代码和 (n2，n1)，因此，可能会生成不是所需的多个冲突。 有多种解决方案都是可用的以便在这些情况下的哈希代码不相同。 一个是要返回的哈希代码`Tuple`反映每个字段的顺序的对象。 下面的示例演示使用的可能实现<xref:System.Tuple%602>类。 但请注意，该实例化的性能开销`Tuple`对象可能会显著影响哈希表中存储大量对象的应用程序的整体性能。  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 第二个备选解决方案涉及的两个或多个位由连续的字段的哈希代码进行左移权重的单个哈希代码。 最佳状况运行，而不是被丢弃，移出第 31 位的位应环绕而不是被放弃。 由于 C# 和 Visual Basic 中的左移运算符的情况下，位将被丢弃，这就需要创建一个左的 shift 包装方法如下所示：  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 下面的示例然后使用此 shift 包装方法来计算的哈希代码`Point`前面的示例中使用结构。  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>哈希函数用于快速将生成一个对象的值相对应的数字 （哈希代码）。哈希函数通常是特定于每种类型，和的唯一性，必须使用至少一个实例字段作为输入。使用静态字段的值，不应计算哈希代码。类派生自<see cref="T:System.Object" />、<see langword="GetHashCode" />方法才可以委托给基类<see cref="M:System.Object.GetHashCode" />仅当派生的类定义的相等性可引用相等性的实现。默认实现<see cref="M:System.Object.GetHashCode" />对于引用类型返回的哈希代码，它等效于由一个<see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />方法。您可以重写<see cref="M:System.Object.GetHashCode" />对于不可变的引用类型。一般情况下，对于可变引用类型，则应重写<see cref="M:System.Object.GetHashCode" />才:-您可以计算字段不是可变; 中的哈希代码或-你可以确保可变对象的哈希代码不会更改时的对象包含在 collecti上依赖于其哈希代码。否则，你可能认为，在哈希表中丢失的可变对象。如果你选择重写<see cref="M:System.Object.GetHashCode" />对于可变的引用类型，你的文档应将其清除该对象存储在哈希表中时，你的类型的用户不应修改对象值。对于值类型，<see cref="M:System.ValueType.GetHashCode" />提供一个默认哈希代码实现，使用反射。你应考虑重写它以提高性能。<block subset="none" type="note"><para> 有关详细信息和计算各种不同的方式的哈希代码的示例，请参阅示例部分。</para></block>  哈希函数必须具有以下属性:-如果两个对象的比较结果为相等，<see cref="M:System.Object.GetHashCode" />每个对象的方法必须返回相同的值。但是，如果两个对象不相等，比较<see cref="M:System.Object.GetHashCode" />两个对象的方法不需要返回不同的值。 -<see cref="M:System.Object.GetHashCode" />对象方法必须始终返回相同哈希代码，只要没有任何修改对确定返回值方法对象 [System.Object.Equals](xref:System.Object.Equals*) 对象状态。请注意，这是仅适用当前执行应用程序，并且，如果再次运行应用程序，也可以返回不同的哈希代码。 -对于获得最佳性能，哈希函数应生成均匀分布于所有输入，包括已大量群集化的输入。含意为对对象状态的小修改应导致大型修改哈希表的最佳性能的生成哈希代码。 的哈希函数应该是成本较低，来计算。 -<see cref="M:System.Object.GetHashCode" />方法不应引发异常。例如，实现<see cref="M:System.String.GetHashCode" />方法提供的<see cref="T:System.String" />类返回相同的字符串值的相同的哈希代码。因此，两个<see cref="T:System.String" />对象返回相同的哈希代码，如果它们表示相同的字符串值。此外，该方法使用的所有字符在字符串中来生成相当随机的分布式输出，即使输入群集在某些范围内 (例如，许多用户可能具有仅包含低 128 ASCII 字符，即使的字符串字符串可以包含任何 65535 个 Unicode 字符）。在类上提供的很好的哈希函数可能会将这些对象添加到哈希表的性能显著影响。在具有键提供哈希函数的良好实现哈希表中，搜索的元素所用常量时间内的 （例如，o （1） 操作）。哈希函数的不佳实现哈希表，在搜索的性能取决于哈希表中的项的数目 (例如，O('n') 操作，其中 n 是哈希表中的项的数目)。恶意用户可以输入增加的冲突，会大大降低取决于哈希表，在以下情况下的应用程序的性能数量的数据:-当哈希函数生成频繁冲突。 -如果哈希表中的对象的大部分生成相等或在大约等于另一个的哈希代码。 -如果用户输入的数据从其计算的哈希代码。派生类重写<see cref="M:System.Object.GetHashCode" />还必须重写<see cref="M:System.Object.Equals(System.Object)" />若要确保视为相等的两个对象具有相同的哈希代码; 否则为<see cref="T:System.Collections.Hashtable" />类型可能无法正常工作。</para>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前实例的 <see cref="T:System.Type" />。</summary>
        <returns>当前实例的准确运行时类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因为<xref:System.Object?displayProperty=nameWithType>在.NET Framework 类型系统中，是所有类型的基类<xref:System.Object.GetType%2A>方法可以用于返回<xref:System.Type>表示所有.NET Framework 类型的对象。 .NET Framework 可识别类型的以下五个类别：  
  
-   类，该类派生自<xref:System.Object?displayProperty=nameWithType>，  
  
-   值类型，派生自<xref:System.ValueType?displayProperty=nameWithType>。  
  
-   接口，派生自<xref:System.Object?displayProperty=nameWithType>从.NET Framework 2.0 开始。  
  
-   枚举，派生自<xref:System.Enum?displayProperty=nameWithType>。  
  
-   委托，它派生自<xref:System.MulticastDelegate?displayProperty=nameWithType>。  
  
 两个对象`x`和`y`具有相同的运行时类型`Object.ReferenceEquals(x.GetType(),y.GetType())`返回`true`。 下面的示例使用<xref:System.Object.GetType%2A>方法替换<xref:System.Object.ReferenceEquals%2A>方法来确定一个数字值是否与其他两个数值的类型相同。  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  若要确定对象是否是特定类型，可以使用你的语言的类型比较关键字或构造。 例如，你可以使用`TypeOf…Is`在 Visual Basic 中构造或`is`C# 中的关键字。  
  
 <xref:System.Object.GetType%2A>方法由派生自的所有类型继承<xref:System.Object>。 这意味着，除了使用你自己的语言的比较关键字，你可以使用<xref:System.Object.GetType%2A>方法来确定的一种特定的对象，如以下示例所示。  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <xref:System.Type>对象公开的类的当前关联的元数据<xref:System.Object>。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Object.GetType%2A>返回当前实例的运行时类型。  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建当前 <see cref="T:System.Object" /> 的浅表副本。</summary>
        <returns>当前 <see cref="T:System.Object" /> 的浅表副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.MemberwiseClone%2A>方法创建的新对象，然后将当前对象的非静态字段复制到新的对象创建的浅表副本。 如果字段是值类型，则执行字段的按位复制。 如果字段是引用类型，引用将复制，但被引用的对象不;因此，原始对象和其克隆引用同一对象。  
  
 例如，考虑对象称为 X 引用对象 A 和 B，反过来，引用对象 c。X 的浅表副本创建新的对象 X2 也引用对象 A 和 b。与此相反，X 的深层副本创建新对象 X2 引用 A2 和 B2，是的一个副本的新对象并 B.B2，反过来，引用新对象 C2，这是 C 的副本。该示例说明浅和深层复制操作之间的差异。  
  
 有很多方法可以实现深层复制操作，如果浅表复制操作由<xref:System.Object.MemberwiseClone%2A>方法并不满足你的需求。 其中包括：  
  
-   调用类构造函数要复制可以使用来自第一个对象的属性值创建第二个对象的对象。 这假定，对象的值完全由其类构造函数中定义。  
  
-   调用<xref:System.Object.MemberwiseClone%2A>方法创建一个对象，对象的浅表副本并将其值是与原始对象的任何属性或其值是引用类型的字段相同的新对象。 `DeepCopy`方法在示例中演示了此方法。  
  
-   序列化对象是较深复制，，然后将序列化的数据还原到另一个对象变量。  
  
-   使用具有递归反射来执行深层复制操作。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Object.MemberwiseClone%2A>方法。 它定义`ShallowCopy`调用的方法<xref:System.Object.MemberwiseClone%2A>方法来执行上的浅表复制操作`Person`对象。 它还定义`DeepCopy`执行深层复制操作的方法`Person`对象。  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 在此示例中，`Person.IdInfo`属性返回`IdInfo`对象。 如示例所示，输出时`Person`通过调用克隆对象<xref:System.Object.MemberwiseClone%2A>方法时，克隆`Person`对象是原始对象，而的独立副本，只不过它们共享相同`Person.IdInfo`对象引用。 因此，修改克隆的`Person.IdInfo`属性更改原始对象的`Person.IdInfo`属性。 另一方面，执行深层副本操作时，克隆`Person`对象，包括其`Person.IdInfo`属性，可以进行修改而不会影响原始对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">要比较的第一个对象。</param>
        <param name="objB">要比较的第二个对象。</param>
        <summary>确定指定的 <see cref="T:System.Object" /> 实例是否是相同的实例。</summary>
        <returns>如果 <paramref name="objA" /> 是与 <paramref name="objB" /> 相同的实例，或两者均为 null，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.Object.Equals%2A>方法和相等运算符，<xref:System.Object.ReferenceEquals%2A>不重写方法。 因此，如果你想要测试两个对象是否相等的引用和你不确定的实现`Equals`方法时，你可以调用<xref:System.Object.ReferenceEquals%2A>方法。  
  
 但是的返回值<xref:System.Object.ReferenceEquals%2A>方法可能看起来存在异常在这些两种方案：  
  
-   比较值类型。 如果`objA`和`objB`是值类型，它们先它们传递给装箱<xref:System.Object.ReferenceEquals%2A>方法。 这意味着，如果这两个`objA`和`objB`表示值类型，同一个实例<xref:System.Object.ReferenceEquals%2A>方法尽管如此返回`false`，如下面的示例所示。  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     装箱值类型的信息，请参阅[装箱和取消装箱](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)。  
  
-   当比较字符串。 如果`objA`和`objB`都是字符串，<xref:System.Object.ReferenceEquals%2A>方法返回`true`如果字符串暂留。 它不执行测试的值相等。  在下面的示例中，`s1`和`s2`因为它们是单个暂存字符串的两个实例是否相等。 但是，`s3`和`s4`是否不相等，因为尽管它们都具有相同的字符串值，但该字符串不暂留。  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     有关字符串暂留的详细信息，请参阅<xref:System.String.IsInterned%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Object.ReferenceEquals%2A>以确定两个对象是否相同的实例。  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前对象的字符串。</summary>
        <returns>表示当前对象的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 主要格式设置.NET Framework 中的方法。 以便它适合于显示，它将对象转换为其字符串表示形式。 (有关格式设置支持.NET Framework 中的信息，请参阅[格式化类型](~/docs/standard/base-types/formatting-types.md)。)默认实现<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法返回的对象类型的完全限定的名称。  
  
> [!IMPORTANT]
>  你可能已达到了此页从成员列表中的另一种类型，按照以下链接。 这是因为该类型不会覆盖<xref:System.Object.ToString%2A?displayProperty=nameWithType>。 相反，它继承的功能<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法。  
  
 经常重写类型<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以提供更适合的字符串表示形式的特定类型。 类型也经常重载<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以提供支持的格式字符串或区分区域性的格式。  
  
 本节内容：  
  
 [默认 Object.ToString() 方法](#Default)   
 [重写 Object.ToString() 方法](#Overriding)   
 [重载 ToString 方法](#Overloading)   
 [扩展 Object.ToString 方法](#Extending)   
 [Windows 运行时的注意事项](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>默认 Object.ToString() 方法  
 默认实现<xref:System.Object.ToString%2A>方法返回的类型的完全限定的名称<xref:System.Object>，如下面的示例所示。  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 因为<xref:System.Object>是所有引用类型的基类在.NET Framework 中，此行为由引用类型继承不会重写<xref:System.Object.ToString%2A>方法。 下面的示例阐释了这一点。 它定义一个名为`Object1`接受所有的默认实现<xref:System.Object>成员。 其<xref:System.Object.ToString%2A>方法返回的对象的完全限定的类型名称。  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>重写 Object.ToString() 方法  
 类型通常覆盖<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以返回一个字符串，表示对象实例。 例如，基类型，如<xref:System.Char>， <xref:System.Int32>，和<xref:System.String>提供<xref:System.Object.ToString%2A>返回该对象表示的值的字符串形式的实现。 下面的示例定义了一个类`Object2`，可重写<xref:System.Object.ToString%2A>方法以返回及其值的类型名称。  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 下表列出了.NET Framework 中的类型类别，并指示它们是否将覆盖<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法。  
  
|类型类别|替代 Object.ToString()|行为|  
|-------------------|-----------------------------------|--------------|  
|类|n/a|n/a|  
|结构|是 (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Object.ToString() 相同|  
|枚举|是 (<xref:System.Enum.ToString?displayProperty=nameWithType>)|成员名称|  
|接口|否|n/a|  
|委托|否|n/a|  
  
 重写，请参阅备注继承者部分以了解更多信息<xref:System.Object.ToString%2A>。  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>重载 ToString 方法  
 除了重写的无参数<xref:System.Object.ToString?displayProperty=nameWithType>方法，许多类型重载`ToString`方法以提供的方法接受参数的版本。 通常情况下，这样做是为了提供对变量的格式设置和区分区域性的格式设置支持。  
  
 以下示例重载`ToString`方法以返回包含的各个字段的值的结果字符串`Automobile`类。 它定义了四个格式字符串： G，返回的模型名称和年;D，返回的模型名称、 年、 和的门; 数C，后者返回模型名称、 年和柱面;和 A，它返回所有四个字段值的字符串。  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 下面的示例调用重载<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>方法以显示货币值的区分区域性的格式。  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 格式字符串和区分区域性的格式设置的详细信息，请参阅[格式化类型](~/docs/standard/base-types/formatting-types.md)。 有关支持的数字值的格式字符串，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 有关支持的日期和时间值的格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>扩展 Object.ToString 方法  
 由于类型都继承默认值<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法，你可能会查找其行为不需要并想要对其进行更改。 这是数组和集合类尤其如此。 时可能会遇到`ToString`方法的数组或集合类来显示其成员的值，它改为显示的类型完全限定的类型名称，如以下示例所示。  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 你有若干选项来生成你想要的结果字符串。  
  
-   如果类型是数组、 集合对象或实现的对象<xref:System.Collections.IEnumerable>或<xref:System.Collections.Generic.IEnumerable%601>接口，可以通过使用枚举其元素`foreach`C# 中的语句或`For Each...Next`在 Visual Basic 中构造。  
  
-   如果此类不是`sealed`（在 C# 中) 或`NotInheritable`（在 Visual Basic 中)，你可以开发一个包装类，从基类继承其<xref:System.Object.ToString%2A?displayProperty=nameWithType>想要自定义的方法。 在最低限度上，这需要你以下：  
  
    1.  实现任何必要的构造函数。 派生的类不会继承其基类构造函数。  
  
    2.  重写<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以返回想要的结果字符串。  
  
     下面的示例定义的包装类<xref:System.Collections.Generic.List%601>类。 它将重写<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以显示每个方法的集合，而不是完全限定的类型名称的值。  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   开发[扩展方法](~/docs/standard/design-guidelines/extension-methods.md)返回所需的结果字符串。 请注意，不能重写默认值<xref:System.Object.ToString%2A?displayProperty=nameWithType>以这种方式的方法 (也就是说，扩展类 （在 C# 中) 或 （在 Visual Basic) 的模块不能有一个名为的无参数方法`ToString`来代替原始类型的调用的函数是`ToString`方法. 你将需要提供其他名称为你无参数`ToString`替换。  
  
     下面的示例定义两种方法的扩展<xref:System.Collections.Generic.List%601>类： 无参数`ToString2`方法，和一个`ToString`方法替换<xref:System.String>表示一个格式字符串的参数。  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>说明 [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 当调用<xref:System.Object.ToString%2A>中类方法[!INCLUDE[wrt](~/includes/wrt-md.md)]，它不会覆盖的类提供的默认行为<xref:System.Object.ToString%2A>。 这是.NET Framework 提供的支持的一部分[!INCLUDE[wrt](~/includes/wrt-md.md)](请参阅[.NET Framework 支持为 Windows 应用商店应用和 Windows 运行时](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md))。 中的类[!INCLUDE[wrt](~/includes/wrt-md.md)]不继承<xref:System.Object>，并不总是实现<xref:System.Object.ToString%2A>。 但是，它们始终会显示为具有<xref:System.Object.ToString%2A>， <xref:System.Object.Equals%28System.Object%29>，和<xref:System.Object.GetHashCode%2A>方法在 C# 或 Visual Basic 代码中，使用它们以及.NET Framework 为这些方法提供默认行为时。  
  
 从开始[!INCLUDE[net_v451](~/includes/net-v451-md.md)]，公共语言运行时将使用[IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)上[!INCLUDE[wrt](~/includes/wrt-md.md)]对象在回退到的默认实现之前<xref:System.Object.ToString%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] 用 C# 或 Visual Basic 编写的类可以重写<xref:System.Object.ToString%2A>方法。  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)]和 IStringable 接口  
 从开始[!INCLUDE[win81](~/includes/win81-md.md)]、[!INCLUDE[wrt](~/includes/wrt-md.md)]包括[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)接口的单一方法[IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)，提供基本格式设置支持相媲美提供的<xref:System.Object.ToString%2A?displayProperty=nameWithType>。 若要避免产生混乱，则不应实现[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)上托管类型。  
  
 通过本机代码或通过在 JavaScript 或 C + 等语言中编写代码的托管的对象调用时 + /CX 中，它们看起来实现[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)。 公共语言运行时自动将路由从调用[IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)到<xref:System.Object.ToString%2A?displayProperty=nameWithType>在事件[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)未在托管对象上实现。  
  
> [!WARNING]
>  因为公共语言运行时自动实现[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)所有的托管类型中的[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]应用，我们建议你不要不提供你自己[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)实现。 实现[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)调用时，可能会导致意外行为`ToString`从[!INCLUDE[wrt](~/includes/wrt-md.md)]、 C + + /CX 中或 JavaScript。  
  
 如果你选择实现[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)中导出的公共托管类型中[!INCLUDE[wrt](~/includes/wrt-md.md)]组件，以下限制适用：  
  
-   你可以定义[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)接口只能在"类实现"关系，如  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     接  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     口。  
  
-   不能实现[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)在接口上。  
  
-   你不能声明为类型参数[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)。  
  
-   [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)不能是方法、 属性或字段的返回类型。  
  
-   不能隐藏你[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)通过使用以下方法定义在基类中的实现：  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     相反， [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)实现必须始终替代基类实现。 只能通过对强类型类实例调用 `ToString` 实现来隐藏该实现。  
  
 请注意，在各种条件，从本机代码调用到托管类型实现[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)或隐藏其[ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)实现可以产生意外的行为。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>当您实现您自己的类型时，则应重写<see cref="M:System.Object.ToString" />方法返回对这些类型有意义的值。派生类需要比的格式设置的更好地控制<see cref="M:System.Object.ToString" />提供可以实现<see cref="T:System.IFormattable" />接口。其<see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />方法使你能够定义控制格式设置的格式字符串，以及用于<see cref="T:System.IFormatProvider" />可以为特定于区域性的格式设置提供的对象。重写<see cref="M:System.Object.ToString" />方法应该遵循以下指南:-友好和可读的形式应为返回的字符串。 -返回的字符串应单独标识对象实例的值。 -返回的字符串应尽可能短，以便它适合于由调试器的显示。 -您<see cref="M:System.Object.ToString" />替代不应返回<see cref="F:System.String.Empty" />或 null 字符串。 -您<see cref="M:System.Object.ToString" />替代不应引发异常。 -如果的字符串表示形式实例是区分区域性的或可采用多种方式进行格式设置，则实现<see cref="T:System.IFormattable" />接口。 -如果返回的字符串包含敏感信息，你应首先要求了适当的权限。如果请求成功，则可以返回的敏感信息;否则，应返回的字符串不包含敏感信息。 -您<see cref="M:System.Object.ToString" />重写应具有任何明显的副作用以避免在调试的复杂性。例如，调用<see cref="M:System.Object.ToString" />方法不应更改实例字段的值。 -如果你的类型实现的分析方法 (或<see langword="Parse" />或<see langword="TryParse" />方法、 构造函数或某些其他实例化从字符串类型的实例的静态方法)，应确保返回的字符串<see cref="M:System.Object.ToString" />方法可以是转换为对象实例。</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>