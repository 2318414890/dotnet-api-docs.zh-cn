<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Object.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e05b5b2-d481-4262-b7b7-7de7ac2afe07da621eb36bda643f3e0a1e5b1a3ef53120877ab9.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">da621eb36bda643f3e0a1e5b1a3ef53120877ab9</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df6cf590aa3087f6c7c202712eee781c6a3c8f96</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/07/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Object">
          <source>Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes.</source>
          <target state="translated">支持 .NET Framework 类层次结构中的所有类，并为派生类提供低级别服务。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Object">
          <source>This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.</source>
          <target state="translated">这是 .NET Framework 中所有类的最终基类；它是类型层次结构的根。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Languages typically do not require a class to declare inheritance from <ph id="ph1">&lt;xref:System.Object&gt;</ph> because the inheritance is implicit.</source>
          <target state="translated">语言通常不需要类来声明从继承<ph id="ph1">&lt;xref:System.Object&gt;</ph>因为继承是隐式。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Because all classes in the .NET Framework are derived from <ph id="ph1">&lt;xref:System.Object&gt;</ph>, every method defined in the <ph id="ph2">&lt;xref:System.Object&gt;</ph> class is available in all objects in the system.</source>
          <target state="translated">因为.NET Framework 中的所有类都派生自<ph id="ph1">&lt;xref:System.Object&gt;</ph>中, 定义的每个方法<ph id="ph2">&lt;xref:System.Object&gt;</ph>类是可用于所有对象系统中。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Derived classes can and do override some of these methods, including:</source>
          <target state="translated">派生类可以和重写其中的某些方法，包括：</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> - Supports comparisons between objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> -支持对象之间的比较。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> - Performs cleanup operations before an object is automatically reclaimed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> -在对象被自动回收之前，请执行清理操作。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> - Generates a number corresponding to the value of the object to support the use of a hash table.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> -生成与对象的值对应一个数字，以支持使用哈希表。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> - Manufactures a human-readable text string that describes an instance of the class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> — 生成描述类的实例的用户可读文本字符串。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Performance Considerations</source>
          <target state="translated">性能注意事项</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">如果您正在设计的类，如的集合，必须在处理任何类型的对象，你可以创建接受的实例的类成员<ph id="ph1">&lt;xref:System.Object&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>However, the process of boxing and unboxing a type carries a performance cost.</source>
          <target state="translated">但是，装箱和取消装箱类型的过程会带来的性能开销。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</source>
          <target state="translated">如果你知道新类将经常处理某些值类型可以使用两个策略之一装箱的成本降到最低。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Create a general method that accepts an <ph id="ph1">&lt;xref:System.Object&gt;</ph> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</source>
          <target state="translated">创建接受的常规方法<ph id="ph1">&lt;xref:System.Object&gt;</ph>类型，以及接受希望你的类以经常处理每个值类型的特定类型的方法重载的一组。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</source>
          <target state="translated">如果特定类型的方法存在，以接受调用的参数类型，没有值类型装箱发生，并且会调用特定类型的方法。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</source>
          <target state="translated">如果没有任何与调用的参数类型匹配的方法自变量，该参数进行装箱，并调用常规方法。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Design your type and its members to use generics.</source>
          <target state="translated">设计你的类型和其成员来使用泛型。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</source>
          <target state="translated">在创建您的类的实例和指定泛型类型参数时，公共语言运行时创建封闭式泛型类型。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>The generic method is type-specific and can be invoked without boxing the calling parameter.</source>
          <target state="translated">泛型方法是特定类型和可以调用而无需装箱调用的参数。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Although it is sometimes necessary to develop general purpose classes that accept and return <ph id="ph1">&lt;xref:System.Object&gt;</ph> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</source>
          <target state="translated">尽管，有时需要开发通用类，接受并返回<ph id="ph1">&lt;xref:System.Object&gt;</ph>类型，通过提供特定类型的类来处理常用的类型上，你可以提高性能。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</source>
          <target state="translated">例如，提供特定于设置和获取布尔值的类消除了装箱和取消装箱的布尔值的成本。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>The following example defines a Point type derived from the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class and overrides many of the virtual methods of the <ph id="ph2">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">下面的示例定义一个派生自类型<ph id="ph1">&lt;xref:System.Object&gt;</ph>类并重写的虚方法的多种<ph id="ph2">&lt;xref:System.Object&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>In addition, the example shows how to call many of the static and instance methods of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">此外，该示例演示如何调用许多静态和实例方法的<ph id="ph1">&lt;xref:System.Object&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">公共静态 (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph>在 Visual Basic 中) 的此类型的成员都是线程安全。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Instance members are not guaranteed to be thread-safe.</source>
          <target state="translated">不保证实例成员都是线程安全。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Object.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.#ctor">
          <source>This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">在派生类中，构造函数将调用此构造函数，但它还可以用于直接创建的实例<ph id="ph1">&lt;xref:System.Object&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="T:System.Object">
          <source>Determines whether two object instances are equal.</source>
          <target state="translated">确定两个对象实例是否相等。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object)">
          <source>The object to compare with the current object.</source>
          <target state="translated">要与当前对象进行比较的对象。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object)">
          <source>Determines whether the specified object is equal to the current object.</source>
          <target state="translated">确定指定的对象是否等于当前对象。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified object  is equal to the current object; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果指定的对象等于当前对象，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The type of comparison between the current instance and the <ph id="ph1">`obj`</ph> parameter depends on whether the current instance is a reference type or a value type.</source>
          <target state="translated">当前实例进行比较的类型和<ph id="ph1">`obj`</ph>参数取决于当前实例是否为引用类型或值类型。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If the current instance is a reference type, the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method tests for reference equality, and a call to the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method is equivalent to a call to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">如果当前实例是引用类型，<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法测试引用相等性，并调用<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法等效于调用<ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Reference equality means that the object variables that are compared refer to the same object.</source>
          <target state="translated">引用相等性意味着进行比较的对象变量引用同一个对象。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example illustrates the result of such a comparison.</source>
          <target state="translated">下面的示例阐释了这种比较的结果。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It defines a <ph id="ph1">`Person`</ph> class, which is a reference type, and calls the <ph id="ph2">`Person`</ph> class constructor to instantiate two new <ph id="ph3">`Person`</ph> objects, <ph id="ph4">`person1a`</ph> and <ph id="ph5">`person2`</ph>, which have the same value.</source>
          <target state="translated">它定义<ph id="ph1">`Person`</ph>类，该类是引用类型，并调用<ph id="ph2">`Person`</ph>类构造函数来实例化两个新<ph id="ph3">`Person`</ph>对象，<ph id="ph4">`person1a`</ph>和<ph id="ph5">`person2`</ph>，其中具有相同的值。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It also assigns <ph id="ph1">`person1a`</ph> to another object variable, <ph id="ph2">`person1b`</ph>.</source>
          <target state="translated">它还会将分配<ph id="ph1">`person1a`</ph>给另一个对象变量， <ph id="ph2">`person1b`</ph>。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As the output from the example shows, <ph id="ph1">`person1a`</ph> and <ph id="ph2">`person1b`</ph> are equal because they reference the same object.</source>
          <target state="translated">如示例所示，输出<ph id="ph1">`person1a`</ph>和<ph id="ph2">`person1b`</ph>由于它们都引用同一个对象是否相等。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, <ph id="ph1">`person1a`</ph> and <ph id="ph2">`person2`</ph> are not equal, although they have the same value.</source>
          <target state="translated">但是，<ph id="ph1">`person1a`</ph>和<ph id="ph2">`person2`</ph>是否不相等，尽管它们具有相同的值。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If the current instance is a value type, the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method tests for value equality.</source>
          <target state="translated">如果当前实例是值类型，<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法测试值是否相等。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Value equality means the following:</source>
          <target state="translated">值相等性意味着：</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The two objects are of the same type.</source>
          <target state="translated">两个对象均为相同的类型。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As the following example shows, a <ph id="ph1">&lt;xref:System.Byte&gt;</ph> object that has a value of 12 does not equal an <ph id="ph2">&lt;xref:System.Int32&gt;</ph> object that has a value of 12, because the two objects have different run-time types.</source>
          <target state="translated">如下面的示例所示，<ph id="ph1">&lt;xref:System.Byte&gt;</ph>的值为 12 的对象不等于<ph id="ph2">&lt;xref:System.Int32&gt;</ph>具有其值为 12，因为两个对象具有不同的运行时类型的对象。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The values of the public and private fields of the two objects are equal.</source>
          <target state="translated">两个对象的公共和私有字段的值相等。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example tests for value equality.</source>
          <target state="translated">下面的示例测试的值相等。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It defines a <ph id="ph1">`Person`</ph> structure, which is a value type, and calls the <ph id="ph2">`Person`</ph> class constructor to instantiate two new <ph id="ph3">`Person`</ph> objects, <ph id="ph4">`person1`</ph> and <ph id="ph5">`person2`</ph>, which have the same value.</source>
          <target state="translated">它定义<ph id="ph1">`Person`</ph>结构，这是值类型，并调用<ph id="ph2">`Person`</ph>类构造函数来实例化两个新<ph id="ph3">`Person`</ph>对象，<ph id="ph4">`person1`</ph>和<ph id="ph5">`person2`</ph>，其中具有相同的值。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As the output from the example shows, although the two object variables refer to different objects, <ph id="ph1">`person1`</ph> and <ph id="ph2">`person2`</ph> are equal because they have the same value for the private <ph id="ph3">`personName`</ph> field.</source>
          <target state="translated">如示例输出所示，虽然两个对象变量引用不同的对象，但<ph id="ph1">`person1`</ph>和<ph id="ph2">`person2`</ph>是否相等的因为它们具有相同的值为私有<ph id="ph3">`personName`</ph>字段。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class is the base class for all types in the .NET Framework, the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method provides the default equality comparison for all other types.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Object&gt;</ph>类是.NET Framework 中的所有类型的基类<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>方法提供对于所有其他类型的默认相等比较。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, types often override the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method to implement value equality.</source>
          <target state="translated">但是，类型通常替代<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>方法来实现值是否相等。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For more information, see the Notes for Callers and Notes for Inheritors sections.</source>
          <target state="translated">有关详细信息，请参阅说明调用方和说明的继承者节。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">说明 <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method overload on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
          <target state="translated">当调用<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>中的类上的方法重载<ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>，它不会覆盖的类提供的默认行为<ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">这是.NET Framework 提供的支持的一部分<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>(请参阅<bpt id="p1">[</bpt>.NET Framework 支持为 Windows 应用商店应用和 Windows 运行时<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>)。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and currently don’t implement an <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method.</source>
          <target state="translated">中的类<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>不继承<ph id="ph2">&lt;xref:System.Object&gt;</ph>，并且不要实施<ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, they appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">但是，它们会显示为具有<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>，和<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法在 C# 或 Visual Basic 代码中，使用它们以及.NET Framework 为这些方法提供的默认行为时。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method overload.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> 用 C# 或 Visual Basic 编写的类可以重写<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Notes for Callers</source>
          <target state="translated">调用方的说明</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Derived classes frequently override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method to implement value equality.</source>
          <target state="translated">经常重写派生的类<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>方法来实现值是否相等。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In addition, types also frequently provide an additional strongly typed overload to the <ph id="ph1">`Equals`</ph> method, typically by implementing the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interface.</source>
          <target state="translated">此外，类型也经常提供到另一个强类型的重载<ph id="ph1">`Equals`</ph>方法，通常通过实现<ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph>接口。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When you call the <ph id="ph1">`Equals`</ph> method to test for equality, you should know whether the current instance overrides <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> and understand how a particular call to an <ph id="ph3">`Equals`</ph> method is resolved.</source>
          <target state="translated">当调用<ph id="ph1">`Equals`</ph>方法来测试相等性，你应知道的当前实例是否替代<ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>并了解如何对特定调用<ph id="ph3">`Equals`</ph>方法处于已解决状态。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</source>
          <target state="translated">否则为你可能不同于你预期的相等性执行测试，并且该方法可能返回了意外的值。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example provides an illustration.</source>
          <target state="translated">下面的示例进行了这方面的演示。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It instantiates three <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects with identical strings, and then makes four calls to <ph id="ph2">`Equals`</ph> methods.</source>
          <target state="translated">它实例化三个<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>使用相同的字符串对象，然后在将四个调用<ph id="ph2">`Equals`</ph>方法。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The first method call returns <ph id="ph1">`true`</ph>, and the remaining three return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">第一种方法调用返回<ph id="ph1">`true`</ph>，和剩余的三个返回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In the first case, the strongly typed <ph id="ph1">&lt;xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType&gt;</ph> method overload, which tests for value equality, is called.</source>
          <target state="translated">在第一个的情况下，强类型化<ph id="ph1">&lt;xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType&gt;</ph>调用方法重载，它的值是否相等，测试。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because the strings assigned to the two <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects are equal, the method returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">因为字符串分配给两个<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>对象是否相等，则该方法返回<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> does not override <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">但是，<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>不重写<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because of this, when the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object is cast to an <ph id="ph2">&lt;xref:System.Object&gt;</ph>, when a <ph id="ph3">&lt;xref:System.Text.StringBuilder&gt;</ph> instance is assigned to a variable of type <ph id="ph4">&lt;xref:System.Object&gt;</ph>, and when the <ph id="ph5">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method is passed two <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph> objects, the default <ph id="ph7">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method is called.</source>
          <target state="translated">因此，当<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>对象强制转换为<ph id="ph2">&lt;xref:System.Object&gt;</ph>，当<ph id="ph3">&lt;xref:System.Text.StringBuilder&gt;</ph>实例分配给类型的变量的<ph id="ph4">&lt;xref:System.Object&gt;</ph>，以及何时<ph id="ph5">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph>方法传递两个<ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph>的对象，默认<ph id="ph7">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> is a reference type, this is equivalent to passing the two <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> objects to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>是引用类型，该属性等同于传递两个<ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph>对象添加到<ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Although all three <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects contain identical strings, they refer to three distinct objects.</source>
          <target state="translated">尽管所有三个<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>对象包含相同的字符串，则指三个不同的对象。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As a result, these three method calls return <ph id="ph1">`false`</ph>.</source>
          <target state="translated">因此，这些三个方法调用返回<ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You can compare the current object to another object for reference equality by calling the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">你可以通过调用比较当前对象与另一个对象引用相等性<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In Visual Basic, you can also use the <ph id="ph1">`is`</ph> keyword (for example, <ph id="ph2">`If Me Is otherObject Then ...`</ph>).</source>
          <target state="translated">在 Visual Basic 中，你还可以使用<ph id="ph1">`is`</ph>关键字 (例如， <ph id="ph2">`If Me Is otherObject Then ...`</ph>)。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Notes for Inheritors</source>
          <target state="translated">对继承者的说明</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When you define your own type, that type inherits the functionality defined by the <ph id="ph1">`Equals`</ph> method of its base type.</source>
          <target state="translated">当你定义你自己的类型时，该类型继承定义的功能<ph id="ph1">`Equals`</ph>方法与其基类型。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following table lists the default implementation of the <ph id="ph1">`Equals`</ph> method for the major categories of types in the .NET Framework.</source>
          <target state="translated">下表列出的默认实现<ph id="ph1">`Equals`</ph>为主要类别的.NET Framework 中的类型的方法。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Type category</source>
          <target state="translated">类型类别</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Equality defined by</source>
          <target state="translated">所定义的相等</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Comments</source>
          <target state="translated">注释</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Class derived directly from <ph id="ph1">&lt;xref:System.Object&gt;</ph></source>
          <target state="translated">直接从派生类 <ph id="ph1">&lt;xref:System.Object&gt;</ph></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Reference equality; equivalent to calling <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">引用相等性;等效于调用<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Structure</source>
          <target state="translated">结构</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</source>
          <target state="translated">值相等。直接逐字节比较或按字段比较使用反射。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Enumeration</source>
          <target state="translated">枚举</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Values must have the same enumeration type and the same underlying value.</source>
          <target state="translated">值必须具有相同的枚举类型和相同的基础值。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Delegate</source>
          <target state="translated">委托</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Delegates must have the same type with identical invocation lists.</source>
          <target state="translated">委托必须具有相同的调用列表的相同类型。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Interface</source>
          <target state="translated">接口</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Reference equality.</source>
          <target state="translated">引用相等性。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For a value type, you should always override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, because tests for equality that rely on reflection offer poor performance.</source>
          <target state="translated">对于值类型，则应始终重写<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>，因为测试是否相等依赖于反射提供性能不佳。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You can also override the default implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</source>
          <target state="translated">此外可以重写的默认实现<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>对于引用类型来测试而不是引用相等性的值是否相等并定义值相等性的精确意义。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Such implementations of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> return <ph id="ph2">`true`</ph> if the two objects have the same value, even if they are not the same instance.</source>
          <target state="translated">此类实现<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>返回<ph id="ph2">`true`</ph>如果两个对象具有相同的值，即使它们不是同一个实例。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</source>
          <target state="translated">该类型的实施者决定构成对象的值，但它通常是部分或全部存储的数据的对象的实例变量中。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For example, the value of a <ph id="ph1">&lt;xref:System.String&gt;</ph> object is based on the characters of the string; the <ph id="ph2">&lt;xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method overrides the <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method to return <ph id="ph4">`true`</ph> for any two string instances that contain the same characters in the same order.</source>
          <target state="translated">例如，值为<ph id="ph1">&lt;xref:System.String&gt;</ph>对象所基于的字符字符串;<ph id="ph2">&lt;xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>方法重写<ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>方法以返回<ph id="ph4">`true`</ph>任何两个字符串包含相同的顺序中的相同字符的实例。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example shows how to override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method to test for value equality.</source>
          <target state="translated">下面的示例演示如何重写<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>方法来测试的值是否相等。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method for the <ph id="ph2">`Person`</ph> class.</source>
          <target state="translated">它将重写<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>方法<ph id="ph2">`Person`</ph>类。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If <ph id="ph1">`Person`</ph> accepted its base class implementation of equality, two <ph id="ph2">`Person`</ph> objects would be equal only if they referenced a single object.</source>
          <target state="translated">如果<ph id="ph1">`Person`</ph>接受相等性，其基类实现两个<ph id="ph2">`Person`</ph>对象将引用单个对象，它们才相等。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, in this case, two <ph id="ph1">`Person`</ph> objects are equal if they have the same value for the <ph id="ph2">`Person.Id`</ph> property.</source>
          <target state="translated">但是，在这种情况下，两个<ph id="ph1">`Person`</ph>对象是否相等，如果它们具有相同的值<ph id="ph2">`Person.Id`</ph>属性。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In addition to overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, you can implement the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interface to provide a strongly typed test for equality.</source>
          <target state="translated">除了重写<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>，你可以实现<ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph>接口，以提供强类型化的测试相等性。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following statements must be true for all implementations of the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method.</source>
          <target state="translated">以下语句必须为 true 的所有实现<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In the list, <ph id="ph1">`x`</ph>, <ph id="ph2">`y`</ph>, and <ph id="ph3">`z`</ph> represent object references that are not <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</source>
          <target state="translated">在列表中， <ph id="ph1">`x`</ph>， <ph id="ph2">`y`</ph>，和<ph id="ph3">`z`</ph>表示不是对象引用<bpt id="p1">**</bpt>null<ept id="p1">**</ept>。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(x)`</ph> returns <ph id="ph2">`true`</ph>, except in cases that involve floating-point types.</source>
          <target state="translated"><ph id="ph1">`x.Equals(x)`</ph> 返回<ph id="ph2">`true`</ph>，涉及浮点类型的情况除外。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.</source>
          <target state="translated">请参阅 ISO/IEC/IEEE 60559:2011，信息技术-微处理器系统-浮点运算。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(y)`</ph> returns the same value as <ph id="ph2">`y.Equals(x)`</ph>.</source>
          <target state="translated"><ph id="ph1">`x.Equals(y)`</ph> 返回值与相同<ph id="ph2">`y.Equals(x)`</ph>。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(y)`</ph> returns <ph id="ph2">`true`</ph> if both <ph id="ph3">`x`</ph> and <ph id="ph4">`y`</ph> are <ph id="ph5">`NaN`</ph>.</source>
          <target state="translated"><ph id="ph1">`x.Equals(y)`</ph> 返回<ph id="ph2">`true`</ph>如果这两个<ph id="ph3">`x`</ph>和<ph id="ph4">`y`</ph>是<ph id="ph5">`NaN`</ph>。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If <ph id="ph1">`(x.Equals(y) &amp;&amp; y.Equals(z))`</ph> returns <ph id="ph2">`true`</ph>, then <ph id="ph3">`x.Equals(z)`</ph> returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`(x.Equals(y) &amp;&amp; y.Equals(z))`</ph>返回<ph id="ph2">`true`</ph>，然后<ph id="ph3">`x.Equals(z)`</ph>返回<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Successive calls to <ph id="ph1">`x.Equals(y)`</ph> return the same value as long as the objects referenced by <ph id="ph2">`x`</ph> and <ph id="ph3">`y`</ph> are not modified.</source>
          <target state="translated">对连续调用<ph id="ph1">`x.Equals(y)`</ph>返回相同的值，只要引用对象<ph id="ph2">`x`</ph>和<ph id="ph3">`y`</ph>不会修改。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(null)`</ph> returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`x.Equals(null)`</ph> 返回 <ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Implementations of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> must not throw exceptions; they should always return a value.</source>
          <target state="translated">实现<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>必须不引发异常; 它们应始终会返回值。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For example, if <ph id="ph1">`obj`</ph> is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph> method should return <ph id="ph4">`false`</ph> instead of throwing an <ph id="ph5">&lt;xref:System.ArgumentNullException&gt;</ph>.</source>
          <target state="translated">例如，如果<ph id="ph1">`obj`</ph>是<ph id="ph2">`null`</ph>、<ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph>方法应返回<ph id="ph4">`false`</ph>而不是引发<ph id="ph5">&lt;xref:System.ArgumentNullException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Follow these guidelines when overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>:</source>
          <target state="translated">重写时，请遵循以下准则<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Types that implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> must override <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
          <target state="translated">类型实现<ph id="ph1">&lt;xref:System.IComparable&gt;</ph>必须重写<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Types that override <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> must also override <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>; otherwise, hash tables  might not work correctly.</source>
          <target state="translated">类型重写<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>还必须重写<ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>; 否则为哈希表可能无法正常工作。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You should consider implementing the <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface to support strongly typed tests for equality.</source>
          <target state="translated">你应该考虑实施<ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph>接口以支持强类型化测试是否相等。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Your <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> implementation should return results that are consistent with <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">你<ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph>实现应返回与相一致的结果<ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method to return the same result as the equality operator.</source>
          <target state="translated">如果您的编程语言支持运算符重载，并且重载相等运算符对于给定的类型，还必须重写<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法以返回与相等运算符相同的结果。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This  helps ensure that class library code that uses <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> (such as <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>) behaves in a manner that is consistent with the way the equality operator is used by application code.</source>
          <target state="translated">这有助于确保使用的类库代码<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>(如<ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>和<ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>) 中运作的方式与应用程序代码使用相等运算符的方法一致。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Guidelines for Reference Types</source>
          <target state="translated">对于引用类型的准则</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following guidelines apply to overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> for a reference type:</source>
          <target state="translated">以下准则适用于重写<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>对于引用类型：</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Consider overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> if the semantics of the type are based on the fact that the type represents some value(s).</source>
          <target state="translated">请考虑重写<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>的类型语义是否基于这一事实的类型表示某些值。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Most reference types must not overload the equality operator, even if they override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">大多数引用类型必须不能重载相等运算符，即使它们将覆盖<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</source>
          <target state="translated">但是，如果你要实现引用类型，用于具有值语义，如复杂的数字类型，你必须重写相等运算符。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You should not override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> on a mutable reference type.</source>
          <target state="translated">不应覆盖<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>上可变的引用类型。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This is because overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> requires that you also override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, as discussed in the previous section.</source>
          <target state="translated">这是因为在重写<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>需要，还可以覆盖<ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法上, 一节中所述。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</source>
          <target state="translated">这意味着，可变的引用类型的实例的哈希代码可以更改在其生存期内，这可能导致哈希表中的对象会丢失。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Guidelines for Value Types</source>
          <target state="translated">值类型的原则</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following guidelines apply to overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> for a value type:</source>
          <target state="translated">以下准则适用于重写<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>对于值类型：</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If you are defining a value type that includes one or more fields whose values are reference types, you should override <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
          <target state="translated">如果你正在定义包括一个或多个字段的值类型其值是引用类型，则应重写<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> implementation provided by <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>由提供实现<ph id="ph2">&lt;xref:System.ValueType&gt;</ph>执行逐字节比较的值类型字段是所有的值类型，但它使用反射来执行其字段包括引用类型的值类型的字段的比较。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If you override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and your development language supports operator overloading, you must overload the equality operator.</source>
          <target state="translated">如果你重写<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>和你的开发语言支持运算符重载，因此您必须重载相等运算符。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You should implement the <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface.</source>
          <target state="translated">应实现<ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph>接口。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Calling the strongly typed <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> method avoids boxing the <ph id="ph2">`obj`</ph> argument.</source>
          <target state="translated">调用的强类型化<ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph>方法可避免装箱<ph id="ph2">`obj`</ph>自变量。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example shows a <ph id="ph1">`Point`</ph> class that overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method to provide value equality, and a <ph id="ph3">`Point3D`</ph> class that is derived from <ph id="ph4">`Point`</ph>.</source>
          <target state="translated">下面的示例演示<ph id="ph1">`Point`</ph>类，并重写<ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>方法以提供值是否相等和<ph id="ph3">`Point3D`</ph>派生自的类<ph id="ph4">`Point`</ph>。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">`Point`</ph> overrides <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> to test for value equality, the <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method is not called.</source>
          <target state="translated">因为<ph id="ph1">`Point`</ph>重写<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>来测试值相等性<ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>不调用方法。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, <ph id="ph1">`Point3D.Equals`</ph> calls <ph id="ph2">`Point.Equals`</ph> because <ph id="ph3">`Point`</ph> implements <ph id="ph4">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> in a manner that provides value equality.</source>
          <target state="translated">但是，<ph id="ph1">`Point3D.Equals`</ph>调用<ph id="ph2">`Point.Equals`</ph>因为<ph id="ph3">`Point`</ph>实现<ph id="ph4">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>提供值是否相等的方式。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">`Point.Equals`</ph> method checks to make sure that the <ph id="ph2">`obj`</ph> argument is not <bpt id="p1">**</bpt>null<ept id="p1">**</ept> and that it references an instance of the same type as this object.</source>
          <target state="translated"><ph id="ph1">`Point.Equals`</ph>方法进行检查以确保<ph id="ph2">`obj`</ph>参数不是<bpt id="p1">**</bpt>null<ept id="p1">**</ept> ，并且它引用与此对象相同的类型的实例。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If either check fails, the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">如果任一检查失败，该方法返回<ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">`Point.Equals`</ph> method calls the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method to determine whether the run-time types of the two objects are identical.</source>
          <target state="translated"><ph id="ph1">`Point.Equals`</ph>方法调用<ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph>方法来确定两个对象的运行时类型是否相同。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If the method used a check of the form <ph id="ph1">`obj is Point`</ph> in C# or <ph id="ph2">`TryCast(obj, Point)`</ph> in Visual Basic, the check would return <ph id="ph3">`true`</ph> in cases where <ph id="ph4">`obj`</ph> is an instance of a derived class of <ph id="ph5">`Point`</ph>, even though <ph id="ph6">`obj`</ph> and the current instance are not of the same run-time type.</source>
          <target state="translated">如果该方法使用的检查的窗体<ph id="ph1">`obj is Point`</ph>在 C# 或<ph id="ph2">`TryCast(obj, Point)`</ph>在 Visual Basic 中，检查将返回<ph id="ph3">`true`</ph>在情况下其中<ph id="ph4">`obj`</ph>是派生的类的实例<ph id="ph5">`Point`</ph>，即使<ph id="ph6">`obj`</ph>和当前实例并不属于相同的运行时类型。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Having verified that both objects are of the same type, the method casts <ph id="ph1">`obj`</ph> to type <ph id="ph2">`Point`</ph> and returns the result of comparing the instance fields of the two objects.</source>
          <target state="translated">验证这两个对象是否相同类型，方法强制转换<ph id="ph1">`obj`</ph>类型<ph id="ph2">`Point`</ph>并返回结果的比较两个对象的实例字段。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In <ph id="ph1">`Point3D.Equals`</ph>, the inherited <ph id="ph2">`Point.Equals`</ph> method, which overrides <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>, is invoked before anything else is done.</source>
          <target state="translated">在<ph id="ph1">`Point3D.Equals`</ph>，继承<ph id="ph2">`Point.Equals`</ph>方法，这将覆盖<ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>，任何其他操作完成之前调用。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">`Point3D`</ph> is a sealed class (<ph id="ph2">`NotInheritable`</ph> in Visual Basic), a check in the form <ph id="ph3">`obj is Point`</ph> in C# or <ph id="ph4">`TryCast(obj, Point)`</ph> in Visual Basic is adequate to ensure that <ph id="ph5">`obj`</ph> is a <ph id="ph6">`Point3D`</ph> object.</source>
          <target state="translated">因为<ph id="ph1">`Point3D`</ph>是一个密封的类 (<ph id="ph2">`NotInheritable`</ph>在 Visual Basic 中)，在窗体中的检查<ph id="ph3">`obj is Point`</ph>在 C# 或<ph id="ph4">`TryCast(obj, Point)`</ph>在 Visual Basic 中是足够用于确保<ph id="ph5">`obj`</ph>是<ph id="ph6">`Point3D`</ph>对象。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If it is a <ph id="ph1">`Point3D`</ph> object, it is cast to a <ph id="ph2">`Point`</ph> object and passed to the base class implementation of <ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">如果它是<ph id="ph1">`Point3D`</ph>对象，它被强制转换为<ph id="ph2">`Point`</ph>对象并传递到基类实现<ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Only when the inherited <ph id="ph1">`Point.Equals`</ph> method returns <ph id="ph2">`true`</ph> does the method compare the <ph id="ph3">`z`</ph> instance fields introduced in the derived class.</source>
          <target state="translated">仅当继承<ph id="ph1">`Point.Equals`</ph>方法返回<ph id="ph2">`true`</ph>没有方法比较<ph id="ph3">`z`</ph>实例在派生类中引入的字段。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example defines a <ph id="ph1">`Rectangle`</ph> class that internally implements a rectangle as two <ph id="ph2">`Point`</ph> objects.</source>
          <target state="translated">下面的示例定义<ph id="ph1">`Rectangle`</ph>内部实现作为两个矩形类<ph id="ph2">`Point`</ph>对象。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">`Rectangle`</ph> class also overrides <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> to provide for value equality.</source>
          <target state="translated"><ph id="ph1">`Rectangle`</ph>类还将重写<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>提供的值是否相等。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Some languages such as C# and Visual Basic support operator overloading.</source>
          <target state="translated">某些语言中的如 C# 和 Visual Basic 支持运算符重载。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When a type overloads the equality operator, it must also override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method to provide the same functionality.</source>
          <target state="translated">当某个类型重载相等运算符时，它还必须重写<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法以提供相同的功能。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This is typically accomplished by writing the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method in terms of the overloaded equality operator, as in the following example.</source>
          <target state="translated">这通常通过编写实现<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方面重载的相等运算符，如以下示例所示的方法。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">`Complex`</ph> is a value type, it cannot be derived from.</source>
          <target state="translated">因为<ph id="ph1">`Complex`</ph>是值类型，它不能从派生。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Therefore, the override to <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method need not call <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> to determine the precise run-time type of each object, but can instead use the <ph id="ph3">`is`</ph> operator in C# or the <ph id="ph4">`TypeOf`</ph> operator in Visual Basic to check the type of the <ph id="ph5">`obj`</ph> parameter.</source>
          <target state="translated">因此，替代<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>方法无需调用<ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph>以确定精确的运行时类型的每个对象，但可以改为使用<ph id="ph3">`is`</ph>C# 中的运算符或<ph id="ph4">`TypeOf`</ph>Visual basic 中检查的类型的运算符<ph id="ph5">`obj`</ph>参数。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The first object to compare.</source>
          <target state="translated">要比较的第一个对象。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The second object to compare.</source>
          <target state="translated">要比较的第二个对象。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>Determines whether the specified object instances are considered equal.</source>
          <target state="translated">确定指定的对象实例是否被视为相等。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the objects are considered equal; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果对象被视为相等，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If both <ph id="ph1">&lt;paramref name="objA" /&gt;</ph> and <ph id="ph2">&lt;paramref name="objB" /&gt;</ph> are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, the method returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="objA" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="objB" /&gt;</ph> 均为 null，此方法返回 <ph id="ph3">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The static <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> method indicates whether two objects, <ph id="ph2">`objA`</ph> and  <ph id="ph3">`objB`</ph>, are equal.</source>
          <target state="translated">静态<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph>方法指示两个对象是否，<ph id="ph2">`objA`</ph>和<ph id="ph3">`objB`</ph>，是否相等。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It also enables you to test objects whose value is <bpt id="p1">**</bpt>null<ept id="p1">**</ept> for equality.</source>
          <target state="translated">它还可用于测试的对象，其值是<bpt id="p1">**</bpt>null<ept id="p1">**</ept>是否相等。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It compares <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> for equality as follows:</source>
          <target state="translated">它将进行比较<ph id="ph1">`objA`</ph>和<ph id="ph2">`objB`</ph>相等性，如下所示：</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It determines whether the two objects represent the same object reference.</source>
          <target state="translated">它确定两个对象是否表示相同的对象引用。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If they do, the method returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">如果他们这样做，则此方法返回<ph id="ph1">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>This test is equivalent to calling the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">此测试等效于调用<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>In addition, if both <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, the method returns <ph id="ph3">`true`</ph>.</source>
          <target state="translated">此外，如果这两个<ph id="ph1">`objA`</ph>和<ph id="ph2">`objB`</ph>是<bpt id="p1">**</bpt>null<ept id="p1">**</ept>，该方法返回<ph id="ph3">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It determines whether either <ph id="ph1">`objA`</ph> or <ph id="ph2">`objB`</ph> is <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</source>
          <target state="translated">它确定是否是<ph id="ph1">`objA`</ph>或<ph id="ph2">`objB`</ph>是<bpt id="p1">**</bpt>null<ept id="p1">**</ept>。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If so, it returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">如果因此，它返回<ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If the two objects do not represent the same object reference and neither is <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, it calls <ph id="ph1">`objA`</ph>.<ph id="ph2">`Equals`</ph>(<ph id="ph3">`objB`</ph>) and returns the result.</source>
          <target state="translated">如果两个对象不表示相同的对象引用，并且二者均<bpt id="p1">**</bpt>null<ept id="p1">**</ept>，它调用<ph id="ph1">`objA`</ph>。<ph id="ph2">`Equals`</ph>(<ph id="ph3">`objB`</ph>) 并返回结果。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>This means that if <ph id="ph1">`objA`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, this override is called.</source>
          <target state="translated">这意味着，如果<ph id="ph1">`objA`</ph>重写<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>方法，调用此重写。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> method and compares it with the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例演示<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph>方法，并将其与<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Object.Finalize">
          <source>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</source>
          <target state="translated">在垃圾回收将某一对象回收前允许该对象尝试释放资源并执行其他清理操作。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法用于执行之前对象被销毁当前对象持有的非托管资源的清理操作。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The method is protected and therefore is accessible only through this class or through a derived class.</source>
          <target state="translated">该方法受保护，并且因此仅通过此类或派生类可访问。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>In this section:</source>
          <target state="translated">本节内容：</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><bpt id="p1">[</bpt>How finalization works<ept id="p1">](#How)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>终止的工作原理<ept id="p1">](#How)</ept></target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><bpt id="p1">[</bpt>Notes for implementers<ept id="p1">](#Notes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>实施者注意事项<ept id="p1">](#Notes)</ept></target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><bpt id="p1">[</bpt>The SafeHandle alternative<ept id="p1">](#SafeHandle)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>SafeHandle 备用方法<ept id="p1">](#SafeHandle)</ept></target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>How finalization works</source>
          <target state="translated">终止的工作原理</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object&gt;</ph> class provides no implementation for the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, and the garbage collector does not mark types derived from <ph id="ph3">&lt;xref:System.Object&gt;</ph> for finalization unless they override the <ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object&gt;</ph>类提供的实现不<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法和垃圾回收器将派生的类型不标记<ph id="ph3">&lt;xref:System.Object&gt;</ph>终止除非它们将覆盖<ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If a type does override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</source>
          <target state="translated">如果类型未重写<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法，则垃圾回收器会将类型的每个实例的条目添加到调用终止队列中的内部结构。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</source>
          <target state="translated">终止队列中包含垃圾回收器才能回收其内存之前，必须运行其终止代码托管堆中的所有对象的条目。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The garbage collector then calls the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method automatically under the following conditions:</source>
          <target state="translated">然后，垃圾回收器调用<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>在以下情况下自动的方法：</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">垃圾回收器发现，一个对象不可访问，除非您通过调用从终止豁免已对象后<ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>During shutdown of an application domain, unless the object is exempt from finalization.</source>
          <target state="translated">在关闭应用程序域中，除非该对象是免于终止的对象。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>During shutdown, even objects that are still accessible are finalized.</source>
          <target state="translated">在关闭期间，终止甚至仍是可访问的对象。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <ph id="ph2">&lt;xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType&gt;</ph> and the <ph id="ph3">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method has not been subsequently called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> 将自动调用一次在给定实例中，除非的对象重新注册通过使用一种机制，如<ph id="ph2">&lt;xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph3">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph>尚未随后调用方法。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> operations have the following limitations:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> 操作具有以下限制：</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The exact time when the finalizer executes is undefined.</source>
          <target state="translated">终结器执行时的确切时间不确定。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>To ensure deterministic release of resources for instances of your class, implement a <ph id="ph1">`Close`</ph> method or provide a <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">若要确保确定性释放资源，对你的类的实例实现<ph id="ph1">`Close`</ph>方法，或者提供<ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph>实现。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</source>
          <target state="translated">两个对象的终结器不保证任何特定顺序运行即使另一个对象引用。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</source>
          <target state="translated">也就是说，如果对象 A 具有对对象 B 的引用，并且二者的终结器，对象 B 可能已经被终结的对象 A 终结器启动时。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The thread on which the finalizer runs is unspecified.</source>
          <target state="translated">终结器运行的线程未指定。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method might not run to completion or might not run at all under the following exceptional circumstances:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法可能无法运行完成，或可能根本不运行下列异常情况下：</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</source>
          <target state="translated">如果另一个终结器会无限期阻止 （进入无限循环，尝试获取的锁，它可以永远不会获取，等等）。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</source>
          <target state="translated">运行时尝试运行终结器来完成，因为其他终结器可能不会调用终结器块如果无限期。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If the process terminates without giving the runtime a chance to clean up.</source>
          <target state="translated">如果不提供机会清理的运行时，进程将终止。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</source>
          <target state="translated">在这种情况下，运行时的第一个通知的进程是终止的一个 DLL_PROCESS_DETACH 通知。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</source>
          <target state="translated">运行时将继续完成在关闭过程的对象，仅当可终结对象数目继续减少。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> or an override of <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active <ph id="ph3">`try`</ph><ph id="ph4">/</ph><ph id="ph5">`finally`</ph> blocks or finalizers are executed.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>或的重写<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>引发异常，并且运行时不承载的应用程序将替代默认策略，运行时终止进程，且无活动<ph id="ph3">`try`</ph> <ph id="ph4">/</ph> <ph id="ph5">`finally`</ph>块或执行终结器。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>This behavior ensures process integrity if the finalizer cannot free or destroy resources.</source>
          <target state="translated">如果终结器无法释放或销毁资源，则此行为确保处理完整性。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Overriding the Finalize method</source>
          <target state="translated">重写 Finalize 方法</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>You should override <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</source>
          <target state="translated">应重写<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>使用非托管的资源，如文件句柄或必须在垃圾回收期间放弃使用它们的托管的对象时释放的数据库连接的类。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>You shouldn't implement a <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method for managed objects because the garbage collector releases managed resources automatically.</source>
          <target state="translated">不应实现<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法托管对象，因为垃圾回收器自动释放托管的资源。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph>可用对象，则包装非托管的资源，建议的替代项是实现使用安全句柄的释放模式并不会覆盖<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>For more information, see <bpt id="p1">[</bpt>The SafeHandle alternative<ept id="p1">](#SafeHandle)</ept> section.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>SafeHandle 备用方法<ept id="p1">](#SafeHandle)</ept>部分。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method does nothing by default, but you should override <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> only if necessary, and only to release unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>方法不执行任何操作默认情况下，但应重写<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>仅当有必要，且仅释放非托管的资源。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</source>
          <target state="translated">回收内存倾向于长得多如果运行终止操作，因为它需要至少两个垃圾回收。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>In addition, you should override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method for reference types only.</source>
          <target state="translated">此外，你应该重写<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>仅类型引用的方法。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The common language runtime only finalizes reference types.</source>
          <target state="translated">公共语言运行时仅完成引用类型。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>It ignores finalizers on value types.</source>
          <target state="translated">它将忽略有关值类型的终结器。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The scope of the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method is <ph id="ph2">`protected`</ph>.</source>
          <target state="translated">作用域<ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>方法是<ph id="ph2">`protected`</ph>。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>You should maintain this limited scope when you override the method in your class.</source>
          <target state="translated">在你的类中重写该方法时，应保持此受限制的作用域。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>By keeping a <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method protected, you prevent users of your application from calling an object's <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method directly.</source>
          <target state="translated">通过让<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>受保护的方法，你可以阻止从调用对象的应用程序的用户<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>直接的方法。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Every implementation of <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> in a derived type must call its base type's implementation of <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">每个实现<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>派生类型中，则必须调用其基类型实现<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>This is the only case in which application code is allowed to call <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">这是其中的应用程序代码可以调用仅用例<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>An object's <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method shouldn't call a method on any objects other than that of its base class.</source>
          <target state="translated">对象的<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法不应在其基本类之外的任何对象上调用方法。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</source>
          <target state="translated">这是因为被调用的其他对象可能在被回收在同一时间调用的对象，如公共语言运行时关闭这种情况。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The C# compiler does not allow you to override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">C# 编译器不允许你重写<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Instead, you provide a finalizer by implementing a <bpt id="p1">[</bpt>destructor<ept id="p1">](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)</ept> for your class.</source>
          <target state="translated">相反，通过实现提供了终结器<bpt id="p1">[</bpt>析构函数<ept id="p1">](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)</ept>为您的类。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>A C# destructor automatically calls the destructor of its base class.</source>
          <target state="translated">C# 析构函数自动调用其基类的析构函数。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Visual C++ also provides its own syntax for implementing the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Visual c + + 还提供了其自己的语法，用于实现<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>For more information, see the "Destructors and finalizers" section of <bpt id="p1">[</bpt>How to: Define and Consume Classes and Structs (C++/CLI)<ept id="p1">](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)</ept>.</source>
          <target state="translated">有关详细信息，请参阅的"析构函数和终结器"部分<bpt id="p1">[</bpt>如何： 定义和使用类和结构 (C + + /cli CLI)<ept id="p1">](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)</ept>。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</source>
          <target state="translated">垃圾回收是不确定的因为你不知道确切地说时垃圾回收器执行终止。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>To release resources immediately, you can also choose to implement the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> and the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">若要释放资源立即，你还可以选择实现<bpt id="p1">[</bpt>释放模式<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>和<ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>接口。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method to free unmanaged resources in the event that the <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method is not called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph>实现可由使用者在类的释放非托管的资源，并且你可以使用<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法释放非托管的资源的事件中<ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>不调用方法。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> 后它已被清除在垃圾回收期间，能够执行几乎任何操作，包括再现的对象 （即，使该对象可访问再次）。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>However, the object can only be resurrected once; <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> cannot be called on resurrected objects during garbage collection.</source>
          <target state="translated">但是，该对象还能够仅重新一次;<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>在垃圾回收期间不能在复活对象上调用。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>There is one action that your implementation of <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> should never take: it should never throw an exception.</source>
          <target state="translated">一个操作，你实现<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>应永远不会采取： 它应永远不会引发异常。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If any exceptions thrown by methods called from the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method are unhandled by the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, the runtime assumes that the <ph id="ph3">&lt;xref:System.Object.Finalize%2A&gt;</ph> method returned and continues to call the <ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph> methods of other objects.</source>
          <target state="translated">如果从调用的方法引发的任何异常<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>处理方法<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法，运行时假设<ph id="ph3">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法返回，并且继续调用<ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph>其他对象的方法。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The SafeHandle alternative</source>
          <target state="translated">SafeHandle 备用方法</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> and <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> terminate the finalizer.</source>
          <target state="translated">创建可靠的终结器是通常难以进行，因为无法有关你的应用程序的状态作出假设以及因为未经处理的系统异常，如<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>和<ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph>终止终结器。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</source>
          <target state="translated">而非实现终结器为您的类释放非托管的资源，你可以使用派生自的对象<ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph>类来包装非托管的资源，，然后实现而无需终结器的释放模式。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The .NET Framework provides the following classes in the <ph id="ph1">&lt;xref:Microsoft.Win32?displayProperty=nameWithType&gt;</ph> namespace that are derived from <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph>:</source>
          <target state="translated">.NET Framework 提供了中的以下类<ph id="ph1">&lt;xref:Microsoft.Win32?displayProperty=nameWithType&gt;</ph>派生自的命名空间<ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> is a wrapper class for a file handle.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> 是的文件句柄的包装类。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph> is a wrapper class for memory-mapped file handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph> 为内存映射文件句柄的包装类。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> is a wrapper class for a pointer to a block of unmanaged memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> 是指向非托管内存块的指针的包装类。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph>, <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>, and <ph id="ph3">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph> are wrapper classes for cryptographic handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph><ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>，和<ph id="ph3">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph>是加密的句柄的包装类。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> is a wrapper class for pipe handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> 是管道句柄的包装类。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> is a wrapper class for a handle to a registry key.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> 是用于注册表项的句柄的包装类。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> is a wrapper class for a wait handle.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> 是用于的等待句柄的包装类。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The following example uses the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> with safe handles instead of overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例使用<bpt id="p1">[</bpt>释放模式<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>而不是重写的安全句柄<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>It defines a <ph id="ph1">`FileAssociation`</ph> class that wraps registry information about the application that handles files with a particular file extension.</source>
          <target state="translated">它定义<ph id="ph1">`FileAssociation`</ph>包装的应用程序处理具有特定文件扩展名的文件的注册表信息的类。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The two registry handles returned as <ph id="ph1">`out`</ph> parameters by Windows <bpt id="p1">[</bpt>RegOpenKeyEx<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)</ept> function calls are passed to the <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> constructor.</source>
          <target state="translated">作为返回两个注册表句柄<ph id="ph1">`out`</ph>参数由 Windows <bpt id="p1">[</bpt>RegOpenKeyEx<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)</ept>函数调用传递到<ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The type's protected <ph id="ph1">`Dispose`</ph> method then calls the <ph id="ph2">`SafeRegistryHandle.Dispose`</ph> method  to free these two handles.</source>
          <target state="translated">类型的受保护<ph id="ph1">`Dispose`</ph>方法然后调用<ph id="ph2">`SafeRegistryHandle.Dispose`</ph>方法释放这些两个控点。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The following example verifies that the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method is called when an object that overrides <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> is destroyed.</source>
          <target state="translated">下面的示例验证<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>对象可重写时，调用方法<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>被销毁。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Note that, in a production application, the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method would be overridden to release unmanaged resources held by the object.</source>
          <target state="translated">请注意，在生产应用程序，<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>将重写方法，以释放由对象拥有的非托管的资源。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Also note that the C# example provides a destructor instead of overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">另请注意，C# 示例提供了析构函数而不是重写<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>For an additional example that overrides the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, see the <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">有关其他示例重写<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法，请参阅<ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Object.GetHashCode">
          <source>Serves as the default hash function.</source>
          <target state="translated">作为默认哈希函数。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Object.GetHashCode">
          <source>A hash code for the current object.</source>
          <target state="translated">当前对象的哈希代码。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> class, the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class, or a type derived from the <ph id="ph3">&lt;xref:System.Collections.DictionaryBase&gt;</ph> class.</source>
          <target state="translated">哈希代码是一个数字值，用于插入和标识基于哈希的集合中的对象，例如<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>类，<ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>类或派生自类型<ph id="ph3">&lt;xref:System.Collections.DictionaryBase&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method provides this hash code for algorithms that need quick checks of object equality.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法为需要的对象相等性的快速检查的算法提供此哈希代码。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the <bpt id="p1">[</bpt>Hash Function<ept id="p1">](https://en.wikipedia.org/wiki/Hash_function)</ept> entry in Wikipedia.</source>
          <target state="translated">有关如何在哈希表中使用哈希代码的信息以及一些其他的哈希代码算法，请参阅<bpt id="p1">[</bpt>哈希函数<ept id="p1">](https://en.wikipedia.org/wiki/Hash_function)</ept>Wikipedia 中的条目。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Two objects that are equal return hash codes that are equal.</source>
          <target state="translated">是相等的相等的返回哈希代码的两个对象。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</source>
          <target state="translated">但是，反过来并不成立： 相等的哈希代码并不表示对象相等性，因为不同 （不相等） 的对象可以具有相同的哈希代码。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Furthermore, the .NET Framework does not guarantee the default implementation of the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms.</source>
          <target state="translated">此外，.NET Framework 并不保证的默认实现<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法和此方法所返回的.NET Framework 版本和平台，例如，32 位和 64 位平台之间可能不同的值。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</source>
          <target state="translated">出于这些原因，请不用作此方法的默认实现的唯一对象标识符哈希的目的。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Two consequences follow from this:</source>
          <target state="translated">从此请按照以下两种结果操作：</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You should not assume that equal hash codes imply object equality.</source>
          <target state="translated">不应假定相等的哈希代码表示对象是否相等。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</source>
          <target state="translated">永远不应将存在，或者在其中创建它，在应用程序域使用的哈希代码，因为相同的对象可能哈希处理跨应用程序域、 过程和平台。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</source>
          <target state="translated">哈希代码旨在高效插入和基于哈希表的集合中查找。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash code is not a permanent value.</source>
          <target state="translated">哈希代码不是永久的值。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For this reason:</source>
          <target state="translated">出于此原因：</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not serialize hash code values or store them in databases.</source>
          <target state="translated">不序列化哈希代码值或将它们存储在数据库中。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not use the hash code as the key to retrieve an object from a keyed collection.</source>
          <target state="translated">不使用的哈希代码作为键从是键控集合中检索对象。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not send hash codes across application domains or processes.</source>
          <target state="translated">不要跨应用程序域或进程发送的哈希代码。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In some cases, hash codes may be computed on a per-process or per-application domain basis.</source>
          <target state="translated">在某些情况下，可能会基于每个进程或每个应用程序域计算哈希代码。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</source>
          <target state="translated">不要使用而不是返回的加密哈希函数，如果你需要加密型强哈希值的哈希代码。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For cryptographic hashes, use a class derived from the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">对于加密哈希，使用派生自的类<ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph>或<ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not test for equality of hash codes to determine whether two objects are equal.</source>
          <target state="translated">先不要测试相等的哈希代码，以确定两个对象是否相等。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>(Unequal objects can have identical hash codes.) To test for equality, call the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method.</source>
          <target state="translated">（不相等的对象可以具有相同的哈希代码。）若要测试相等性，调用<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method can be overridden by a derived type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>派生类型可以重写方法。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> is not overridden, hash codes for reference types are computed by calling the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method of the base class, which computes a hash code based on an object's reference; for more information, see <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>是不重写，哈希代码为引用类型计算通过调用<ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>的基类，计算哈希代码的方法基于对象的引用; 有关详细信息，请参阅<ph id="ph3">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In other words, two objects for which the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> have identical hash codes.</source>
          <target state="translated">换而言之，两个对象为其<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法返回<ph id="ph2">`true`</ph>具有相同的哈希代码。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If value types do not override <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</source>
          <target state="translated">如果值类型不会重写<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>基本类的方法使用反射来计算基于该类型的字段的值的哈希代码。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In other words, value types whose fields have equal values have equal hash codes.</source>
          <target state="translated">换而言之，其字段具有相等的值的值类型具有相等的哈希代码。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For more information about overriding <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, see the "Notes to Inheritors" section.</source>
          <target state="translated">有关重写<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>，请参阅"对继承者的说明"部分。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If you override the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, you should also override <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>, and vice versa.</source>
          <target state="translated">如果你重写<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法，则应重写<ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>，反之亦然。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If your overridden <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> when two objects are tested for equality, your overridden <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method must return the same value for the two objects.</source>
          <target state="translated">如果你重写<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>方法返回<ph id="ph2">`true`</ph>两个对象是否相等，重写的测试时<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法必须返回两个对象相同的值。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If an object that is used as a key in a hash table does not provide a useful implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, you can specify a hash code provider by supplying an <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> implementation to one of the overloads of the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> class constructor.</source>
          <target state="translated">如果用作哈希表中的键的对象未提供的有用实现<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>，你可以指定哈希代码提供程序通过提供<ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph>实现的重载之一<ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>类构造函数。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">说明 <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">当调用<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>中类方法<ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>，它不会覆盖的类提供的默认行为<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">这是.NET Framework 提供的支持的一部分<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>(请参阅<bpt id="p1">[</bpt>.NET Framework 支持为 Windows 应用商店应用和 Windows 运行时<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>)。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and currently don’t implement a <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">中的类<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>不继承<ph id="ph2">&lt;xref:System.Object&gt;</ph>，并且不要实施<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>However, they appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">但是，它们会显示为具有<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>，和<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法在 C# 或 Visual Basic 代码中，使用它们以及.NET Framework 为这些方法提供的默认行为时。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> 用 C# 或 Visual Basic 编写的类可以重写<ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <ph id="ph1">&lt;xref:System.Int32&gt;</ph> type is to simply return that value.</source>
          <target state="translated">计算具有相同或比范围较小的数字值的哈希代码的最简单方法之一<ph id="ph1">&lt;xref:System.Int32&gt;</ph>类型是只需返回该值。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The following example shows such an implementation for a <ph id="ph1">`Number`</ph> structure.</source>
          <target state="translated">下面的示例演示此类的实现<ph id="ph1">`Number`</ph>结构。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Frequently, a type has multiple data fields that can participate in generating the hash code.</source>
          <target state="translated">通常情况下，类型具有多个可以参与生成的哈希代码的数据字段。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>One way to generate a hash code is to combine these fields using an <ph id="ph1">`XOR (eXclusive OR)`</ph> operation, as shown in the following example.</source>
          <target state="translated">生成的哈希代码的一种方法是组合使用这些字段<ph id="ph1">`XOR (eXclusive OR)`</ph>操作，如下面的示例中所示。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</source>
          <target state="translated">前面的示例返回 (n1，n2) 的同一哈希代码和 (n2，n1)，因此，可能会生成不是所需的多个冲突。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A number of solutions are available so that hash codes in these cases are not identical.</source>
          <target state="translated">有多种解决方案都是可用的以便在这些情况下的哈希代码不相同。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>One is to return the hash code of a <ph id="ph1">`Tuple`</ph> object that reflects the order of each field.</source>
          <target state="translated">一个是要返回的哈希代码<ph id="ph1">`Tuple`</ph>反映每个字段的顺序的对象。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The following example shows a possible implementation that uses the <ph id="ph1">&lt;xref:System.Tuple%602&gt;</ph> class.</source>
          <target state="translated">下面的示例演示使用的可能实现<ph id="ph1">&lt;xref:System.Tuple%602&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Note, though, that the performance overhead of instantiating a <ph id="ph1">`Tuple`</ph> object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</source>
          <target state="translated">但请注意，该实例化的性能开销<ph id="ph1">`Tuple`</ph>对象可能会显著影响哈希表中存储大量对象的应用程序的整体性能。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</source>
          <target state="translated">第二个备选解决方案涉及的两个或多个位由连续的字段的哈希代码进行左移权重的单个哈希代码。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</source>
          <target state="translated">最佳状况运行，而不是被丢弃，移出第 31 位的位应环绕而不是被放弃。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</source>
          <target state="translated">由于 C# 和 Visual Basic 中的左移运算符的情况下，位将被丢弃，这就需要创建一个左的 shift 包装方法如下所示：</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The following example then uses this shift-and-wrap method to compute the hash code of the <ph id="ph1">`Point`</ph> structure used in the previous examples.</source>
          <target state="translated">下面的示例然后使用此 shift 包装方法来计算的哈希代码<ph id="ph1">`Point`</ph>前面的示例中使用结构。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object.</source>
          <target state="translated">哈希函数用于快速将生成一个对象的值相对应的数字 （哈希代码）。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input.</source>
          <target state="translated">哈希函数通常是特定于每种类型，和的唯一性，必须使用至少一个实例字段作为输入。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Hash codes should not be computed by using the values of static fields.</source>
          <target state="translated">使用静态字段的值，不应计算哈希代码。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For classes derived from <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>, the <ph id="ph2">&lt;see langword="GetHashCode" /&gt;</ph> method can delegate to the base class <ph id="ph3">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> implementation only if the derived class defines equality to be reference equality.</source>
          <target state="translated">类派生自<ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>、<ph id="ph2">&lt;see langword="GetHashCode" /&gt;</ph>方法才可以委托给基类<ph id="ph3">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>仅当派生的类定义的相等性可引用相等性的实现。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The default implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> for reference types returns a hash code that is equivalent to the one returned by the <ph id="ph2">&lt;see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /&gt;</ph> method.</source>
          <target state="translated">默认实现<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>对于引用类型返回的哈希代码，它等效于由一个<ph id="ph2">&lt;see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You can override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> for immutable reference types.</source>
          <target state="translated">您可以重写<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>对于不可变的引用类型。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In general, for mutable reference types, you should override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> only if:</source>
          <target state="translated">一般情况下，对于可变引用类型，则应重写<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>才：</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You can compute the hash code from fields that are not mutable; or</source>
          <target state="translated">您可以计算字段不是可变; 中的哈希代码或</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</source>
          <target state="translated">你可以确保可变对象的哈希代码不会更改时的对象包含在一个集合，其中依赖于其哈希代码。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Otherwise, you might think that the mutable object is lost in the hash table.</source>
          <target state="translated">否则，你可能认为，在哈希表中丢失的可变对象。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If you do choose to override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.</source>
          <target state="translated">如果你选择重写<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>对于可变的引用类型，你的文档应将其清除该对象存储在哈希表中时，你的类型的用户不应修改对象值。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For value types, <ph id="ph1">&lt;see cref="M:System.ValueType.GetHashCode" /&gt;</ph> provides a default hash code implementation that uses reflection.</source>
          <target state="translated">对于值类型，<ph id="ph1">&lt;see cref="M:System.ValueType.GetHashCode" /&gt;</ph>提供一个默认哈希代码实现，使用反射。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You should consider overriding it for better performance.</source>
          <target state="translated">你应考虑重写它以提高性能。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For more information and examples that compute hash codes in a variety of ways, see the Examples section.</source>
          <target state="translated">有关详细信息和计算各种不同的方式的哈希代码的示例，请参阅示例部分。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash function must have the following properties:</source>
          <target state="translated">哈希函数必须具有以下属性：</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If two objects compare as equal, the <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> method for each object must return the same value.</source>
          <target state="translated">如果两个对象的比较结果为相等，<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>每个对象的方法必须返回相同的值。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>However, if two objects do not compare as equal, the <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> methods for the two objects do not have to return different values.</source>
          <target state="translated">但是，如果两个对象不相等，比较<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>两个对象的方法不需要返回不同的值。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's <bpt id="p1">[</bpt>System.Object.Equals<ept id="p1">](xref:System.Object.Equals*)</ept> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>对象的方法必须始终返回相同的哈希代码，只要不没有对确定返回值的对象的对象状态的任何修改<bpt id="p1">[</bpt>System.Object.Equals<ept id="p1">](xref:System.Object.Equals*)</ept>方法。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.</source>
          <target state="translated">请注意，这是仅适用当前执行应用程序，并且，如果再次运行应用程序，也可以返回不同的哈希代码。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered.</source>
          <target state="translated">为了获得最佳性能，哈希函数应生成均匀分布于所有输入，包括已大量群集化的输入。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.</source>
          <target state="translated">含意为对对象状态的小修改应导致大型修改哈希表的最佳性能的生成哈希代码。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Hash functions should be inexpensive to compute.</source>
          <target state="translated">哈希函数应该是成本较低，来计算。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> method should not throw exceptions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>方法不应引发异常。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For example, the implementation of the <ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph> method provided by the <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> class returns identical hash codes for identical string values.</source>
          <target state="translated">例如，实现<ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph>方法提供的<ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>类返回相同的字符串值的相同的哈希代码。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Therefore, two <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects return the same hash code if they represent the same string value.</source>
          <target state="translated">因此，两个<ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>对象返回相同的哈希代码，如果它们表示相同的字符串值。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</source>
          <target state="translated">此外，该方法使用的所有字符在字符串中来生成相当随机的分布式输出，即使输入群集在某些范围内 (例如，许多用户可能具有仅包含低 128 ASCII 字符，即使的字符串字符串可以包含任何 65535 个 Unicode 字符）。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table.</source>
          <target state="translated">在类上提供的很好的哈希函数可能会将这些对象添加到哈希表的性能显著影响。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation).</source>
          <target state="translated">在具有键提供哈希函数的良好实现哈希表中，搜索的元素所用常量时间内的 （例如，o （1） 操作）。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of items in the hash table).</source>
          <target state="translated">哈希函数的不佳实现哈希表，在搜索的性能取决于哈希表中的项的数目 (例如，O (<ph id="ph1">`n`</ph>) 操作，其中<ph id="ph2">`n`</ph>是哈希表中的项的数目)。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:</source>
          <target state="translated">恶意用户可以输入增加的冲突，会大大降低取决于哈希表，在以下情况下的应用程序的性能数量的数据：</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When hash functions produce frequent collisions.</source>
          <target state="translated">当哈希函数生成频繁冲突。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.</source>
          <target state="translated">当哈希表中的对象的大部分生成相等或在大约等于另一个的哈希代码。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When users input the data from which the hash code is computed.</source>
          <target state="translated">当用户输入的数据从其计算的哈希代码。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Derived classes that override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> must also override <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> to guarantee that two objects considered equal have the same hash code; otherwise, the <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> type might not work correctly.</source>
          <target state="translated">派生类重写<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>还必须重写<ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>若要确保视为相等的两个对象具有相同的哈希代码; 否则为<ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>类型可能无法正常工作。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Object.GetType">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the current instance.</source>
          <target state="translated">获取当前实例的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Object.GetType">
          <source>The exact runtime type of the current instance.</source>
          <target state="translated">当前实例的准确运行时类型。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Because <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> is the base class for all types in the .NET Framework type system, the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method can be used to return <ph id="ph3">&lt;xref:System.Type&gt;</ph> objects that represent all .NET Framework types.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>在.NET Framework 类型系统中，是所有类型的基类<ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph>方法可以用于返回<ph id="ph3">&lt;xref:System.Type&gt;</ph>表示所有.NET Framework 类型的对象。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The .NET Framework recognizes the following five categories of types:</source>
          <target state="translated">.NET Framework 可识别类型的以下五个类别：</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Classes, which are derived from <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>,</source>
          <target state="translated">类，该类派生自<ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>，</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Value types, which are derived from <ph id="ph1">&lt;xref:System.ValueType?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">值类型，派生自<ph id="ph1">&lt;xref:System.ValueType?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Interfaces, which are derived from <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> starting with the .NET Framework 2.0.</source>
          <target state="translated">接口，派生自<ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>从.NET Framework 2.0 开始。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Enumerations, which are derived from <ph id="ph1">&lt;xref:System.Enum?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">枚举，派生自<ph id="ph1">&lt;xref:System.Enum?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Delegates, which are derived from <ph id="ph1">&lt;xref:System.MulticastDelegate?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">委托，它派生自<ph id="ph1">&lt;xref:System.MulticastDelegate?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>For two objects <ph id="ph1">`x`</ph> and <ph id="ph2">`y`</ph> that have identical runtime types, <ph id="ph3">`Object.ReferenceEquals(x.GetType(),y.GetType())`</ph> returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">两个对象<ph id="ph1">`x`</ph>和<ph id="ph2">`y`</ph>具有相同的运行时类型<ph id="ph3">`Object.ReferenceEquals(x.GetType(),y.GetType())`</ph>返回<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method with the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method to determine whether one numeric value is the same type as two other numeric values.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph>方法替换<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法来确定一个数字值是否与其他两个数值的类型相同。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</source>
          <target state="translated">若要确定对象是否是特定类型，可以使用你的语言的类型比较关键字或构造。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>For example, you can use the <ph id="ph1">`TypeOf…Is`</ph> construct in Visual Basic or the <ph id="ph2">`is`</ph> keyword in C#.</source>
          <target state="translated">例如，你可以使用<ph id="ph1">`TypeOf…Is`</ph>在 Visual Basic 中构造或<ph id="ph2">`is`</ph>C# 中的关键字。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method is inherited by all types that derive from <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph>方法由派生自的所有类型继承<ph id="ph2">&lt;xref:System.Object&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>This means that, in addition to using your own language's comparison keyword, you can use the <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method to determine the type of a particular object, as the following example shows.</source>
          <target state="translated">这意味着，除了使用你自己的语言的比较关键字，你可以使用<ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph>方法来确定的一种特定的对象，如以下示例所示。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object exposes the metadata associated with the class of the current <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph>对象公开的类的当前关联的元数据<ph id="ph2">&lt;xref:System.Object&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The following code example demonstrates that <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> returns the runtime type of the current instance.</source>
          <target state="translated">下面的代码示例演示<ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph>返回当前实例的运行时类型。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Object.MemberwiseClone">
          <source>Creates a shallow copy of the current <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">创建当前 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> 的浅表副本。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Object.MemberwiseClone">
          <source>A shallow copy of the current <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> 的浅表副本。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>The <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>方法创建的新对象，然后将当前对象的非静态字段复制到新的对象创建的浅表副本。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>If a field is a value type, a bit-by-bit copy of the field is performed.</source>
          <target state="translated">如果字段是值类型，则执行字段的按位复制。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</source>
          <target state="translated">如果字段是引用类型，引用将复制，但被引用的对象不;因此，原始对象和其克隆引用同一对象。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</source>
          <target state="translated">例如，考虑对象称为 X 引用对象 A 和 B，反过来，引用对象 c。X 的浅表副本创建新的对象 X2 也引用对象 A 和 b。与此相反，X 的深层副本创建新对象 X2 引用 A2 和 B2，是的一个副本的新对象并 B.B2，反过来，引用新对象 C2，这是 C 的副本。该示例说明浅和深层复制操作之间的差异。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method does not meet your needs.</source>
          <target state="translated">有很多方法可以实现深层复制操作，如果浅表复制操作由<ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>方法并不满足你的需求。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>These include the following:</source>
          <target state="translated">其中包括：</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</source>
          <target state="translated">调用类构造函数要复制可以使用来自第一个对象的属性值创建第二个对象的对象。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>This assumes that the values of an object are entirely defined by its class constructor.</source>
          <target state="translated">这假定，对象的值完全由其类构造函数中定义。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Call the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>方法创建一个对象，对象的浅表副本并将其值是与原始对象的任何属性或其值是引用类型的字段相同的新对象。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>The <ph id="ph1">`DeepCopy`</ph> method in the example illustrates this approach.</source>
          <target state="translated"><ph id="ph1">`DeepCopy`</ph>方法在示例中演示了此方法。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</source>
          <target state="translated">序列化对象是较深复制，，然后将序列化的数据还原到另一个对象变量。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Use reflection with recursion to perform the deep copy operation.</source>
          <target state="translated">使用具有递归反射来执行深层复制操作。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例演示<ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>It defines a <ph id="ph1">`ShallowCopy`</ph> method that calls the <ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method to perform a shallow copy operation on a <ph id="ph3">`Person`</ph> object.</source>
          <target state="translated">它定义<ph id="ph1">`ShallowCopy`</ph>调用的方法<ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>方法来执行上的浅表复制操作<ph id="ph3">`Person`</ph>对象。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>It also defines a <ph id="ph1">`DeepCopy`</ph> method that performs a deep copy operation on a <ph id="ph2">`Person`</ph> object.</source>
          <target state="translated">它还定义<ph id="ph1">`DeepCopy`</ph>执行深层复制操作的方法<ph id="ph2">`Person`</ph>对象。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>In this example, the <ph id="ph1">`Person.IdInfo`</ph> property returns an <ph id="ph2">`IdInfo`</ph> object.</source>
          <target state="translated">在此示例中，<ph id="ph1">`Person.IdInfo`</ph>属性返回<ph id="ph2">`IdInfo`</ph>对象。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>As the output from the example shows, when a <ph id="ph1">`Person`</ph> object is cloned by calling the <ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method, the cloned <ph id="ph3">`Person`</ph> object is an independent copy of the original object, except that they share the same <ph id="ph4">`Person.IdInfo`</ph> object reference.</source>
          <target state="translated">如示例所示，输出时<ph id="ph1">`Person`</ph>通过调用克隆对象<ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>方法时，克隆<ph id="ph3">`Person`</ph>对象是原始对象，而的独立副本，只不过它们共享相同<ph id="ph4">`Person.IdInfo`</ph>对象引用。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>As a result, modifying the clone's <ph id="ph1">`Person.IdInfo`</ph> property changes the original object's <ph id="ph2">`Person.IdInfo`</ph> property.</source>
          <target state="translated">因此，修改克隆的<ph id="ph1">`Person.IdInfo`</ph>属性更改原始对象的<ph id="ph2">`Person.IdInfo`</ph>属性。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>On the other hand, when a deep copy operation is performed, the cloned <ph id="ph1">`Person`</ph> object, including its <ph id="ph2">`Person.IdInfo`</ph> property, can be modified without affecting the original object.</source>
          <target state="translated">另一方面，执行深层副本操作时，克隆<ph id="ph1">`Person`</ph>对象，包括其<ph id="ph2">`Person.IdInfo`</ph>属性，可以进行修改而不会影响原始对象。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>The first object to compare.</source>
          <target state="translated">要比较的第一个对象。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>The second object  to compare.</source>
          <target state="translated">要比较的第二个对象。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> instances are the same instance.</source>
          <target state="translated">确定指定的 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> 实例是否是相同的实例。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="objA" /&gt;</ph> is the same instance as <ph id="ph3">&lt;paramref name="objB" /&gt;</ph> or if both are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="objA" /&gt;</ph> 是与 <ph id="ph3">&lt;paramref name="objB" /&gt;</ph> 相同的实例，或两者均为 null，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method and the equality operator, the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method cannot be overridden.</source>
          <target state="translated">与不同<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>方法和相等运算符，<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>不重写方法。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>Because of this, if you want to test two object references for equality and you are unsure about the implementation of the <ph id="ph1">`Equals`</ph> method, you can call the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">因此，如果你想要测试两个对象是否相等的引用和你不确定的实现<ph id="ph1">`Equals`</ph>方法时，你可以调用<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>However, the return value of the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method may appear to be anomalous in these two scenarios:</source>
          <target state="translated">但是的返回值<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法可能看起来存在异常在这些两种方案：</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>When comparing value types.</source>
          <target state="translated">比较值类型。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>If <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are value types, they are boxed before they are passed to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">如果<ph id="ph1">`objA`</ph>和<ph id="ph2">`objB`</ph>是值类型，它们先它们传递给装箱<ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>This means that if both <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> represent the same instance of a value type, the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method nevertheless returns <ph id="ph4">`false`</ph>, as the following example shows.</source>
          <target state="translated">这意味着，如果这两个<ph id="ph1">`objA`</ph>和<ph id="ph2">`objB`</ph>表示值类型，同一个实例<ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法尽管如此返回<ph id="ph4">`false`</ph>，如下面的示例所示。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>For information on boxing value types, see <bpt id="p1">[</bpt>Boxing and Unboxing<ept id="p1">](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)</ept>.</source>
          <target state="translated">装箱值类型的信息，请参阅<bpt id="p1">[</bpt>装箱和取消装箱<ept id="p1">](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>When comparing strings.</source>
          <target state="translated">当比较字符串。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>If <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are strings, the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method returns <ph id="ph4">`true`</ph> if the string is interned.</source>
          <target state="translated">如果<ph id="ph1">`objA`</ph>和<ph id="ph2">`objB`</ph>都是字符串，<ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>方法返回<ph id="ph4">`true`</ph>如果字符串暂留。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>It does not perform a test for value equality.</source>
          <target state="translated">它不执行测试的值相等。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>In the following example, <ph id="ph1">`s1`</ph> and <ph id="ph2">`s2`</ph> are equal because they are two instances of a single interned string.</source>
          <target state="translated">在下面的示例中，<ph id="ph1">`s1`</ph>和<ph id="ph2">`s2`</ph>因为它们是单个暂存字符串的两个实例是否相等。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>However, <ph id="ph1">`s3`</ph> and <ph id="ph2">`s4`</ph> are not equal, because although they are have identical string values, that string is not interned.</source>
          <target state="translated">但是，<ph id="ph1">`s3`</ph>和<ph id="ph2">`s4`</ph>是否不相等，因为尽管它们都具有相同的字符串值，但该字符串不暂留。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>For more information about string interning, see <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">有关字符串暂留的详细信息，请参阅<ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> to determine if two objects are the same instance.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>以确定两个对象是否相同的实例。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Object.ToString">
          <source>Returns a string that represents the current object.</source>
          <target state="translated">返回表示当前对象的字符串。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Object.ToString">
          <source>A string that represents the current object.</source>
          <target state="translated">表示当前对象的字符串。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> is the major formatting method in the .NET Framework.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> 主要格式设置.NET Framework 中的方法。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It converts an object to its string representation so that it is suitable for display.</source>
          <target state="translated">以便它适合于显示，它将对象转换为其字符串表示形式。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>(For information about formatting support in the .NET Framework, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.) Default implementations of the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method return the fully qualified name of the object's type.</source>
          <target state="translated">(有关格式设置支持.NET Framework 中的信息，请参阅<bpt id="p1">[</bpt>格式化类型<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>。)默认实现<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法返回的对象类型的完全限定的名称。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You may have reached this page by following the link from the member list of another type.</source>
          <target state="translated">你可能已达到了此页从成员列表中的另一种类型，按照以下链接。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>That is because that type does not override <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">这是因为该类型不会覆盖<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Instead, it inherits the functionality of the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">相反，它继承的功能<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Types frequently override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to provide a more suitable string representation of a particular type.</source>
          <target state="translated">经常重写类型<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法以提供更适合的字符串表示形式的特定类型。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Types also frequently overload the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to provide support for format strings or culture-sensitive formatting.</source>
          <target state="translated">类型也经常重载<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法以提供支持的格式字符串或区分区域性的格式。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>In this section:</source>
          <target state="translated">本节内容：</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>The default Object.ToString() method<ept id="p1">](#Default)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>默认 Object.ToString() 方法<ept id="p1">](#Default)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Overriding the Object.ToString() method<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>重写 Object.ToString() 方法<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Overloading the ToString method<ept id="p1">](#Overloading)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>重载 ToString 方法<ept id="p1">](#Overloading)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Extending the Object.ToString method<ept id="p1">](#Extending)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>扩展 Object.ToString 方法<ept id="p1">](#Extending)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Notes for the Windows Runtime<ept id="p1">](#WinRT)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Windows 运行时的注意事项<ept id="p1">](#WinRT)</ept></target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The default Object.ToString() method</source>
          <target state="translated">默认 Object.ToString() 方法</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The default implementation of the <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method returns the fully qualified name of the type of the <ph id="ph2">&lt;xref:System.Object&gt;</ph>, as the following example shows.</source>
          <target state="translated">默认实现<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>方法返回的类型的完全限定的名称<ph id="ph2">&lt;xref:System.Object&gt;</ph>，如下面的示例所示。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Because <ph id="ph1">&lt;xref:System.Object&gt;</ph> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Object&gt;</ph>是所有引用类型的基类在.NET Framework 中，此行为由引用类型继承不会重写<ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example illustrates this.</source>
          <target state="translated">下面的示例阐释了这一点。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It defines a class named <ph id="ph1">`Object1`</ph> that accepts the default implementation of all <ph id="ph2">&lt;xref:System.Object&gt;</ph> members.</source>
          <target state="translated">它定义一个名为<ph id="ph1">`Object1`</ph>接受所有的默认实现<ph id="ph2">&lt;xref:System.Object&gt;</ph>成员。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Its <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method returns the object's fully qualified type name.</source>
          <target state="translated">其<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>方法返回的对象的完全限定的类型名称。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overriding the Object.ToString() method</source>
          <target state="translated">重写 Object.ToString() 方法</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Types commonly override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to return a string that represents the object instance.</source>
          <target state="translated">类型通常覆盖<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法以返回一个字符串，表示对象实例。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For example, the base types such as <ph id="ph1">&lt;xref:System.Char&gt;</ph>, <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, and <ph id="ph3">&lt;xref:System.String&gt;</ph> provide <ph id="ph4">&lt;xref:System.Object.ToString%2A&gt;</ph> implementations that return the string form of the value that the object represents.</source>
          <target state="translated">例如，基类型，如<ph id="ph1">&lt;xref:System.Char&gt;</ph>， <ph id="ph2">&lt;xref:System.Int32&gt;</ph>，和<ph id="ph3">&lt;xref:System.String&gt;</ph>提供<ph id="ph4">&lt;xref:System.Object.ToString%2A&gt;</ph>返回该对象表示的值的字符串形式的实现。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example defines a class, <ph id="ph1">`Object2`</ph>, that overrides the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method to return the type name along with its value.</source>
          <target state="translated">下面的示例定义了一个类<ph id="ph1">`Object2`</ph>，可重写<ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph>方法以返回及其值的类型名称。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following table lists the type categories in the .NET Framework and indicates whether or not they override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">下表列出了.NET Framework 中的类型类别，并指示它们是否将覆盖<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Type category</source>
          <target state="translated">类型类别</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overrides Object.ToString()</source>
          <target state="translated">替代 Object.ToString()</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Behavior</source>
          <target state="translated">行为</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Class</source>
          <target state="translated">类</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">n/a</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">n/a</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Structure</source>
          <target state="translated">结构</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Yes (<ph id="ph1">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph>)</source>
          <target state="translated">是 (<ph id="ph1">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph>)</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Same as Object.ToString()</source>
          <target state="translated">Object.ToString() 相同</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Enumeration</source>
          <target state="translated">枚举</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Yes (<ph id="ph1">&lt;xref:System.Enum.ToString?displayProperty=nameWithType&gt;</ph>)</source>
          <target state="translated">是 (<ph id="ph1">&lt;xref:System.Enum.ToString?displayProperty=nameWithType&gt;</ph>)</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The member name</source>
          <target state="translated">成员名称</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Interface</source>
          <target state="translated">接口</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">n/a</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Delegate</source>
          <target state="translated">委托</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">n/a</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>See the Notes to Inheritors section for additional information on overriding <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
          <target state="translated">重写，请参阅备注继承者部分以了解更多信息<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overloading the ToString method</source>
          <target state="translated">重载 ToString 方法</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>In addition to overriding the parameterless <ph id="ph1">&lt;xref:System.Object.ToString?displayProperty=nameWithType&gt;</ph> method, many types overload the <ph id="ph2">`ToString`</ph> method to provide versions of the method that accept parameters.</source>
          <target state="translated">除了重写的无参数<ph id="ph1">&lt;xref:System.Object.ToString?displayProperty=nameWithType&gt;</ph>方法，许多类型重载<ph id="ph2">`ToString`</ph>方法以提供的方法接受参数的版本。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</source>
          <target state="translated">通常情况下，这样做是为了提供对变量的格式设置和区分区域性的格式设置支持。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example overloads the <ph id="ph1">`ToString`</ph> method to return a result string that includes the value of various fields of an <ph id="ph2">`Automobile`</ph> class.</source>
          <target state="translated">以下示例重载<ph id="ph1">`ToString`</ph>方法以返回包含的各个字段的值的结果字符串<ph id="ph2">`Automobile`</ph>类。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</source>
          <target state="translated">它定义了四个格式字符串： G，返回的模型名称和年;D，返回的模型名称、 年、 和的门; 数C，后者返回模型名称、 年和柱面;和 A，它返回所有四个字段值的字符串。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example calls the overloaded <ph id="ph1">&lt;xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method to display culture-sensitive formatting of a currency value.</source>
          <target state="translated">下面的示例调用重载<ph id="ph1">&lt;xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>方法以显示货币值的区分区域性的格式。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For more information on format strings and culture-sensitive formatting, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
          <target state="translated">格式字符串和区分区域性的格式设置的详细信息，请参阅<bpt id="p1">[</bpt>格式化类型<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For the format strings supported by numeric values, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">有关支持的数字值的格式字符串，请参阅<bpt id="p1">[</bpt>标准数字格式字符串<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>和<bpt id="p2">[</bpt>自定义数字格式字符串<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For the format strings supported by date and time values, see <bpt id="p1">[</bpt>Standard Date and Time Format Strings<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Date and Time Format Strings<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.</source>
          <target state="translated">有关支持的日期和时间值的格式字符串，请参阅<bpt id="p1">[</bpt>标准日期和时间格式字符串<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept>和<bpt id="p2">[</bpt>自定义日期和时间格式字符串<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Extending the Object.ToString method</source>
          <target state="translated">扩展 Object.ToString 方法</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Because a type inherits the default <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method, you may find its behavior undesirable and want to change it.</source>
          <target state="translated">由于类型都继承默认值<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法，你可能会查找其行为不需要并想要对其进行更改。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>This is particularly true of arrays and collection classes.</source>
          <target state="translated">这是数组和集合类尤其如此。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>While you may expect the <ph id="ph1">`ToString`</ph> method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</source>
          <target state="translated">时可能会遇到<ph id="ph1">`ToString`</ph>方法的数组或集合类来显示其成员的值，它改为显示的类型完全限定的类型名称，如以下示例所示。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You have several options to produce the result string that you'd like.</source>
          <target state="translated">你有若干选项来生成你想要的结果字符串。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the type is an array, a collection object, or an object that implements the <ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interfaces, you can enumerate its elements by using the <ph id="ph3">`foreach`</ph> statement in C# or the <ph id="ph4">`For Each...Next`</ph> construct in Visual Basic.</source>
          <target state="translated">如果类型是数组、 集合对象或实现的对象<ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph>或<ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>接口，可以通过使用枚举其元素<ph id="ph3">`foreach`</ph>C# 中的语句或<ph id="ph4">`For Each...Next`</ph>在 Visual Basic 中构造。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the class is not <ph id="ph1">`sealed`</ph> (in C#) or <ph id="ph2">`NotInheritable`</ph> (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method you want to customize.</source>
          <target state="translated">如果此类不是<ph id="ph1">`sealed`</ph>（在 C# 中) 或<ph id="ph2">`NotInheritable`</ph>（在 Visual Basic 中)，你可以开发一个包装类，从基类继承其<ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>想要自定义的方法。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>At a minimum, this requires that you do the following:</source>
          <target state="translated">在最低限度上，这需要你以下：</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Implement any necessary constructors.</source>
          <target state="translated">实现任何必要的构造函数。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Derived classes do not inherit their base class constructors.</source>
          <target state="translated">派生的类不会继承其基类构造函数。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to return the result string that you'd like.</source>
          <target state="translated">重写<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法以返回想要的结果字符串。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example defines a wrapper class for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class.</source>
          <target state="translated">下面的示例定义的包装类<ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to display the value of each method of the collection rather than the fully qualified type name.</source>
          <target state="translated">它将重写<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>方法以显示每个方法的集合，而不是完全限定的类型名称的值。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Develop an <bpt id="p1">[</bpt>extension method<ept id="p1">](~/docs/standard/design-guidelines/extension-methods.md)</ept> that returns the result string that you want.</source>
          <target state="translated">开发<bpt id="p1">[</bpt>扩展方法<ept id="p1">](~/docs/standard/design-guidelines/extension-methods.md)</ept>返回所需的结果字符串。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Note that you can't override the default <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named <ph id="ph2">`ToString`</ph> that is called in place of the original type's <ph id="ph3">`ToString`</ph> method.</source>
          <target state="translated">请注意，不能重写默认值<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>以这种方式的方法 (也就是说，扩展类 （在 C# 中) 或 （在 Visual Basic) 的模块不能有一个名为的无参数方法<ph id="ph2">`ToString`</ph>来代替原始类型的调用的函数是<ph id="ph3">`ToString`</ph>方法.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You'll have to provide some other name for your parameterless <ph id="ph1">`ToString`</ph> replacement.</source>
          <target state="translated">你将需要提供其他名称为你无参数<ph id="ph1">`ToString`</ph>替换。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example defines two methods that extend the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class: a parameterless <ph id="ph2">`ToString2`</ph> method, and a <ph id="ph3">`ToString`</ph> method with a <ph id="ph4">&lt;xref:System.String&gt;</ph> parameter that represents a format string.</source>
          <target state="translated">下面的示例定义两种方法的扩展<ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>类： 无参数<ph id="ph2">`ToString2`</ph>方法，和一个<ph id="ph3">`ToString`</ph>方法替换<ph id="ph4">&lt;xref:System.String&gt;</ph>表示一个格式字符串的参数。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">说明 <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
          <target state="translated">当调用<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>中类方法<ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>，它不会覆盖的类提供的默认行为<ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">这是.NET Framework 提供的支持的一部分<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>(请参阅<bpt id="p1">[</bpt>.NET Framework 支持为 Windows 应用商店应用和 Windows 运行时<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>)。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and don’t always implement a <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
          <target state="translated">中的类<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>不继承<ph id="ph2">&lt;xref:System.Object&gt;</ph>，并不总是实现<ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>However, they always appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</source>
          <target state="translated">但是，它们始终会显示为具有<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>，和<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>方法在 C# 或 Visual Basic 代码中，使用它们以及.NET Framework 为这些方法提供默认行为时。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, the common language runtime will use <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> on a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object before falling back to the default implementation of <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>，公共语言运行时将使用<bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>上<ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>对象在回退到的默认实现之前<ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> 用 C# 或 Visual Basic 编写的类可以重写<ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> and the IStringable Interface</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>和 IStringable 接口</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Starting with <ph id="ph1">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> includes an <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> interface whose single method, <bpt id="p2">[</bpt>IStringable.ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>, provides basic formatting support comparable to that provided by <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>、<ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>包括<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>接口的单一方法<bpt id="p2">[</bpt>IStringable.ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>，提供基本格式设置支持相媲美提供的<ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>To prevent ambiguity, you should not implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> on managed types.</source>
          <target state="translated">若要避免产生混乱，则不应实现<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>上托管类型。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</source>
          <target state="translated">通过本机代码或通过在 JavaScript 或 C + 等语言中编写代码的托管的对象调用时 + /CX 中，它们看起来实现<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The common language runtime will automatically route calls from <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> to <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> in the event <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> is not implemented on the managed object.</source>
          <target state="translated">公共语言运行时自动将路由从调用<bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>到<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>在事件<bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>未在托管对象上实现。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Because the common language runtime auto-implements <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> for all managed types in <ph id="ph1">[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]</ph> apps, we recommend that you do not provide your own <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementation.</source>
          <target state="translated">因为公共语言运行时自动实现<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>所有的托管类型中的<ph id="ph1">[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]</ph>应用，我们建议你不要不提供你自己<bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>实现。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Implementing <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> may result in unintended behavior when calling <ph id="ph1">`ToString`</ph> from the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, C++/CX, or JavaScript.</source>
          <target state="translated">实现<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>调用时，可能会导致意外行为<ph id="ph1">`ToString`</ph>从<ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>、 C + + /CX 中或 JavaScript。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If you do choose to implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> in a public managed type that is exported in a <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> component, the following restrictions apply:</source>
          <target state="translated">如果你选择实现<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>中导出的公共托管类型中<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>组件，以下限制适用：</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You can define the <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> interface only in a "class implements" relationship, such as</source>
          <target state="translated">你可以定义<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>接口只能在"类实现"关系，如</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>in C#, or</source>
          <target state="translated">接</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>in Visual Basic.</source>
          <target state="translated">口。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You cannot implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> on an interface.</source>
          <target state="translated">不能实现<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>在接口上。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You cannot declare a parameter to be of type <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</source>
          <target state="translated">你不能声明为类型参数<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> cannot be the return type of a method, property, or field.</source>
          <target state="translated"><bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>不能是方法、 属性或字段的返回类型。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You cannot hide your <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementation from base classes by using a method definition such as the following:</source>
          <target state="translated">不能隐藏你<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>通过使用以下方法定义在基类中的实现：</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Instead, the <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementation must always override the base class implementation.</source>
          <target state="translated">相反， <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>实现必须始终替代基类实现。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You can hide a <ph id="ph1">`ToString`</ph> implementation only by invoking it on a strongly typed class instance.</source>
          <target state="translated">只能通过对强类型类实例调用 <ph id="ph1">`ToString`</ph> 实现来隐藏该实现。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Note that under a variety of conditions, calls from native code to a managed type that implements <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> or hides its <bpt id="p2">[</bpt>ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementation can produce unexpected behavior.</source>
          <target state="translated">请注意，在各种条件，从本机代码调用到托管类型实现<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>或隐藏其<bpt id="p2">[</bpt>ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>实现可以产生意外的行为。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>When you implement your own types, you should override the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method to return values that are meaningful for those types.</source>
          <target state="translated">当您实现您自己的类型时，则应重写<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>方法返回对这些类型有意义的值。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Derived classes that require more control over formatting than <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> provides can implement the <ph id="ph2">&lt;see cref="T:System.IFormattable" /&gt;</ph> interface.</source>
          <target state="translated">派生类需要比的格式设置的更好地控制<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>提供可以实现<ph id="ph2">&lt;see cref="T:System.IFormattable" /&gt;</ph>接口。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Its <ph id="ph1">&lt;see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /&gt;</ph> method enables you to define format strings that control formatting and to use an <ph id="ph2">&lt;see cref="T:System.IFormatProvider" /&gt;</ph> object that can provide for culture-specific formatting.</source>
          <target state="translated">其<ph id="ph1">&lt;see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /&gt;</ph>方法使你能够定义控制格式设置的格式字符串，以及用于<ph id="ph2">&lt;see cref="T:System.IFormatProvider" /&gt;</ph>可以为特定于区域性的格式设置提供的对象。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overrides of the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method should follow these guidelines:</source>
          <target state="translated">重写<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>方法应遵循以下准则：</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The returned string should be friendly and readable by humans.</source>
          <target state="translated">返回的字符串应友好、 更具可读性人所理解。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The returned string should uniquely identify the value of the object instance.</source>
          <target state="translated">返回的字符串应单独标识对象实例的值。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The returned string should be as short as possible so that it is suitable for display by a debugger.</source>
          <target state="translated">返回的字符串应尽可能短，以便它适合于由调试器的显示。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Your <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> override should not return <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> or a null string.</source>
          <target state="translated">你<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>替代不应返回<ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>或 null 字符串。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Your <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> override should not throw an exception.</source>
          <target state="translated">你<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>替代不应引发异常。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <ph id="ph1">&lt;see cref="T:System.IFormattable" /&gt;</ph> interface.</source>
          <target state="translated">如果实例的字符串表示区分区域性，或可采用多种方式进行格式设置，则实现<ph id="ph1">&lt;see cref="T:System.IFormattable" /&gt;</ph>接口。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the returned string includes sensitive information, you should first demand an appropriate permission.</source>
          <target state="translated">如果返回的字符串包含敏感信息，你应首先要求了适当的权限。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.</source>
          <target state="translated">如果请求成功，则可以返回的敏感信息;否则，应返回的字符串不包含敏感信息。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Your <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> override should have no observable side effects to avoid complications in debugging.</source>
          <target state="translated">你<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>重写应具有任何明显的副作用以避免在调试的复杂性。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For example, a call to the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method should not change the value of instance fields.</source>
          <target state="translated">例如，调用<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>方法不应更改实例字段的值。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If your type implements a parsing method (or <ph id="ph1">&lt;see langword="Parse" /&gt;</ph> or <ph id="ph2">&lt;see langword="TryParse" /&gt;</ph> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <ph id="ph3">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method can be converted to an object instance.</source>
          <target state="translated">如果你的类型实现分析方法 (或<ph id="ph1">&lt;see langword="Parse" /&gt;</ph>或<ph id="ph2">&lt;see langword="TryParse" /&gt;</ph>方法、 构造函数或某些其他实例化从字符串类型的实例的静态方法)，应确保返回的字符串<ph id="ph3">&lt;see cref="M:System.Object.ToString" /&gt;</ph>方法可以是转换为对象实例。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>
