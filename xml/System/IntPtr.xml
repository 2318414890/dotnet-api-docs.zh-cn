<Type Name="IntPtr" FullName="System.IntPtr">
  <TypeSignature Language="C#" Value="public struct IntPtr : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit native int extends System.ValueType implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.IntPtr" />
  <TypeSignature Language="VB.NET" Value="Public Structure IntPtr&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public value class IntPtr : System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="63aa1-101">用于表示指针或句柄的平台特定类型。</span><span class="sxs-lookup"><span data-stu-id="63aa1-101">A platform-specific type that is used to represent a pointer or a handle.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63aa1-102"><xref:System.IntPtr>类型都旨在成为一个其大小为特定于平台的整数。</span><span class="sxs-lookup"><span data-stu-id="63aa1-102">The <xref:System.IntPtr> type is designed to be an integer whose size is platform-specific.</span></span> <span data-ttu-id="63aa1-103">也就是说，此类型的实例预计会在 32 位硬件和操作系统，32 位和 64 位在 64 位硬件和操作系统上。</span><span class="sxs-lookup"><span data-stu-id="63aa1-103">That is, an instance of this type is expected to be 32-bits on 32-bit hardware and operating systems, and 64-bits on 64-bit hardware and operating systems.</span></span>  
  
 <span data-ttu-id="63aa1-104"><xref:System.IntPtr>语言支持指针，并作为一种通用引用语言，并不支持指针之间的数据的方式，可以使用类型。</span><span class="sxs-lookup"><span data-stu-id="63aa1-104">The <xref:System.IntPtr> type can be used by languages that support pointers, and as a common means of referring to data between languages that do and do not support pointers.</span></span>  
  
 <span data-ttu-id="63aa1-105"><xref:System.IntPtr> 对象还可用来保存句柄。</span><span class="sxs-lookup"><span data-stu-id="63aa1-105"><xref:System.IntPtr> objects can also be used to hold handles.</span></span> <span data-ttu-id="63aa1-106">例如，实例的<xref:System.IntPtr>用于广泛在<xref:System.IO.FileStream?displayProperty=nameWithType>类来保存文件句柄。</span><span class="sxs-lookup"><span data-stu-id="63aa1-106">For example, instances of <xref:System.IntPtr> are used extensively in the <xref:System.IO.FileStream?displayProperty=nameWithType> class to hold file handles.</span></span>  
  
 <span data-ttu-id="63aa1-107"><xref:System.IntPtr>类型是符合 CLS 时<xref:System.UIntPtr>类型不是。</span><span class="sxs-lookup"><span data-stu-id="63aa1-107">The <xref:System.IntPtr> type is CLS-compliant, while the <xref:System.UIntPtr> type is not.</span></span> <span data-ttu-id="63aa1-108">仅<xref:System.IntPtr>类型在公共语言运行时的用法。</span><span class="sxs-lookup"><span data-stu-id="63aa1-108">Only the <xref:System.IntPtr> type is used in the common language runtime.</span></span> <span data-ttu-id="63aa1-109"><xref:System.UIntPtr>类型主要用于维护与体系结构对称性<xref:System.IntPtr>类型。</span><span class="sxs-lookup"><span data-stu-id="63aa1-109">The <xref:System.UIntPtr> type is provided mostly to maintain architectural symmetry with the <xref:System.IntPtr> type.</span></span>  
  
 <span data-ttu-id="63aa1-110">此类型实现<xref:System.Runtime.Serialization.ISerializable>接口。</span><span class="sxs-lookup"><span data-stu-id="63aa1-110">This type implements the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63aa1-111">下面的示例使用托管的指针反向数组中的字符。</span><span class="sxs-lookup"><span data-stu-id="63aa1-111">The following example uses managed pointers to reverse the characters in an array.</span></span> <span data-ttu-id="63aa1-112">它将初始化后<xref:System.String>对象，并获取其长度，它执行以下：</span><span class="sxs-lookup"><span data-stu-id="63aa1-112">After it initializes a <xref:System.String> object and gets its length, it does the following:</span></span>  
  
1.  <span data-ttu-id="63aa1-113">调用<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType>方法将 Unicode 字符串复制到为 ANSI （单字节） 字符的非托管内存。</span><span class="sxs-lookup"><span data-stu-id="63aa1-113">Calls the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> method to copy the Unicode string to unmanaged memory as an ANSI (one-byte) character.</span></span> <span data-ttu-id="63aa1-114">该方法返回<xref:System.IntPtr>指向非托管字符串的开头的对象。</span><span class="sxs-lookup"><span data-stu-id="63aa1-114">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged string.</span></span> <span data-ttu-id="63aa1-115">Visual Basic 示例直接调用使用此指针在 c + + 和 C# 示例中，它被强制转换为指向一个字节的指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-115">The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</span></span>  
  
2.  <span data-ttu-id="63aa1-116">调用<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType>方法来分配相同的字节数，如占用的非托管的字符串。</span><span class="sxs-lookup"><span data-stu-id="63aa1-116">Calls the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> method to allocate the same number of bytes as the unmanaged string occupies.</span></span> <span data-ttu-id="63aa1-117">该方法返回<xref:System.IntPtr>指向非托管内存块的开头的对象。</span><span class="sxs-lookup"><span data-stu-id="63aa1-117">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged block of memory.</span></span> <span data-ttu-id="63aa1-118">Visual Basic 示例直接调用使用此指针在 c + + 和 C# 示例中，它被强制转换为指向一个字节的指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-118">The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</span></span>  
  
3.  <span data-ttu-id="63aa1-119">Visual Basic 示例定义一个名为变量`offset`等于 ANSI 字符串的长度。</span><span class="sxs-lookup"><span data-stu-id="63aa1-119">The Visual Basic example defines a variable named `offset` that is equal to the length of the ANSI string.</span></span> <span data-ttu-id="63aa1-120">它用于确定的偏移量到下一步特许的 ANSI 字符串中复制到其中的非托管内存。</span><span class="sxs-lookup"><span data-stu-id="63aa1-120">It is used to determine the offset into unmanaged memory to which the next charter in the ANSI string is copied.</span></span> <span data-ttu-id="63aa1-121">由于其起始值是字符串的长度，复制操作将复制的字符从字符串的开头到内存块的末尾。</span><span class="sxs-lookup"><span data-stu-id="63aa1-121">Because its starting value is the length of the string, the copy operation will copy a character from the start of the string to the end of the memory block.</span></span>  
  
     <span data-ttu-id="63aa1-122">C# 和 c + + 示例调用<xref:System.IntPtr.ToPointer%2A>方法可用于访问的字符串和非托管的内存块的起始地址的非托管的指针并且也将添加一个小于 ANSI 字符串的起始地址的字符串的长度。</span><span class="sxs-lookup"><span data-stu-id="63aa1-122">The C# and C++ examples call the <xref:System.IntPtr.ToPointer%2A> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and they add one less than the length of the string to the starting address of the ANSI string.</span></span> <span data-ttu-id="63aa1-123">因为非托管的字符串指针现在指向字符串的末尾，复制操作会将复制的字符从字符串末尾到内存块的起始位置。</span><span class="sxs-lookup"><span data-stu-id="63aa1-123">Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</span></span>  
  
4.  <span data-ttu-id="63aa1-124">使用循环将每个字符从字符串复制到非托管内存块。</span><span class="sxs-lookup"><span data-stu-id="63aa1-124">Uses a loop to copy each character from the string to the unmanaged block of memory.</span></span>  
  
     <span data-ttu-id="63aa1-125">Visual Basic 示例调用<xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType>方法来为 ANSI 字符串从托管指针指定偏移量读取的字节 （或单字节字符）。</span><span class="sxs-lookup"><span data-stu-id="63aa1-125">The Visual Basic example calls the <xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType> method to read the byte (or one-byte character) at a specified offset from the managed pointer to the ANSI string.</span></span> <span data-ttu-id="63aa1-126">偏移量会循环每次迭代时递增。</span><span class="sxs-lookup"><span data-stu-id="63aa1-126">The offset is incremented with each iteration of the loop.</span></span> <span data-ttu-id="63aa1-127">然后，它调用<xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType>方法写入字节的内存地址由托管加上的内存块的起始地址`offset`。</span><span class="sxs-lookup"><span data-stu-id="63aa1-127">It then calls the <xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType> method to write the byte to the memory address defined by the starting address of the unmanaged block of memory plus `offset`.</span></span> <span data-ttu-id="63aa1-128">然后，它递减`offset`。</span><span class="sxs-lookup"><span data-stu-id="63aa1-128">It then decrements `offset`.</span></span>  
  
     <span data-ttu-id="63aa1-129">C# 和 c + + 示例执行复制操作，然后递减到非托管 ANSI 字符串中的下一个位置的地址指针并且递增指向非托管的块中的下一步地址的指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-129">The C# and C++ examples perform the copy operation, then decrement the pointer to the address of the next location in the unmanaged ANSI string and increment the pointer to the next address in the unmanaged block.</span></span>  
  
5.  <span data-ttu-id="63aa1-130">所有的示例调用<xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>要转换包含托管 Unicode 的复制的 ANSI 字符串的非托管的内存块<xref:System.String>对象。</span><span class="sxs-lookup"><span data-stu-id="63aa1-130">All examples call the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <xref:System.String> object.</span></span>  
  
6.  <span data-ttu-id="63aa1-131">在显示的原始和反向字符串之后, 所有示例都调用<xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>方法释放非托管的 ANSI 字符串和非托管的内存块分配的内存。</span><span class="sxs-lookup"><span data-stu-id="63aa1-131">After displaying the original and reversed strings, all examples call the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</span></span>  
  
 [!code-cpp[System.IntPtr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.intptr/cpp/topointer.cpp#1)]
 [!code-csharp[System.IntPtr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr/cs/topointer.cs#1)]
 [!code-vb[System.IntPtr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr/vb/topointer.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="63aa1-132">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="63aa1-132">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.UIntPtr" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="63aa1-133">初始化 <see cref="T:System.IntPtr" /> 的新实例。</span><span class="sxs-lookup"><span data-stu-id="63aa1-133">Initializes a new instance of <see cref="T:System.IntPtr" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(int value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="63aa1-134">32 位有符号整数中包含的指针或句柄。</span><span class="sxs-lookup"><span data-stu-id="63aa1-134">A pointer or handle contained in a 32-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="63aa1-135">使用指定的 32 位指针或句柄初始化 <see cref="T:System.IntPtr" /> 的新实例。</span><span class="sxs-lookup"><span data-stu-id="63aa1-135">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified 32-bit pointer or handle.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(long value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="63aa1-136">64 位有符号整数中包含的指针或句柄。</span><span class="sxs-lookup"><span data-stu-id="63aa1-136">A pointer or handle contained in a 64-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="63aa1-137">使用指定的 64 位指针初始化 <see cref="T:System.IntPtr" /> 的新实例。</span><span class="sxs-lookup"><span data-stu-id="63aa1-137">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified 64-bit pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63aa1-138">如果时才会引发异常的值`value`需要比当前平台所支持的更多比特。</span><span class="sxs-lookup"><span data-stu-id="63aa1-138">An exception is only thrown if the value of `value` requires more bits than the current platform supports.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="63aa1-139">在 32 位的平台上，<paramref name="value" /> 太大或太小，无法表示为 <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="63aa1-139">On a 32-bit platform, <paramref name="value" /> is too large or too small to represent as an <see cref="T:System.IntPtr" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (void* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Void*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(void* value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Void*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="63aa1-140">指向未指定类型的指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-140">A pointer to an unspecified type.</span></span></param>
        <summary><span data-ttu-id="63aa1-141">使用指定的指向未指定类型的指针初始化 <see cref="T:System.IntPtr" /> 的新实例。</span><span class="sxs-lookup"><span data-stu-id="63aa1-141">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified pointer to an unspecified type.</span></span></summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="63aa1-142">需要完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="63aa1-142">requires full trust for the immediate caller.</span></span> <span data-ttu-id="63aa1-143">此成员不能由部分受信任或不透明的代码。</span><span class="sxs-lookup"><span data-stu-id="63aa1-143">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Void" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static IntPtr Add (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Add(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Add(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Add(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="63aa1-144">要为其增加偏移量的指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-144">The pointer to add the offset to.</span></span></param>
        <param name="offset"><span data-ttu-id="63aa1-145">要增加的偏移量。</span><span class="sxs-lookup"><span data-stu-id="63aa1-145">The offset to add.</span></span></param>
        <summary><span data-ttu-id="63aa1-146">为指针值添加偏移量。</span><span class="sxs-lookup"><span data-stu-id="63aa1-146">Adds an offset to the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="63aa1-147">反映为 <paramref name="offset" /> 增加 <paramref name="pointer" /> 的新指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-147">A new pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63aa1-148"><xref:System.IntPtr.Add%2A>方法不会引发异常，如果结果过大而无法表示为指定的平台上的指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-148">The <xref:System.IntPtr.Add%2A> method does not throw an exception if the result is too large to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="63aa1-149">相反，在未选中的上下文执行加法运算。</span><span class="sxs-lookup"><span data-stu-id="63aa1-149">Instead, the addition operation is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="63aa1-150">不支持运算符重载或自定义运算符的语言可以使用此方法的指针值添加偏移量。</span><span class="sxs-lookup"><span data-stu-id="63aa1-150">Languages that do not support operator overloading or custom operators can use this method to add an offset to the value of a pointer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63aa1-151">下面的示例实例化<xref:System.IntPtr>对象指向一个 10 个元素的数组，开头，然后调用<xref:System.IntPtr.Add%2A>方法来循环访问数组中的元素。</span><span class="sxs-lookup"><span data-stu-id="63aa1-151">The following example instantiates an <xref:System.IntPtr> object that points to the beginning of a ten-element array, and then calls the <xref:System.IntPtr.Add%2A> method to iterate the elements in the array.</span></span>  
  
 [!code-csharp[System.IntPtr.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.add/cs/add1.cs#1)]
 [!code-vb[System.IntPtr.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="63aa1-152">要与此示例比较的对象，或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="63aa1-152">An object to compare with this instance or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="63aa1-153">返回一个值，该值指示此实例是否等于指定的对象。</span><span class="sxs-lookup"><span data-stu-id="63aa1-153">Returns a value indicating whether this instance is equal to a specified object.</span></span></summary>
        <returns>
          <span data-ttu-id="63aa1-154">如果 <see langword="true" /> 是 <paramref name="obj" /> 的实例并且等于此实例的值，则为 <see cref="T:System.IntPtr" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="63aa1-154"><see langword="true" /> if <paramref name="obj" /> is an instance of <see cref="T:System.IntPtr" /> and equals the value of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="63aa1-155">返回此实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="63aa1-155">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="63aa1-156">32 位有符号整数哈希代码。</span><span class="sxs-lookup"><span data-stu-id="63aa1-156">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static IntPtr operator + (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Addition(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr operator +(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="63aa1-157">要为其增加偏移量的指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-157">The pointer to add the offset to.</span></span></param>
        <param name="offset"><span data-ttu-id="63aa1-158">要增加的偏移量。</span><span class="sxs-lookup"><span data-stu-id="63aa1-158">The offset to add.</span></span></param>
        <summary><span data-ttu-id="63aa1-159">为指针值添加偏移量。</span><span class="sxs-lookup"><span data-stu-id="63aa1-159">Adds an offset to the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="63aa1-160">反映为 <paramref name="offset" /> 增加 <paramref name="pointer" /> 的新指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-160">A new pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63aa1-161"><xref:System.IntPtr.op_Addition%2A>方法定义的加法运算<xref:System.IntPtr>对象。</span><span class="sxs-lookup"><span data-stu-id="63aa1-161">The <xref:System.IntPtr.op_Addition%2A> method defines the addition operation for <xref:System.IntPtr> objects.</span></span> <span data-ttu-id="63aa1-162">它使代码如下所示。</span><span class="sxs-lookup"><span data-stu-id="63aa1-162">It enables code such as the following.</span></span>  
  
 [!code-csharp[System.IntPtr.op_Addition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.op_addition/cs/addition1.cs#1)]
 [!code-vb[System.IntPtr.op_Addition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.op_addition/vb/addition1.vb#1)]  
  
 <span data-ttu-id="63aa1-163">不支持自定义运算符的语言可以调用<xref:System.IntPtr.Add%2A>方法相反。</span><span class="sxs-lookup"><span data-stu-id="63aa1-163">Languages that do not support custom operators can call the <xref:System.IntPtr.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="63aa1-164">如果结果过大而无法表示为指定的平台上的指针，加法运算不引发异常。</span><span class="sxs-lookup"><span data-stu-id="63aa1-164">The addition operation does not throw an exception if the result is too large to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="63aa1-165">相反，它是在未选中的上下文中执行。</span><span class="sxs-lookup"><span data-stu-id="63aa1-165">Instead, it is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="63aa1-166">此运算符的等效方法是 <xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="63aa1-166">The equivalent method for this operator is <xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.Add(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(native int value1, native int value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (value1 As IntPtr, value2 As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(IntPtr value1, IntPtr value2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value1" Type="System.IntPtr" />
        <Parameter Name="value2" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value1"><span data-ttu-id="63aa1-167">要比较的第一个指针或句柄。</span><span class="sxs-lookup"><span data-stu-id="63aa1-167">The first pointer or handle to compare.</span></span></param>
        <param name="value2"><span data-ttu-id="63aa1-168">要比较的第二个指针或句柄。</span><span class="sxs-lookup"><span data-stu-id="63aa1-168">The second pointer or handle to compare.</span></span></param>
        <summary><span data-ttu-id="63aa1-169">确定 <see cref="T:System.IntPtr" /> 的两个指定的实例是否相等。</span><span class="sxs-lookup"><span data-stu-id="63aa1-169">Determines whether two specified instances of <see cref="T:System.IntPtr" /> are equal.</span></span></summary>
        <returns>
          <span data-ttu-id="63aa1-170">如果 <paramref name="value1" /> 等于 <paramref name="value2" />，则为 <see langword="true" />否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="63aa1-170"><see langword="true" /> if <paramref name="value1" /> equals <paramref name="value2" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="63aa1-171">此运算符的等效方法是 <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="63aa1-171">The equivalent method for this operator is <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="63aa1-172">将指定的数据类型转换为 <see cref="T:System.IntPtr" /> 值，或将 <see cref="T:System.IntPtr" /> 值转换为指定的数据类型。</span><span class="sxs-lookup"><span data-stu-id="63aa1-172">Converts a specified data type to an <see cref="T:System.IntPtr" /> value, or an <see cref="T:System.IntPtr" /> value to a specified data type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Int32)~System.IntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="63aa1-173">32 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="63aa1-173">A 32-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="63aa1-174">将 32 位有符号整数的值转换为 <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="63aa1-174">Converts the value of a 32-bit signed integer to an <see cref="T:System.IntPtr" />.</span></span></summary>
        <returns><span data-ttu-id="63aa1-175">初始化为 <see cref="T:System.IntPtr" /> 的 <paramref name="value" /> 新实例。</span><span class="sxs-lookup"><span data-stu-id="63aa1-175">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Int64)~System.IntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Long) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="63aa1-176">64 位带符号整数。</span><span class="sxs-lookup"><span data-stu-id="63aa1-176">A 64-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="63aa1-177">将 64 位有符号整数值转换为 <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="63aa1-177">Converts the value of a 64-bit signed integer to an <see cref="T:System.IntPtr" />.</span></span></summary>
        <returns><span data-ttu-id="63aa1-178">初始化为 <see cref="T:System.IntPtr" /> 的 <paramref name="value" /> 新实例。</span><span class="sxs-lookup"><span data-stu-id="63aa1-178">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="63aa1-179">在 32 位的平台上，<paramref name="value" /> 太大，无法表示为一个 <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="63aa1-179">On a 32-bit platform, <paramref name="value" /> is too large to represent as an <see cref="T:System.IntPtr" />.</span></span></exception>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="63aa1-180">要转换的指针或句柄。</span><span class="sxs-lookup"><span data-stu-id="63aa1-180">The pointer or handle to convert.</span></span></param>
        <summary><span data-ttu-id="63aa1-181">将指定的 <see cref="T:System.IntPtr" /> 的值转换为 32 位有符号整数。</span><span class="sxs-lookup"><span data-stu-id="63aa1-181">Converts the value of the specified <see cref="T:System.IntPtr" /> to a 32-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="63aa1-182"><paramref name="value" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="63aa1-182">The contents of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63aa1-183">如果时才会引发异常的值`value`需要比当前平台所支持的更多比特。</span><span class="sxs-lookup"><span data-stu-id="63aa1-183">An exception is only thrown if the value of `value` requires more bits than the current platform supports.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="63aa1-184">在 64 位平台上，<paramref name="value" /> 的值太大，无法表示为一个 32 位有符号整数。</span><span class="sxs-lookup"><span data-stu-id="63aa1-184">On a 64-bit platform, the value of <paramref name="value" /> is too large to represent as a 32-bit signed integer.</span></span></exception>
        <altmember cref="M:System.IntPtr.ToInt32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As IntPtr) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="63aa1-185">要转换的指针或句柄。</span><span class="sxs-lookup"><span data-stu-id="63aa1-185">The pointer or handle to convert.</span></span></param>
        <summary><span data-ttu-id="63aa1-186">将指定的 <see cref="T:System.IntPtr" /> 的值转换为 64 位有符号整数。</span><span class="sxs-lookup"><span data-stu-id="63aa1-186">Converts the value of the specified <see cref="T:System.IntPtr" /> to a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="63aa1-187"><paramref name="value" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="63aa1-187">The contents of <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <altmember cref="M:System.IntPtr.ToInt64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator void* (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname void* op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Void*" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator void*(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="63aa1-188">要转换的指针或句柄。</span><span class="sxs-lookup"><span data-stu-id="63aa1-188">The pointer or handle to convert.</span></span></param>
        <summary><span data-ttu-id="63aa1-189">将指定的 <see cref="T:System.IntPtr" /> 的值转换为指向未指定类型的指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-189">Converts the value of the specified <see cref="T:System.IntPtr" /> to a pointer to an unspecified type.</span></span>  
  
 <span data-ttu-id="63aa1-190">此 API 不兼容 CLS。</span><span class="sxs-lookup"><span data-stu-id="63aa1-190">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="63aa1-191"><paramref name="value" /> 的内容。</span><span class="sxs-lookup"><span data-stu-id="63aa1-191">The contents of <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <altmember cref="M:System.IntPtr.ToPointer" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (void* value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(void* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(void* value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Void*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="63aa1-192">指向未指定类型的指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-192">A pointer to an unspecified type.</span></span></param>
        <summary><span data-ttu-id="63aa1-193">将指向未指定类型的指定指针转换为 <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="63aa1-193">Converts the specified pointer to an unspecified type to an <see cref="T:System.IntPtr" />.</span></span>  
  
 <span data-ttu-id="63aa1-194">此 API 不兼容 CLS。</span><span class="sxs-lookup"><span data-stu-id="63aa1-194">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="63aa1-195">初始化为 <see cref="T:System.IntPtr" /> 的 <paramref name="value" /> 新实例。</span><span class="sxs-lookup"><span data-stu-id="63aa1-195">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="63aa1-196">需要完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="63aa1-196">requires full trust for the immediate caller.</span></span> <span data-ttu-id="63aa1-197">此成员不能由部分受信任或不透明的代码。</span><span class="sxs-lookup"><span data-stu-id="63aa1-197">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(native int value1, native int value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (value1 As IntPtr, value2 As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(IntPtr value1, IntPtr value2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value1" Type="System.IntPtr" />
        <Parameter Name="value2" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value1"><span data-ttu-id="63aa1-198">要比较的第一个指针或句柄。</span><span class="sxs-lookup"><span data-stu-id="63aa1-198">The first pointer or handle to compare.</span></span></param>
        <param name="value2"><span data-ttu-id="63aa1-199">要比较的第二个指针或句柄。</span><span class="sxs-lookup"><span data-stu-id="63aa1-199">The second pointer or handle to compare.</span></span></param>
        <summary><span data-ttu-id="63aa1-200">确定 <see cref="T:System.IntPtr" /> 的两个指定的实例是否不等。</span><span class="sxs-lookup"><span data-stu-id="63aa1-200">Determines whether two specified instances of <see cref="T:System.IntPtr" /> are not equal.</span></span></summary>
        <returns>
          <span data-ttu-id="63aa1-201">如果 <paramref name="value1" /> 不等于 <paramref name="value2" />，则为 <see langword="true" />否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="63aa1-201"><see langword="true" /> if <paramref name="value1" /> does not equal <paramref name="value2" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="63aa1-202">此运算符的等效方法是 <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="63aa1-202">The equivalent method for this operator is <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static IntPtr operator - (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Subtraction(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr operator -(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="63aa1-203">要从中减去偏移量的指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-203">The pointer to subtract the offset from.</span></span></param>
        <param name="offset"><span data-ttu-id="63aa1-204">要减去的偏移量。</span><span class="sxs-lookup"><span data-stu-id="63aa1-204">The offset to subtract.</span></span></param>
        <summary><span data-ttu-id="63aa1-205">从指针值中减去偏移量。</span><span class="sxs-lookup"><span data-stu-id="63aa1-205">Subtracts an offset from the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="63aa1-206">反映从 <paramref name="offset" /> 中减去 <paramref name="pointer" /> 的新指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-206">A new pointer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63aa1-207"><xref:System.IntPtr.op_Subtraction%2A>方法定义的减法运算<xref:System.IntPtr>对象。</span><span class="sxs-lookup"><span data-stu-id="63aa1-207">The <xref:System.IntPtr.op_Subtraction%2A> method defines the subtraction operation for <xref:System.IntPtr> objects.</span></span> <span data-ttu-id="63aa1-208">它使代码如下所示。</span><span class="sxs-lookup"><span data-stu-id="63aa1-208">It enables code such as the following.</span></span>  
  
 [!code-csharp[System.IntPtr.op_Addition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.op_addition/cs/op_subtraction1.cs#2)]
 [!code-vb[System.IntPtr.op_Addition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.op_addition/vb/op_subtraction1.vb#2)]  
  
 <span data-ttu-id="63aa1-209">不支持自定义运算符的语言可以调用<xref:System.IntPtr.Subtract%2A>方法相反。</span><span class="sxs-lookup"><span data-stu-id="63aa1-209">Languages that do not support custom operators can call the <xref:System.IntPtr.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="63aa1-210">减法运算不引发异常，如果结果为太小而无法表示为指定的平台上的指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-210">The subtraction operation does not throw an exception if the result is too small to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="63aa1-211">相反，它是在未选中的上下文中执行。</span><span class="sxs-lookup"><span data-stu-id="63aa1-211">Instead, it is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="63aa1-212">此运算符的等效方法是 <xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="63aa1-212">The equivalent method for this operator is <xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public static int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.IntPtr.Size" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int Size { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="63aa1-213">获取此实例的大小。</span><span class="sxs-lookup"><span data-stu-id="63aa1-213">Gets the size of this instance.</span></span></summary>
        <value><span data-ttu-id="63aa1-214">此进程中的指针或句柄的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="63aa1-214">The size of a pointer or handle in this process, measured in bytes.</span></span> <span data-ttu-id="63aa1-215">此属性的值在 32 位进程中为 4，在 64 位进程中为 8。</span><span class="sxs-lookup"><span data-stu-id="63aa1-215">The value of this property is 4 in a 32-bit process, and 8 in a 64-bit process.</span></span> <span data-ttu-id="63aa1-216">通过 C# 和 Visual Basic 编译器编译代码时，可以通过设置 <see langword="/platform" /> 开关定义该进程类型。</span><span class="sxs-lookup"><span data-stu-id="63aa1-216">You can define the process type by setting the <see langword="/platform" /> switch when you compile your code with the C# and Visual Basic compilers.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static IntPtr Subtract (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Subtract(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Subtract(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="63aa1-217">要从中减去偏移量的指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-217">The pointer to subtract the offset from.</span></span></param>
        <param name="offset"><span data-ttu-id="63aa1-218">要减去的偏移量。</span><span class="sxs-lookup"><span data-stu-id="63aa1-218">The offset to subtract.</span></span></param>
        <summary><span data-ttu-id="63aa1-219">从指针值中减去偏移量。</span><span class="sxs-lookup"><span data-stu-id="63aa1-219">Subtracts an offset from the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="63aa1-220">反映从 <paramref name="offset" /> 中减去 <paramref name="pointer" /> 的新指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-220">A new pointer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63aa1-221"><xref:System.IntPtr.Subtract%2A>方法不会引发异常，如果结果为太小而无法表示为指定的平台上的指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-221">The <xref:System.IntPtr.Subtract%2A> method does not throw an exception if the result is too small to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="63aa1-222">相反，在未选中的上下文执行减法运算。</span><span class="sxs-lookup"><span data-stu-id="63aa1-222">Instead, the subtraction operation is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="63aa1-223">不支持运算符重载或自定义运算符的语言可以使用此方法要减去的偏移量的指针的值。</span><span class="sxs-lookup"><span data-stu-id="63aa1-223">Languages that do not support operator overloading or custom operators can use this method to subtract an offset from the value of a pointer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63aa1-224">下面的示例实例化<xref:System.IntPtr>对象，指向数组末尾之间的 10 个元素，然后呼叫<xref:System.IntPtr.Subtract%2A>方法以按逆序循环访问数组中的元素。</span><span class="sxs-lookup"><span data-stu-id="63aa1-224">The following example instantiates an <xref:System.IntPtr> object that points to the end of a ten-element array, and then calls the <xref:System.IntPtr.Subtract%2A> method to iterate the elements in the array in reverse order.</span></span>  
  
 [!code-csharp[System.IntPtr.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.IntPtr.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.IEquatable&lt;System.IntPtr&gt;.Equals">
      <MemberSignature Language="C#" Value="bool IEquatable&lt;IntPtr&gt;.Equals (IntPtr other);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IEquatable&lt;System.IntPtr&gt;.Equals(native int other) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.System#IEquatable&lt;System#IntPtr&gt;#Equals(System.IntPtr)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As IntPtr) As Boolean Implements IEquatable(Of IntPtr).Equals" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IEquatable&lt;System.IntPtr&gt;.Equals(IntPtr other) = IEquatable&lt;IntPtr&gt;::Equals;" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="63aa1-225">要填充数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="63aa1-225">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object to populate with data.</span></span></param>
        <param name="context"><span data-ttu-id="63aa1-226">此序列化的目标。</span><span class="sxs-lookup"><span data-stu-id="63aa1-226">The destination for this serialization.</span></span> <span data-ttu-id="63aa1-227">（未使用此参数；指定 <see langword="null" />。）</span><span class="sxs-lookup"><span data-stu-id="63aa1-227">(This parameter is not used; specify <see langword="null" />.)</span></span></param>
        <summary><span data-ttu-id="63aa1-228">使用序列化当前的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象所需的所有数据填充 <see cref="T:System.IntPtr" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="63aa1-228">Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data needed to serialize the current <see cref="T:System.IntPtr" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63aa1-229">此方法填充`info`参数，并且当前值<xref:System.IntPtr>对象。</span><span class="sxs-lookup"><span data-stu-id="63aa1-229">This method populates the `info` parameter with the value of the current <xref:System.IntPtr> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="63aa1-230"><paramref name="info" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="63aa1-230"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="63aa1-231">需要完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="63aa1-231">requires full trust for the immediate caller.</span></span> <span data-ttu-id="63aa1-232">此成员不能由部分受信任或不透明的代码。</span><span class="sxs-lookup"><span data-stu-id="63aa1-232">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public int ToInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ToInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function ToInt32 () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ToInt32();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="63aa1-233">将此实例的值转换为 32 位有符号整数。</span><span class="sxs-lookup"><span data-stu-id="63aa1-233">Converts the value of this instance to a 32-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="63aa1-234">与此实例的值相等的 32 位有符号整数。</span><span class="sxs-lookup"><span data-stu-id="63aa1-234">A 32-bit signed integer equal to the value of this instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="63aa1-235">在 64 位平台上，此实例的值太大或太小，无法表示为一个 32 位有符号的整数。</span><span class="sxs-lookup"><span data-stu-id="63aa1-235">On a 64-bit platform, the value of this instance is too large or too small to represent as a 32-bit signed integer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public long ToInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function ToInt64 () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToInt64();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="63aa1-236">将此实例的值转换为 64 位有符号整数。</span><span class="sxs-lookup"><span data-stu-id="63aa1-236">Converts the value of this instance to a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="63aa1-237">与此实例的值相等的 64 位有符号整数。</span><span class="sxs-lookup"><span data-stu-id="63aa1-237">A 64-bit signed integer equal to the value of this instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToPointer">
      <MemberSignature Language="C#" Value="public void* ToPointer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void* ToPointer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void* ToPointer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="63aa1-238">将此实例的值转换为指向未指定类型的指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-238">Converts the value of this instance to a pointer to an unspecified type.</span></span></summary>
        <returns><span data-ttu-id="63aa1-239">指向 <see cref="T:System.Void" /> 的指针，即是说，该指针所指向的内存包含有未指定类型的数据。</span><span class="sxs-lookup"><span data-stu-id="63aa1-239">A pointer to <see cref="T:System.Void" />; that is, a pointer to memory containing data of an unspecified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="63aa1-240">下面的示例使用托管的指针反向数组中的字符。</span><span class="sxs-lookup"><span data-stu-id="63aa1-240">The following example uses managed pointers to reverse the characters in an array.</span></span> <span data-ttu-id="63aa1-241">它将初始化后<xref:System.String>对象，并获取其长度，它执行以下：</span><span class="sxs-lookup"><span data-stu-id="63aa1-241">After it initializes a <xref:System.String> object and gets its length, it does the following:</span></span>  
  
-   <span data-ttu-id="63aa1-242">调用<xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType>方法将 Unicode 字符串复制到非托管内存中，为 ANSI （单字节） 字符。</span><span class="sxs-lookup"><span data-stu-id="63aa1-242">Calls the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> method to copy the Unicode string to unmanaged memory as ANSI (one-byte) characters.</span></span> <span data-ttu-id="63aa1-243">该方法返回<xref:System.IntPtr>指向非托管字符串的开头的对象。</span><span class="sxs-lookup"><span data-stu-id="63aa1-243">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged string.</span></span>  
  
-   <span data-ttu-id="63aa1-244">调用<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType>方法来分配相同的字节数，如占用的非托管的字符串。</span><span class="sxs-lookup"><span data-stu-id="63aa1-244">Calls the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> method to allocate the same number of bytes as the unmanaged string occupies.</span></span> <span data-ttu-id="63aa1-245">该方法返回<xref:System.IntPtr>指向非托管内存块的开头的对象。</span><span class="sxs-lookup"><span data-stu-id="63aa1-245">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged block of memory.</span></span>  
  
-   <span data-ttu-id="63aa1-246">调用<xref:System.IntPtr.ToPointer%2A>方法可用于访问的字符串和非托管的内存块的起始地址的非托管的指针，并将添加一个小于 ANSI 字符串的起始地址的字符串的长度。</span><span class="sxs-lookup"><span data-stu-id="63aa1-246">Calls the <xref:System.IntPtr.ToPointer%2A> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and adds one less than the length of the string to the starting address of the ANSI string.</span></span> <span data-ttu-id="63aa1-247">因为非托管的字符串指针现在指向字符串的末尾，复制操作会将复制的字符从字符串末尾到内存块的起始位置。</span><span class="sxs-lookup"><span data-stu-id="63aa1-247">Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</span></span>  
  
-   <span data-ttu-id="63aa1-248">使用循环将每个字符从字符串复制到非托管内存块。</span><span class="sxs-lookup"><span data-stu-id="63aa1-248">Uses a loop to copy each character from the string to the unmanaged block of memory.</span></span> <span data-ttu-id="63aa1-249">操作完成后每个副本，它递减指向非托管 ANSI 字符串中的下一个位置的地址的指针，并增加指向非托管的块中的下一步地址的指针。</span><span class="sxs-lookup"><span data-stu-id="63aa1-249">After each copy operation, it decrements the pointer to the address of the next location in the unmanaged ANSI string and increments the pointer to the next address in the unmanaged block.</span></span>  
  
-   <span data-ttu-id="63aa1-250">调用<xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>要转换包含托管 Unicode 的复制的 ANSI 字符串的非托管的内存块<xref:System.String>对象。</span><span class="sxs-lookup"><span data-stu-id="63aa1-250">Calls the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <xref:System.String> object.</span></span>  
  
-   <span data-ttu-id="63aa1-251">后显示原始和反向字符串，调用<xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType>方法释放非托管的 ANSI 字符串和非托管的内存块分配的内存。</span><span class="sxs-lookup"><span data-stu-id="63aa1-251">After displaying the original and reversed strings, calls the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</span></span>  
  
 [!code-cpp[System.IntPtr.ToPointer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.IntPtr.ToPointer/cpp/topointer.cpp#1)]
 [!code-csharp[System.IntPtr.ToPointer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.IntPtr.ToPointer/cs/topointer.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="63aa1-252">将当前 <see cref="T:System.IntPtr" /> 对象的数值转换为其等效字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="63aa1-252">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="63aa1-253">将当前 <see cref="T:System.IntPtr" /> 对象的数值转换为其等效字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="63aa1-253">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span></span></summary>
        <returns><span data-ttu-id="63aa1-254">此实例的值的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="63aa1-254">The string representation of the value of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63aa1-255">如果值<xref:System.IntPtr.Size%2A>此实例的属性是 4，则此方法等效于<xref:System.Int32.ToString%2A?displayProperty=nameWithType>; 否则为此方法相当于<xref:System.Int64.ToString%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="63aa1-255">If the value of the <xref:System.IntPtr.Size%2A> property for this instance is 4, then this method is equivalent to <xref:System.Int32.ToString%2A?displayProperty=nameWithType>; otherwise, this method is equivalent to <xref:System.Int64.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="63aa1-256">控制当前 <see cref="T:System.IntPtr" /> 对象转换方式的格式规范。</span><span class="sxs-lookup"><span data-stu-id="63aa1-256">A format specification that governs how the current <see cref="T:System.IntPtr" /> object is converted.</span></span></param>
        <summary><span data-ttu-id="63aa1-257">将当前 <see cref="T:System.IntPtr" /> 对象的数值转换为其等效字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="63aa1-257">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span></span></summary>
        <returns><span data-ttu-id="63aa1-258">当前 <see cref="T:System.IntPtr" /> 对象的值的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="63aa1-258">The string representation of the value of the current <see cref="T:System.IntPtr" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63aa1-259">如果`format`参数是`null`或空字符串 ("")，返回值的格式与常规格式说明符 ("G")。</span><span class="sxs-lookup"><span data-stu-id="63aa1-259">If the `format` parameter is `null` or an empty string (""), the return value is formatted with the general format specifier ("G").</span></span> <span data-ttu-id="63aa1-260">有关数字格式说明符的详细信息，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)主题。</span><span class="sxs-lookup"><span data-stu-id="63aa1-260">For more information about numeric format specifiers, see the [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) topic.</span></span>  
  
 <span data-ttu-id="63aa1-261">返回值的格式使用固定区域性。</span><span class="sxs-lookup"><span data-stu-id="63aa1-261">The return value is formatted using the invariant culture.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly IntPtr Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly native int Zero" />
      <MemberSignature Language="DocId" Value="F:System.IntPtr.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly IntPtr Zero;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="63aa1-262">表示已初始化为零的指针或句柄的只读字段。</span><span class="sxs-lookup"><span data-stu-id="63aa1-262">A read-only field that represents a pointer or handle that has been initialized to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63aa1-263">此字段的值不等于`null`。</span><span class="sxs-lookup"><span data-stu-id="63aa1-263">The value of this field is not equivalent to `null`.</span></span> <span data-ttu-id="63aa1-264">使用此字段可有效地确定实例是否<xref:System.IntPtr>已设置为非零值。</span><span class="sxs-lookup"><span data-stu-id="63aa1-264">Use this field to efficiently determine whether an instance of <xref:System.IntPtr> has been set to a value other than zero.</span></span>  
  
 <span data-ttu-id="63aa1-265">例如，假定变量，ip，是的一个实例<xref:System.IntPtr>。</span><span class="sxs-lookup"><span data-stu-id="63aa1-265">For example, assume the variable, ip, is an instance of <xref:System.IntPtr>.</span></span> <span data-ttu-id="63aa1-266">你可以确定是否它已设置将它与由构造函数，例如返回的值进行比较:" `if ip != new IntPtr(0)...` "。</span><span class="sxs-lookup"><span data-stu-id="63aa1-266">You can determine if it has been set by comparing it to the value returned by a constructor, for example: " `if ip != new IntPtr(0)...` ".</span></span> <span data-ttu-id="63aa1-267">但是，调用构造函数来获取被初始化的指针的效率低。</span><span class="sxs-lookup"><span data-stu-id="63aa1-267">However, invoking a constructor to get an unintialized pointer is inefficient.</span></span> <span data-ttu-id="63aa1-268">它是更好的做法代码" `if ip != IntPtr.Zero...` "，或" `if !IntPtr.Zero.Equals(ip)...` "。</span><span class="sxs-lookup"><span data-stu-id="63aa1-268">It is better to code either " `if ip != IntPtr.Zero...` ", or " `if !IntPtr.Zero.Equals(ip)...` ".</span></span>  
  
 <span data-ttu-id="63aa1-269">当从托管代码调用 Windows API，您可以传递<xref:System.IntPtr.Zero?displayProperty=nameWithType>而不是`null`如果自变量应为任一的指针或`null`。</span><span class="sxs-lookup"><span data-stu-id="63aa1-269">When calling the Windows API from managed code, you can pass <xref:System.IntPtr.Zero?displayProperty=nameWithType> instead of `null` if an argument is expected to be either a pointer or a `null`.</span></span> <span data-ttu-id="63aa1-270">例如，以下调用 Windows`CreateFile`函数提供<xref:System.IntPtr.Zero?displayProperty=nameWithType>为`pSecurityAttributes`和`hTemplateFile`自变量值。</span><span class="sxs-lookup"><span data-stu-id="63aa1-270">For example, the following call to the Windows `CreateFile` function supplies <xref:System.IntPtr.Zero?displayProperty=nameWithType> for the `pSecurityAttributes` and `hTemplateFile` argument values.</span></span>  
  
 [!code-csharp[System.IntPtr.Zero#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.zero/cs/zero4.cs#2)]
 [!code-vb[System.IntPtr.Zero#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.zero/vb/zero4.vb#2)]  
  
> [!NOTE]
>  <span data-ttu-id="63aa1-271">尽管<xref:System.IntPtr.Zero>等效于`null`针对具有参数或返回值可以是指针的 Windows API 函数或`null`，<xref:System.IntPtr.Zero>不等效于`null`。</span><span class="sxs-lookup"><span data-stu-id="63aa1-271">Although <xref:System.IntPtr.Zero> is equivalent to `null` for Windows API functions with parameters or return values that can be either pointers or `null`, <xref:System.IntPtr.Zero> is not equivalent to `null`.</span></span> <span data-ttu-id="63aa1-272">传递`null`到`IntPtr.Zero.Equals`方法始终返回`false`。</span><span class="sxs-lookup"><span data-stu-id="63aa1-272">Passing `null` to the `IntPtr.Zero.Equals` method always returns `false`.</span></span>  
  
 <span data-ttu-id="63aa1-273">你还可以测试`null`与返回任一指针的 Windows API 函数调用返回值或`null`通过比较的返回的值与<xref:System.IntPtr.Zero?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="63aa1-273">You can also test for a `null` return value from Windows API function calls that return either a pointer or a `null` by comparing the returned value with <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="63aa1-274">例如，调用`GetWindow`函数在下面的示例尝试检索不存在窗口的句柄。</span><span class="sxs-lookup"><span data-stu-id="63aa1-274">For example, the call to the `GetWindow` function in the following example tries to retrieve the handle of a non-existent window.</span></span> <span data-ttu-id="63aa1-275">如果它调用从非托管代码，该函数将返回`null`，但当从托管代码调用时，它将返回<xref:System.IntPtr.Zero?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="63aa1-275">If it were called from unmanaged code, the function would return `null`, but when it is called from managed code, it returns <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.IntPtr.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.zero/cs/zero2.cs#1)]
 [!code-vb[System.IntPtr.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.zero/vb/zero2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>