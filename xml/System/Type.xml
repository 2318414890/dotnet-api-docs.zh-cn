<Type Name="Type" FullName="System.Type">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a40925048dd06746d1e1cda2a76aa4ecaae1b916" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731511" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示类型声明：类类型、接口类型、数组类型、值类型、枚举类型、类型参数、泛型类型定义，以及开放或封闭构造的泛型类型。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` 是的根<xref:System.Reflection>功能的访问的元数据的主要方式。 使用的成员<xref:System.Type>以及模块和程序集在其中部署类获取有关类型声明，有关成员的类型 （如构造函数、 方法、 字段、 属性和事件的类），信息。  
  
 所需的代码使用反射来获取有关类型和成员，信息而不考虑其访问级别没有权限。 所需的代码使用反射来访问公共成员或其访问级别将使其可见在正常的编译过程的其他成员没有权限。 但是，在你的类不是继承的代码可使用反射访问成员，通常将无法访问，例如私有或内部的方法，或受保护的类型的字段顺序，你的代码必须具有<xref:System.Security.Permissions.ReflectionPermission>。 请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。  
  
 `Type` 是允许多个实现的抽象基类。 系统将始终提供派生的类`RuntimeType`。 在反射中，运行时的单词开头的所有类都创建一次每个系统，并且支持比较操作中的对象。  
  
> [!NOTE]
>  在多线程处理的情况下，不要锁定<xref:System.Type>以便将同步访问对象`static`数据。 其他代码，，您可以不控制，还可能会锁定您的类类型。 这可能会导致死锁。 相反，将对静态数据的访问同步通过锁定私有`static`对象。  
  
> [!NOTE]
>  派生的类可以访问受保护的成员的调用代码的基类，这些类。 此外，调用代码的程序集的程序集成员允许访问。 一般来说，如果在早期绑定代码中，允许访问你然后还允许您访问后期绑定代码中。  
  
> [!NOTE]
>  扩展其他接口的接口不会继承扩展的接口中定义的方法。  
  
 本节内容：  
  
 [一个类型对象表示什么类型？](#WhatTypes)   
 [检索一个类型对象](#Retrieve)   
 [比较相等性的类型对象](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>一个类型对象表示什么类型？  
 此类是线程安全的;多个线程可以同时读取从这种类型的实例。 实例<xref:System.Type>类可以表示任何以下类型：  
  
-   类  
  
-   值类型  
  
-   数组  
  
-   接口  
  
-   枚举  
  
-   委托  
  
-   构造的泛型类型和泛型类型定义  
  
-   类型实参和类型参数的构造的泛型类型、 泛型类型定义和泛型方法定义  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>检索一个类型对象  
 <xref:System.Type>可以通过以下方式获取与特定类型关联的对象：  
  
-   实例<xref:System.Object.GetType%2A?displayProperty=nameWithType>方法返回<xref:System.Type>表示的类型的实例的对象。 因为所有的托管的类型派生自<xref:System.Object>、<xref:System.Object.GetType%2A>可以对任何类型的实例调用方法。  
  
     下面的示例调用<xref:System.Object.GetType%2A?displayProperty=nameWithType>方法来确定一个对象数组中每个对象的运行时类型。  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   静态<xref:System.Type.GetType%2A?displayProperty=nameWithType>方法返回<xref:System.Type>表示由其完全限定名称指定的类型的对象。  
  
-   <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>， <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>，和<xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType>方法返回`Type`表示模块中定义的类型的对象。 第一种方法可以用于获取数组的<xref:System.Type>的模块中定义的所有公共和私有类型的对象。 (你可以获取的实例`Module`通过<xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType>方法，或通过<xref:System.Type.Module%2A?displayProperty=nameWithType>属性。)  
  
-   <xref:System.Reflection.Assembly?displayProperty=nameWithType>对象包含大量的方法来检索一个程序集，包括中定义的类<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>， <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>，和<xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>。  
  
-   <xref:System.Type.FindInterfaces%2A>方法返回经筛选的支持的一种类型的接口类型列表。  
  
-   <xref:System.Type.GetElementType%2A>方法返回`Type`表示的元素的对象。  
  
-   <xref:System.Type.GetInterfaces%2A>和<xref:System.Type.GetInterface%2A>方法返回<xref:System.Type>表示所支持的一种类型的接口类型的对象。  
  
-   <xref:System.Type.GetTypeArray%2A>方法返回的数组<xref:System.Type>表示指定的任意一组对象类型的对象。 这些对象将指定类型的数组与<xref:System.Object>。  
  
-   <xref:System.Type.GetTypeFromProgID%2A>和<xref:System.Type.GetTypeFromCLSID%2A>为 COM 互操作提供方法。 它们返回<xref:System.Type>表示由指定的类型的对象`ProgID`或`CLSID`。  
  
-   <xref:System.Type.GetTypeFromHandle%2A>方法提供的互操作性。 它将返回`Type`表示类句柄指定的类型的对象。  
  
-   C#`typeof`运算符，c + +`typeid`运算符和 Visual Basic`GetType`运算符获取`Type`类型的对象。  
  
-   <xref:System.Type.MakeGenericType%2A>方法返回<xref:System.Type>对象表示构造的泛型类型，为开放式构造的类型，如果其<xref:System.Type.ContainsGenericParameters%2A>属性返回`true`，和封闭式构造类型否则。 可以实例化泛型类型，仅当已关闭。  
  
-   <xref:System.Type.MakeArrayType%2A>， <xref:System.Type.MakePointerType%2A>，和<xref:System.Type.MakeByRefType%2A>方法返回<xref:System.Type>分别，表示指定的类型、 指向具有指定的类型和引用参数的类型的指针的数组的对象 (`ref`在 C# 中， `ByRef`在 Visual Basic 中)。  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>比较相等性的类型对象  
 A <xref:System.Type> ，表示一种类型是唯一的对象; 即，两个<xref:System.Type>对象引用是否引用同一对象当且仅当它们表示同一类型。 这样的比较<xref:System.Type>对象使用引用相等性。 下面的示例比较<xref:System.Type>表示的整数值，以确定它们是否是相同类型的数字的对象。  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 下面的示例演示几个具有代表性的功能的<xref:System.Type>。 C#`typeof`运算符 (`GetType`在 Visual Basic 中的运算符`typeid`中 Visual c + + 运算符) 用于获取<xref:System.Type>对象，表示<xref:System.String>。 从此<xref:System.Type>对象，<xref:System.Type.GetMethod%2A>方法用于获取<xref:System.Reflection.MethodInfo>表示<xref:System.String.Substring%2A>采用的起始位置和长度的重载。  
  
 若要标识重载签名，该代码示例创建一个临时数组，包含两个<xref:System.Type>对象表示`int`(`Integer`在 Visual Basic 中)。  
  
> [!NOTE]
>  若要精确，该数组包含两个引用指向的实例<xref:System.Type>表示`int`当前的应用程序域中。 对于任何类型，没有只有一个实例<xref:System.Type>每个应用程序域。  
  
 此代码示例使用<xref:System.Reflection.MethodInfo>来调用<xref:System.String.Substring%2A>方法的字符串"Hello，World ！"，并显示结果。  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
    <block subset="none" type="overrides">
      <para>继承自<see langword="Type" />，必须重写以下成员：  
  
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Type" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数由派生类调用的类型对象的构造过程。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在其中声明该类型的 <see cref="T:System.Reflection.Assembly" />。 对于泛型类型，则获取在其中定义该泛型类型的 <see cref="T:System.Reflection.Assembly" />。</summary>
        <value>描述包含当前类型的程序集的 <see cref="T:System.Reflection.Assembly" /> 实例。 对于泛型类型，该实例描述包含泛型类型定义的程序集，而不是创建和使用特定构造类型的程序集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>对象表示构造的泛型类型，此属性返回包含泛型类型定义的程序集。 例如，假设你创建一个名为 MyGenerics.dll 包含泛型类型定义的程序集`MyGenericStack<T>`(`MyGenericStack(Of T)`在 Visual Basic 中， `generic<T> ref class MyGenericStack` c + + 中)。 如果你创建的实例`MyGenericStack<int>`(`MyGenericStack(Of Integer)`在 Visual Basic 中) 在另一个程序集中，<xref:System.Type.Assembly%2A>的构造类型的属性返回<xref:System.Reflection.Assembly>一个程序。  
  
 同样，如果当前<xref:System.Type>对象表示未分配的泛型参数`T`，此属性返回包含定义的泛型类型的程序集`T`。  
  
 如果<xref:System.Type.Assembly%2A?displayProperty=nameWithType>属性不是在一个特定的.NET 实现，如.NET 核心或通用 Windows 平台上可用，请使用<xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType>属性改为。      
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例显示与类关联的程序集名称和类型的完全限定的名称。  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取类型的程序集限定名，其中包括从中加载 <see cref="T:System.Type" /> 的程序集的名称。</summary>
        <value>
          <see cref="T:System.Type" /> 的程序集限定名，其中包括从中加载 <see cref="T:System.Type" /> 的程序集的名称；或者为 <see langword="null" />（如果当前实例表示泛型类型参数）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一种类型的程序集限定名称包含的类型名称，包括其命名空间后, 跟逗号后, 跟的程序集的显示名称。 使用获取程序集的显示名称<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>属性。  
  
> [!NOTE]
>  在.NET Framework 2.0 版中，处理器体系结构添加到程序集标识，并且可以指定为程序集名称字符串的一部分。 例如，"ProcessorArchitecture = msil"。 但是，不包括在返回的字符串<xref:System.Type.AssemblyQualifiedName%2A>属性，出于兼容性原因。 请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
 支持公共语言运行时的所有编译器将都发出的嵌套类的简单名称和反射构造查询时，根据以下约定的重整的名称。  
  
|分隔符|含义|  
|---------------|-------------|  
|反斜杠 (\\)|转义字符。|  
|逗号 （，）|之前的程序集名称。|  
|加号 （+）|前面有嵌套的类。|  
|句点 （.）|表示命名空间标识符。|  
|方括号 ([])|后一个类型名称，表示该类型的数组。<br /><br /> 或<br /><br /> 对于泛型类型，包括泛型类型自变量列表。<br /><br /> 或<br /><br /> 类型自变量列表中包含的程序集限定类型。|  
  
 例如，一个类的程序集限定名称可能如下所示：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 如果命名空间包含加号，例如 TopNamespace.Sub+Namespace，则将转义字符前面加号 （+） (\\) 以防止它被解释为嵌套的分隔符。 反射将发出此字符串，如下所示：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 一个"+ +"变为"\\+\\+"，和一个"\\"变为"\\\\"。  
  
 可以保持此限定的名，并在以后使用它来加载<xref:System.Type>。 若要搜索并加载<xref:System.Type>，使用<xref:System.Type.GetType%2A>与类型名称只有或程序集限定的类型名称。 <xref:System.Type.GetType%2A> 类型名称仅将查找的<xref:System.Type>调用方的程序集中，然后在系统程序集。 <xref:System.Type.GetType%2A> 使用程序集限定的类型名称将会查找<xref:System.Type>任何程序集中。  
  
 类型名称可能包含表示的类型，例如类型是引用类型、 指针类型或数组类型有关的其他信息的尾随字符。 若要检索的类型名称不具有这些尾随字符，请使用`t.GetElementType().ToString()`，其中`t`是的类型。  
  
 空间是适用于程序集名称之外的所有类型名称组件。 在程序集名称中前 '，' 分隔符的空格相关，但是 '，' 分隔符后的空格将被忽略。  
  
 泛型类型的泛型自变量是本身由程序集名称限定。 例如，在的程序集限定类型名称`MyGenericClass<int>`(`MyGenericClass(Of Integer)`在 Visual Basic 中)，`int`扩展到的程序集限定类型名称<xref:System.Int32>。  
  
 如果当前<xref:System.Type>对象表示泛型参数，则此属性返回`null`。  
  
   
  
## Examples  
 下面的示例显示与类关联的程序集名称和类型的完全限定的名称。  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 下面的示例对返回的字符串进行比较<xref:System.Type.ToString%2A>方法和`Name`， <xref:System.Type.FullName%2A>，和<xref:System.Type.AssemblyQualifiedName%2A>属性。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与 <see cref="T:System.Type" /> 关联的属性。</summary>
        <value>表示 <see cref="T:System.Reflection.TypeAttributes" /> 的属性集的 <see cref="T:System.Type" /> 对象，除非 <see cref="T:System.Type" /> 表示泛型类型形参，在此情况下该值未指定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些成员<xref:System.Reflection.TypeAttributes>枚举是表示一组值的掩码。 每个组包含基础值为零的一个成员。 例如，基础值的<xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType>中的成员<xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>组为零，因为是<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>中的成员<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>组。 因此，您必须对这些值进行测试之前使用掩码。 说明如示例所示。  
  
> [!TIP]
>  大多数情况下，属性如<xref:System.Type.IsClass%2A>，<xref:System.Type.IsAutoLayout%2A>，和<xref:System.Type.IsSpecialName%2A>可以更方便地使用比类型属性。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此属性返回的泛型类型定义的属性。 例如，为返回的属性`MyGenericClass<int>`(`MyGenericClass(Of Integer)`在 Visual Basic 中) 的属性`MyGenericClass<T>`(`MyGenericClass(Of T)`在 Visual Basic 中)。  
  
 如果当前<xref:System.Type>表示泛型类型参数-即，如果<xref:System.Type.IsGenericParameter%2A>属性返回`true`-<xref:System.Reflection.TypeAttributes>未指定此属性返回的值。  
  
   
  
## Examples  
 以下示例使用该域<xref:System.Type.Attributes%2A>属性。  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 直接从中继承的类型。</summary>
        <value>当前 <see cref="T:System.Type" /> 直接从中继承的 <see cref="T:System.Type" />；或者如果当前 <see langword="null" /> 表示 <see langword="Type" /> 类或一个接口，则为 <see cref="T:System.Object" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基类型是从其当前的类型直接继承的类型。 <xref:System.Object> 是唯一的类型，因此没有基类型，`null`作为的基类型返回<xref:System.Object>。  
  
 接口继承自零个或多个基接口;因此，此属性返回`null`如果`Type`对象表示的接口。 基接口可以确定与<xref:System.Type.GetInterfaces%2A>或<xref:System.Type.FindInterfaces%2A>。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，基类型反映泛型自变量。 以下面的声明为例：  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 构造类型`C<int>`(`C(Of Integer)`在 Visual Basic 中)，则<xref:System.Type.BaseType%2A>属性返回`B<int>`。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型定义，<xref:System.Type.BaseType%2A>返回类约束，即，类型参数必须继承的类。 如果没有类约束，<xref:System.Type.BaseType%2A>返回<xref:System.Object?displayProperty=nameWithType>。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Type.BaseType%2A>属性。  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 下面的示例使用递归将列出整个继承层次结构的程序集中找到的每个类。 该示例定义一个名为类`C`派生的名为的类`B`，而后者又派生自类名为`A`。  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Type" /> 对象是否具有尚未被特定类型替代的类型参数。</summary>
        <value>
          如果 <see langword="true" /> 对象本身是泛型类型形参或者具有尚未提供特定类型的类型形参，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建类型的实例，必须有任何泛型类型定义或该类型本身中任何封闭泛型类型，或在任何元素中的类型中的类型参数的开放式构造的类型。 另一种说法是，当检查以递归方式，该类型必须包含任何泛型类型参数。  
  
 由于类型可以为任意复杂，在进行此决定会很困难。 为了方便起见和降低错误的可能性<xref:System.Type.ContainsGenericParameters%2A>属性提供一种标准的方式来区分封闭式构造类型，可实例化，和开放构造类型，不能。 如果<xref:System.Type.ContainsGenericParameters%2A>属性返回`true`，类型不能被实例化。  
  
 <xref:System.Type.ContainsGenericParameters%2A>属性类型参数的以递归方式搜索。 例如，它返回`true`一个数组，其元素是类型为`A<T>`(`A(Of T)`在 Visual Basic 中)，即使数组本身不是泛型。 与此相反的行为<xref:System.Type.IsGenericType%2A>属性，它返回`false`数组。  
  
 示例类和显示的值的表的一组<xref:System.Type.ContainsGenericParameters%2A>属性，请参阅<xref:System.Type.IsGenericType%2A>。  
  
   
  
## Examples  
 下面的示例定义具有两个类型参数的泛型类，然后定义派生自的第一个类的第二个泛型类。 派生的类的基类具有两个类型参数： 第一种是<xref:System.Int32>和第二个是派生类型的类型参数。 该示例显示有关这些泛型类的信息，包括位置报告的<xref:System.Type.GenericParameterPosition%2A>属性。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个表示声明方法的 <see cref="T:System.Reflection.MethodBase" />（如果当前 <see cref="T:System.Type" /> 表示泛型方法的一个类型参数）。</summary>
        <value>如果当前 <see cref="T:System.Type" /> 表示泛型方法的一个类型参数，则为一个表示声明方法的 <see cref="T:System.Reflection.MethodBase" />；否则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 声明的方法是泛型方法定义。 也就是说，如果<xref:System.Type.DeclaringMethod%2A>不返回`null`，然后`DeclaringMethod.IsGenericMethodDefinition`返回`true`。  
  
 <xref:System.Type.DeclaringType%2A>和<xref:System.Type.DeclaringMethod%2A>属性标识的泛型类型定义或最初在其中定义泛型类型参数的泛型方法定义：  
  
-   如果<xref:System.Type.DeclaringMethod%2A>属性返回<xref:System.Reflection.MethodInfo>，则该<xref:System.Reflection.MethodInfo>表示泛型方法定义，以及当前<xref:System.Type>对象表示该泛型方法定义的类型参数。  
  
-   如果<xref:System.Type.DeclaringMethod%2A>属性返回`null`，则<xref:System.Type.DeclaringType%2A>属性始终返回<xref:System.Type>对象表示泛型类型定义和当前<xref:System.Type>对象表示泛型类型的类型参数定义。  
  
-   获取<xref:System.Type.DeclaringMethod%2A>类型上的属性其<xref:System.Type.IsGenericParameter%2A>属性是`false`引发<xref:System.InvalidOperationException>。  
  
 <xref:System.Reflection.MethodBase>返回<xref:System.Type.DeclaringMethod%2A>属性<xref:System.Reflection.MethodInfo>对于泛型方法，或<xref:System.Reflection.ConstructorInfo>对于泛型构造函数。  
  
> [!NOTE]
>  在.NET Framework 2.0 版中，不支持泛型构造函数。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的代码示例定义具有泛型方法，将一个类型自变量分配给该方法，并调用生成的构造泛型方法的类。 它还显示有关泛型方法定义和构造的方法的信息。 在中显示的泛型方法定义中，类型参数的信息时`DisplayGenericMethodInfo`方法中，此代码示例演示的值<xref:System.Type.DeclaringMethod%2A>方法的泛型类型参数的属性。  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用来声明当前的嵌套类型或泛型类型参数的类型。</summary>
        <value>如果当前的类型是嵌套类型，则为表示封闭类型的 <see cref="T:System.Type" /> 对象；如果当前的类型是泛型类型的类型参数，则为泛型类型的定义；如果当前的类型是泛型方法的类型参数，则为用来声明泛型方法的类型；否则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>对象表示泛型类型的类型参数，则此属性返回的泛型类型定义。  
  
 如果当前<xref:System.Type>对象表示泛型方法的类型参数，则此属性返回包含泛型方法定义的类型。 如果类型是泛型，则返回的泛型类型定义。 下面的代码返回的泛型类型定义的即<xref:System.Collections.Generic.List%601>泛型类，该类包含<xref:System.Collections.Generic.List%601.ConvertAll%2A>泛型方法：  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数<xref:System.Type.DeclaringType%2A>和<xref:System.Type.DeclaringMethod%2A>属性标识其中泛型类型参数的泛型类型定义或泛型方法定义最初定义：  
  
-   如果<xref:System.Type.DeclaringMethod%2A>属性返回<xref:System.Reflection.MethodInfo>，则该<xref:System.Reflection.MethodInfo>表示泛型方法定义，以及当前<xref:System.Type>对象表示该泛型方法定义的类型参数。  
  
-   如果<xref:System.Type.DeclaringMethod%2A>属性返回`null`，则<xref:System.Type.DeclaringType%2A>属性始终返回<xref:System.Type>对象表示泛型类型定义和当前<xref:System.Type>对象表示泛型类型的类型参数定义。  
  
-   获取<xref:System.Type.DeclaringType%2A>类型上的属性其<xref:System.Type.IsGenericParameter%2A>属性是`false`引发<xref:System.InvalidOperationException>。  
  
   
  
## Examples  
 此示例显示派生类中的一种方法的声明类型。  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取默认联编程序的引用，该程序实现的内部规则用于选择由 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> 调用的合适成员。</summary>
        <value>系统使用的默认联编程序的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供与公共语言运行时的默认联编程序是适用于所有情况但在极个别的情况。 如果你需要的联编程序不同于所提供的默认联编程序，如下所示规则定义一种类型派生自<xref:System.Reflection.Binder>类并将该类型使用的实例传递`binder`参数之一的<xref:System.Type.InvokeMember%2A>重载。  
  
 反射建模常规类型系统可访问性的规则。 例如，如果调用方在同一程序集，调用方不将特殊权限需要用于内部成员。 否则，调用方需要<xref:System.Security.Permissions.ReflectionPermission>。 这是与受保护的成员的查找一致、 专用和等。  
  
 一般原则是，<xref:System.Reflection.Binder.ChangeType%2A>应执行仅扩大转换，永远不会丢失数据。 扩大转换的一个示例将转换为 64 位有符号的整数的值将 32 位有符号的整数的值。 这被有别于收缩转换，后者可能丢失数据。 收缩转换的一个示例将一个 64 位带符号的整数转换为 32 位有符号整数。  
  
 下表列出了默认联编程序支持的转换。  
  
|源类型|目标类型|  
|-----------------|-----------------|  
|任何类型|与其基类型。|  
|任何类型|它实现的接口。|  
|Char|Unt16、 UInt32、 Int32、 UInt64、 Int64、 Single、 Double|  
|Byte|Char、 Unt16、 Int16、 UInt32、 Int32、 UInt64、 Int64、 Single、 Double|  
|SByte|Int16、Int32、Int64、Single、Double|  
|UInt16|UInt32、Int32、UInt64、Int64、Single、Double|  
|Int16|Int32、Int64、Single、Double|  
|UInt32|UInt64、Int64、Single、Double|  
|Int32|Int64、Single、Double|  
|UInt64|Single、Double|  
|Int64|Single、Double|  
|Single|Double|  
|非引用|按引用。|  
  
   
  
## Examples  
 下面的示例获取默认的联编程序从`DefaultBinder`属性，并通过调用成员 MyClass`DefaultBinder`值作为参数传递给<xref:System.Type.InvokeMember%2A>。  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>分隔 <see cref="T:System.Type" /> 的命名空间中的名称。 此字段为只读。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="T:System.Type" /> 类型的空数组。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示`EmptyTypes`字段之一使用`GetConstructor`方法来获取不采用参数的构造函数。  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定当前 <see cref="T:System.Type" /> 的基础系统类型是否与指定 <see cref="T:System.Object" /> 或 <see cref="T:System.Type" /> 的基础系统类型相同。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">该对象，其基础系统类型将与当前 <see cref="T:System.Type" /> 的基础系统类型相比较。 为成功比较，<c>o</c> 必须能够被强制转换或转换为类型 <see cref="T:System.Type" /> 的对象。</param>
        <summary>确定当前 <see cref="T:System.Type" /> 的基础系统类型是否与指定 <see cref="T:System.Object" /> 的基础系统类型相同。</summary>
        <returns>
          如果 <paramref name="o" /> 的基础系统类型与当前 <see cref="T:System.Type" /> 的基础系统类型相同，则为 <see langword="true" />；否则为 <see langword="false" />。 如果 ：此方法也会返回 <see langword="false" />。  
  
-   <paramref name="o" /> 为 <see langword="null" />。  
  
-   <paramref name="o" /> 不能强制转换或转换为 <see cref="T:System.Type" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Object.Equals%2A?displayProperty=nameWithType>。 将它强制转换`o`类型的对象到<xref:System.Type>和调用<xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Type.Equals%28System.Object%29>要比较各种<xref:System.Type>对象实例的各种<xref:System.Object>实例。  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 以下两项操作是特别值得注意关于示例：  
  
-   比较<xref:System.Type>对象，表示一个整数，它<xref:System.Reflection.TypeInfo>对象，表示返回的整数`true`因为<xref:System.Reflection.TypeInfo>派生自<xref:System.Type>。  
  
-   比较<xref:System.Type>对象，表示<xref:System.Collections.Generic.IList%601>对象 （开放式泛型类型）`List(Of String)`对象 （封闭式泛型类型） 返回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">该对象，其基础系统类型将与当前 <see cref="T:System.Type" /> 的基础系统类型相比较。</param>
        <summary>确定当前 <see cref="T:System.Type" /> 的基础系统类型是否与指定 <see cref="T:System.Type" /> 的基础系统类型相同。</summary>
        <returns>
          如果 <paramref name="o" /> 的基础系统类型与当前 <see cref="T:System.Type" /> 的基础系统类型相同，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例使用`Equals`比较两个类型。  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用在特性上的成员筛选器。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此字段保留对使用的委托的引用<xref:System.Type.FindMembers%2A>方法。 通过此委托封装该方法采用两个参数： 第一种是<xref:System.Reflection.MemberInfo>对象和第二个是`Object`。 该方法确定是否`MemberInfo`对象与指定的条件相匹配`Object`。 `Object`可能会分配任何一种在类字段的值<xref:System.Reflection.FieldAttributes>， <xref:System.Reflection.MethodAttributes>，或<xref:System.Reflection.MethodImplAttributes>。  
  
 例如，`Object`可以分配中的字段的值`FieldAttributes`如公共。 在这种情况下，当`FilterAttribute`调用委托时，它将返回`true`表示的方法时，才`MemberInfo`对象用元数据中的公共字段属性修饰。  
  
   
  
## Examples  
 下面的示例获取`FilterAttribute`委托，将它传递作为参数传递给<xref:System.Type.FindMembers%2A>方法，并显示指定的成员和及其属性。  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于名称的区分大小写的成员筛选器。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此字段保留对使用的委托的引用<xref:System.Type.FindMembers%2A>方法。 通过此委托封装该方法采用两个参数： 第一种是<xref:System.Reflection.MemberInfo>对象和第二个是`Object`。 该方法确定是否`MemberInfo`对象与指定的条件相匹配`Object`。 `Object`分配一个字符串值，其中可能包括尾随"*"通配符。 支持唯一通配符结束字符串匹配。  
  
 例如，`Object`可能会分配的值"字节 *"。 在这种情况下，当`FilterName`调用委托时，它将返回`true`表示的方法时，才`MemberInfo`对象具有"字节"开头的名称。  
  
   
  
## Examples  
 下面的代码示例获取与用户定义关联的方法`Application`类型。  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于名称的不区分大小写的成员筛选器。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此字段保留对使用的委托的引用<xref:System.Type.FindMembers%2A>方法。 通过此委托封装该方法采用两个参数： 第一种是<xref:System.Reflection.MemberInfo>对象和第二个是`Object`。 该方法确定是否`MemberInfo`对象与指定的条件相匹配`Object`。 `Object`分配一个字符串值，其中可能包括尾随"*"通配符。 支持唯一通配符结束字符串匹配。  
  
 例如，`Object`可能会分配的值"字节 *"。 在这种情况下，当`FilterName`调用委托，它将返回 true，仅表示的方法如果`MemberInfo`对象具有开头"字节"，以忽略大小写的名称。  
  
   
  
## Examples  
 下面的示例获取`MemberFilter`委托，将它传递作为参数传递给<xref:System.Type.FindMembers%2A>方法，并显示方法和及其属性的`String`忽略大小写字母"c"开头的类。  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">对照 <c>filterCriteria</c> 比较接口的委托。</param>
        <param name="filterCriteria">确定接口是否应包括在返回数组中的搜索判据。</param>
        <summary>返回表示接口（由当前 <see cref="T:System.Type" /> 所实现或继承）的筛选列表的 <see cref="T:System.Type" /> 对象数组。</summary>
        <returns>一个表示当前 <see cref="T:System.Type" /> 实现或继承的接口的筛选列表的 <see cref="T:System.Type" /> 对象数组，或者类型 <see cref="T:System.Type" /> 的空数组（如果当前 <see cref="T:System.Type" /> 没有实现或继承匹配筛选器的接口）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由派生类中重写。  
  
 <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType>和<xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType>委托提供<xref:System.Reflection.Module?displayProperty=nameWithType>还可以使用类，以替代<xref:System.Reflection.TypeFilter?displayProperty=nameWithType>委托。  
  
 搜索期间，将会考虑所有此类实现的接口的是，是否是由基类或该类本身声明。  
  
 此方法搜索基类层次结构，返回每个匹配的接口以及所有匹配的每个类实现这些接口实现的每个接口 （即，返回匹配的接口的传递闭包）。 返回没有重复的接口。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数<xref:System.Type.FindInterfaces%2A>搜索所有接口中声明约束类型参数中，并通过接口继承的所有接口约束中声明。 如果当前<xref:System.Type>表示泛型类型的类型自变量<xref:System.Type.FindInterfaces%2A>搜索所有类型，由实现的接口，无论它们与约束匹配。  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> 可以返回泛型接口，即使在非泛型的类型。 例如，实现非泛型类型可能`IEnumerable<int>`(`IEnumerable(Of Integer)`在 Visual Basic 中)。  
  
   
  
## Examples  
 下面的示例查找指定的接口实现或继承的指定类型，然后显示接口名称。  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用静态初始值设定项时引发了异常。</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">指示要搜索的成员类型的对象。</param>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <param name="filter">执行比较的委托，如果当前被检查的成员匹配 <c>filterCriteria</c>，则返回 <see langword="true" />；否则返回 <see langword="false" />。 可以使用该类提供的 <see langword="FilterAttribute" />、<see langword="FilterName" /> 和 <see langword="FilterNameIgnoreCase" /> 委托。 第一个委托使用 <see langword="FieldAttributes" />、<see langword="MethodAttributes" /> 和 <see langword="MethodImplAttributes" /> 的字段作为搜索判据，另两个委托使用 <see langword="String" /> 对象作为搜索判据。</param>
        <param name="filterCriteria">确定成员是否在 <see langword="MemberInfo" /> 对象数组中返回的搜索判据。  
  
 <see langword="FieldAttributes" />、<see langword="MethodAttributes" /> 和 <see langword="MethodImplAttributes" /> 的字段可以和该类提供的 <see langword="FilterAttribute" /> 委托一起使用。</param>
        <summary>返回指定成员类型的 <see cref="T:System.Reflection.MemberInfo" /> 对象的筛选数组。</summary>
        <returns>指定成员类型的 <see cref="T:System.Reflection.MemberInfo" /> 对象的筛选数组。  
  
 或  
  
 如果当前 <see cref="T:System.Reflection.MemberInfo" /> 没有匹配筛选判据的 <see cref="T:System.Type" /> 类型成员，则为 <paramref name="memberType" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由派生类中重写。  
  
 成员包括属性、 方法、 字段、 事件和等等。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括的成员：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Instance`在搜索中包括实例成员。  
  
-   指定`BindingFlags.Static`在搜索中包括静态成员。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共成员。  
  
-   指定`BindingFlags.NonPublic`在搜索中包括非公共成员 （即，私有、 内部和受保护成员）。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.DeclaredOnly` 要搜索仅上声明的成员<xref:System.Type>，不只是继承的成员。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 有效值为<xref:System.Type.MemberType%2A>中定义<xref:System.Reflection.MemberInfo>。 如果没有找到任何此类成员，则返回一个空数组。  
  
 若要获取类初始值设定项 (.cctor) 使用此方法，必须指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 你还可以获取类初始值设定项使用<xref:System.Type.TypeInitializer%2A>属性。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型或泛型方法，<xref:System.Type.FindMembers%2A>处理由类约束和接口约束的类型参数声明的任何成员。  
  
   
  
## Examples  
 下面的示例查找与指定的搜索条件匹配的类中的所有成员，然后显示匹配的成员。  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该类型的完全限定名称，包括其命名空间，但不包括程序集。</summary>
        <value>该类型的完全限定名，包括其命名空间，但不包括程序集；如果当前实例表示泛型类型参数、数组类型、指针类型或基于类型参数的 <see langword="null" /> 类型，或表示不属于泛型类型定义但包含无法解析的类型参数的泛型类型，则为 <see langword="byref" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，完全限定的名称的<xref:System.String>类型是`System.String`。 返回的程序集限定名称与此形成对比<xref:System.Type.AssemblyQualifiedName%2A>属性，它的完整名称和完整的程序集名称组成。  
  
 如果当前类型表示封闭式泛型类型，返回字符串中的类型自变量<xref:System.Type.FullName%2A>属性由其完整的程序集名称限定，即使没有进行其完全限定的字符串表示形式泛型类型本身也是如此程序集名称。 下面的示例演示了差异 FullName 属性中为表示泛型类型定义的类型和一个表示封闭式泛型类型。  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 此属性返回`null`如果：  
  
-   当前<xref:System.Type>对象表示泛型类型的类型参数。  
  
     下面的示例检索的类型参数<xref:System.Nullable%601>类型，并尝试显示其<xref:System.Type.FullName%2A>属性。  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   当前<xref:System.Type>对象表示数组类型，将指针类型、 或`byref`基于泛型类型参数的类型。  
  
     下面的示例定义泛型类型， `Generictype1<T>`，使用的三个方法： `Display(T[])`，后者传递的类型 T; 数组`HandleT(T)`，后者传递一个 T 对象中; 和`ChangeValue(ref T)`，后者按引用传递 T 对象。 由于 C# 和 Visual Basic 不允许我们将定义为中的指针的 T`HandleT`方法，我们必须调用<xref:System.Type.MakePointerType%2A>方法<xref:System.Type>表示要创建指向泛型类型的指针的方法的参数类型的对象。 示例输出显示，在所有三种情况下，<xref:System.Type.FullName%2A>属性是`null`。  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   当前的类型包含尚未被特定类型替代的泛型类型参数 (即，<xref:System.Type.ContainsGenericParameters%2A>属性返回`true`)，但类型不是泛型类型定义 (，即<xref:System.Type.IsGenericTypeDefinition%2A>属性将返回 `false`  
  
     在下面的示例中，`Derived<T>`继承自`Base<T>`。 <xref:System.Type.BaseType%2A>属性获取<xref:System.Type>表示基类型的对象`Derived<T>`，并将其<xref:System.Type.FullName%2A>属性返回`null`。  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     若要获取<xref:System.Type.FullName%2A>不`null`，你可以使用<xref:System.Type.GetGenericTypeDefinition%2A>方法来获取泛型类型定义，如示例所示。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例显示了指定的类型的完整名称。  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 下面的示例对返回的字符串进行比较<xref:System.Type.ToString%2A>方法和`Name`， <xref:System.Type.FullName%2A>，和<xref:System.Type.AssemblyQualifiedName%2A>属性。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取描述当前泛型类型参数的协变和特殊约束的 <see cref="T:System.Reflection.GenericParameterAttributes" /> 标志。</summary>
        <value>
          <see cref="T:System.Reflection.GenericParameterAttributes" /> 值的按位组合，用于描述当前泛型类型参数的协变和特殊约束。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的值包含描述当前泛型类型参数是协变的标志以及描述任何特殊约束的标志。 使用<xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType>值选择的协方差标志，并使用<xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType>要选择的约束标志值。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的代码示例定义一个泛型类型`Test`两个类型参数具有不同的约束。 程序执行时，使用检查这些约束<xref:System.Type.GenericParameterAttributes%2A>属性和<xref:System.Type.GetGenericParameterConstraints%2A>方法。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前的 <see cref="T:System.Type" /> 对象不是泛型类型参数。 也就是说，<see cref="P:System.Type.IsGenericParameter" /> 属性将返回 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.Type" /> 对象表示泛型类型或泛型方法的类型参数时，获取类型参数在声明它的泛型类型或方法的类型参数列表中的位置。</summary>
        <value>类型参数在定义它的泛型类型或方法的类型参数列表中的位置。 位置编号从 0 开始。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GenericParameterPosition%2A>属性返回的类型参数的位置中的泛型类型定义或泛型方法定义的参数列表最初定义的类型参数的位置。 <xref:System.Type.DeclaringType%2A>和<xref:System.Type.DeclaringMethod%2A>属性确定泛型类型或方法定义：  
  
-   如果<xref:System.Type.DeclaringMethod%2A>属性返回<xref:System.Reflection.MethodInfo>，则该<xref:System.Reflection.MethodInfo>表示泛型方法定义，以及当前<xref:System.Type>对象表示该泛型方法定义的类型参数。  
  
-   如果<xref:System.Type.DeclaringMethod%2A>属性返回`null`，则<xref:System.Type.DeclaringType%2A>属性始终返回<xref:System.Type>对象表示泛型类型定义和当前<xref:System.Type>对象表示泛型类型的类型参数定义。  
  
 若要为的值提供正确的上下文<xref:System.Type.GenericParameterPosition%2A>属性，它则需要来确定泛型类型或类型参数所属的方法。 例如，考虑泛型方法的返回值`GetSomething`下面的代码中：  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 返回的类型`GetSomething`取决于提供给类的类型自变量`A`并对其`GetSomething`本身。 你可以获取<xref:System.Reflection.MethodInfo>为`GetSomething`，并且可以从所获取的返回类型。 当你检查的类型参数的返回类型，<xref:System.Type.GenericParameterPosition%2A>都返回 0。 位置`V`为 0，因为`V`是类的类型参数列表中的第一个类型参数`A`。 位置`X`为 0，因为`X`是中的类型参数列表的第一个类型参数`GetSomething`。  
  
> [!NOTE]
>  调用<xref:System.Type.GenericParameterPosition%2A>属性将导致异常，如果当前<xref:System.Type>不表示类型参数。 当检查开放构造类型的类型自变量时，使用<xref:System.Type.IsGenericParameter%2A>属性来告知哪些是类型参数，哪些是类型。 <xref:System.Type.IsGenericParameter%2A>属性返回`true`类型参数; 然后可以使用<xref:System.Type.GenericParameterPosition%2A>方法可以获取其位置并使用<xref:System.Type.DeclaringMethod%2A>和<xref:System.Type.DeclaringType%2A>属性，以确定泛型方法或类型定义它的定义.  
  
   
  
## Examples  
 下面的示例定义具有两个类型参数的泛型类，并定义派生自的第一个类的第二个泛型类。 派生的类的基类具有两个类型参数： 第一种是<xref:System.Int32>，而第二个是派生类型的一个类型参数。 该示例显示有关这些泛型类的信息，包括位置报告的<xref:System.Type.GenericParameterPosition%2A>属性。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前的类型不表示类型参数。 也就是说，<see cref="P:System.Type.IsGenericParameter" /> 返回 <see langword="false" />。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此类型泛型类型参数的数组。</summary>
        <value>此类型的泛型类型参数的数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性获取仅的泛型类型自变量;也就是说，已为当前类型的泛型类型参数指定的类型。 如果当前类型是泛型类型定义，此属性将返回空数组。  
  
> [!NOTE]
>  如果泛型类型中使用了泛型方法或另一个泛型类型中，其泛型类型参数的一些可能的封闭方法或类型的泛型类型参数。  
  
 若要获取表示泛型类型定义的类型的泛型类型参数，请使用<xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType>属性。 若要获取<xref:System.Reflection.TypeInfo>当前对象<xref:System.Type>对象，请使用<xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType>扩展方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取数组中的维数。</summary>
        <returns>包含当前类型中维数的整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示在一个数组中的维数。  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此方法的功能在基类中不受支持，并且必须改为在派生类中实现。</exception>
        <exception cref="T:System.ArgumentException">当前类型不是数组。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，实现 <see cref="P:System.Type.Attributes" /> 属性 (Property)，并获取指示与 <see cref="T:System.Type" /> 关联的属性 (Attribute) 的位屏蔽。</summary>
        <returns>表示 <see cref="T:System.Reflection.TypeAttributes" /> 的属性集的 <see cref="T:System.Type" /> 对象。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的特定构造函数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">表示需要的构造函数的参数个数、顺序和类型的 <see cref="T:System.Type" /> 对象的数组。  
  
 或  
  
 <see cref="T:System.Type" /> 对象的空数组，用于获取不带参数的构造函数。 这样的空数组由 <see langword="static" /> 字段 <see cref="F:System.Type.EmptyTypes" /> 提供。</param>
        <summary>搜索其参数与指定数组中的类型匹配的公共实例构造函数。</summary>
        <returns>为表示某个公共实例构造函数（该构造函数的参数与参数类型数组中的类型匹配）的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重载查找的公共实例构造函数，不能用于获取了类初始值设定项 (.cctor)。 若要获取的类初始值设定项，请使用采用重载<xref:System.Reflection.BindingFlags>，并指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 你还可以获取类初始值设定项使用<xref:System.Type.TypeInitializer%2A>属性。  
  
 如果请求的构造函数为非公共，此方法返回`null`。  
  
> [!NOTE]
>  查找构造函数和方法时，不能省略参数。 在调用时，仅可以省略参数。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.ConstructorInfo>具有类型参数替换为相应的类型实参。 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此方法始终返回`null`。  
  
   
  
## Examples  
 下面的示例获取的一种`MyClass`，获取<xref:System.Reflection.ConstructorInfo>对象，并显示构造函数签名。  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多维的。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
 或  
  
 要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="types">
          <see cref="T:System.Type" /> 对象的数组，表示构造函数要获取的参数的个数、顺序和类型。  
  
 或  
  
 获取不使用参数的构造函数的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。  
  
 或  
  
 <see cref="F:System.Type.EmptyTypes" />。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与参数类型数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>使用指定绑定约束搜索其参数与指定自变量类型和修饰符匹配的构造函数。</summary>
        <returns>表示符合指定要求的构造函数的 <see cref="T:System.Reflection.ConstructorInfo" /> 对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不存在完全匹配， `binder` coerce 中指定的参数类型将尝试`types`以便选择一个匹配项的数组。 如果`binder`无法选择匹配项，然后单击`null`返回。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要包含在搜索中的构造函数：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共构造函数。  
  
-   指定`BindingFlags.NonPublic`要包含在搜索中的非公共构造函数 （即，私有、 内部和受保护的构造函数）。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要获取类初始值设定项 (.cctor) 使用此方法重载，你必须指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 你还可以获取类初始值设定项使用<xref:System.Type.TypeInitializer%2A>属性。  
  
> [!NOTE]
>  查找构造函数和方法时，不能省略参数。 在调用时，仅可以省略参数。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.ConstructorInfo>具有类型参数替换为相应的类型实参。 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此方法始终返回`null`。  
  
   
  
## Examples  
 下面的程序获取的一种`MyClass1`类，获取<xref:System.Reflection.ConstructorInfo>对象匹配指定的绑定标志，并显示构造函数的签名。  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多维的。  
  
 或  
  
 <paramref name="modifiers" /> 是多维的。  
  
 或  
  
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
 或  
  
 要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="callConvention">对象，用于指定要使用的一套规则，这些规则涉及自变量的顺序和布局、传递返回值的方式、用于自变量的寄存器和清理堆栈的方式。</param>
        <param name="types">
          <see cref="T:System.Type" /> 对象的数组，表示构造函数要获取的参数的个数、顺序和类型。  
  
 或  
  
 获取不使用参数的构造函数的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <c>types</c> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>用指定绑定约束和指定调用约定，搜索其参数与指定自变量类型及修饰符匹配的构造函数。</summary>
        <returns>表示符合指定要求的构造函数的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 虽然默认的联编程序不处理<xref:System.Reflection.ParameterModifier>(`modifiers`参数)，你可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写的自定义的联编程序`modifiers`。 `ParameterModifier` 当通过 COM 互操作调用，才使用并且可以通过引用传递的参数进行处理。  
  
 如果不存在完全匹配， `binder` coerce 中指定的参数类型将尝试`types`以便选择一个匹配项的数组。 如果`binder`无法选择匹配项，然后单击`null`返回。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要包含在搜索中的构造函数：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共构造函数。  
  
-   指定`BindingFlags.NonPublic`要包含在搜索中的非公共构造函数 （即，私有、 内部和受保护的构造函数）。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要获取类初始值设定项 (.cctor) 使用此方法，必须指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 你还可以获取类初始值设定项使用<xref:System.Type.TypeInitializer%2A>属性。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
> [!NOTE]
>  查找构造函数和方法时，不能省略参数。 在调用时，仅可以省略参数。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.ConstructorInfo>具有类型参数替换为相应的类型实参。 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此方法始终返回`null`。  
  
   
  
## Examples  
 下面的示例获取的一种`MyClass1`，获取<xref:System.Reflection.ConstructorInfo>匹配指定的绑定标志，并显示构造函数签名的对象。  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多维的。  
  
 或  
  
 <paramref name="modifiers" /> 是多维的。  
  
 或  
  
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
 或  
  
 要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="callConvention">对象，用于指定要使用的一套规则，这些规则涉及自变量的顺序和布局、传递返回值的方式、用于自变量的寄存器和清理堆栈的方式。</param>
        <param name="types">
          <see cref="T:System.Type" /> 对象的数组，表示构造函数要获取的参数的个数、顺序和类型。  
  
 或  
  
 获取不使用参数的构造函数的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <c>types</c> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>当在派生类中重写时，使用指定的绑定约束和指定的调用约定搜索其参数与指定的自变量类型和修饰符匹配的构造函数。</summary>
        <returns>表示符合指定要求的构造函数的 <see cref="T:System.Reflection.ConstructorInfo" /> 对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 虽然默认的联编程序不处理<xref:System.Reflection.ParameterModifier>(`modifiers`参数)，你可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写的自定义的联编程序`modifiers`。 `ParameterModifier` 当通过 COM 互操作调用，才使用并且可以通过引用传递的参数进行处理。  
  
 如果不存在完全匹配， `binder` coerce 中指定的参数类型将尝试`types`以便选择一个匹配项的数组。 如果`binder`无法选择匹配项，然后单击`null`返回。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要包含在搜索中的构造函数：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共构造函数。  
  
-   指定`BindingFlags.NonPublic`要包含在搜索中的非公共构造函数 （即，私有、 内部和受保护的构造函数）。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 此方法实现 <xref:System.Type.GetConstructor%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多维的。  
  
 或  
  
 <paramref name="modifiers" /> 是多维的。  
  
 或  
  
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <exception cref="T:System.NotSupportedException">当前类型是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的构造函数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回为当前 <see cref="T:System.Type" /> 定义的所有公共构造函数。</summary>
        <returns>
          <see cref="T:System.Reflection.ConstructorInfo" /> 对象的数组，表示当前 <see cref="T:System.Type" /> 定义的所有公共实例构造函数，但不包括类型初始值设定项（静态构造函数）。 如果没有为当前 <see cref="T:System.Type" /> 定义公共实例构造函数，或者当前 <see cref="T:System.Type" /> 表示泛型类型或泛型方法的定义中的类型参数，则返回 <see cref="T:System.Reflection.ConstructorInfo" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A>方法不返回按特定顺序，如声明顺序排列的构造函数。 你的代码必须不依赖于构造函数的返回顺序因为该顺序可以改变。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 此方法重载调用<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>方法重载中，与<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>在 Visual Basic 中)。 它将找不到类初始值设定项 (.cctor)。 若要查找类初始值设定项，请使用采用重载<xref:System.Reflection.BindingFlags>，并指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 你还可以获取类初始值设定项使用<xref:System.Type.TypeInitializer%2A>属性。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.ConstructorInfo>与替换为相应的类型实参的类型参数的对象。 例如，如果类`C<T>`具有构造函数`C(T t1)`(`Sub New(ByVal t1 As T)`在 Visual Basic 中)，则调用<xref:System.Type.GetConstructors%2A>上`C<int>`返回<xref:System.Reflection.ConstructorInfo>表示`C(int t1)`C# 中 (`Sub New(ByVal t1 As Integer)`在 Visual Basic 中)。  
  
 如果当前<xref:System.Type>表示泛型类型参数，<xref:System.Type.GetConstructors%2A>方法返回一个空数组。  
  
   
  
## Examples  
 此示例中显示的输出<xref:System.Type.GetConstructors%2A>重载从具有两个实例构造函数和一个静态构造函数的类。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 此代码的输出为：  
  
 2  
  
 False  
  
 False  
  
 因为<xref:System.Type.GetConstructors>重载仅使用<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>和<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>，静态构造函数既不计算的`for`表达式也由计算`IsStatic`。  
  
 若要查找静态构造函数，使用<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>重载，并将传递组合 (逻辑`OR`) 的<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>，下面的代码示例中所示：  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 现在的输出为：  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <summary>当在派生类中重写时，使用指定 <see cref="T:System.Type" /> 搜索为当前 <see langword="BindingFlags" /> 定义的构造函数。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.ConstructorInfo" /> 定义的匹配指定绑定约束的所有构造函数的 <see cref="T:System.Type" /> 对象数组，包括类型初始值设定项（如果定义的话）。 如果当前 <see cref="T:System.Reflection.ConstructorInfo" /> 没有定义构造函数，或者定义的构造函数都不符合绑定约束，或者当前 <see cref="T:System.Type" /> 表示泛型类型或泛型方法定义的类型参数，则返回 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A>方法不返回按特定顺序，如声明顺序排列的构造函数。 你的代码必须不依赖于构造函数的返回顺序因为该顺序可以改变。  
  
 `bindingAttr` 可以用于指定是否返回只有公共构造函数或公共和非公共构造函数。  
  
 如果不存在完全匹配， `binder` coerce 中指定的参数类型将尝试`types`以便选择一个匹配项的数组。 如果`binder`无法选择匹配项，然后单击`null`返回。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要包含在搜索中的构造函数：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共构造函数。  
  
-   指定`BindingFlags.NonPublic`要包含在搜索中的非公共构造函数 （即，私有、 内部和受保护的构造函数）。 基类的构造函数不会返回。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要获取类初始值设定项 (.cctor) 使用此方法重载，你必须指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 你还可以获取类初始值设定项使用<xref:System.Type.TypeInitializer%2A>属性。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.ConstructorInfo>与替换为相应的类型实参的类型参数的对象。 例如，如果类`C<T>`具有构造函数`C(T t1)`(`Sub New(ByVal t1 As T)`在 Visual Basic 中)，则调用<xref:System.Type.GetConstructors%2A>上`C<int>`返回<xref:System.Reflection.ConstructorInfo>表示`C(int t1)`C# 中 (`Sub New(ByVal t1 As Integer)`在 Visual Basic 中)。  
  
 如果当前<xref:System.Type>表示泛型类型参数，<xref:System.Type.GetConstructors%2A>方法返回一个空数组。  
  
   
  
## Examples  
 此示例中显示的输出<xref:System.Type.GetConstructors>重载从具有两个实例构造函数和一个静态构造函数的类。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 此代码的输出为：  
  
 2  
  
 False  
  
 False  
  
 因为<xref:System.Type.GetConstructors%2A>重载仅使用<xref:System.Reflection.BindingFlags.Public>和<xref:System.Reflection.BindingFlags.Instance>，静态构造函数既不计算的`for`表达式也由计算`IsStatic`。  
  
 若要查找静态构造函数，使用<xref:System.Type.GetConstructors%2A>重载，并将其传递的组合 （逻辑或） <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>， <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>，下面的代码示例中所示：  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 现在的输出为：  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>搜索为设置了 <see cref="T:System.Type" /> 的当前 <see cref="T:System.Reflection.DefaultMemberAttribute" /> 定义的成员。</summary>
        <returns>表示当前 <see cref="T:System.Reflection.MemberInfo" /> 的所有默认成员的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 如果当前 <see cref="T:System.Reflection.MemberInfo" /> 没有默认成员，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetDefaultMembers%2A>方法不返回成员按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于成员的返回顺序因为该顺序可以改变。  
  
 此方法由派生类中重写。  
  
 成员包括属性、 方法、 字段、 事件和等等。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.MemberInfo>与替换为相应的类型实参的类型参数的对象。 例如，如果类`C<T>`都有一个属性`P`返回`T`，则调用<xref:System.Type.GetDefaultMembers%2A>上`C<int>`返回`int P`C# 中 (`Property P As Integer`在 Visual Basic 中)。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法，则此方法的定义中的类型参数搜索类约束的成员或成员的<xref:System.Object>如果没有类约束。  
  
   
  
## Examples  
 下面的示例获取的默认成员信息`MyClass`并显示的默认成员。  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，返回当前数组、指针或引用类型包含的或引用的对象的 <see cref="T:System.Type" />。</summary>
        <returns>当前数组、指针或引用类型包含或引用的对象的 <see cref="T:System.Type" />；如果当前 <see langword="null" /> 不是数组或指针，不是按引用传递，或者表示泛型类型或泛型方法的定义中的泛型类型或类型参数，则为 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回`null`为<xref:System.Array>类。  
  
   
  
## Examples  
 下面的示例演示如何使用`GetElementType`方法。  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要检索其名称的值。</param>
        <summary>返回当前枚举类型中具有指定值的常数的名称。</summary>
        <returns>当前枚举类型中具有指定值的成员的名称；如果未找到这样的常数，则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">当前类型不是一个枚举。  
  
 或  
  
 <paramref name="value" /> 不是当前类型，也不具有与当前类型相同的基础类型。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前枚举类型中各个成员的名称。</summary>
        <returns>一个数组，其中包含枚举中各个成员的名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回值数组的元素进行排序的枚举常量的二进制值 （即，符号值）。 如果数组包含与相同的值的枚举的常数，则不指定其相应名称的顺序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前类型不是一个枚举。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前枚举类型的基础类型。</summary>
        <returns>当前枚举的基础类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，C# 和 Visual Basic 中的一个枚举的基础类型是<xref:System.Int32>。 可以指定其他整数类型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前类型不是一个枚举。  
  
 或  
  
 枚举类型无效，因为它包含多个实例字段。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前枚举类型中各个常数的值组成的数组。</summary>
        <returns>包含值的数组。 该数组的元素按枚举常量的二进制值（无符号值）排序。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">当前类型不是一个枚举。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取由当前 <see cref="T:System.Type" /> 声明或继承的特定事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">该字符串包含事件名称，该事件是由当前 <see cref="T:System.Type" /> 声明或继承的。</param>
        <summary>返回表示指定的公共事件的 <see cref="T:System.Reflection.EventInfo" /> 对象。</summary>
        <returns>如找到，则为表示由当前 <see cref="T:System.Type" /> 声明或继承的指定公共事件的对象；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果它具有至少一个方法或访问器是公共的则认为反射到公共事件。 否则，该事件被视为私有的并且你必须使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，组合使用这些值`Or`) 来获取它。  
  
 搜索`name`区分大小写。 搜索包括公共静态和公共实例事件。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.EventInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的事件。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Reflection.EventInfo>对象，并指定事件的按钮类获取事件。  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">字符串包含由当前的 <see cref="T:System.Type" /> 声明或继承的事件的名称。</param>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，返回表示指定事件的 <see cref="T:System.Reflection.EventInfo" /> 对象。</summary>
        <returns>如找到，则为表示由当前 <see cref="T:System.Type" /> 声明或继承的指定公共事件的对象；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括的事件：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共事件。  
  
-   指定`BindingFlags.NonPublic`若要在搜索中包括非公共事件 （即，私有、 内部和受保护事件）。  
  
-   指定`BindingFlags.FlattenHierarchy`包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.IgnoreCase` 若要忽略的大小写`name`。  
  
-   `BindingFlags.DeclaredOnly` 要搜索仅上声明的事件<xref:System.Type>，不只是继承的事件。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果它具有至少一个方法或访问器是公共的则认为反射到公共事件。 否则，该事件被视为私有的并且你必须使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，组合使用这些值`Or`) 来获取它。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.EventInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的事件。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29>方法搜索的类型的公共或非公共事件名为"单击"不是`static`(`Shared`在 Visual Basic 中)。  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取由当前 <see cref="T:System.Type" /> 声明或继承的事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回由当前 <see cref="T:System.Type" /> 声明或继承的所有公共事件。</summary>
        <returns>表示由当前 <see cref="T:System.Reflection.EventInfo" /> 声明或继承的所有公共事件的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 如果当前 <see cref="T:System.Reflection.EventInfo" /> 没有默认成员，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果它具有至少一个方法或访问器是公共的则认为反射到公共事件。 否则，该事件被视为私有的并且你必须使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，组合使用这些值`Or`) 来获取它。  
  
 <xref:System.Type.GetEvents%2A>方法不返回事件按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于事件的返回顺序因为该顺序可以改变。  
  
 此方法由派生类中重写。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.EventInfo>与替换为相应的类型实参的类型参数的对象。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的事件。  
  
   
  
## Examples  
 下面的示例获取数组的<xref:System.Reflection.EventInfo>的对象，获取有关的所有事件`Button`类，并显示事件名称。 若要编译 Visual Basic 示例，请使用下面的命令行：  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，搜索由当前 <see cref="T:System.Type" /> 声明或继承的事件。</summary>
        <returns>
          <see cref="T:System.Reflection.EventInfo" /> 对象的数组，表示当前 <see cref="T:System.Type" /> 所声明或继承的与指定绑定约束匹配的所有事件。  
  
 或  
  
 如果当前 <see cref="T:System.Reflection.EventInfo" /> 没有事件，或者如果没有一个事件匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetEvents%2A>方法不返回事件按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于事件的返回顺序因为该顺序可以改变。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括的事件：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共事件。  
  
-   指定`BindingFlags.NonPublic`若要在搜索中包括非公共事件 （即，私有、 内部和受保护事件）。 仅保护，将返回基类上的内部事件;不会返回私有基类上的事件。  
  
-   指定`BindingFlags.FlattenHierarchy`包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.DeclaredOnly` 要搜索仅上声明的事件<xref:System.Type>，不只是继承的事件。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果它具有至少一个方法或访问器是公共的则认为反射到公共事件。 否则，该事件被视为私有的并且你必须使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，组合使用这些值`Or`) 来获取它。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.EventInfo>与替换为相应的类型实参的类型参数的对象。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的事件。  
  
   
  
## Examples  
 下面的示例获取数组的<xref:System.Reflection.EventInfo>与指定的绑定标志匹配的对象获取的所有事件`Button`类，并显示事件名称。 若要编译 Visual Basic 示例，请使用下面的命令行：  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的特定字段。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的数据字段的名称的字符串。</param>
        <summary>搜索具有指定名称的公共字段。</summary>
        <returns>如找到，则为表示具有指定名称的公共字段的对象；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索`name`区分大小写。 搜索包括公共静态和公共实例字段。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.FieldInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的字段。  
  
   
  
## Examples  
 下面的示例获取`Type`对象指定的类，获取<xref:System.Reflection.FieldInfo>字段的对象，并显示字段的值。  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">该 <see cref="T:System.Type" /> 对象为 <see cref="T:System.Reflection.Emit.TypeBuilder" />，其 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法尚未被调用。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的数据字段的名称的字符串。</param>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <summary>使用指定绑定约束搜索指定字段。</summary>
        <returns>表示符合指定要求的字段的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括哪些字段：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`若要在搜索中包含公共字段。  
  
-   指定`BindingFlags.NonPublic`若要在搜索中包含非公共字段 （即，私有、 内部和受保护字段）。  
  
-   指定`BindingFlags.FlattenHierarchy`包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.IgnoreCase` 若要忽略的大小写`name`。  
  
-   `BindingFlags.DeclaredOnly` 要搜索仅上声明的字段<xref:System.Type>，不只是继承的字段。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.FieldInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的字段。  
  
   
  
## Examples  
 下面的示例获取`Type`对象指定的类，获取<xref:System.Reflection.FieldInfo>匹配指定的绑定标志，并显示字段的值的字段的对象。  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的字段。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前 <see cref="T:System.Type" /> 的所有公共字段。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的所有公共字段的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 如果没有为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的公共字段，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A>方法不返回字段按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于字段的返回顺序因为该顺序可以改变。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.FieldInfo>与替换为相应的类型实参的类型参数的对象。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的公共字段。  
  
   
  
## Examples  
 下面的示例演示使用`GetFields()`方法。  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，搜索为当前 <see cref="T:System.Type" /> 定义的字段。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的匹配指定绑定约束的所有字段的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 如果没有为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的字段，或者如果没有一个定义的字段匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A>方法不返回字段按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于字段的返回顺序因为该顺序可以改变。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括哪些字段：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`若要在搜索中包含公共字段。  
  
-   指定`BindingFlags.NonPublic`若要在搜索中包含非公共字段 （即，私有、 内部和受保护字段）。 仅保护，将返回基类上的内部字段;基类上的私有字段不会返回。  
  
-   指定`BindingFlags.FlattenHierarchy`包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.DeclaredOnly` 要搜索仅上声明的字段<xref:System.Type>，不只是继承的字段。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.FieldInfo>与替换为相应的类型实参的类型参数的对象。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的公共字段。  
  
   
  
## Examples  
 下面的示例演示使用`GetFields(BindingFlags)`方法。  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示封闭式泛型类型的类型参数或泛型类型定义的类型参数的 <see cref="T:System.Type" /> 对象的数组。</summary>
        <returns>表示泛型类型的类型实参的 <see cref="T:System.Type" /> 对象的数组。 如果当前类型不是泛型类型，则返回一个空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组元素的泛型类型的类型参数列表中出现的顺序返回。  
  
-   如果当前类型是封闭式构造的类型 (即，<xref:System.Type.ContainsGenericParameters%2A>属性返回`false`)，返回的数组<xref:System.Type.GetGenericArguments%2A>方法包含已分配给泛型类型定义的泛型类型参数的类型.  
  
-   如果当前类型是泛型类型定义，该数组包含的类型参数。  
  
-   如果当前类型为开放式构造的类型 (即，<xref:System.Type.ContainsGenericParameters%2A>属性返回`true`) 中的特定类型不已分配到的所有类型参数和类型参数的封闭式泛型类型或方法，该数组包含类型和类型参数。 使用<xref:System.Type.IsGenericParameter%2A>属性来区分它们。 有关此方案的演示，请参阅的代码示例<xref:System.Type.ContainsGenericParameters%2A>属性。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Type.GetGenericArguments%2A>方法以显示构造的类型的类型自变量和其泛型类型定义的类型参数。  
  
 此代码示例摘自更大的示例为提供<xref:System.Type.IsGenericTypeDefinition%2A>属性。 请参阅示例输出更大的示例。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。 派生类必须提供一个实现。</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前泛型类型参数约束的 <see cref="T:System.Type" /> 对象的数组。</summary>
        <returns>表示当前泛型类型参数上的约束的 <see cref="T:System.Type" /> 对象的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 泛型类型参数上的每个约束都表示为<xref:System.Type>对象。 使用<xref:System.Type.IsClass%2A>属性以确定约束是否是基类约束; 如果该属性返回`false`，约束为接口约束。 如果某个类型参数没有类约束和接口约束，则返回一个空数组。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的代码示例定义一个泛型类型`Test`两个类型参数具有不同的约束。 程序执行时，使用检查这些约束<xref:System.Type.GenericParameterAttributes%2A>属性和<xref:System.Type.GetGenericParameterConstraints%2A>方法。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前的 <see cref="T:System.Type" /> 对象不是泛型类型参数。 也就是说，<see cref="P:System.Type.IsGenericParameter" /> 属性将返回 <see langword="false" />。</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个表示可用于构造当前泛型类型的泛型类型定义的 <see cref="T:System.Type" /> 对象。</summary>
        <returns>表示可用于构造当前类型的泛型类型的 <see cref="T:System.Type" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 泛型类型定义是可从其构造其他类型的模板。 例如，从泛型类型定义`G<T>`（用表示 C# 语法;`G(Of T)`在 Visual Basic 中或`generic <typename T> ref class G`c + + 中) 构造并将其实例化类型`G<int>`(`G(Of Integer)`在 Visual Basic 中)。 给定<xref:System.Type>对象表示此构造类型，<xref:System.Type.GetGenericTypeDefinition%2A>方法返回的泛型类型定义。  
  
 如果两个构造的类型创建从相同的泛型类型定义，使用相同的类型实参，<xref:System.Type.GetGenericTypeDefinition%2A>方法返回相同<xref:System.Type>这两种类型的对象。  
  
 如果调用<xref:System.Type.GetGenericTypeDefinition%2A>方法<xref:System.Type>对象已表示泛型类型定义，它将返回当前<xref:System.Type>。  
  
> [!IMPORTANT]
>  泛型类型的数组不是泛型本身。 在 C# 代码`A<int>[] v;`或 Visual Basic 代码`Dim v() As A(Of Integer)`，变量的类型`v`不是泛型。 使用<xref:System.Type.IsGenericType%2A>来确定类型是否为泛型之前调用<xref:System.Type.GetGenericTypeDefinition%2A>。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的代码示例通过使用普通的实例创建创建构造类型的实例，然后使用<xref:System.Type.GetType%2A>和<xref:System.Type.GetGenericTypeDefinition%2A>方法来检索的构造的类型和泛型类型定义。 此示例使用泛型<xref:System.Collections.Generic.Dictionary%602>类型; 构造的类型表示<xref:System.Collections.Generic.Dictionary%602>的`Test`具有字符串键的对象。  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前类型不是泛型类型。  也就是说，<see cref="P:System.Type.IsGenericType" /> 返回 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。 派生类必须提供一个实现。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此实例的哈希代码。</summary>
        <returns>此实例的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例显示的哈希代码`System.Windows.Forms.Button`类。  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取由当前 <see cref="T:System.Type" /> 实现或继承的特定接口。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的接口名称的字符串。 对于泛型接口，这是重整名称。</param>
        <summary>搜索具有指定名称的接口。</summary>
        <returns>表示具有指定名称且由当前的 <see cref="T:System.Type" /> 实现或继承的接口的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索`name`区分大小写。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Type>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法，则此方法的定义中的类型参数将搜索接口约束和继承的类或接口约束的所有接口。  
  
> [!NOTE]
>  对于泛型接口，`name`参数是重整的名称，以重音符结尾 (\`) 和类型参数的数目。 这适用于泛型接口定义和构造的泛型接口。 例如，若要查找`IExample<T>`(`IExample(Of T)`在 Visual Basic 中) 或`IExample<string>`(`IExample(Of String)`在 Visual Basic 中)，搜索``"IExample`1"``。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Type.GetInterface%28System.String%29>方法搜索<xref:System.Collections.Hashtable>类<xref:System.Runtime.Serialization.IDeserializationCallback>接口，并列出接口的方法。  
  
 代码示例还演示<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>方法重载与<xref:System.Type.GetInterfaceMap%2A>方法。  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">当前 <see cref="T:System.Type" /> 表示使用不同类型参数实现同一泛型接口的类型。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的接口名称的字符串。 对于泛型接口，这是重整名称。</param>
        <param name="ignoreCase">
          <see langword="true" /> 表示对于用来指定简单接口名称的 <c>name</c> 部分（该部分指定命名空间大小写必须正确）忽略其大小写。  
  
 或  
  
 <see langword="false" /> 表示对 <c>name</c> 的所有部分执行区分大小写的搜索。</param>
        <summary>当在派生类中重写时，搜索指定的接口，指定是否要对接口名称执行不区分大小写的搜索。</summary>
        <returns>表示具有指定名称且由当前的 <see cref="T:System.Type" /> 实现或继承的接口的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ignoreCase`参数仅适用于不到命名空间的简单接口名称。 部分`name`，指定该命名空间必须包含正确的大小写，或将找不到该接口。 例如，"System.icomparable"查找在字符串<xref:System.IComparable>接口，但字符串"system.icomparable"却没有。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Type>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法，则此方法的定义中的类型参数将搜索接口约束和继承的类或接口约束的所有接口。  
  
> [!NOTE]
>  对于泛型接口，`name`参数是重整的名称，以重音符结尾 (\`) 和类型参数的数目。 这适用于泛型接口定义和构造的泛型接口。 例如，若要查找`IExample<T>`(`IExample(Of T)`在 Visual Basic 中) 或`IExample<string>`(`IExample(Of String)`在 Visual Basic 中)，搜索`"IExample`1"。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>方法执行不区分大小写的搜索的<xref:System.Collections.Hashtable>类<xref:System.Collections.IEnumerable>接口。  
  
 代码示例还演示<xref:System.Type.GetInterface%28System.String%29>方法重载与<xref:System.Type.GetInterfaceMap%2A>方法。  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">当前 <see cref="T:System.Type" /> 表示使用不同类型参数实现同一泛型接口的类型。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">要检索其映射的接口类型。</param>
        <summary>返回指定接口类型的接口映射。</summary>
        <returns>表示 <paramref name="interfaceType" /> 的接口映射的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接口映射表示如何接口映射到实现该接口的类上的实际成员。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，类型参数替换的元素中的适当类型自变量为<xref:System.Reflection.InterfaceMapping>此方法返回。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Type.GetInterfaceMap%2A>方法来确定如何<xref:System.IFormatProvider>接口映射到<xref:System.Globalization.CultureInfo>方法，以及如何<xref:System.IAppDomainSetup>接口映射到<xref:System.AppDomainSetup>属性。 请注意，因为<xref:System.IAppDomainSetup>接口定义一组属性，返回<xref:System.Reflection.InterfaceMapping>对象包括单独<xref:System.Reflection.MethodInfo>对象的属性的 get 和 set 访问器。  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="interfaceType" /> 未由当前类型实现。  
  
 或  
  
 <paramref name="interfaceType" /> 参数不引用接口。  
  
 或  
  
 <paramref name="interfaceType" /> 是泛型接口，当前类型是数组类型。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">当前的 <see cref="T:System.Type" /> 表示泛型类型参数；即，<see cref="P:System.Type.IsGenericParameter" /> 为 <see langword="true" />。</exception>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。 派生类必须提供一个实现。</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，获取由当前 <see cref="T:System.Type" /> 实现或继承的所有接口。</summary>
        <returns>表示由当前 <see cref="T:System.Type" /> 实现或继承的所有接口的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 如果没有由当前 <see cref="T:System.Type" /> 实现或继承的接口，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetInterfaces%2A>方法不返回接口按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于接口的返回顺序因为该顺序可以改变。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Type>与替换为相应的类型实参的类型参数的对象。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法，则此方法的定义中的类型参数将搜索接口约束和继承的类或接口约束的所有接口。  
  
   
  
## Examples  
 下面的示例获取指定的类的类型，并显示该类型实现或继承的所有接口。 若要编译 Visual Basic 示例，请使用以下的编译器命令：  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">调用静态初始值设定项时引发了异常。</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的指定成员。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共成员名称的字符串。</param>
        <summary>搜索具有指定名称的公共成员。</summary>
        <returns>一个表示具有指定名称的公共成员的 <see cref="T:System.Reflection.MemberInfo" /> 对象数组（如果找到的话）；否则为空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索`name`区分大小写。 搜索范围包括公共静态和公共实例成员。  
  
 成员包括属性、 方法、 字段、 事件和等等。  
  
 <xref:System.Type.GetMember%2A>方法不返回成员按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于成员的返回顺序因为该顺序可以改变。  
  
 此方法重载将找不到类初始值设定项 (.cctor)。 若要查找类初始值设定项，请使用采用重载<xref:System.Reflection.BindingFlags>，并指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 你还可以获取类初始值设定项使用<xref:System.Type.TypeInitializer%2A>属性。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.MemberInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法，则此方法的定义中的类型参数搜索类约束的成员或成员的<xref:System.Object>如果没有类约束。  
  
> [!NOTE]
>  对于泛型方法，不包括中的类型自变量`name`。 例如，C# 代码`GetMember("MyMethod<int>")`搜索文本同名的成员"`MyMethod<int>`"，而不是一个名为方法`MyMethod`具有的类型的一个泛型参数`int`。  
  
   
  
## Examples  
 下面的示例显示的所有成员`String`以字母 C 开头的类  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的成员的名称的字符串。</param>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，返回空数组。</param>
        <summary>使用指定绑定约束搜索指定成员。</summary>
        <returns>一个表示具有指定名称的公共成员的 <see cref="T:System.Reflection.MemberInfo" /> 对象数组（如果找到的话）；否则为空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由派生类中重写。  
  
 成员包括属性、 方法、 字段、 事件和等等。  
  
 <xref:System.Type.GetMember%2A>方法不返回成员按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于成员的返回顺序因为该顺序可以改变。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括的成员：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共成员。  
  
-   指定`BindingFlags.NonPublic`在搜索中包括非公共成员 （即，私有、 内部和受保护成员）。  
  
-   指定`BindingFlags.FlattenHierarchy`包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.IgnoreCase` 若要忽略的大小写`name`。  
  
-   `BindingFlags.DeclaredOnly` 要搜索仅上声明的成员<xref:System.Type>，不只是继承的成员。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要获取类初始值设定项 (.cctor) 使用此方法重载，必须指定".cctor"为`name`，和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中) 为`bindingAttr`。 你还可以获取类初始值设定项使用<xref:System.Type.TypeInitializer%2A>属性。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.MemberInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法，则此方法的定义中的类型参数搜索类约束的成员或成员的<xref:System.Object>如果没有类约束。  
  
> [!NOTE]
>  对于泛型方法，不包括中的类型自变量`name`。 例如，C# 代码`GetMember("MyMethod<int>")`搜索文本同名的成员"`MyMethod<int>`"，而不是一个名为方法`MyMethod`具有的类型的一个泛型参数`int`。  
  
   
  
## Examples  
 下面的示例显示的所有公共静态成员`myString`以字母 C 开头的类  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的成员的名称的字符串。</param>
        <param name="type">要搜索的值。</param>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，返回空数组。</param>
        <summary>使用指定绑定约束搜索指定成员类型的指定成员。</summary>
        <returns>一个表示具有指定名称的公共成员的 <see cref="T:System.Reflection.MemberInfo" /> 对象数组（如果找到的话）；否则为空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成员包括属性、 方法、 字段、 事件和等等。  
  
 <xref:System.Type.GetMember%2A>方法不返回成员按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于成员的返回顺序因为该顺序可以改变。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括的成员：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共成员。  
  
-   指定`BindingFlags.NonPublic`在搜索中包括非公共成员 （即，私有、 内部和受保护成员）。  
  
-   指定`BindingFlags.FlattenHierarchy`包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.IgnoreCase` 若要忽略的大小写`name`。  
  
-   `BindingFlags.DeclaredOnly` 要搜索仅上声明的成员<xref:System.Type>，不只是继承的成员。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要获取类初始值设定项 (.cctor) 使用此方法重载，必须指定".cctor"为`name`，<xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType>为`type`，和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>中Visual Basic) 的`bindingAttr`。 你还可以获取类初始值设定项使用<xref:System.Type.TypeInitializer%2A>属性。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.MemberInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法，则此方法的定义中的类型参数搜索类约束的成员或成员的<xref:System.Object>如果没有类约束。  
  
> [!NOTE]
>  对于泛型方法，不包括中的类型自变量`name`。 例如，C# 代码`GetMember("MyMethod<int>")`搜索文本同名的成员"`MyMethod<int>`"，而不是一个名为方法`MyMethod`具有的类型的一个泛型参数`int`。  
  
   
  
## Examples  
 下面的示例显示的所有方法`myString`以字母 C 开头的类  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">派生类必须提供一个实现。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的成员（包括属性、方法、字段、事件等）。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回为当前 <see cref="T:System.Type" /> 的所有公共成员。</summary>
        <returns>表示当前 <see cref="T:System.Reflection.MemberInfo" /> 的所有公共成员的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 如果当前 <see cref="T:System.Reflection.MemberInfo" /> 没有公共成员，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成员包括属性、 方法、 字段、 事件和等等。  
  
 <xref:System.Type.GetMembers%2A>方法不返回成员按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于成员的返回顺序因为该顺序可以改变。  
  
 此方法重载调用<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>方法重载中，与<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>在 Visual Basic 中)。 它将找不到类初始值设定项 (.cctor)。 若要查找类初始值设定项，请使用采用重载<xref:System.Reflection.BindingFlags>，并指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 你还可以获取类初始值设定项使用<xref:System.Type.TypeInitializer%2A>属性。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.MemberInfo>与替换为相应的类型实参的类型参数的对象。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法，则此方法的定义中的类型参数搜索类约束的成员或成员的<xref:System.Object>如果没有类约束。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Type.GetMembers>方法重载来收集有关指定类的所有公共成员的信息。  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 如果为零 (<see cref="F:System.Reflection.BindingFlags.Default" />)，则返回空数组。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，搜索为当前 <see cref="T:System.Type" /> 定义的成员。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.MemberInfo" /> 定义的匹配指定绑定约束的所有成员的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 如果没有为当前 <see cref="T:System.Reflection.MemberInfo" /> 定义的成员，或者如果没有一个定义的成员匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成员包括属性、 方法、 字段、 事件和等等。  
  
 <xref:System.Type.GetMembers%2A>方法不返回成员按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于成员的返回顺序因为该顺序可以改变。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括的成员：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共成员。  
  
-   指定`BindingFlags.NonPublic`在搜索中包括非公共成员 （即，私有、 内部和受保护成员）。 仅保护和; 不在返回基类上的内部成员基类上的私有成员不会返回。  
  
-   指定`BindingFlags.FlattenHierarchy`包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.DeclaredOnly` 要搜索仅上声明的成员<xref:System.Type>，不只是继承的成员。  
  
 调用此方法仅用`Public`标志或仅`NonPublic`标志将返回指定的成员，并且不需要任何其他标志。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要获取类初始值设定项 (.cctor) 使用此方法重载，你必须指定<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 你还可以获取类初始值设定项使用<xref:System.Type.TypeInitializer%2A>属性。  
  
 如果当前表示构造的泛型类型，此方法将返回<xref:System.Reflection.MemberInfo>与替换为相应的类型实参的类型参数的对象。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法，则此方法的定义中的类型参数搜索类约束的成员或成员的<xref:System.Object>如果没有类约束。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>方法重载来收集有关指定类的所有公共实例成员的信息。  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的特定方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共方法的名称的字符串。</param>
        <summary>搜索具有指定名称的公共方法。</summary>
        <returns>表示具有指定名称的公共方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索`name`区分大小写。 搜索范围包括公共静态和公共实例方法。  
  
 如果一种方法重载方法，有多个公共方法，<xref:System.Type.GetMethod%28System.String%29>方法抛出异常<xref:System.Reflection.AmbiguousMatchException>异常。 在下面的示例中，因为没有多个公共重载引发异常<xref:System.Int32.ToString%2A?displayProperty=nameWithType>方法。  另一方面，因为`Person.ToString`方法重写<xref:System.Object.ToString%2A?displayProperty=nameWithType>并因此不重载，则<xref:System.Type.GetMethod%28System.String%29>方法是能够检索<xref:System.Reflection.MethodInfo>对象。  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 你可以执行以下操作以检索特定的方法之一：  
  
-   调用<xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29>方法并指定`bindingAttr`唯一标识该方法的参数。 例如，如果将引发异常，因为类型具有一个静态和实例重载，则可以指定`bindingAttr`参数<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>。  
  
-   调用的重载<xref:System.Type.GetMethod%2A>包含方法中，`types`参数定义的方法的参数的类型。  
  
-   调用<xref:System.Type.GetMethods>方法来检索包含所有属于一种类型的公共方法的数组。 然后，可以循环来标识重复的方法名为`name`。  
  
 如果当前表示构造的泛型类型，此方法将返回<xref:System.Reflection.MethodInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型或泛型方法，则此方法定义中搜索类约束的方法或方法的<xref:System.Object>如果没有类约束。  
  
> [!NOTE]
>  对于泛型方法，不包括中的类型自变量`name`。 例如，C# 代码`GetMember("MyMethod<int>")`搜索文本同名的成员"`MyMethod<int>`"，而不是一个名为方法`MyMethod`具有的类型的一个泛型参数`int`。  
  
   
  
## Examples  
 下面的示例获取名为的方法`MethodA`。  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到了多个具有指定名称的方法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的方法名称的字符串。</param>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <summary>使用指定绑定约束搜索指定方法。</summary>
        <returns>表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括的方法：  
  
-   你必须指定<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>为了获取返回。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>要包含在搜索中的公共方法。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>要包含在搜索中的非公共方法 （即，私有、 内部和受保护的方法）。  
  
-   指定<xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType>包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> 若要忽略的大小写`name`。  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> 要搜索只有上声明的方法<xref:System.Type>，不只是继承的方法。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果一种方法重载方法，多个重载满足指定的约束`bindingAttr`自变量，该方法将引发<xref:System.Reflection.AmbiguousMatchException>异常。 在下面的示例中，将引发异常，因为：  
  
-   `TestClass`类型具有两个公共实例重载`DisplayValue`方法，`DisplayValue(String)`和`DisplayValue(String, Object[])`。  
  
-   `TestClass`类型具有两个公共实例重载`Equals`方法，其中一个继承自<xref:System.Object>:`Equals(TestClass)`和`Equals(Object)`。  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 你可以执行以下操作以检索特定的方法之一：  
  
-   更改的绑定约束。 在前面的示例中，尝试检索公共实例`Equals`方法声明由类型并不继承成功检索`Equals(TestClass)`。  
  
-   调用的重载<xref:System.Type.GetMethod%2A>包含方法中，`types`参数定义的方法的参数的类型。  
  
-   调用<xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29>方法来检索包含所有具有指定的绑定特性的方法属于一种类型的数组。 然后，可以循环来标识重复的方法名为`name`。 这种方法如下所示的上一示例的处理程序<xref:System.Reflection.AmbiguousMatchException>异常。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.MethodInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型或泛型方法，则此方法定义中搜索类约束的方法或方法的<xref:System.Object>如果没有类约束。  
  
> [!NOTE]
>  对于泛型方法，不包括中的类型自变量`name`。 例如，C# 代码`GetMember("MyMethod<int>")`搜索文本同名的成员"`MyMethod<int>`"，而不是一个名为方法`MyMethod`具有的类型的一个泛型参数`int`。  
  
   
  
## Examples  
 下面的示例获取符合指定的绑定标志的方法。  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定绑定约束匹配的方法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共方法的名称的字符串。</param>
        <param name="types">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</param>
        <summary>搜索其参数与指定参数类型匹配的指定公共方法。</summary>
        <returns>表示其参数与指定参数类型匹配的公共方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索`name`区分大小写。 搜索范围包括公共静态和公共实例方法。  
  
> [!NOTE]
>  查找构造函数和方法时，不能省略参数。 在调用时，仅可以省略参数。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.MethodInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型或泛型方法，则此方法定义中搜索类约束的方法或方法的<xref:System.Object>如果没有类约束。  
  
> [!NOTE]
>  `name`参数不能包含类型参数。 例如，C# 代码`GetMethod("MyGenericMethod<int>")`搜索具有文本名称的方法"`MyGenericMethod<int>`"，而不是一个名为方法`MyGenericMethod`具有的类型的一个泛型参数`int`。 请改用`GetMethod("MyGenericMethod")`中的相应参数`types`数组。  
  
   
  
## Examples  
 下面的示例查找的特定重载`MethodA`，指定不同的自变量类型。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]示例需要`/unsafe`编译器选项。  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 下面的示例检索<xref:System.Reflection.MethodInfo>对象表示`Add`非泛型类型的方法 (<xref:System.Collections.ArrayList>类)，开放式泛型类型 (<xref:System.Collections.Generic.List%601>类)，和封闭式泛型类型 (`List(Of String)`类型。  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 该示例定义了`GetAddMethod`检索相应的方法<xref:System.Reflection.MethodInfo>对象。 若要提供`types`开放式泛型类型参数，它调用<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>方法。 若要提供`types`封闭式泛型类型参数，它检索的值<xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到了多个具有指定名称和指定参数的方法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多维的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共方法的名称的字符串。</param>
        <param name="types">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <c>types</c> 数组中的相应元素关联的特性。 仅当通过 COM 互操作进行调用时才使用，而且仅处理通过引用传递的参数。 默认的联编程序不处理此参数。</param>
        <summary>搜索其参数与指定自变量类型及修饰符匹配的指定公共方法。</summary>
        <returns>表示符合指定要求的公共方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 虽然默认的联编程序不处理<xref:System.Reflection.ParameterModifier>(`modifiers`参数)，你可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写的自定义的联编程序`modifiers`。 `ParameterModifier` 当通过 COM 互操作调用，才使用并且可以通过引用传递的参数进行处理。  
  
 搜索`name`区分大小写。 搜索范围包括公共静态和公共实例方法。  
  
> [!NOTE]
>  查找构造函数和方法时，不能省略参数。 在调用时，仅可以省略参数。  
  
 如果当前表示构造的泛型类型，此方法将返回<xref:System.Reflection.MethodInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型或泛型方法，则此方法定义中搜索类约束的方法或方法的<xref:System.Object>如果没有类约束。  
  
> [!NOTE]
>  对于泛型方法，不包括中的类型自变量`name`。 例如，C# 代码`GetMethod("MyMethod<int>")`搜索文本同名的成员"`MyMethod<int>`"，而不是一个名为方法`MyMethod`具有的类型的一个泛型参数`int`。 请改用`GetMethod("MyMethod")`中的相应参数`types`数组。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到了多个具有指定名称和指定参数的方法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多维的。  
  
 或  
  
 <paramref name="modifiers" /> 是多维的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的方法名称的字符串。</param>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
 或  
  
 要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="types">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <c>types</c> 数组中的相应元素关联的特性。 仅当通过 COM 互操作进行调用时才使用，而且仅处理通过引用传递的参数。 默认的联编程序不处理此参数。</param>
        <summary>使用指定绑定约束，搜索其参数与指定自变量类型及修饰符匹配的指定方法。</summary>
        <returns>表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 虽然默认的联编程序不处理<xref:System.Reflection.ParameterModifier>(`modifiers`参数)，你可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写的自定义的联编程序`modifiers`。 `ParameterModifier` 当通过 COM 互操作调用，才使用并且可以通过引用传递的参数进行处理。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括的方法：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共方法。  
  
-   指定`BindingFlags.NonPublic`要包含在搜索中的非公共方法 （即，私有、 内部和受保护的方法）。  
  
-   指定`BindingFlags.FlattenHierarchy`包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.IgnoreCase` 若要忽略的大小写`name`。  
  
-   `BindingFlags.DeclaredOnly` 要搜索只有上声明的方法<xref:System.Type>，不只是继承的方法。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
> [!NOTE]
>  查找构造函数和方法时，不能省略参数。 在调用时，仅可以省略参数。  
  
 如果当前表示构造的泛型类型，此方法将返回<xref:System.Reflection.MethodInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型或泛型方法，则此方法定义中搜索类约束的方法或方法的<xref:System.Object>如果没有类约束。  
  
> [!NOTE]
>  对于泛型方法，不包括中的类型自变量`name`。 例如，C# 代码`GetMember("MyMethod<int>")`搜索文本同名的成员"`MyMethod<int>`"，而不是一个名为方法`MyMethod`具有的类型的一个泛型参数`int`。  
  
   
  
## Examples  
 下面的示例查找的特定重载`MethodA`，指定绑定约束和不同的自变量类型。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]示例需要`/unsafe`编译器选项。  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定绑定约束匹配的方法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多维的。  
  
 或  
  
 <paramref name="modifiers" /> 是多维的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的方法名称的字符串。</param>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
 或  
  
 要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="callConvention">该对象用于指定要使用的一套规则，这些规则涉及自变量的顺序和布局、传递返回值的方式、用于自变量的寄存器和清理堆栈的方式。</param>
        <param name="types">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <c>types</c> 数组中的相应元素关联的特性。 仅当通过 COM 互操作进行调用时才使用，而且仅处理通过引用传递的参数。 默认的联编程序不处理此参数。</param>
        <summary>用指定的绑定约束和指定的调用约定，搜索参数与指定的自变量类型及修饰符相匹配的指定方法。</summary>
        <returns>表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 虽然默认的联编程序不处理<xref:System.Reflection.ParameterModifier>(`modifiers`参数)，你可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写的自定义的联编程序`modifiers`。 `ParameterModifier` 当通过 COM 互操作调用，才使用并且可以通过引用传递的参数进行处理。  
  
 下表显示返回通过基类的成员`GetXXX`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括的方法：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共方法。  
  
-   指定`BindingFlags.NonPublic`要包含在搜索中的非公共方法 （即，私有、 内部和受保护的方法）。  
  
-   指定`BindingFlags.FlattenHierarchy`包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.IgnoreCase` 若要忽略的大小写`name`。  
  
-   `BindingFlags.DeclaredOnly` 要搜索只有上声明的方法<xref:System.Type>，不只是继承的方法。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
> [!NOTE]
>  查找构造函数和方法时，不能省略参数。 在调用时，仅可以省略参数。  
  
 如果当前表示构造的泛型类型，此方法将返回<xref:System.Reflection.MethodInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型或泛型方法，则此方法定义中搜索类约束的方法或方法的<xref:System.Object>如果没有类约束。  
  
> [!NOTE]
>  对于泛型方法，不包括中的类型自变量`name`。 例如，C# 代码`GetMember("MyMethod<int>")`搜索文本同名的成员"`MyMethod<int>`"，而不是一个名为方法`MyMethod`具有的类型的一个泛型参数`int`。  
  
   
  
## Examples  
 下面的示例查找的特定重载`MethodA`，指定绑定约束，调用约定和不同的自变量类型。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]示例需要`/unsafe`编译器选项。  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定绑定约束匹配的方法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多维的。  
  
 或  
  
 <paramref name="modifiers" /> 是多维的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的方法名称的字符串。</param>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
 或  
  
 要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="callConvention">该对象，用于指定要使用的一套规则，这些规则涉及自变量的顺序和布局、传递返回值的方式、用于自变量的寄存器以及哪个进程清理堆栈。</param>
        <param name="types">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 一个类型为 <see cref="T:System.Type" />（即 Type[] types = new Type[0]）的空数组，用于获取一个不带参数的方法。  
  
 或  
  
 <see langword="null" />。 如果 <c>types</c> 为 <see langword="null" />，则参数不匹配。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <c>types</c> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>当在派生类中重写时，使用指定的绑定约束和指定的调用约定搜索其参数与指定的自变量类型和修饰符匹配的指定方法。</summary>
        <returns>表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 虽然默认的联编程序不处理<xref:System.Reflection.ParameterModifier>(`modifiers`参数)，你可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写的自定义的联编程序`modifiers`。 `ParameterModifier` 当通过 COM 互操作调用，才使用并且可以通过引用传递的参数进行处理。  
  
 如果 `types` 为 `null`，则参数不匹配。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括的方法：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共方法。  
  
-   指定`BindingFlags.NonPublic`要包含在搜索中的非公共方法 （即，私有、 内部和受保护的方法）。  
  
-   指定`BindingFlags.FlattenHierarchy`包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.IgnoreCase` 若要忽略的大小写`name`。  
  
-   `BindingFlags.DeclaredOnly` 要搜索只有上声明的方法<xref:System.Type>，不只是继承的方法。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定绑定约束匹配的方法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多维的。  
  
 或  
  
 <paramref name="modifiers" /> 是多维的。  
  
 或  
  
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <exception cref="T:System.NotSupportedException">当前类型是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回为当前 <see cref="T:System.Type" /> 的所有公共方法。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的所有公共方法的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 如果没有为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的公共方法，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A>方法不返回方法按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于方法的返回顺序因为该顺序可以改变。  
  
 此调用所返回的方法的数组中不包括构造函数。 请单独调用`GetConstructors()`若要获取的构造函数方法。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
> [!NOTE]
>  查找构造函数和方法时，不能省略参数。 在调用时，仅可以省略参数。  
  
 如果当前表示构造的泛型类型，此方法将返回<xref:System.Reflection.MethodInfo>与替换为相应的类型实参的类型参数的对象。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型或泛型方法，则此方法定义中搜索类约束的方法或方法的<xref:System.Object>如果没有类约束。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，搜索为当前 <see cref="T:System.Type" /> 定义的方法。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的匹配指定绑定约束的所有方法的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 如果没有为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的方法，或者如果没有一个定义的方法匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A>方法不返回方法按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于方法的返回顺序因为该顺序可以改变。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括的方法：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共方法。  
  
-   指定`BindingFlags.NonPublic`要包含在搜索中的非公共方法 （即，私有、 内部和受保护的方法）。 仅保护和; 基类上的内部方法不返回不会返回私有基类上的方法。  
  
-   指定`BindingFlags.FlattenHierarchy`包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.DeclaredOnly` 要搜索只有上声明的方法<xref:System.Type>，不只是继承的方法。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
> [!NOTE]
>  查找构造函数和方法时，不能省略参数。 在调用时，仅可以省略参数。  
  
 如果当前表示构造的泛型类型，此方法将返回<xref:System.Reflection.MethodInfo>与替换为相应的类型实参的类型参数的对象。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型或泛型方法，则此方法定义中搜索类约束的方法或方法的<xref:System.Object>如果没有类约束。  
  
   
  
## Examples  
 下面的示例创建具有两个公共方法和一个受保护的方法的类，创建`Type`对象对应于`MyTypeClass`，获取所有的公共和非公共方法，并显示其名称。  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取嵌套在当前 <see cref="T:System.Type" /> 中的特定类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的嵌套类型的名称的字符串。</param>
        <summary>搜索具有指定名称的公共嵌套类型。</summary>
        <returns>如找到，则为表示具有指定名称的公共嵌套类型的对象；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索`name`区分大小写。  
  
 使用嵌套类的简单名称`name`。 不要使用外部类名称限定它。 对于泛型的嵌套类，使用重整的名称-即，追加了抑音符和泛型参数的数目。 例如，使用字符串"内部\`1"来获取泛型嵌套类`Inner<T>`(`Inner(Of T)`在 Visual Basic 中)。 不包括类型参数的特定于语言的语法。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的嵌套的类型。  
  
 如果嵌套的类型是泛型，则此方法将返回其泛型类型定义。 即使封闭泛型类型是封闭式构造的类型，也是如此。  
  
> [!NOTE]
>  如果当前<xref:System.Type>表示 C#、 Visual Basic 或 c + + 中, 定义的泛型类型及其嵌套的类型是所有泛型的即使它们具有没有其自己的泛型形参。 这不一定是真正的动态程序集中定义的或使用编译的嵌套类型[Ilasm.exe （IL 汇编程序）](~/docs/framework/tools/ilasm-exe-il-assembler.md)。  
  
 嵌套的泛型类型和构造嵌套的泛型类型，将从其泛型类型定义的信息，请参阅<xref:System.Type.MakeGenericType%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的嵌套类型的名称的字符串。</param>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <summary>当在派生类中重写时，使用指定绑定约束搜索指定嵌套类型。</summary>
        <returns>表示符合指定要求的嵌套类型的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用嵌套类的简单名称`name`。 不要使用外部类名称限定它。 对于泛型的嵌套类，使用重整的名称-即，追加了抑音符和泛型参数的数目。 例如，使用字符串"内部\`1"来获取泛型嵌套类`Inner<T>`(`Inner(Of T)`在 Visual Basic 中)。 不包括类型参数的特定于语言的语法。  
  
 以下<xref:System.Reflection.BindingFlags>要包括在搜索中的标志可以用于定义其嵌套的筛选器类型：  
  
-   你必须指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>要获取返回。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>要包含在搜索中的公共嵌套的类型。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>要包含在搜索中的非公共嵌套的类型 （即，私有、 内部和受保护嵌套类型）。  
  
 此方法返回仅当前类型的嵌套的类型。 它不会搜索当前类型的基类。 若要查找在基类中嵌套的类型，必须遍历继承层次结构，调用<xref:System.Type.GetNestedType%2A>在每个级别。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>将被忽略。  
  
 调用此方法仅用<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>标志或仅<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>标志将返回指定的嵌套类型，并不需要任何其他标志。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的嵌套的类型。  
  
 如果嵌套的类型是泛型，则此方法将返回其泛型类型定义。 即使封闭泛型类型是封闭式构造的类型，也是如此。  
  
> [!NOTE]
>  如果当前<xref:System.Type>表示 C#、 Visual Basic 或 c + + 中, 定义的泛型类型及其嵌套的类型是所有泛型的即使它们具有没有其自己的泛型形参。 这不一定是真正的动态程序集中定义的或使用编译的嵌套类型[Ilasm.exe （IL 汇编程序）](~/docs/framework/tools/ilasm-exe-il-assembler.md)。  
  
 嵌套的泛型类型和构造嵌套的泛型类型，将从其泛型类型定义的信息，请参阅<xref:System.Type.MakeGenericType%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取嵌套在当前 <see cref="T:System.Type" /> 中的类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回嵌套在当前的 <see cref="T:System.Type" /> 中的公共类型。</summary>
        <returns>
          <see cref="T:System.Type" /> 对象的数组，这些对象表示嵌套在当前 <see cref="T:System.Type" /> 中的公共类型（搜索是非递归的）；如果当前的 <see cref="T:System.Type" /> 中没有嵌套公共类型，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetNestedTypes%2A>方法不返回类型按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于类型的返回顺序因为该顺序可以改变。  
  
 返回仅立即嵌套在当前类型的公共类型;搜索是非递归。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的嵌套的类型。  
  
 如果嵌套的类型是泛型，则此方法将返回其泛型类型定义。 即使封闭泛型类型是封闭式构造的类型，也是如此。  
  
> [!NOTE]
>  如果当前<xref:System.Type>表示 C#、 Visual Basic 或 c + + 中, 定义的泛型类型及其嵌套的类型是所有泛型的即使它们具有没有其自己的泛型形参。 这不一定是真正的动态程序集中定义的或使用编译的嵌套类型[Ilasm.exe （IL 汇编程序）](~/docs/framework/tools/ilasm-exe-il-assembler.md)。  
  
 嵌套的泛型类型和构造嵌套的泛型类型，将从其泛型类型定义的信息，请参阅<xref:System.Type.MakeGenericType%2A>。  
  
   
  
## Examples  
 下面的示例定义了一个嵌套的类和一个`struct`中`MyClass`，然后，获取使用的类型的嵌套类型的对象和`MyClass`。  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <summary>当在派生类中重写时，使用指定绑定约束搜索嵌套在当前 <see cref="T:System.Type" /> 中的类型。</summary>
        <returns>
          <see cref="T:System.Type" /> 对象数组，这些对象表示嵌套在当前 <see cref="T:System.Type" /> 中的所有与指定的绑定约束匹配的类型（搜索是非递归的）；如果没有找到与绑定约束匹配的嵌套类型，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索嵌套类型不是递归的。  
  
 <xref:System.Type.GetNestedTypes%2A>方法不返回类型按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于类型的返回顺序因为该顺序可以改变。  
  
 以下<xref:System.Reflection.BindingFlags>要包括在搜索中的标志可以用于定义其嵌套的筛选器类型：  
  
-   你必须指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>要获取返回。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>要包含在搜索中的公共嵌套的类型。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>要包含在搜索中的非公共嵌套的类型 （即，私有、 内部和受保护嵌套类型）。  
  
 此方法返回仅当前类型的嵌套的类型。 它不会搜索当前类型的基类。 若要查找在基类中嵌套的类型，必须遍历继承层次结构，调用<xref:System.Type.GetNestedTypes%2A>在每个级别。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>将被忽略。  
  
 调用此方法仅用<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>标志或仅<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>标志将返回指定的嵌套类型，并不需要任何其他标志。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的嵌套的类型。  
  
 如果嵌套的类型是泛型，则此方法将返回其泛型类型定义。 即使封闭泛型类型是封闭式构造的类型，也是如此。  
  
> [!NOTE]
>  如果当前<xref:System.Type>表示 C#、 Visual Basic 或 c + + 中, 定义的泛型类型及其嵌套的类型是所有泛型的即使它们具有没有其自己的泛型形参。 这不一定是真正的动态程序集中定义的或使用编译的嵌套类型[Ilasm.exe （IL 汇编程序）](~/docs/framework/tools/ilasm-exe-il-assembler.md)。  
  
 嵌套的泛型类型和构造嵌套的泛型类型，将从其泛型类型定义的信息，请参阅<xref:System.Type.MakeGenericType%2A>。  
  
   
  
## Examples  
 下面的示例创建两个嵌套公共类和两个嵌套的受保护的类，并显示的匹配指定的绑定约束的类的信息。  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回为当前 <see cref="T:System.Type" /> 的所有公共属性。</summary>
        <returns>表示当前 <see cref="T:System.Reflection.PropertyInfo" /> 的所有公共属性的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 如果当前 <see cref="T:System.Reflection.PropertyInfo" /> 没有公共属性，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此重载是等效于调用<xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29>重载`bindingAttr`参数等于`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`在 C# 和`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`在 Visual Basic 中。 它将返回所有公共实例和静态属性，定义表示由当前的类型的两个那些<xref:System.Type>对象，以及从其基类型继承。  
  
 如果它已是公共的至少一个访问器，属性被视为反射到公共。 否则，该属性被视为私有的并且你必须使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，组合使用这些值`Or`) 来获取它。  
  
 <xref:System.Type.GetProperties%2A>方法不返回属性按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于属性的返回顺序因为该顺序可以改变。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 如果当前表示构造的泛型类型，此方法将返回<xref:System.Reflection.PropertyInfo>与替换为相应的类型实参的类型参数的对象。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的属性。  
  
   
  
## Examples  
 下面的示例演示 `GetProperties` 方法的用法。  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，搜索当前 <see cref="T:System.Type" /> 的属性。</summary>
        <returns>表示当前 <see cref="T:System.Reflection.PropertyInfo" /> 的匹配指定绑定约束的所有属性的 <see cref="T:System.Type" /> 对象数组。  
  
 或  
  
 如果当前 <see cref="T:System.Reflection.PropertyInfo" /> 没有属性，或者如果没有一个属性匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果它已是公共的至少一个访问器，属性被视为反射到公共。 否则，该属性被视为私有的并且你必须使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，组合使用这些值`Or`) 来获取它。  
  
 <xref:System.Type.GetProperties%2A>方法不返回属性按特定的顺序，如按字母顺序排列或声明顺序排列。 你的代码必须不依赖于属性的返回顺序因为该顺序可以改变。  
  
 以下<xref:System.Reflection.BindingFlags>要包括在搜索中的标志可以用于定义其嵌套的筛选器类型：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共属性。  
  
-   指定`BindingFlags.NonPublic`若要在搜索中包含非公共属性 （即，私有、 内部和受保护属性）。 仅保护和; 基类上的内部属性不返回不会返回私有基类上的属性。  
  
-   指定`BindingFlags.FlattenHierarchy`包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.DeclaredOnly` 若要搜索仅上声明的属性<xref:System.Type>，不只是继承的属性。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果它已是公共的至少一个访问器，属性被视为反射到公共。 否则，该属性被视为私有的并且你必须使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，组合使用这些值`Or`) 来获取它。  
  
 如果当前表示构造的泛型类型，此方法将返回<xref:System.Reflection.PropertyInfo>与替换为相应的类型实参的类型参数的对象。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的属性。  
  
   
  
## Examples  
 下面的示例定义一个名为`PropertyClass`包括六个属性： 两个都是公开，一个是私有、 受保护的一个，是内部 (`Friend`在 Visual Basic 中)，并且其中一个受保护内部 (`Protected Friend`在 Visual Basic 中)。 然后，它显示一些基本属性信息 (属性名称和类型、 是否是读/写，并且的可见性其`get`和`set`访问器) 的匹配指定的绑定约束的属性。  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的特定属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共属性名的字符串。</param>
        <summary>搜索具有指定名称的公共属性。</summary>
        <returns>表示具有指定名称的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 搜索`name`区分大小写。 搜索包含公共静态和公共实例的属性。  
  
 如果它已是公共的至少一个访问器，属性被视为反射到公共。 否则，该属性被视为私有的并且你必须使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，组合使用这些值`Or`) 来获取它。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.PropertyInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的属性。  
  
 在其中的情况下<xref:System.Reflection.AmbiguousMatchException>发生如下：  
  
-   某个类型包含两个具有相同的索引的属性名称但不同数量的参数。 若要解析多义性，使用的重载<xref:System.Type.GetProperty%2A>方法，它指定参数类型。  
  
-   派生的类型声明一个属性，通过使用隐藏继承的属性具有相同的名称，`new`修饰符 (`Shadows`在 Visual Basic 中)。 若要解析多义性，使用<xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29>方法重载，并添加<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>标志以将搜索限制为不会继承的成员。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]简化访问索引的属性的语法，并允许一个索引的属性，为其类型的默认值。 例如，如果变量`myList`指<xref:System.Collections.ArrayList>，语法`myList[3]`(`myList(3)`在 Visual Basic 中) 检索索引为 3 的元素。 您可以重载属性。  
  
 在 C# 中，此功能称为一个索引器，且不能按名称引用。 默认情况下，C# 索引器元数据中显示作为名为"Item"索引属性。 但是，类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>特性更改的元数据中索引器的名称。 例如，<xref:System.String>类具有名为一个索引器<xref:System.String.Chars%2A>。 以外项，名称也可以使用 C# 以外的语言创建的索引的属性。  
  
 若要确定类型是否具有默认属性，请使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法来测试<xref:System.Reflection.DefaultMemberAttribute>属性。 如果该类型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>属性返回的默认属性的名称。  
  
   
  
## Examples  
 下面的示例检索`Type`对象的用户定义的类，检索该类的属性，并显示属性名称。  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 在内部，此属性由所引用的元数据中的名称"项。" 若要获取的任何尝试`PropertyInfo`使用反射必须指定此内部名称，以正确地返回`PropertyInfo`属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到了多个具有指定名称的属性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的属性名的字符串。</param>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <summary>使用指定的绑定约束搜索指定属性。</summary>
        <returns>表示符合指定要求的属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果它已是公共的至少一个访问器，属性被视为反射到公共。 否则，该属性被视为私有的并且你必须使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，组合使用这些值`Or`) 来获取它。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括哪些属性：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共属性。  
  
-   指定`BindingFlags.NonPublic`若要在搜索中包含非公共属性 （即，私有、 内部和受保护属性）。  
  
-   指定`BindingFlags.FlattenHierarchy`包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.IgnoreCase` 若要忽略的大小写`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜索仅上声明的属性<xref:System.Type>，不只是继承的属性。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.PropertyInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的属性。  
  
 在其中的情况下<xref:System.Reflection.AmbiguousMatchException>发生如下：  
  
-   某个类型包含两个具有相同的索引的属性名称但不同数量的参数。 若要解析多义性，使用的重载<xref:System.Type.GetProperty%2A>方法，它指定参数类型。  
  
-   派生的类型声明一个属性，隐藏继承的属性具有相同的名称，使用`new`修饰符 (`Shadows`在 Visual Basic 中)。 若要解析多义性，包括<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>以限制对不会继承的成员的搜索。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]简化访问索引的属性的语法，并允许一个索引的属性，为其类型的默认值。 例如，如果变量`myList`指<xref:System.Collections.ArrayList>，语法`myList[3]`(`myList(3)`在 Visual Basic 中) 检索索引为 3 的元素。 您可以重载属性。  
  
 在 C# 中，此功能称为一个索引器，且不能按名称引用。 默认情况下，C# 索引器元数据中显示作为名为"Item"索引属性。 但是，类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>特性更改的元数据中索引器的名称。 例如，<xref:System.String>类具有名为一个索引器<xref:System.String.Chars%2A>。 以外项，名称也可以使用 C# 以外的语言创建的索引的属性。  
  
 若要确定类型是否具有默认属性，请使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法来测试<xref:System.Reflection.DefaultMemberAttribute>属性。 如果该类型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>属性返回的默认属性的名称。  
  
   
  
## Examples  
 下面的示例检索用户定义的类的类型，检索该类的属性并显示根据指定的绑定约束的属性名称。  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称的属性且属性与指定绑定约束匹配。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共属性名的字符串。</param>
        <param name="returnType">属性的返回类型。</param>
        <summary>搜索具有指定名称和返回类型的公共属性。</summary>
        <returns>表示具有指定名称的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果它已是公共的至少一个访问器，属性被视为反射到公共。 否则，该属性被视为私有的并且你必须使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，组合使用这些值`Or`) 来获取它。  
  
 搜索`name`区分大小写。 搜索包含公共静态和公共实例的属性。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.PropertyInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的属性。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]简化访问索引的属性的语法，并允许一个索引的属性，为其类型的默认值。 例如，如果变量`myList`指<xref:System.Collections.ArrayList>，语法`myList[3]`(`myList(3)`在 Visual Basic 中) 检索索引为 3 的元素。 您可以重载属性。  
  
 在 C# 中，此功能称为一个索引器，且不能按名称引用。 默认情况下，C# 索引器元数据中显示作为名为"Item"索引属性。 但是，类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>特性更改的元数据中索引器的名称。 例如，<xref:System.String>类具有名为一个索引器<xref:System.String.Chars%2A>。 以外项，名称也可以使用 C# 以外的语言创建的索引的属性。  
  
 若要确定类型是否具有默认属性，请使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法来测试<xref:System.Reflection.DefaultMemberAttribute>属性。 如果该类型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>属性返回的默认属性的名称。  
  
   
  
## Examples  
 下面的示例定义具有一个属性的类，并检索的名称和类型的属性。  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到了多个具有指定名称的属性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" /> 或 <paramref name="returnType" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共属性名的字符串。</param>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。  
  
 或  
  
 获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <summary>搜索其参数与指定自变量类型匹配的指定公共属性。</summary>
        <returns>表示其参数与指定参数类型匹配的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果它已是公共的至少一个访问器，属性被视为反射到公共。 否则，该属性被视为私有的并且你必须使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，组合使用这些值`Or`) 来获取它。  
  
 搜索`name`区分大小写。 搜索包含公共静态和公共实例的属性。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.PropertyInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的属性。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]简化访问索引的属性的语法，并允许一个索引的属性，为其类型的默认值。 例如，如果变量`myList`指<xref:System.Collections.ArrayList>，语法`myList[3]`(`myList(3)`在 Visual Basic 中) 检索索引为 3 的元素。 您可以重载属性。  
  
 在 C# 中，此功能称为一个索引器，且不能按名称引用。 默认情况下，C# 索引器元数据中显示作为名为"Item"索引属性。 但是，类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>特性更改的元数据中索引器的名称。 例如，<xref:System.String>类具有名为一个索引器<xref:System.String.Chars%2A>。 以外项，名称也可以使用 C# 以外的语言创建的索引的属性。  
  
 若要确定类型是否具有默认属性，请使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法来测试<xref:System.Reflection.DefaultMemberAttribute>属性。 如果该类型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>属性返回的默认属性的名称。  
  
   
  
## Examples  
 下面的示例检索`Type`的用户定义的类，对象检索此类的属性，并作为参数传递给指定的显示的属性名称和类型的属性`GetProperty`。  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定自变量类型匹配的属性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多维的。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> 的元素为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共属性名的字符串。</param>
        <param name="returnType">属性的返回类型。</param>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。  
  
 或  
  
 获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <summary>搜索其参数与指定自变量类型匹配的指定公共属性。</summary>
        <returns>表示其参数与指定参数类型匹配的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果它已是公共的至少一个访问器，属性被视为反射到公共。 否则，该属性被视为私有的并且你必须使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，组合使用这些值`Or`) 来获取它。  
  
 搜索`name`区分大小写。 搜索包含公共静态和公共实例的属性。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.PropertyInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的属性。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]简化访问索引的属性的语法，并允许一个索引的属性，为其类型的默认值。 例如，如果变量`myList`指<xref:System.Collections.ArrayList>，语法`myList[3]`(`myList(3)`在 Visual Basic 中) 检索索引为 3 的元素。 您可以重载属性。  
  
 在 C# 中，此功能称为一个索引器，且不能按名称引用。 默认情况下，C# 索引器元数据中显示作为名为"Item"索引属性。 但是，类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>特性更改的元数据中索引器的名称。 例如，<xref:System.String>类具有名为一个索引器<xref:System.String.Chars%2A>。 以外项，名称也可以使用 C# 以外的语言创建的索引的属性。  
  
 若要确定类型是否具有默认属性，请使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法来测试<xref:System.Reflection.DefaultMemberAttribute>属性。 如果该类型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>属性返回的默认属性的名称。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定自变量类型匹配的属性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多维的。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> 的元素为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共属性名的字符串。</param>
        <param name="returnType">属性的返回类型。</param>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。  
  
 或  
  
 获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <c>types</c> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>搜索其参数与指定自变量类型及修饰符匹配的指定公共属性。</summary>
        <returns>表示符合指定要求的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果它已是公共的至少一个访问器，属性被视为反射到公共。 否则，该属性被视为私有的并且你必须使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，组合使用这些值`Or`) 来获取它。  
  
 虽然默认的联编程序不处理<xref:System.Reflection.ParameterModifier>(`modifiers`参数)，你可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写的自定义的联编程序`modifiers`。 `ParameterModifier` 当通过 COM 互操作调用，才使用并且可以通过引用传递的参数进行处理。  
  
 搜索`name`区分大小写。 搜索包含公共静态和公共实例的属性。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.PropertyInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的属性。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]简化访问索引的属性的语法，并允许一个索引的属性，为其类型的默认值。 例如，如果变量`myList`指<xref:System.Collections.ArrayList>，语法`myList[3]`(`myList(3)`在 Visual Basic 中) 检索索引为 3 的元素。 您可以重载属性。  
  
 在 C# 中，此功能称为一个索引器，且不能按名称引用。 默认情况下，C# 索引器元数据中显示作为名为"Item"索引属性。 但是，类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>特性更改的元数据中索引器的名称。 例如，<xref:System.String>类具有名为一个索引器<xref:System.String.Chars%2A>。 以外项，名称也可以使用 C# 以外的语言创建的索引的属性。  
  
 若要确定类型是否具有默认属性，请使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法来测试<xref:System.Reflection.DefaultMemberAttribute>属性。 如果该类型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>属性返回的默认属性的名称。  
  
   
  
## Examples  
 下面的示例获取`Type`对象对应于`MyPropertyClass`，并且使用的自变量传递给检索此类的索引的属性`GetProperty`方法。  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定自变量类型和修饰符匹配的属性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多维的。  
  
 或  
  
 <paramref name="modifiers" /> 是多维的。  
  
 或  
  
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> 的元素为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的属性名的字符串。</param>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
 或  
  
 要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="returnType">属性的返回类型。</param>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。  
  
 或  
  
 获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <c>types</c> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>使用指定的绑定约束，搜索参数与指定的自变量类型及修饰符匹配的指定属性。</summary>
        <returns>表示符合指定要求的属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果它已是公共的至少一个访问器，属性被视为反射到公共。 否则，该属性被视为私有的并且你必须使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中，组合使用这些值`Or`) 来获取它。  
  
 虽然默认的联编程序不处理<xref:System.Reflection.ParameterModifier>(`modifiers`参数)，你可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写的自定义的联编程序`modifiers`。 `ParameterModifier` 当通过 COM 互操作调用，才使用并且可以通过引用传递的参数进行处理。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括哪些属性：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共属性。  
  
-   指定`BindingFlags.NonPublic`若要在搜索中包含非公共属性 （即，私有、 内部和受保护属性）。  
  
-   指定`BindingFlags.FlattenHierarchy`包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.IgnoreCase` 若要忽略的大小写`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜索仅上声明的属性<xref:System.Type>，不只是继承的属性。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此方法返回<xref:System.Reflection.PropertyInfo>具有类型参数替换为相应的类型实参。  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，此方法搜索类约束的属性。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)][!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]，和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]简化访问索引的属性的语法，并允许一个索引的属性，为其类型的默认值。 例如，如果变量`myList`指<xref:System.Collections.ArrayList>，语法`myList[3]`(`myList(3)`在 Visual Basic 中) 检索索引为 3 的元素。 您可以重载属性。  
  
 在 C# 中，此功能称为一个索引器，且不能按名称引用。 默认情况下，C# 索引器元数据中显示作为名为"Item"索引属性。 但是，类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>特性更改的元数据中索引器的名称。 例如，<xref:System.String>类具有名为一个索引器<xref:System.String.Chars%2A>。 以外项，名称也可以使用 C# 以外的语言创建的索引的属性。  
  
 若要确定类型是否具有默认属性，请使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>方法来测试<xref:System.Reflection.DefaultMemberAttribute>属性。 如果该类型具有<xref:System.Reflection.DefaultMemberAttribute>、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>属性返回的默认属性的名称。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称的属性且属性与指定绑定约束匹配。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多维的。  
  
 或  
  
 <paramref name="modifiers" /> 是多维的。  
  
 或  
  
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="types" /> 的元素为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的属性名的字符串。</param>
        <param name="bindingAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。  
  
 或  
  
 零，以返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载成员、强制自变量类型和通过反射调用成员。  
  
 或  
  
 要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="returnType">属性的返回类型。</param>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。  
  
 或  
  
 获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <c>types</c> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>当在派生类中重写时，使用指定的绑定约束搜索其参数与指定的自变量类型和修饰符匹配的指定属性。</summary>
        <returns>表示符合指定要求的属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 虽然默认的联编程序不处理<xref:System.Reflection.ParameterModifier>(`modifiers`参数)，你可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写的自定义的联编程序`modifiers`。 `ParameterModifier` 当通过 COM 互操作调用，才使用并且可以通过引用传递的参数进行处理。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括哪些属性：  
  
-   你必须指定`BindingFlags.Instance`或`BindingFlags.Static`为了获取返回。  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共属性。  
  
-   指定`BindingFlags.NonPublic`若要在搜索中包含非公共属性 （即，私有、 内部和受保护属性）。  
  
-   指定`BindingFlags.FlattenHierarchy`包括`public`和`protected`沿层次结构; 向上的静态成员`private`继承类中的静态成员不包括。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.IgnoreCase` 若要忽略的大小写`name`。  
  
-   `BindingFlags.DeclaredOnly` 若要搜索仅上声明的属性<xref:System.Type>，不只是继承的属性。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称的属性且属性与指定绑定约束匹配。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> 是多维的。  
  
 或  
  
 <paramref name="modifiers" /> 是多维的。  
  
 或  
  
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <exception cref="T:System.NotSupportedException">当前类型是 <see cref="T:System.Reflection.Emit.TypeBuilder" />、<see cref="T:System.Reflection.Emit.EnumBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取表示指定类型的 <see cref="T:System.Type" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" />。</summary>
        <returns>当前的 <see cref="T:System.Type" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的程序集限定名称。 请参阅 <see cref="P:System.Type.AssemblyQualifiedName" />。 如果该类型位于当前正在执行的程序集中或者 Mscorlib.dll 中，则提供由命名空间限定的类型名称就足够了。</param>
        <summary>获取具有指定名称的 <see cref="T:System.Type" />，执行区分大小写的搜索。</summary>
        <returns>具有指定名称的类型（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用<xref:System.Type.GetType%2A>方法来获取<xref:System.Type>中另一个程序集中，类型的对象，如果你知道其命名空间限定名称。 <xref:System.Type.GetType%2A> 导致中指定的程序集的加载`typeName`。 你也可以加载程序集使用<xref:System.Reflection.Assembly.Load%2A>方法，，然后使用<xref:System.Type.GetType%2A>或<xref:System.Reflection.Assembly.GetTypes%2A>方法<xref:System.Reflection.Assembly>类，以获取<xref:System.Type>对象。 如果一个类型位于到你的程序在编译时已知的程序集中，它是在 C# 中，使用更加高效<xref:System.Type.GetType%2A>在 Visual Basic 或 c + + 中。  
  
> [!NOTE]
>  如果`typeName`找不到，对的调用<xref:System.Type.GetType%28System.String%29>方法返回`null`。 它不会引发异常。 若要控制是否会引发异常，请调用的重载<xref:System.Type.GetType%2A>方法具有`throwOnError`参数。  
  
 <xref:System.Type.GetType%2A> 仅适用于从磁盘加载的程序集。 如果调用<xref:System.Type.GetType%2A>查找中使用定义的动态程序集定义的类型<xref:System.Reflection.Emit>服务，你可能会不一致的行为。 行为取决于动态程序集是持久的即，创建使用`RunAndSave`或`Save`访问模式的<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>枚举。 如果动态程序集是持久性的并且已写入到磁盘之前`GetType`是调用，加载程序磁盘上找到保存的程序集，加载该程序集，并检索该程序集的类型。 如果程序集未保存到磁盘时`GetType`调用时，该方法返回`null`。 `GetType` 不能理解瞬态动态程序集;因此，调用`GetType`检索瞬态中的类型动态程序集返回`null`。  
  
 若要使用`GetType`上动态模块，订阅<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件并调用`GetType`在保存前。 否则，你将在内存中得到的程序集的两个副本。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 数组或 COM 类型是不执行搜索，除非它们已经被加载到表中的可用类。  
  
 `typeName` 可以将类型名称由限定其命名空间或包含规范的程序集名称的程序集限定名称。 请参阅 <xref:System.Type.AssemblyQualifiedName%2A>。  
  
 如果`typeName`包括命名空间而不是程序集名称，此方法搜索仅调用对象的程序集和 Mscorlib.dll，按此顺序。 如果部分或完整的程序集名称使用完全限定类型名称，此方法搜索在指定的程序集。 如果集具有强名称，则完整的程序集名称是必需的。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>属性返回包括嵌套的类型、 程序集名称和泛型类型参数的完全限定的类型名称。 所有支持公共语言运行时编译器将发出的嵌套类的简单名称和反射构造查询时，根据以下约定的重整的名称。  
  
> [!NOTE]
>  在.NET Framework 2.0 版中，处理器体系结构添加到程序集标识，并且可以指定为程序集名称字符串的一部分。 例如，"ProcessorArchitecture = msil"。 但是，不包括在返回的字符串<xref:System.Type.AssemblyQualifiedName%2A>属性，出于兼容性原因。 你也可以通过创建加载类型<xref:System.Reflection.AssemblyName>对象并将其传递到的相应重载<xref:System.Reflection.Assembly.Load%2A>方法。 然后，可以使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法来加载的程序集中的类型。 另请参见<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
|分隔符|含义|  
|---------------|-------------|  
|反斜杠 (\\)|转义字符。|  
|反撇号 （'）|前面有一个或多个数字表示多个类型参数，位于末尾的泛型类型的名称。|  
|方括号 ([])|泛型类型参数列表，用于构造的泛型类型; 括起来在类型参数列表中，则将程序集限定的类型。|  
|逗号 （，）|之前的程序集名称。|  
|句点 （.）|表示命名空间标识符。|  
|加号 （+）|前面有嵌套的类。|  
  
 例如，一个类的完全限定的名称可能如下所示：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 如果命名空间为 TopNamespace.Sub+Namespace，则字符串将不得不前面加一个转义字符加号 （+） (\\) 以防止它被解释为嵌套的分隔符。 反射发出此字符串，如下所示：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 一个"+ +"变为"\\+\\+"，和一个"\\"变为"\\\\"。  
  
 可以保持此限定的名，并在以后使用它来加载<xref:System.Type>。 若要搜索并加载<xref:System.Type>，使用<xref:System.Type.GetType%2A>与类型名称只有或程序集限定的类型名称。 <xref:System.Type.GetType%2A> 类型名称仅将查找的<xref:System.Type>调用方的程序集中，然后在系统程序集。 <xref:System.Type.GetType%2A> 使用程序集限定的类型名称将会查找<xref:System.Type>任何程序集中。  
  
 类型名称可能包含表示的类型，例如类型是引用类型、 指针类型或数组类型有关的其他信息的尾随字符。 若要检索的类型名称不具有这些尾随字符，请使用`t.GetElementType().ToString()`，其中`t`是的类型。  
  
 空间是适用于程序集名称之外的所有类型名称组件。 在程序集名称中前 '，' 分隔符的空格相关，但是 '，' 分隔符后的空格将被忽略。  
  
 泛型类型的名称结尾反撇号 (\`) 跟数字表示泛型类型参数的数目。 此名称重整的用途是允许编译器来支持在同一范围中发生的泛型类型具有相同名称但具有不同数量的类型参数。 例如，反射返回的重整的名称`Tuple`1` and `元组`2`从泛型方法`Tuple(Of T)`和`Tuple(Of T0, T1)`在 Visual Basic 中，或`Tuple<T>`和元组`\<T0, T1>`Visual C# 中。  
  
 对于泛型类型，类型参数列表括在方括号内，并由逗号分隔的类型自变量。 例如，泛型<xref:System.Collections.Generic.Dictionary%602>具有两个类型参数。 A<xref:System.Collections.Generic.Dictionary%602>的`MyType`具有键的类型<xref:System.String>可能表示为以下形式：  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 若要指定类型参数列表中的程序集限定类型，请将括在括号内的程序集限定类型。 否则，分隔各个部分的程序集限定名称的逗号被解释为分隔其他类型参数。 例如，<xref:System.Collections.Generic.Dictionary%602>的`MyType`fromMyAssembly.dll，与键类型<xref:System.String>，可能会按以下方式指定：  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  程序集限定的类型仅出现在类型参数列表中，可以将它们括在括号中。 用于在类型参数列表中搜索程序集限定和非限定类型的规则是限定和未限定的非泛型类型的规则相同。  
  
 可以为 null 的类型是泛型类型的特殊情况。 例如，可以为 null<xref:System.Int32>由字符串"System.Nullable'1[System.Int32]"。  
  
> [!NOTE]
>  在 C#、 c + + 和 Visual Basic，还可获取可以为 null 的类型使用类型运算符。 例如，可以为 null<xref:System.Boolean>返回类型`typeof(Nullable<bool>)`在 C# 中，通过`Nullable<Boolean>::typeid`c + + 中和`GetType(Nullable(Of Boolean))`在 Visual Basic 中。  
  
 下表显示与使用的语法`GetType`为各种类型。  
  
|若要获取|使用|  
|------------|---------|  
|可以为 null <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|指向非托管的指针 `MyType`|`Type.GetType("MyType*")`|  
|非托管的指针的指针到 `MyType`|`Type.GetType("MyType**")`|  
|托管的指针或对引用 `MyType`|`Type.GetType("MyType&")`。 请注意，与指针不同，引用仅限于一个级别。|  
|父类和嵌套的类|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限为 0 的一维数组|`Type.GetType("MyType[]")`|  
|具有未知的下限的一维数组|`Type.GetType("MyType[*]")`|  
|N 维数组|在括号中的 n-1 次数一共逗号 （，）。 例如，`System.Object[,,]`表示一个三维`Object`数组。|  
|由一维数组的数组|`Type.GetType("MyType[][]")`|  
|矩形二维数组具有未知的下限|`Type.GetType("MyType[,]")`|  
|具有一个类型参数的泛型类型|`Type.GetType("MyGenericType`1[MyType]")`|  
|具有两个类型参数的泛型类型|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|具有两个程序集限定类型参数的泛型类型|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`|  
|具有程序集限定的类型自变量的程序集限定的泛型类型|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|一个其类型参数为具有两个类型参数的泛型类型的泛型类型|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 下面的示例检索的类型`System.Int32`并使用该类型对象显示<xref:System.Type.FullName%2A>属性`System.Int32`。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
 或  
  
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
 或  
  
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 在[适用于 Windows 应用商店应用的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或[可移植类库](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 找到了程序集或其依赖项之一，但无法加载它们。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而程序集使用更高的版本编译。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的程序集限定名称。 请参阅 <see cref="P:System.Type.AssemblyQualifiedName" />。 如果该类型位于当前正在执行的程序集中或者 Mscorlib.dll 中，则提供由命名空间限定的类型名称就足够了。</param>
        <param name="throwOnError">
          如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。 指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。 请参见“异常”部分。</param>
        <summary>获取具有指定名称的 <see cref="T:System.Type" />，指定是否执行区分大小写的搜索，以及在找不到类型时是否引发异常。</summary>
        <returns>具有指定名称的类型。 如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。 在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。 请参见“异常”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用<xref:System.Type.GetType%2A>方法来获取<xref:System.Type>中另一个程序集中，类型的对象，如果你知道其命名空间限定名称。 <xref:System.Type.GetType%2A> 导致中指定的程序集的加载`typeName`。 你也可以加载程序集使用<xref:System.Reflection.Assembly.Load%2A>方法，，然后使用<xref:System.Type.GetType%2A>或<xref:System.Reflection.Assembly.GetTypes%2A>方法<xref:System.Reflection.Assembly>类，以获取<xref:System.Type>对象。 如果一个类型位于到你的程序在编译时已知的程序集中，它会更加高效使用`typeof`在 C# 中，<xref:System.Type.GetType%2A>在 Visual Basic 中，或`typeid`c + + 中。  
  
 `GetType` 仅适用于从磁盘加载的程序集。 如果调用`GetType`查找中使用定义的动态程序集定义的类型<xref:System.Reflection.Emit>服务，你可能会不一致的行为。 行为取决于动态程序集是持久的即，创建使用`RunAndSave`或`Save`访问模式的<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>枚举。 如果动态程序集是持久性的并且已写入到磁盘之前`GetType`是调用，加载程序磁盘上找到保存的程序集，加载该程序集，并检索该程序集的类型。 如果程序集未保存到磁盘时`GetType`调用时，该方法返回`null`。 `GetType` 不能理解瞬态动态程序集;因此，调用`GetType`检索瞬态中的类型动态程序集返回`null`。  
  
 若要使用`GetType`上动态模块，订阅<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件并调用`GetType`在保存前。 否则，你将在内存中得到的程序集的两个副本。  
  
 `throwOnError`参数指定时会发生什么情况类型未找到，并还会取消取消某些其他异常条件，如异常部分中所述。 一些例外情况引发而不考虑的值`throwOnError`。 例如，如果找到的类型，但不能加载，<xref:System.TypeLoadException>引发即使`throwOnError`是`false`。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 数组或 COM 类型是不执行搜索，除非它们已经被加载到表中的可用类。  
  
 `typeName` 可以将类型名称由限定其命名空间或包含规范的程序集名称的程序集限定名称。 请参阅 <xref:System.Type.AssemblyQualifiedName%2A>。  
  
 如果`typeName`包括命名空间而不是程序集名称，此方法搜索仅调用对象的程序集和 Mscorlib.dll，按此顺序。 如果部分或完整的程序集名称使用完全限定类型名称，此方法搜索在指定的程序集。 如果集具有强名称，则完整的程序集名称是必需的。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>属性返回包括嵌套的类型、 程序集名称和泛型自变量的完全限定的类型名称。 所有支持公共语言运行时编译器将发出的嵌套类的简单名称和反射构造查询时，根据以下约定的重整的名称。  
  
> [!NOTE]
>  在.NET Framework 2.0 版中，处理器体系结构添加到程序集标识，并且可以指定为程序集名称字符串的一部分。 例如，"ProcessorArchitecture = msil"。 但是，不包括在返回的字符串<xref:System.Type.AssemblyQualifiedName%2A>属性，出于兼容性原因。 你也可以通过创建加载类型<xref:System.Reflection.AssemblyName>对象并将其传递到的相应重载<xref:System.Reflection.Assembly.Load%2A>方法。 然后，可以使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法来加载的程序集中的类型。 另请参见<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
|分隔符|含义|  
|---------------|-------------|  
|反斜杠 (\\)|转义字符。|  
|反撇号 （'）|前面有一个或多个数字表示多个类型参数，位于末尾的泛型类型的名称。|  
|方括号 ([])|泛型类型参数列表，用于构造的泛型类型; 括起来在类型参数列表中，则将程序集限定的类型。|  
|逗号 （，）|之前的程序集名称。|  
|句点 （.）|表示命名空间标识符。|  
|加号 （+）|前面有嵌套的类。|  
  
 例如，一个类的完全限定的名称可能如下所示：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 如果命名空间为 TopNamespace.Sub+Namespace，则字符串将不得不前面加一个转义字符加号 （+） (\\) 以防止它被解释为嵌套的分隔符。 反射发出此字符串，如下所示：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 一个"+ +"变为"\\+\\+"，和一个"\\"变为"\\\\"。  
  
 可以保持此限定的名，并在以后使用它来加载<xref:System.Type>。 若要搜索并加载<xref:System.Type>，使用<xref:System.Type.GetType%2A>与类型名称只有或程序集限定的类型名称。 <xref:System.Type.GetType%2A> 类型名称仅将查找的<xref:System.Type>调用方的程序集中，然后在系统程序集。 <xref:System.Type.GetType%2A> 使用程序集限定的类型名称将会查找<xref:System.Type>任何程序集中。  
  
 类型名称可能包含表示的类型，例如类型是引用类型、 指针类型或数组类型有关的其他信息的尾随字符。 若要检索的类型名称不具有这些尾随字符，请使用`t.GetElementType().ToString()`，其中`t`是的类型。  
  
 空间是适用于程序集名称之外的所有类型名称组件。 在程序集名称中前 '，' 分隔符的空格相关，但是 '，' 分隔符后的空格将被忽略。  
  
 泛型类型的名称结尾反撇号 (\`) 跟数字表示泛型类型参数的数目。 此名称重整的用途是允许编译器来支持在同一范围中发生的泛型类型具有相同名称但具有不同数量的类型参数。 例如，反射返回的重整的名称`Tuple`1` and `元组`2`从泛型方法`Tuple(Of T)`和`Tuple(Of T0, T1)`在 Visual Basic 中，或`Tuple<T>`和元组`\<T0, T1>`Visual C# 中。  
  
 对于泛型类型，类型参数列表括在方括号内，并由逗号分隔的类型自变量。 例如，泛型<xref:System.Collections.Generic.Dictionary%602>具有两个类型参数。 A<xref:System.Collections.Generic.Dictionary%602>的`MyType`具有键的类型<xref:System.String>可能表示为以下形式：  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 若要指定类型参数列表中的程序集限定类型，请将括在括号内的程序集限定类型。 否则，分隔各个部分的程序集限定名称的逗号被解释为分隔其他类型参数。 例如，<xref:System.Collections.Generic.Dictionary%602>的`MyType`MyAssembly.dll，具有键的类型从<xref:System.String>，可能会按以下方式指定：  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  程序集限定的类型仅出现在类型参数列表中，可以将它们括在括号中。 用于在类型参数列表中搜索程序集限定和非限定类型的规则是限定和未限定的非泛型类型的规则相同。  
  
 可以为 null 的类型是泛型类型的特殊情况。 例如，可以为 null<xref:System.Int32>由字符串"System.Nullable'1[System.Int32]"。  
  
> [!NOTE]
>  在 C#、 c + + 和 Visual Basic，还可获取可以为 null 的类型使用类型运算符。 例如，可以为 null<xref:System.Boolean>返回类型`typeof(Nullable<bool>)`在 C# 中，通过`Nullable<Boolean>::typeid`c + + 中和`GetType(Nullable(Of Boolean))`在 Visual Basic 中。  
  
 下表显示与使用的语法`GetType`为各种类型。  
  
|若要获取|使用|  
|------------|---------|  
|可以为 null <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|指向非托管的指针 `MyType`|`Type.GetType("MyType*")`|  
|非托管的指针的指针到 `MyType`|`Type.GetType("MyType**")`|  
|托管的指针或对引用 `MyType`|`Type.GetType("MyType&")`。 请注意，与指针不同，引用仅限于一个级别。|  
|父类和嵌套的类|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限为 0 的一维数组|`Type.GetType("MyArray[]")`|  
|具有未知的下限的一维数组|`Type.GetType("MyArray[*]")`|  
|N 维数组|在括号中的 n-1 次数一共逗号 （，）。 例如，`System.Object[,,]`表示一个三维`Object`数组。|  
|二维数组的数组|`Type.GetType("MyArray[][]")`|  
|矩形二维数组具有未知的下限|`Type.GetType("MyArray[,]")`|  
|具有一个类型参数的泛型类型|`Type.GetType("MyGenericType`1[MyType]")`|  
|具有两个类型参数的泛型类型|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|具有两个程序集限定类型参数的泛型类型|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`|  
|具有程序集限定的类型自变量的程序集限定的泛型类型|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|一个其类型参数为具有两个类型参数的泛型类型的泛型类型|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 下面的示例检索的类型`System.Int32`并使用该类型对象显示<xref:System.Type.FullName%2A>属性`System.Int32`。 如果一个类型对象引用不存在程序集，此示例将引发异常。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。  
  
 或  
  
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。  
  
 或  
  
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。  
  
 或  
  
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。  
  
 或  
  
 <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> 是 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法。 例如："MyType[,*,]"。  
  
 或  
  
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
 或  
  
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
 或  
  
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 在[适用于 Windows 应用商店应用的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或[可移植类库](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 找到了程序集或其依赖项之一，但无法加载它们。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而程序集使用更高的版本编译。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的程序集限定名称。 请参阅 <see cref="P:System.Type.AssemblyQualifiedName" />。 如果该类型位于当前正在执行的程序集中或者 Mscorlib.dll 中，则提供由命名空间限定的类型名称就足够了。</param>
        <param name="throwOnError">
          <see langword="true" /> 则引发异常（如果找不到类型）；<see langword="false" /> 则返回<see langword="null" />.Specifying<see langword="false" />，也抑制了其他一些异常情况，但不是所有异常。 请参见“异常”部分。</param>
        <param name="ignoreCase">
          如果为 <see langword="true" />，则执行不区分大小写的 <c>typeName</c> 搜索；如果为 <see langword="false" />，则执行区分大小写的 <c>typeName</c> 搜索。</param>
        <summary>获取具有指定名称的 <see cref="T:System.Type" />，指定是否执行区分大小写的搜索，以及在找不到类型时是否引发异常。</summary>
        <returns>具有指定名称的类型。 如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。 在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。 请参见“异常”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用<xref:System.Type.GetType%2A>方法来获取<xref:System.Type>中另一个程序集中，类型的对象，如果你知道其命名空间限定名称。 <xref:System.Type.GetType%2A> 导致中指定的程序集的加载`typeName`。 你也可以加载程序集使用<xref:System.Reflection.Assembly.Load%2A>方法，，然后使用<xref:System.Type.GetType%2A>或<xref:System.Reflection.Assembly.GetTypes%2A>方法<xref:System.Reflection.Assembly>类，以获取<xref:System.Type>对象。 如果一个类型位于到你的程序在编译时已知的程序集中，它会更加高效使用`typeof`在 C# 中，<xref:System.Type.GetType%2A>在 Visual Basic 中，或`typeid`c + + 中。  
  
 `GetType` 仅适用于从磁盘加载的程序集。 如果调用`GetType`查找中使用定义的动态程序集定义的类型<xref:System.Reflection.Emit>服务，你可能会不一致的行为。 行为取决于动态程序集是持久的即，创建使用`RunAndSave`或`Save`访问模式的<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>枚举。 如果动态程序集是持久性的并且已写入到磁盘之前`GetType`是调用，加载程序磁盘上找到保存的程序集，加载该程序集，并检索该程序集的类型。 如果程序集未保存到磁盘时`GetType`调用时，该方法返回`null`。 `GetType` 不能理解瞬态动态程序集;因此，调用`GetType`检索瞬态中的类型动态程序集返回`null`。  
  
 若要使用`GetType`上动态模块，订阅<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件并调用`GetType`在保存前。 否则，你将在内存中得到的程序集的两个副本。  
  
 `throwOnError`参数指定时会发生什么情况类型未找到，并还会取消取消某些其他异常条件，如异常部分中所述。 一些例外情况引发而不考虑的值`throwOnError`。 例如，如果找到的类型，但不能加载，<xref:System.TypeLoadException>引发即使`throwOnError`是`false`。  
  
 下表显示返回通过基类的成员`Get`反射的类型上时的方法。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|否|否|  
|字段|否|可以。 字段始终为按名称和签名隐藏。|  
|事件|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
|方法|否|可以。 方法 （虚拟和非虚拟） 可以隐藏按名称或按名称和签名隐藏。|  
|嵌套的类型|否|否|  
|Property|不适用|常规类型系统规则是： 继承实现的属性的方法相同。 反射视为由名称和签名隐藏的属性。 请参阅备注 2 下面。|  
  
1.  按名称和签名隐藏会将所有的部分的签名，包括自定义修饰符，返回类型、 参数类型、 标记和非托管调用约定。 这是二进制比较。  
  
2.  为反射，属性和事件都是按名称和签名隐藏。 如果你有具有同时具有 get 和 set 访问器的属性在基的类中，但派生的类具有仅一个 get 访问器，派生的类属性会隐藏基类属性中，并且你将无法访问基本类 setter。  
  
3.  自定义属性不是常规类型系统的一部分。  
  
 数组或 COM 类型是不执行搜索，除非它们已经被加载到表中的可用类。  
  
 `typeName` 可以将类型名称由限定其命名空间或包含规范的程序集名称的程序集限定名称。 请参阅 <xref:System.Type.AssemblyQualifiedName%2A>。  
  
 如果`typeName`包括命名空间而不是程序集名称，此方法搜索仅调用对象的程序集和 Mscorlib.dll，按此顺序。 如果部分或完整的程序集名称使用完全限定类型名称，此方法搜索在指定的程序集。 如果集具有强名称，则完整的程序集名称是必需的。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>属性返回包括嵌套的类型、 程序集名称和类型自变量的完全限定的类型名称。 所有支持公共语言运行时编译器将发出的嵌套类的简单名称和反射构造查询时，根据以下约定的重整的名称。  
  
> [!NOTE]
>  在.NET Framework 2.0 版中，处理器体系结构添加到程序集标识，并且可以指定为程序集名称字符串的一部分。 例如，"ProcessorArchitecture = msil"。 但是，不包括在返回的字符串<xref:System.Type.AssemblyQualifiedName%2A>属性，出于兼容性原因。 你也可以通过创建加载类型<xref:System.Reflection.AssemblyName>对象并将其传递到的相应重载<xref:System.Reflection.Assembly.Load%2A>方法。 然后，可以使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法来加载的程序集中的类型。 另请参见<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
|分隔符|含义|  
|---------------|-------------|  
|反斜杠 (\\)|转义字符。|  
|反撇号 （'）|前面有一个或多个数字表示多个类型参数，位于末尾的泛型类型的名称。|  
|方括号 ([])|泛型类型参数列表，用于构造的泛型类型; 括起来在类型参数列表中，则将程序集限定的类型。|  
|逗号 （，）|之前的程序集名称。|  
|句点 （.）|表示命名空间标识符。|  
|加号 （+）|前面有嵌套的类。|  
  
 例如，一个类的完全限定的名称可能如下所示：  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 如果命名空间为 TopNamespace.Sub+Namespace，则字符串将不得不前面加一个转义字符加号 （+） (\\) 以防止它被解释为嵌套的分隔符。 反射发出此字符串，如下所示：  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 一个"+ +"变为"\\+\\+"，和一个"\\"变为"\\\\"。  
  
 可以保持此限定的名，并在以后使用它来加载<xref:System.Type>。 若要搜索并加载<xref:System.Type>，使用<xref:System.Type.GetType%2A>与类型名称只有或程序集限定的类型名称。 <xref:System.Type.GetType%2A> 类型名称仅将查找的<xref:System.Type>调用方的程序集中，然后在系统程序集。 <xref:System.Type.GetType%2A> 使用程序集限定的类型名称将会查找<xref:System.Type>任何程序集中。  
  
 类型名称可能包含表示的类型，例如类型是引用类型、 指针类型或数组类型有关的其他信息的尾随字符。 若要检索的类型名称不具有这些尾随字符，请使用`t.GetElementType().ToString()`，其中`t`是的类型。  
  
 空间是适用于程序集名称之外的所有类型名称组件。 在程序集名称中前 '，' 分隔符的空格相关，但是 '，' 分隔符后的空格将被忽略。  
  
 泛型类型的名称结尾反撇号 (\`) 跟数字表示泛型类型参数的数目。 此名称重整的用途是允许编译器来支持在同一范围中发生的泛型类型具有相同名称但具有不同数量的类型参数。 例如，反射返回的重整的名称`Tuple`1` and `元组`2`从泛型方法`Tuple(Of T)`和`Tuple(Of T0, T1)`在 Visual Basic 中，或`Tuple<T>`和元组`\<T0, T1>`Visual C# 中。  
  
 对于泛型类型，类型参数列表括在方括号内，并由逗号分隔的类型自变量。 例如，泛型<xref:System.Collections.Generic.Dictionary%602>具有两个类型参数。 A<xref:System.Collections.Generic.Dictionary%602>的`MyType`具有键的类型<xref:System.String>可能表示为以下形式：  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 若要指定类型参数列表中的程序集限定类型，请将括在括号内的程序集限定类型。 否则，分隔各个部分的程序集限定名称的逗号被解释为分隔其他类型参数。 例如，<xref:System.Collections.Generic.Dictionary%602>的`MyType`MyAssembly.dll，具有键的类型从<xref:System.String>，可能会按以下方式指定：  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  程序集限定的类型仅出现在类型参数列表中，可以将它们括在括号中。 用于在类型参数列表中搜索程序集限定和非限定类型的规则是限定和未限定的非泛型类型的规则相同。  
  
 可以为 null 的类型是泛型类型的特殊情况。 例如，可以为 null<xref:System.Int32>由字符串"System.Nullable'1[System.Int32]"。  
  
> [!NOTE]
>  在 C#、 c + + 和 Visual Basic，还可获取可以为 null 的类型使用类型运算符。 例如，可以为 null<xref:System.Boolean>返回类型`typeof(Nullable<bool>)`在 C# 中，通过`Nullable<Boolean>::typeid`c + + 中和`GetType(Nullable(Of Boolean))`在 Visual Basic 中。  
  
 下表显示与使用的语法`GetType`为各种类型。  
  
|若要获取|使用|  
|------------|---------|  
|可以为 null <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|指向非托管的指针 `MyType`|`Type.GetType("MyType*")`|  
|非托管的指针的指针到 `MyType`|`Type.GetType("MyType**")`|  
|托管的指针或对引用 `MyType`|`Type.GetType("MyType&")`。 请注意，与指针不同，引用仅限于一个级别。|  
|父类和嵌套的类|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限为 0 的一维数组|`Type.GetType("MyArray[]")`|  
|具有未知的下限的一维数组|`Type.GetType("MyArray[*]")`|  
|N 维数组|在括号中的 n-1 次数一共逗号 （，）。 例如，`System.Object[,,]`表示一个三维`Object`数组。|  
|二维数组的数组|`Type.GetType("MyArray[][]")`|  
|矩形二维数组具有未知的下限|`Type.GetType("MyArray[,]")`|  
|具有一个类型参数的泛型类型|`Type.GetType("MyGenericType`1[MyType]")`|  
|具有两个类型参数的泛型类型|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|具有两个程序集限定类型参数的泛型类型|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`|  
|具有程序集限定的类型自变量的程序集限定的泛型类型|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|一个其类型参数为具有两个类型参数的泛型类型的泛型类型|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。  
  
 或  
  
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。  
  
 或  
  
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。  
  
 或  
  
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。  
  
 或  
  
 <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> 是 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法。 例如："MyType[,*,]"。  
  
 或  
  
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
 或  
  
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
 或  
  
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了程序集或其依赖项之一，但无法加载它们。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而程序集使用更高的版本编译。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的名称。 如果提供了 <c>typeResolver</c> 参数，则类型名称可以为 <c>typeResolver</c> 能够解析的任何字符串。 如果提供了 <c>assemblyResolver</c> 参数，或者使用了标准类型解析，则除非该类型位于当前正在执行的程序集或 Mscorlib.dll 中（在这种情况下足以提供其命名空间所限定的类型名称），否则 <c>typeName</c> 必须为程序集限定的名称（请参阅 <see cref="P:System.Type.AssemblyQualifiedName" />）。</param>
        <param name="assemblyResolver">一个方法，它定位并返回 <c>typeName</c> 中指定的程序集。 以 <see cref="T:System.Reflection.AssemblyName" /> 对象形式传递给 <c>assemblyResolver</c> 的程序集名称。 如果 <c>typeName</c> 不包含程序集的名称，则不调用 <c>assemblyResolver</c>。 如果未提供 <c>assemblyResolver</c>，则执行标准程序集解析。  
  
 警告   不要通过未知的或不受信任的调用方传递方法。 此操作可能会导致恶意代码特权提升。 仅使用你提供或者熟悉的方法。</param>
        <param name="typeResolver">一个方法，它在由 <c>assemblyResolver</c> 或标准程序集解析返回的程序集中定位并返回 <c>typeName</c> 所指定的类型。 如果未提供任何程序集，则 <c>typeResolver</c> 方法可以提供一个程序集。 该方法还采用一个参数以指定是否执行不区分大小写的搜索；<see langword="false" /> 传递给该参数。  
  
 警告   不要通过未知的或不受信任的调用方传递方法。</param>
        <summary>获取具有指定名称的类型，（可选）提供自定义方法以解析程序集和该类型。</summary>
        <returns>具有指定名称的类型，如果未找到该类型，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为此方法和有关的详细信息的使用方案`assemblyResolver`和`typeResolver`在找不到参数<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法重载。  
  
> [!NOTE]
>  如果`typeName`找不到，对的调用<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>方法返回`null`。 它不会引发异常。 若要控制是否会引发异常，请调用的重载<xref:System.Type.GetType%2A>方法具有`throwOnError`参数。  
  
 调用此方法重载是调用相同<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法重载并指定`false`为`throwOnError`和`ignoreCase`参数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.ArgumentException">当 <paramref name="typeName" /> 分析为类型名称和程序集名称（例如当简单类型名包含未转义的特殊字符）时，将发生错误。  
  
 或  
  
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
 或  
  
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
 或  
  
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了程序集或其依赖项之一，但无法加载它们。  
  
 或  
  
 <paramref name="typeName" /> 包含无效的程序集名称。  
  
 或  
  
 <paramref name="typeName" /> 是不含类型名称的有效程序集名称。</exception>
        <exception cref="T:System.BadImageFormatException">该程序集或其依赖项之一无效。  
  
 或  
  
 此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的名称。 如果提供了 <c>typeResolver</c> 参数，则类型名称可以为 <c>typeResolver</c> 能够解析的任何字符串。 如果提供了 <c>assemblyResolver</c> 参数，或者使用了标准类型解析，则除非该类型位于当前正在执行的程序集或 Mscorlib.dll 中（在这种情况下足以提供其命名空间所限定的类型名称），否则 <c>typeName</c> 必须为程序集限定的名称（请参阅 <see cref="P:System.Type.AssemblyQualifiedName" />）。</param>
        <param name="assemblyResolver">一个方法，它定位并返回 <c>typeName</c> 中指定的程序集。 以 <see cref="T:System.Reflection.AssemblyName" /> 对象形式传递给 <c>assemblyResolver</c> 的程序集名称。 如果 <c>typeName</c> 不包含程序集的名称，则不调用 <c>assemblyResolver</c>。 如果未提供 <c>assemblyResolver</c>，则执行标准程序集解析。  
  
 警告   不要通过未知的或不受信任的调用方传递方法。 此操作可能会导致恶意代码特权提升。 仅使用你提供或者熟悉的方法。</param>
        <param name="typeResolver">一个方法，它在由 <c>assemblyResolver</c> 或标准程序集解析返回的程序集中定位并返回 <c>typeName</c> 所指定的类型。 如果未提供任何程序集，则该方法可以提供一个程序集。 该方法还采用一个参数以指定是否执行不区分大小写的搜索；<see langword="false" /> 传递给该参数。  
  
 警告   不要通过未知的或不受信任的调用方传递方法。</param>
        <param name="throwOnError">
          如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。 指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。 请参见“异常”部分。</param>
        <summary>获取具有指定名称的类型，指定在找不到该类型时是否引发异常，（可选）提供自定义方法以解析程序集和该类型。</summary>
        <returns>具有指定名称的类型。 如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。 在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。 请参见“异常”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为此方法和有关的详细信息的使用方案`assemblyResolver`和`typeResolver`在找不到参数<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法重载。  
  
 调用此方法重载是调用相同<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法重载并指定`false`为`ignoreCase`参数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。  
  
 或  
  
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。  
  
 或  
  
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。  
  
 或  
  
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。  
  
 或  
  
 <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.ArgumentException">当 <paramref name="typeName" /> 分析为类型名称和程序集名称（例如当简单类型名包含未转义的特殊字符）时，将发生错误。  
  
 或  
  
 <paramref name="throwOnError" /> 为 <see langword="true" /> 且 <paramref name="typeName" /> 包含无效的语法（例如，"MyType[,*,]"）。  
  
 或  
  
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
 或  
  
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
 或  
  
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。  
  
 或  
  
 <paramref name="typeName" /> 包含无效的程序集名称。  
  
 或  
  
 <paramref name="typeName" /> 是不含类型名称的有效程序集名称。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了程序集或它的一个依赖项，但无法加载它们。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的名称。 如果提供了 <c>typeResolver</c> 参数，则类型名称可以为 <c>typeResolver</c> 能够解析的任何字符串。 如果提供了 <c>assemblyResolver</c> 参数，或者使用了标准类型解析，则除非该类型位于当前正在执行的程序集或 Mscorlib.dll 中（在这种情况下足以提供其命名空间所限定的类型名称），否则 <c>typeName</c> 必须为程序集限定的名称（请参阅 <see cref="P:System.Type.AssemblyQualifiedName" />）。</param>
        <param name="assemblyResolver">一个方法，它定位并返回 <c>typeName</c> 中指定的程序集。 以 <see cref="T:System.Reflection.AssemblyName" /> 对象形式传递给 <c>assemblyResolver</c> 的程序集名称。 如果 <c>typeName</c> 不包含程序集的名称，则不调用 <c>assemblyResolver</c>。 如果未提供 <c>assemblyResolver</c>，则执行标准程序集解析。  
  
 警告   不要通过未知的或不受信任的调用方传递方法。 此操作可能会导致恶意代码特权提升。 仅使用你提供或者熟悉的方法。</param>
        <param name="typeResolver">一个方法，它在由 <c>assemblyResolver</c> 或标准程序集解析返回的程序集中定位并返回 <c>typeName</c> 所指定的类型。 如果未提供任何程序集，则该方法可以提供一个程序集。 该方法还采用一个参数以指定是否执行不区分大小写的搜索；<c>ignoreCase</c> 的值传递给该参数。  
  
 警告   不要通过未知的或不受信任的调用方传递方法。</param>
        <param name="throwOnError">
          如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。 指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。 请参见“异常”部分。</param>
        <param name="ignoreCase">
          如果为 <see langword="true" />，则执行不区分大小写的 <c>typeName</c> 搜索；如果为 <see langword="false" />，则执行区分大小写的 <c>typeName</c> 搜索。</param>
        <summary>获取具有指定名称的类型，指定是否执行区分大小写的搜索，在找不到类型时是否引发异常，（可选）提供自定义方法以解析程序集和该类型。</summary>
        <returns>具有指定名称的类型。 如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。 在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。 请参见“异常”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法重载和其关联的重载 (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>和<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) 替换的默认实现<xref:System.Type.GetType%2A>具有更灵活的实现方法。 通过提供你自己的方法来解析类型名称和包含它们的程序集的名称，您可以执行以下操作：  
  
-   控制哪个版本的一种类型从加载的程序集。  
  
-   提供另一个位置来查找不包括程序集名称的类型名称。  
  
-   加载程序集使用部分程序集名称。  
  
-   返回的子类<xref:System.Type?displayProperty=nameWithType>，不由公共语言运行时 (CLR)。  
  
 例如，在版本容错序列化此方法可通过使用部分名称搜索"best fit"的程序集。 其他重载<xref:System.Type.GetType%2A>方法需要一个程序集限定类型名称，其中包括的版本号。  
  
 可能需要返回的子类的类型系统的备用实现<xref:System.Type?displayProperty=nameWithType>，不由 CLR; 所有类型的其他重载返回<xref:System.Type.GetType%2A>方法是运行时类型。  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>用法说明  
 此方法重载和其关联的重载分析`typeName`到的类型和程序集名称的名称，然后解析该名称。 因为类型名称必须解析程序集的上下文中，程序集名称的解析在类型名称的解析之前发生。  
  
> [!NOTE]
>  如果你不熟悉的程序集限定类型名称的概念，请参阅<xref:System.Type.AssemblyQualifiedName%2A>属性。  
  
 如果`typeName`不是程序集限定名称，跳过程序集解析。 非限定的类型名称可以解决 Mscorlib.dll 或当前正在执行的程序集的上下文中，也可以根据需要提供中的程序集`typeResolver`参数。 包括或忽略程序集名称，例如，为中的表会显示不同类型的名称解析的影响[混合名称解析](#mixed_name_resolution)部分。  
  
 常规用法注释：  
  
-   不要将传递到方法`assemblyResolver`或`typeResolver`如果来自未知或不受信任的调用方。 仅使用你提供或者熟悉的方法。  
  
    > [!CAUTION]
    >  使用来自未知或不受信任的调用方的方法可能会导致恶意代码特权提升。  
  
-   如果省略`assemblyResolver`和/或`typeResolver`参数、 的值`throwOnError`参数传递给执行的默认解析的方法。  
  
-   如果`throwOnError`是`true`，此方法将引发<xref:System.TypeLoadException>时`typeResolver`返回`null`，和一个<xref:System.IO.FileNotFoundException>时`assemblyResolver`返回`null`。  
  
-   此方法不会捕获引发的异常`assemblyResolver`和`typeResolver`。 你负责由解析程序方法引发任何异常。  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>解析程序集  
 `assemblyResolver`方法接收<xref:System.Reflection.AssemblyName>对象，生成的分析中包含的字符串的程序集名称`typeName`。 如果`typeName`不包含程序集名称，`assemblyResolver`不调用和`null`传递给`typeResolver`。  
  
 如果`assemblyResolver`不提供标准的程序集探测用于查找程序集。 如果`assemblyResolver`提供，<xref:System.Type.GetType%2A>方法不执行标准探测; 在这种情况下你必须确保你`assemblyResolver`可以处理传递给它的所有程序集。  
  
 `assemblyResolver`方法应返回`null`如果无法解析的程序集。 如果`assemblyResolver`返回`null`，`typeResolver`不调用且不进行其他处理发生; 此外，如果`throwOnError`是`true`、<xref:System.IO.FileNotFoundException>引发。  
  
 如果<xref:System.Reflection.AssemblyName>传递给`assemblyResolver`是部分名称、 一个或多个其部件是`null`。 例如，如果它具有无版本<xref:System.Reflection.AssemblyName.Version%2A>属性是`null`。 如果<xref:System.Reflection.AssemblyName.Version%2A>属性，<xref:System.Reflection.AssemblyName.CultureInfo%2A>属性，与<xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>方法都返回`null`，然后提供的程序集简单名称。 `assemblyResolver`方法可以使用或忽略程序集名称的所有部分。  
  
 不同的程序集解析选项的效果将显示为中的表[混合名称解析](#mixed_name_resolution)部分中的，对于简单和程序集限定类型名称。  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>解析类型  
 如果`typeName`并不指定程序集名称，`typeResolver`始终调用。 如果`typeName`指定程序集名称，`typeResolver`仅在已成功解析程序集名称时调用。 如果`assemblyResolver`或标准程序集的探查返回`null`，`typeResolver`不调用。  
  
 `typeResolver`方法接收三个自变量：  
  
-   要搜索的程序集或`null`如果`typeName`不包含程序集名称。  
  
-   类型的简单名称。 对于嵌套类型，这是最外层包含类型。 对于泛型类型，这是泛型类型的简单名称。  
  
-   一个布尔值，是`true`如果忽略类型名称的情况。  
  
 实现确定这些自变量的使用的方式。 `typeResolver`方法应返回`null`如果无法解析类型。 如果`typeResolver`返回`null`和`throwOnError`是`true`的此重载<xref:System.Type.GetType%2A>引发<xref:System.TypeLoadException>。  
  
 不同类型解析选项的效果将显示为中的表[混合名称解析](#mixed_name_resolution)部分中的，对于简单和程序集限定类型名称。  
  
#### <a name="resolving-nested-types"></a>解决嵌套的类型  
 如果`typeName`是嵌套的类型，只有最外面的名称包含类型传递给`typeResolver`。 当`typeResolver`返回此类型，<xref:System.Type.GetNestedType%2A>方法以递归方式调用之前的最内部的嵌套的类型已得到解决。  
  
#### <a name="resolving-generic-types"></a>解决泛型类型  
 <xref:System.Type.GetType%2A>称为以递归方式来解析泛型类型： 首先，若要解决该泛型类型本身，然后，若要解决其类型自变量。 如果类型参数是泛型，<xref:System.Type.GetType%2A>称为以递归方式解决其类型参数时，依次类推。  
  
 组合`assemblyResolver`和`typeResolver`提供必须能够解析此递归的所有级别。 例如，假设你提供`assemblyResolver`控制的加载`MyAssembly`。 假设你想要解析的泛型类型`Dictionary<string, MyType>`(`Dictionary(Of String, MyType)`在 Visual Basic 中)。 您可以传递以下泛型类型名称：  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 请注意，`MyType`是仅限定程序集的类型参数。 名称<xref:System.Collections.Generic.Dictionary%602>和<xref:System.String>类不是程序集限定。 你`typeResolver`必须能够处理或者程序集或`null`，因为它将接收`null`为<xref:System.Collections.Generic.Dictionary%602>和<xref:System.String>。 它可以处理这种情况下，通过调用的重载<xref:System.Type.GetType%2A>接受一个字符串，因为这两个非限定的类型名称是 Mscorlib.dll 中的方法：  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 `assemblyResolver`方法不调用字典类型和字符串类型，因为这些类型名不是程序集限定。  
  
 现在假设，而不是`System.String`，第一种泛型自变量类型是`YourType`，从`YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 因为此程序集既 Mscorlib.dll，也没有当前正在执行的程序集，无法解析`YourType`没有程序集限定名。 因为你`assemblyResolve`将以递归方式调用，它必须能够处理这种情况。 而不是返回`null`以外的其他程序集`MyAssembly`，它现在将执行使用提供程序集加载<xref:System.Reflection.AssemblyName>对象。  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 返回到[用法说明](#usage_notes)。  
  
#### <a name="resolving-type-names-with-special-characters"></a>解析类型名称带有特殊字符  
 某些字符在程序集限定名称中具有特殊含义。 如果简单类型名称中包含这些字符，字符会导致分析错误的简单名称的程序集限定名称的一部分时。 若要避免出现分析错误，必须转义的特殊字符以反斜杠之前可以将传递到的程序集限定名称,<xref:System.Type.GetType%2A>方法。 例如，如果名为一种类型`Strange]Type`，转义符必须添加方括号前，如下所示： `Strange\]Type`。  
  
> [!NOTE]
>  使用此类特殊字符的名称不能在 Visual Basic 或 C# 中，创建，但可以通过使用 Microsoft 中间语言 (MSIL) 或发出动态程序集创建。  
  
 下表显示作为类型名称的特殊字符。  
  
|字符|含义|  
|---------------|-------------|  
|`,` （逗号）|程序集限定名称的分隔符。|  
|`[]` （方括号）|作为后缀对，该值指示数组类型;作为分隔符对，包含泛型自变量列表和程序集限定名称。|  
|`&` （and 符）|作为后缀，该值指示类型是引用类型。|  
|`*` （星号）|作为后缀，该值指示一种类型是指针类型。|  
|`+` （加号）|对于嵌套类型的分隔符。|  
|`\` （反斜杠）|转义字符。|  
  
 属性，如<xref:System.Type.AssemblyQualifiedName%2A>返回正确转义字符串。 必须传递到正确转义的字符串<xref:System.Type.GetType%2A>方法。 反过来，<xref:System.Type.GetType%2A>方法将传递到正确转义的名称`typeResolver`和默认类型解析方法。 如果需要进行比较的名称中的非转义名称`typeResolver`，必须删除转义符。  
  
 返回到[用法说明](#usage_notes)。  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>混合的名称解析  
 下表总结了之间的交互`assemblyResolver`， `typeResolver`，以及默认名称解析，类型名称和程序集名称中的所有组合`typeName`:  
  
|类型名称的内容|程序集冲突解决程序方法|类型解析程序方法|结果|  
|---------------------------|------------------------------|--------------------------|------------|  
|程序集类型|null|null|等效于调用<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法重载。|  
|程序集类型|提供|null|`assemblyResolver` 返回的程序集或返回`null`如果无法解析程序集。 如果程序集解析，<xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法重载用于加载程序集的类型; 否则，将不尝试解析类型。|  
|程序集类型|null|提供|等效于将转换到的程序集名称<xref:System.Reflection.AssemblyName>对象，并调用<xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType>方法重载来获取程序集。 如果程序集解析，则将它传递到`typeResolver`; 否则为`typeResolver`不调用，并且没有任何进一步的尝试解析类型。|  
|程序集类型|提供|提供|`assemblyResolver` 返回的程序集或返回`null`如果无法解析程序集。 如果程序集解析，则将它传递到`typeResolver`; 否则为`typeResolver`不调用，并且没有任何进一步的尝试解析类型。|  
|类型|为 null 提供|null|等效于调用<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法重载。 由于未提供的程序集名称，搜索仅 Mscorlib.dll 和当前正在执行的程序集。 如果`assemblyResolver`提供，它将被忽略。|  
|类型|为 null 提供|提供|`typeResolver` 调用时，和`null`传递程序集。 `typeResolver` 可以从任何程序集，包括它的用途加载的程序集提供一种类型。 如果`assemblyResolver`提供，它将被忽略。|  
|程序集|为 null 提供|为 null 提供|A<xref:System.IO.FileLoadException>引发，因为程序集名称会进行分析，就像它是程序集限定类型名称。 这将导致无效的程序集名称。|  
  
 回：[用法说明](#usage_notes)，[解析的程序集](#resolving_assemblies)，[解析类型](#resolving_types)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。  
  
 或  
  
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。  
  
 或  
  
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。  
  
 或  
  
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。  
  
 或  
  
 <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.ArgumentException">当 <paramref name="typeName" /> 分析为类型名称和程序集名称（例如当简单类型名包含未转义的特殊字符）时，将发生错误。  
  
 或  
  
 <paramref name="throwOnError" /> 为 <see langword="true" /> 且 <paramref name="typeName" /> 包含无效的语法（例如，"MyType[,*,]"）。  
  
 或  
  
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
 或  
  
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
 或  
  
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。</exception>
        <exception cref="T:System.IO.FileLoadException">已找到该程序集或其依赖项之一，但无法加载。  
  
 或  
  
 <paramref name="typeName" /> 包含无效的程序集名称。  
  
 或  
  
 <paramref name="typeName" /> 是不含类型名称的有效程序集名称。</exception>
        <exception cref="T:System.BadImageFormatException">该程序集或其依赖项之一无效。  
  
 或  
  
 此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">要确定其类型的对象数组。</param>
        <summary>获取指定数组中对象的类型。</summary>
        <returns>表示 <see cref="T:System.Type" /> 中相应元素的类型的 <paramref name="args" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Type.GetTypeArray%2A>方法来列出的数组的元素的类型。  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="args" /> 的其中一个或多个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用类初始值设定项，并且至少一个引发异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">要获取其基础代码的类型。</param>
        <summary>获取指定 <see cref="T:System.Type" /> 的基础类型代码。</summary>
        <returns>如果 <see cref="F:System.TypeCode.Empty" /> 为 <paramref name="type" />，则为基础类型代码或 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 继承自<xref:System.Type>，可以将此方法的行为更改通过重写<xref:System.Type.GetTypeCodeImpl%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示如何<xref:System.TypeCode>枚举可用。 在决策块内中`WriteObjectInfo`方法，<xref:System.TypeCode>的<xref:System.Object>将检查参数，并向控制台写入相应的消息。  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.Type" /> 实例的基础类型代码。</summary>
        <returns>基础类型的类型代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法提供的实现`static`（在 C# 中) 或`Shared`（在 Visual Basic)<xref:System.Type.GetTypeCode%28System.Type%29>方法。 继承自<xref:System.Type>，您可以重写该方法以提供您自己的实现<xref:System.Type.GetTypeCode%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取与指定类标识符 (CLSID) 关联的类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">要获取的类型的 CLSID。</param>
        <summary>获取与指定类标识符 (CLSID) 关联的类型。</summary>
        <returns>
          <see langword="System.__ComObject" />，无论 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>方法支持后期绑定访问到非托管 COM 对象从.NET Framework 应用程序时你知道该 COM 对象的类标识符 (CLSID)。  在注册表的 HKEY_CLASSES_ROOT\CLSID 项定义 COM 类的类标识符。 你可以检索的值<xref:System.Type.IsCOMObject%2A>属性来确定此方法返回的类型是否为 COM 对象。  
  
> [!TIP]
>  你可以调用<xref:System.Type.GetTypeFromProgID%2A>方法用于后期绑定访问 COM 对象你知道其编程标识符 (ProgID)。  
  
 实例化其 CLSID 从非托管的 COM 对象是一个两步过程：  
  
1.  获取<xref:System.Type>对象，表示`__ComObject`对应 CLSID 通过调用<xref:System.Type.GetTypeFromCLSID%2A>方法。  
  
2.  调用<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法可实例化 COM 对象。  
  
 请参阅方面的演示示例。  
  
 <xref:System.Type.GetTypeFromCLSID%28System.Guid%29>重载将忽略在实例化时可能发生的任何异常<xref:System.Type>对象基于`clsid`自变量。 请注意，在引发任何异常`clsid`注册表中找不到。  
  
   
  
## Examples  
 下面的示例使用 Microsoft Word 的 CLSID[应用程序对象](http://msdn.microsoft.com/library/office/ff838565.aspx)来检索表示 Microsoft Word 应用程序的 COM 类型。 它然后实例化类型通过调用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，并通过调用关闭它[Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)方法。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>在使用 COM 对象，不与.NET Framework 对象时，此方法旨在供使用。 所有托管对象，包括对 COM 可见 (即，其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性是<see langword="true" />) 有 GUID 返回<see cref="P:System.Type.GUID" />属性。 尽管该方法返回<see cref="T:System.Type" />对象对应的.NET Framework 的 GUID 的对象，则无法使用此<see cref="T:System.Type" />对象来创建的类型实例方法调用<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如以下示例所示。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 相反，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />应仅用于检索的非托管的 COM 对象，并且生成的 GUID<see cref="T:System.Type" />对象传递给<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必须表示非托管的 COM 对象。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">要获取的类型的 CLSID。</param>
        <param name="throwOnError">
          <see langword="true" /> 将引发所发生的任何异常。  
  
 或  
  
 <see langword="false" /> 将忽略所发生的任何异常。</param>
        <summary>获取与指定类标识符 (CLSID) 关联的类型，指定在加载该类型时如果发生错误是否引发异常。</summary>
        <returns>
          <see langword="System.__ComObject" />，无论 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>方法支持后期绑定访问到非托管 COM 对象从.NET Framework 应用程序时你知道该 COM 对象的类标识符 (CLSID)。  在注册表的 HKEY_CLASSES_ROOT\CLSID 项定义 COM 类的类标识符。 你可以检索的值<xref:System.Type.IsCOMObject%2A>属性来确定此方法返回的类型是否为 COM 对象。  
  
> [!TIP]
>  你可以调用<xref:System.Type.GetTypeFromProgID%2A>方法用于后期绑定访问 COM 对象你知道其编程标识符 (ProgID)。  
  
 实例化其 CLSID 从非托管的 COM 对象是一个两步过程：  
  
1.  获取<xref:System.Type>对象，表示`__ComObject`对应 CLSID 通过调用<xref:System.Type.GetTypeFromCLSID%2A>方法。  
  
2.  调用<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法可实例化 COM 对象。  
  
 请参阅方面的演示示例。  
  
 如异常<xref:System.OutOfMemoryException>时指定，将引发`true`为`throwOnError`，但它不会为未注册的 Clsid。  
  
   
  
## Examples  
 下面的示例使用 Microsoft Word 的 CLSID[应用程序对象](http://msdn.microsoft.com/library/office/ff838565.aspx)来检索表示 Microsoft Word 应用程序的 COM 类型。 它然后实例化类型通过调用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，并通过调用关闭它[Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)方法。 如果在加载该类型时发生错误，将引发异常。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>在使用 COM 对象，不与.NET Framework 对象时，此方法旨在供使用。 所有托管对象，包括对 COM 可见 (即，其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性是<see langword="true" />) 有 GUID 返回<see cref="P:System.Type.GUID" />属性。 尽管该方法返回<see cref="T:System.Type" />对象对应的.NET Framework 的 GUID 的对象，则无法使用此<see cref="T:System.Type" />对象来创建的类型实例方法调用<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如以下示例所示。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 相反，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />应仅用于检索的非托管的 COM 对象，并且生成的 GUID<see cref="T:System.Type" />对象传递给<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必须表示非托管的 COM 对象。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">要获取的类型的 CLSID。</param>
        <param name="server">用于从中加载该类型的服务器。 如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</param>
        <summary>从指定服务器获取与指定类标识符 (CLSID) 关联的类型。</summary>
        <returns>
          <see langword="System.__ComObject" />，无论 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>方法支持后期绑定访问到非托管 COM 对象从.NET Framework 应用程序时你知道该 COM 对象的类标识符 (CLSID)。  在注册表的 HKEY_CLASSES_ROOT\CLSID 项定义 COM 类的类标识符。 你可以检索的值<xref:System.Type.IsCOMObject%2A>属性来确定此方法返回的类型是否为 COM 对象。  
  
> [!TIP]
>  你可以调用<xref:System.Type.GetTypeFromProgID%2A>方法用于后期绑定访问 COM 对象你知道其编程标识符 (ProgID)。  
  
 实例化其 CLSID 从非托管的 COM 对象是一个两步过程：  
  
1.  获取<xref:System.Type>对象，表示`__ComObject`对应 CLSID 通过调用<xref:System.Type.GetTypeFromCLSID%2A>方法。  
  
2.  调用<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法可实例化 COM 对象。  
  
   
  
## Examples  
 下面的示例使用 Microsoft Word 的 CLSID[应用程序对象](http://msdn.microsoft.com/library/office/ff838565.aspx)来检索表示中名为 computer17.central.contoso.com 的服务器的 Microsoft Word 应用程序的 COM 类型。它然后实例化类型通过调用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，并通过调用关闭它[Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)方法。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>在使用 COM 对象，不与.NET Framework 对象时，此方法旨在供使用。 所有托管对象，包括对 COM 可见 (即，其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性是<see langword="true" />) 有 GUID 返回<see cref="P:System.Type.GUID" />属性。 尽管该方法返回<see cref="T:System.Type" />对象对应的.NET Framework 的 GUID 的对象，则无法使用此<see cref="T:System.Type" />对象来创建的类型实例方法调用<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如以下示例所示。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 相反，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />应仅用于检索的非托管的 COM 对象，并且生成的 GUID<see cref="T:System.Type" />对象传递给<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必须表示非托管的 COM 对象。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">要获取的类型的 CLSID。</param>
        <param name="server">用于从中加载该类型的服务器。 如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</param>
        <param name="throwOnError">
          <see langword="true" /> 将引发所发生的任何异常。  
  
 或  
  
 <see langword="false" /> 将忽略所发生的任何异常。</param>
        <summary>从指定服务器获取与指定类标识符 (CLSID) 关联的类型，指定在加载该类型时如果发生错误是否引发异常。</summary>
        <returns>
          <see langword="System.__ComObject" />，无论 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A>方法支持后期绑定访问到非托管 COM 对象从.NET Framework 应用程序时你知道该 COM 对象的类标识符 (CLSID)。  在注册表的 HKEY_CLASSES_ROOT\CLSID 项定义 COM 类的类标识符。 你可以检索的值<xref:System.Type.IsCOMObject%2A>属性来确定此方法返回的类型是否为 COM 对象。  
  
> [!TIP]
>  你可以调用<xref:System.Type.GetTypeFromProgID%2A>方法用于后期绑定访问 COM 对象你知道其编程标识符 (ProgID)。  
  
 实例化其 CLSID 从非托管的 COM 对象是一个两步过程：  
  
1.  获取<xref:System.Type>对象，表示`__ComObject`对应 CLSID 通过调用<xref:System.Type.GetTypeFromCLSID%2A>方法。  
  
2.  调用<xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>方法可实例化 COM 对象。  
  
 如异常<xref:System.OutOfMemoryException>时指定，将引发`true`为`throwOnError`，但它不会为未注册的 Clsid。  
  
   
  
## Examples  
 下面的示例使用 Microsoft Word 的 CLSID[应用程序对象](http://msdn.microsoft.com/library/office/ff838565.aspx)来检索表示中名为 computer17.central.contoso.com 的服务器的 Microsoft Word 应用程序的 COM 类型。它然后实例化类型通过调用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，并通过调用关闭它[Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx)方法。 如果在加载该类型时发生错误，将引发异常。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>在使用 COM 对象，不与.NET Framework 对象时，此方法旨在供使用。 所有托管对象，包括对 COM 可见 (即，其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性是<see langword="true" />) 有 GUID 返回<see cref="P:System.Type.GUID" />属性。 尽管<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />方法返回<see cref="T:System.Type" />对应于为特定的托管对象的 GUID 对象，则无法使用此<see cref="T:System.Type" />对象来创建的类型实例方法调用<see cref="M:System.Activator.CreateInstance(System.Type)" />方法，如下面的示例显示。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 相反，<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />应仅用于检索的非托管的 COM 对象，并且生成的 GUID<see cref="T:System.Type" />对象传递给<see cref="M:System.Activator.CreateInstance(System.Type)" />方法必须表示非托管的 COM 对象。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">引用类型的对象。</param>
        <summary>获取由指定类型句柄引用的类型。</summary>
        <returns>如果 <see cref="T:System.RuntimeTypeHandle" /> 的 <see langword="null" /> 属性为 <see cref="P:System.RuntimeTypeHandle.Value" />，则为由指定的 <paramref name="handle" /> 引用的类型，或者为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 句柄仅在获取它们的应用程序域中是有效的。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Type.GetTypeFromHandle%2A>方法以获取<xref:System.Type>对象<xref:System.RuntimeTypeHandle>由<xref:System.Type.GetTypeHandle%2A>方法。  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取与指定程序标识符 (ProgID) 关联的类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">要获取的类型的 ProgID。</param>
        <summary>获取与指定程序标识符 (ProgID) 关联的类型，如果在加载 <see cref="T:System.Type" /> 时遇到错误，则返回空值。</summary>
        <returns>如果 <paramref name="progID" /> 是注册表中的有效项，并且有与之关联的类型，则为与指定 ProgID 关联的类型；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此方法用于 COM 支持。 因为它们已取代命名空间的概念，Progid 不会使用 Microsoft.NET Framework 中。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">要获取的类型的 ProgID。</param>
        <param name="throwOnError">
          <see langword="true" /> 将引发所发生的任何异常。  
  
 或  
  
 <see langword="false" /> 将忽略所发生的任何异常。</param>
        <summary>获取与指定程序标识符 (ProgID) 关联的类型，指定如果在加载该类型时发生错误是否引发异常。</summary>
        <returns>如果 <paramref name="progID" /> 是注册表中的有效项且有与之关联的类型，则为与指定程序标识符 (ProgID) 关联的类型；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此方法用于 COM 支持。 程序 Id 不会使用 Microsoft.NET Framework 中因为它们已取代命名空间的概念。  
  
   
  
## Examples  
 下面的示例检索通过传递 ProgID，指定是否引发异常，如果是无效的 ProgID 的类型。 然后，该示例显示 ClassID 相关的 ProgID，以及任何适用的异常消息。  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">未注册指定的 ProgID。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">要获取的类型的 ProgID。</param>
        <param name="server">用于从中加载该类型的服务器。 如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</param>
        <summary>从指定服务器获取与指定程序标识符 (progID) 关联的类型，如果在加载该类型时遇到错误则返回空值。</summary>
        <returns>如果 <paramref name="progID" /> 是注册表中的有效项且有与之关联的类型，则为与指定程序标识符 (ProgID) 关联的类型；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此方法用于 COM 支持。 程序 Id 不会使用 Microsoft.NET Framework 中因为它们已取代命名空间的概念。  
  
   
  
## Examples  
 下面的示例检索通过将 ProgID 和服务器名称传递的类型。 该示例然后显示相关的 ProgID，ClassID 或 ProgID 或服务器名称无效时引发异常。  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="prodID" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">要获取的 <see cref="T:System.Type" /> 的 progID。</param>
        <param name="server">用于从中加载该类型的服务器。 如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</param>
        <param name="throwOnError">
          <see langword="true" /> 将引发所发生的任何异常。  
  
 或  
  
 <see langword="false" /> 将忽略所发生的任何异常。</param>
        <summary>从指定服务器获取与指定程序标识符 (progID) 关联的类型，指定如果在加载该类型时发生错误是否引发异常。</summary>
        <returns>如果 <paramref name="progID" /> 是注册表中的有效项且有与之关联的类型，则为与指定程序标识符 (ProgID) 关联的类型；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此方法用于 COM 支持。 程序 Id 不会使用 Microsoft.NET Framework 中因为它们已取代命名空间的概念。  
  
   
  
## Examples  
 下面的示例检索通过将 ProgID 和服务器名称传递的类型。 然后，该示例显示相关的 ProgID，指定是否引发异常，如果 ProgID 或服务器名称无效 ClassID。  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">未注册指定的 progID。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">要获取类型句柄的对象。</param>
        <summary>获取指定对象的 <see cref="T:System.Type" /> 的句柄。</summary>
        <returns>指定 <see cref="T:System.Type" /> 的 <see cref="T:System.Object" /> 的句柄。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 句柄仅在获取它们的应用程序域中是有效的。  
  
   
  
## Examples  
 下面的示例定义类`MyClass1`，获取它的实例并检索对象的运行时句柄。  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与 <see cref="T:System.Type" /> 关联的 GUID。</summary>
        <value>获取与 <see cref="T:System.Type" /> 关联的 GUID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GUID 是与类型使用相关联<xref:System.Runtime.InteropServices.GuidAttribute>属性。  
  
   
  
## Examples  
 下面的示例创建类`MyClass1`具有公共方法，创建`Type`对象对应于`MyClass1`，并获取<xref:System.Guid>结构使用`GUID`属性`Type`类。  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示当前 <see cref="T:System.Type" /> 是包含还是引用另一类型，即当前 <see cref="T:System.Type" /> 是数组、指针还是通过引用传递。</summary>
        <value>
          如果 <see langword="true" /> 为数组、指针或按引用传递，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，Type.GetType("Int32[]")。HasElementType 返回`true`，但 Type.GetType("Int32")。HasElementType 返回`false`。 HasElementType 也会返回`true`为"Int32 *"和"Int32 （& a)"。  
  
 如果当前<xref:System.Type>表示泛型类型或类型参数的泛型类型或泛型方法定义中的此属性始终返回`false`。  
  
   
  
## Examples  
 下面的示例返回`true`或`false`取决于该对象是否为数组、 引用类型或指针。  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，实现 <see cref="P:System.Type.HasElementType" /> 属性，确定当前 <see cref="T:System.Type" /> 是否包含另一类型或对其引用；即，当前 <see cref="T:System.Type" /> 是否是数组、指针或由引用传递。</summary>
        <returns>
          如果 <see langword="true" /> 为数组、指针或按引用传递，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，Type.GetType("Int32[]")。HasElementTypeImpl 返回`true`，但 Type.GetType("Int32")。HasElementTypeImpl 返回`false`。 HasElementTypeImpl 也会返回`true`为"Int32 *"和"Int32 （& a)"。  
  
   
  
## Examples  
 下面的示例定义类`MyTypeDelegator`，值将覆盖`HasElementTypeImpl`方法。 主类检查`HasElementType`属性并显示的元素类型。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>调用当前 <see cref="T:System.Type" /> 的特定成员。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">字符串，它包含要调用的构造函数、方法、属性或字段成员的名称。  
  
 或  
  
 空字符串 ("")，表示调用默认成员。  
  
 或  
  
 对于 <see langword="IDispatch" /> 成员，则为一个表示 DispID 的字符串，例如"[DispID=3]"。</param>
        <param name="invokeAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。 访问可以是 <see langword="BindingFlags" /> 之一，如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> 和 <see langword="GetField" /> 等。 查找类型无需指定。 如果省略查找的类型，则将使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
 或  
  
 要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。 请注意，为了成功地使用变量参数来调用方法重载，可能必须显式定义 <see cref="T:System.Reflection.Binder" /> 对象。</param>
        <param name="target">对其调用指定成员的对象。</param>
        <param name="args">包含传递给要调用的成员的参数的数组。</param>
        <summary>使用指定的绑定约束并匹配指定的自变量列表，调用指定成员。</summary>
        <returns>一个对象，表示被调用成员的返回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  不能使用<xref:System.Type.InvokeMember%2A>调用泛型方法。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括的成员：  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共成员。  
  
-   指定`BindingFlags.NonPublic`在搜索中包括非公共成员 （即，专用和受保护成员）。  
  
-   指定`BindingFlags.FlattenHierarchy`包括层次结构向上的静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.IgnoreCase` 若要忽略的大小写`name`。  
  
-   `BindingFlags.DeclaredOnly` 要搜索仅上声明的成员<xref:System.Type>，不只是继承的成员。  
  
 以下<xref:System.Reflection.BindingFlags>调用标志可以用于表示要与成员执行的操作：  
  
-   `CreateInstance` 若要调用构造函数。 `name` 将被忽略。 与其他调用标志无效。  
  
-   `InvokeMethod` 若要调用方法，但不是构造函数或类型初始值设定项。 未有效，且`SetField`或`SetProperty`。 如果`InvokeMethod`本身，指定`BindingFlags.Public`， `BindingFlags.Instance`，和`BindingFlags.Static`会自动包括。  
  
-   `GetField` 若要获取的字段的值。 未有效，且`SetField`。  
  
-   `SetField` 若要设置的字段值。 未有效，且`GetField`。  
  
-   `GetProperty` 若要获取的属性。 未有效，且`SetProperty`。  
  
-   `SetProperty` 若要设置一个属性。 未有效，且`GetProperty`。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果以下条件都成立，则将调用一个方法：  
  
-   方法声明中的参数的数目等于中的参数数目`args`数组 (除非成员上定义了默认参数和`BindingFlags.OptionalParamBinding`指定)。  
  
-   每个自变量的类型可以转换由参数的类型联编程序。  
  
 联编程序将查找所有匹配的方法。 这些方法找到基于请求的绑定类型 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`， `GetProperty`，依次类推)。 按名称、 数量的参数和一组绑定器中定义的搜索修饰符进行筛选的方法集。  
  
 选择方法后，它被调用。 此时，检查可访问性。 搜索可能基于与该方法关联的可访问性属性来控制搜索哪些方法集。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>方法<xref:System.Reflection.Binder>类负责选择要调用的方法。 默认的联编程序选择最精确的匹配。  
  
 对于完全受信任的代码; 忽略访问限制也就是说，可以访问并通过调用的私有构造函数、 方法、 字段和属性<xref:System.Reflection>每当的代码是完全受信任。  
  
 你可以使用`Type.InvokeMember`将字段设置为特定值，通过指定<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>。 例如，如果你想要设置 C 和 F 的类上名为 F 的公共实例字段是`String`，你可以使用如下代码：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 如果 F `String[]`，你可以使用如下代码：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 这将初始化到该新数组的字段 F。 你还可以使用`Type.InvokeMember`设置通过使用类似以下的代码中提供的值，然后选择下一步的值的索引的数组中的位置：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 这将更改 F 包含字符串"b"数组中的字符串"z"。  
  
 当调用`IDispatch`成员，你可以指定而不是成员名称，使用字符串格式的 DispID"[DispID = # #]"。 例如，如果 DispID MyComMethod 为 3，你可以指定字符串"[DispID = 3]"而不是"MyComMethod"。 调用成员的 DispID 比速度快按名称查找成员。 在复杂的聚合方案中，DispID 有时是调用所需的成员的唯一方法。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，此方法可以用于访问非公共成员，如果调用方已被授予<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标志，并且如果非公共成员的授予集限制为调用方的授予集或子集其中。 (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
   
  
## Examples  
 下面的示例使用`InvokeMember`访问成员的类型。  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> 不包含 <see langword="CreateInstance" />，并且 <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 属性。  
  
 或  
  
 <paramref name="invokeAttr" /> 不包含以下某个绑定标志：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。  
  
 或  
  
 <paramref name="invokeAttr" /> 包含 <see langword="CreateInstance" /> 与 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 的组合。  
  
 或  
  
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetField" /> 和 <see langword="SetField" />。  
  
 或  
  
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。  
  
 或  
  
 <paramref name="invokeAttr" /> 包含 <see langword="InvokeMethod" /> 与 <see langword="SetField" /> 或 <see langword="SetProperty" /> 的组合。  
  
 或  
  
 <paramref name="invokeAttr" /> 包含 <see langword="SetField" />，并且 <paramref name="args" /> 具有多个元素。  
  
 或  
  
 对 COM 对象调用了此方法，但以下绑定标志中有一个未传入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。  
  
 或  
  
 其中一个命名参数数组包含一个值为 <see langword="null" /> 的字符串。</exception>
        <exception cref="T:System.MethodAccessException">指定的成员是类初始值设定项。</exception>
        <exception cref="T:System.MissingFieldException">找不到此字段或属性。</exception>
        <exception cref="T:System.MissingMethodException">找不到与 <paramref name="args" /> 中的参数匹配的方法。  
  
 或  
  
 当前 <see cref="T:System.Type" /> 对象表示包含开放类型参数的类型，也就是说，<see cref="P:System.Type.ContainsGenericParameters" /> 将返回 <see langword="true" />。</exception>
        <exception cref="T:System.Reflection.TargetException">不能在 <paramref name="target" /> 上调用指定的成员。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">多个方法与绑定条件匹配。</exception>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework 当前不支持此方法。</exception>
        <exception cref="T:System.InvalidOperationException">由 <paramref name="name" /> 表示的方法具有一个或多个未指定的泛型类型参数。 也就是说，此方法的 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 属性将返回 <see langword="true" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">对于访问而不考虑其授予非公共成员设置。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">调用非托管的代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">字符串，它包含要调用的构造函数、方法、属性或字段成员的名称。  
  
 或  
  
 空字符串 ("")，表示调用默认成员。  
  
 或  
  
 对于 <see langword="IDispatch" /> 成员，则为一个表示 DispID 的字符串，例如"[DispID=3]"。</param>
        <param name="invokeAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。 访问可以是 <see langword="BindingFlags" /> 之一，如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> 和 <see langword="GetField" /> 等。 查找类型无需指定。 如果省略查找的类型，则将使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
 或  
  
 要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。 请注意，为了成功地使用变量参数来调用方法重载，可能必须显式定义 <see cref="T:System.Reflection.Binder" /> 对象。</param>
        <param name="target">对其调用指定成员的对象。</param>
        <param name="args">包含传递给要调用的成员的参数的数组。</param>
        <param name="culture">表示要使用的全局化区域设置的对象，它对区域设置特定的转换可能是必需的，比如将数字 <see cref="T:System.String" /> 转换为 <see cref="T:System.Double" />。  
  
 或  
  
 要使用当前线程的 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="T:System.Globalization.CultureInfo" />）。</param>
        <summary>使用指定的绑定约束和匹配的指定参数列表及区域性来调用指定成员。</summary>
        <returns>一个对象，表示被调用成员的返回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 虽然默认的联编程序不处理<xref:System.Globalization.CultureInfo>(`culture`参数)，你可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写的自定义的联编程序`culture`。  
  
> [!NOTE]
>  不能使用<xref:System.Type.InvokeMember%2A>调用泛型方法。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括的成员：  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共成员。  
  
-   指定`BindingFlags.NonPublic`在搜索中包括非公共成员 （即，私有、 内部和受保护成员）。  
  
-   指定`BindingFlags.FlattenHierarchy`包括层次结构向上的静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.IgnoreCase` 若要忽略的大小写`name`。  
  
-   `BindingFlags.DeclaredOnly` 要搜索仅上声明的成员<xref:System.Type>，不只是继承的成员。  
  
 以下<xref:System.Reflection.BindingFlags>调用标志可以用于表示要与成员执行的操作：  
  
-   `CreateInstance` 若要调用构造函数。 `name` 将被忽略。 与其他调用标志无效。  
  
-   `InvokeMethod` 若要调用方法，但不是构造函数或类型初始值设定项。 未有效，且`SetField`或`SetProperty`。 如果`InvokeMethod`本身，指定`BindingFlags.Public`， `BindingFlags.Instance`，和`BindingFlags.Static`会自动包括。  
  
-   `GetField` 若要获取的字段的值。 未有效，且`SetField`。  
  
-   `SetField` 若要设置的字段值。 未有效，且`GetField`。  
  
-   `GetProperty` 若要获取的属性。 未有效，且`SetProperty`。  
  
-   `SetProperty` 若要设置一个属性。 未有效，且`GetProperty`。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果以下条件都成立，则将调用一个方法：  
  
-   方法声明中的参数的数目等于中的参数数目`args`数组 (除非成员上定义了默认参数和`BindingFlags.OptionalParamBinding`指定)。  
  
-   每个自变量的类型可以转换由参数的类型联编程序。  
  
 联编程序将查找所有匹配的方法。 这些方法找到基于请求的绑定类型 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`， `GetProperty`，依次类推)。 按名称、 数量的参数和一组绑定器中定义的搜索修饰符进行筛选的方法集。  
  
 选择方法后，它被调用。 此时，检查可访问性。 搜索可能基于与该方法关联的可访问性属性来控制搜索哪些方法集。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>方法<xref:System.Reflection.Binder>类负责选择要调用的方法。 默认的联编程序选择最精确的匹配。  
  
 对于完全受信任的代码; 忽略访问限制也就是说，是在私有构造函数、 方法、 字段和属性访问而完全受信任代码时，通过反射调用。  
  
 你可以使用`Type.InvokeMember`将字段设置为特定值，通过指定<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>。 例如，如果你想要设置 C 和 F 的类上名为 F 的公共实例字段是`String`你可以使用如下代码：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 如果 F `String[]`，你可以使用如下代码：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 这将初始化到该新数组的字段 F。 你还可以使用`Type.InvokeMember`设置通过使用类似以下的代码中提供的值，然后选择下一步的值的索引的数组中的位置：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 这将更改 F 包含字符串"b"数组中的字符串"z"。  
  
 当调用`IDispatch`成员可以指定而不是成员名称，使用字符串格式的 DispID"[DispID = # #]"。 例如，如果 DispID MyComMethod 为 3，你可以指定字符串"[DispID = 3]"而不是"MyComMethod"。 调用成员的 DispID 比速度快按名称查找成员。 在复杂的聚合方案中，DispID 有时是调用所需的成员的唯一方法。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，此方法可以用于访问非公共成员，如果调用方已被授予<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标志，并且如果非公共成员的授予集限制为调用方的授予集或子集其中。 (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> 不包含 <see langword="CreateInstance" />，并且 <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 属性。  
  
 或  
  
 <paramref name="invokeAttr" /> 不包含以下某个绑定标志：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。  
  
 或  
  
 <paramref name="invokeAttr" /> 包含 <see langword="CreateInstance" /> 与 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 的组合。  
  
 或  
  
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetField" /> 和 <see langword="SetField" />。  
  
 或  
  
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。  
  
 或  
  
 <paramref name="invokeAttr" /> 包含 <see langword="InvokeMethod" /> 与 <see langword="SetField" /> 或 <see langword="SetProperty" /> 的组合。  
  
 或  
  
 <paramref name="invokeAttr" /> 包含 <see langword="SetField" />，并且 <paramref name="args" /> 具有多个元素。  
  
 或  
  
 对 COM 对象调用了此方法，但以下绑定标志中有一个未传入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。  
  
 或  
  
 其中一个命名参数数组包含一个值为 <see langword="null" /> 的字符串。</exception>
        <exception cref="T:System.MethodAccessException">指定的成员是类初始值设定项。</exception>
        <exception cref="T:System.MissingFieldException">找不到此字段或属性。</exception>
        <exception cref="T:System.MissingMethodException">找不到与 <paramref name="args" /> 中的参数匹配的方法。  
  
 或  
  
 当前 <see cref="T:System.Type" /> 对象表示包含开放类型参数的类型，也就是说，<see cref="P:System.Type.ContainsGenericParameters" /> 将返回 <see langword="true" />。</exception>
        <exception cref="T:System.Reflection.TargetException">不能在 <paramref name="target" /> 上调用指定的成员。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">多个方法与绑定条件匹配。</exception>
        <exception cref="T:System.InvalidOperationException">由 <paramref name="name" /> 表示的方法具有一个或多个未指定的泛型类型参数。 也就是说，此方法的 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 属性将返回 <see langword="true" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">对于访问而不考虑其授予非公共成员设置。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">调用非托管的代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">字符串，它包含要调用的构造函数、方法、属性或字段成员的名称。  
  
 或  
  
 空字符串 ("")，表示调用默认成员。  
  
 或  
  
 对于 <see langword="IDispatch" /> 成员，则为一个表示 DispID 的字符串，例如"[DispID=3]"。</param>
        <param name="invokeAttr">一个位屏蔽，由一个或多个指定搜索执行方式的 <see cref="T:System.Reflection.BindingFlags" /> 组成。 访问可以是 <see langword="BindingFlags" /> 之一，如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> 和 <see langword="GetField" /> 等。 查找类型无需指定。 如果省略查找的类型，则将使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
 或  
  
 要使用 <see cref="P:System.Type.DefaultBinder" /> 的空引用（在 Visual Basic 中为 Nothing）。 请注意，为了成功地使用变量参数来调用方法重载，可能必须显式定义 <see cref="T:System.Reflection.Binder" /> 对象。</param>
        <param name="target">对其调用指定成员的对象。</param>
        <param name="args">包含传递给要调用的成员的参数的数组。</param>
        <param name="modifiers">
          <see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <c>args</c> 数组中的相应元素关联的特性。 参数的关联的属性存储在成员的签名中。  
  
 只有在调用 COM 组件时，默认联编程序才处理此参数。</param>
        <param name="culture">表示要使用的全局化区域设置的 <see cref="T:System.Globalization.CultureInfo" /> 对象，它对区域设置特定的转换可能是必需的，比如将数字 String 转换为 Double。  
  
 或  
  
 要使用当前线程的 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="T:System.Globalization.CultureInfo" />）。</param>
        <param name="namedParameters">包含参数名称的数组，<c>args</c> 数组中的值将传递给这些参数。</param>
        <summary>当在派生类中重写时，使用指定的绑定约束并匹配指定的参数列表、修饰符和区域性，调用指定成员。</summary>
        <returns>一个对象，表示被调用成员的返回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` 调用构造函数成员或方法成员、 获取或设置的属性成员、 获取或设置数据字段成员，或获取或设置数组成员的元素。  
  
> [!NOTE]
>  不能使用<xref:System.Type.InvokeMember%2A>调用泛型方法。  
  
 当调用`IDispatch`成员可以指定而不是成员名称，使用字符串格式的 DispID"[DispID = # #]"。 例如，如果 DispID MyComMethod 为 3，你可以指定字符串"[DispID = 3]"而不是"MyComMethod"。 调用成员的 DispID 比速度快按名称查找成员。 在复杂的聚合方案中，DispID 有时是调用所需的成员的唯一方法。  
  
 虽然默认的联编程序不处理<xref:System.Reflection.ParameterModifier>或<xref:System.Globalization.CultureInfo>(`modifiers`和`culture`参数)，你可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写的自定义的联编程序`modifiers`和`culture`. `ParameterModifier` 当通过 COM 互操作调用，才使用并且可以通过引用传递的参数进行处理。  
  
 `namedParameters` 数组中的每一个参数获取 `args` 数组中相应元素中的值。 如果 `args` 的长度大于 `namedParameters` 的长度，则按顺序传递剩余的参数值。  
  
 `namedParameters`数组可以用于更改输入数组中的参数的顺序。 例如，给定方法`M(string a, int b)`(`M(ByVal a As String, ByVal b As Integer)`在 Visual Basic 中) 和输入的数组`{ 42, "x" }`，输入的数组可以传递不变以`args`如果数组`{ "b", "a" }`为提供`namedParameters`。  
  
 以下<xref:System.Reflection.BindingFlags>的筛选器标志可以用于定义要在搜索中包括的成员：  
  
-   指定`BindingFlags.Public`要包含在搜索中的公共成员。  
  
-   指定`BindingFlags.NonPublic`在搜索中包括非公共成员 （即，私有、 内部和受保护成员）。  
  
-   指定`BindingFlags.FlattenHierarchy`包括层次结构向上的静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可以用于更改搜索的工作原理：  
  
-   `BindingFlags.IgnoreCase` 若要忽略的大小写`name`。  
  
-   `BindingFlags.DeclaredOnly` 要搜索仅上声明的成员<xref:System.Type>，不只是继承的成员。  
  
 以下<xref:System.Reflection.BindingFlags>调用标志可以用于表示要与成员执行的操作：  
  
-   `CreateInstance` 若要调用构造函数。 `name` 将被忽略。 与其他调用标志无效。  
  
-   `InvokeMethod` 若要调用方法，但不是构造函数或类型初始值设定项。 未有效，且`SetField`或`SetProperty`。 如果`InvokeMethod`本身，指定`BindingFlags.Public`， `BindingFlags.Instance`，和`BindingFlags.Static`会自动包括。  
  
-   `GetField` 若要获取的字段的值。 未有效，且`SetField`。  
  
-   `SetField` 若要设置的字段值。 未有效，且`GetField`。  
  
-   `GetProperty` 若要获取的属性。 未有效，且`SetProperty`。  
  
-   `SetProperty` 若要设置一个属性。 未有效，且`GetProperty`。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果以下条件都成立，则将调用一个方法：  
  
-   方法声明中的参数的数目等于中的参数数目`args`数组 (除非成员上定义了默认参数和`BindingFlags.OptionalParamBinding`指定)。  
  
-   每个自变量的类型可以转换由参数的类型联编程序。  
  
 联编程序将查找所有匹配的方法。 这些方法找到基于请求的绑定类型 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`， `GetProperty`，依次类推)。 按名称、 数量的参数和一组绑定器中定义的搜索修饰符进行筛选的方法集。  
  
 选择方法后，它被调用。 此时，检查可访问性。 搜索可能基于与该方法关联的可访问性属性来控制搜索哪些方法集。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>方法<xref:System.Reflection.Binder>类负责选择要调用的方法。 默认的联编程序选择最精确的匹配。  
  
 `InvokeMember` 可用来调用参数具有默认值的方法。 若要将绑定到这些方法，反射，需要<xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType>指定。 对于具有默认值参数，你可以提供不同的值，也可以提供<xref:System.Reflection.Missing.Value?displayProperty=nameWithType>可以使用默认值。  
  
 例如，考虑 MyMethod 之类的方法 (x，float y int = 2.0)。 若要调用此方法使用仅 mymethod （4） 作为第一个参数，请将上面的绑定标志之一和传递两个参数，即第一个参数的 4 和`Missing.Value`为第二个参数。 除非你使用`Missing.Value`，你不能省略可选参数`Invoke`方法。 如果必须这样做，则使用`InvokeMember`相反。  
  
 对于完全受信任的代码; 忽略访问限制也就是说，可以访问并通过调用的私有构造函数、 方法、 字段和属性<xref:System.Reflection>每当的代码是完全受信任。  
  
 你可以使用`Type.InvokeMember`将字段设置为特定值，通过指定<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>。 例如，如果你想要设置 C 和 F 的类上名为 F 的公共实例字段是`String`，你可以使用如下代码：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 如果 F `String[]`，你可以使用如下代码：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 这将初始化到该新数组的字段 F。 你还可以使用`Type.InvokeMember`设置通过使用类似以下的代码中提供的值，然后选择下一步的值的索引的数组中的位置：  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 这将更改 F 包含字符串"b"数组中的字符串"z"。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，此方法可以用于访问非公共成员，如果调用方已被授予<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标志，并且如果非公共成员的授予集限制为调用方的授予集或子集其中。 (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> 不包含 <see langword="CreateInstance" />，并且 <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="args" /> 和 <paramref name="modifiers" /> 的长度不相同。  
  
 或  
  
 <paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 属性。  
  
 或  
  
 <paramref name="invokeAttr" /> 不包含以下某个绑定标志：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。  
  
 或  
  
 <paramref name="invokeAttr" /> 包含 <see langword="CreateInstance" /> 与 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 的组合。  
  
 或  
  
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetField" /> 和 <see langword="SetField" />。  
  
 或  
  
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。  
  
 或  
  
 <paramref name="invokeAttr" /> 包含 <see langword="InvokeMethod" /> 与 <see langword="SetField" /> 或 <see langword="SetProperty" /> 的组合。  
  
 或  
  
 <paramref name="invokeAttr" /> 包含 <see langword="SetField" />，并且 <paramref name="args" /> 具有多个元素。  
  
 或  
  
 命名的参数数组大于参数数组。  
  
 或  
  
 对 COM 对象调用了此方法，但以下绑定标志中有一个未传入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。  
  
 或  
  
 其中一个命名参数数组包含一个值为 <see langword="null" /> 的字符串。</exception>
        <exception cref="T:System.MethodAccessException">指定的成员是类初始值设定项。</exception>
        <exception cref="T:System.MissingFieldException">找不到此字段或属性。</exception>
        <exception cref="T:System.MissingMethodException">找不到与 <paramref name="args" /> 中的参数匹配的方法。  
  
 或  
  
 找不到具有 <paramref name="namedParameters" /> 中提供的参数名称的成员。  
  
 或  
  
 当前 <see cref="T:System.Type" /> 对象表示包含开放类型参数的类型，也就是说，<see cref="P:System.Type.ContainsGenericParameters" /> 将返回 <see langword="true" />。</exception>
        <exception cref="T:System.Reflection.TargetException">不能在 <paramref name="target" /> 上调用指定的成员。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">多个方法与绑定条件匹配。</exception>
        <exception cref="T:System.InvalidOperationException">由 <paramref name="name" /> 表示的方法具有一个或多个未指定的泛型类型参数。 也就是说，此方法的 <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> 属性将返回 <see langword="true" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">对于访问而不考虑其授予非公共成员设置。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">调用非托管的代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为抽象的并且必须被重写。</summary>
        <value>
          如果 <see cref="T:System.Type" /> 是抽象的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAbstract%2A>属性返回`true`在以下情况：  
  
-   当前类型是抽象的;也就是说，它不能实例化，但仅可用作派生类的基类。 在 C# 中，抽象类均未标有[抽象](~/docs/csharp/language-reference/keywords/abstract.md)关键字; 在 Visual Basic 中，它们用来标记[MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)关键字。  
  
-   当前类型是接口。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此属性始终返回`false`。  
  
   
  
## Examples  
 下面的示例创建的数组<xref:System.Type>表示以下类型的对象： 包含类型返回`true`的指定的对象是否`abstract`; 否则为它将返回`false`。  
  
-   `AbstractClass`一个抽象类 (类标记为`abstract`在 C# 和`MustInherit`在 Visual Basic 中)。  
  
-   `DerivedClass`继承自的类`AbstractClass`。  
  
-   `SingleClass`非可继承的类。 它将定义为`sealed`在 C# 和`NotInheritable`在 Visual Basic 中。  
  
-   `ITypeInfo`一个接口。  
  
-   `ImplementingClass`一个类以实现`ITypeInfo`接口。  
  
 该方法返回`true`仅为`AbstractClass`，抽象类，和`ITypeInfo`，该接口。  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否为 <see langword="AnsiClass" /> 选择了字符串格式属性 <see cref="T:System.Type" />。</summary>
        <value>
          如果为 <see langword="true" /> 选择了字符串格式属性 <see langword="AnsiClass" />，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>选择字符串格式属性。 字符串格式属性通过定义字符串的解释方式提高互操作性。  
  
 如果当前<xref:System.Type>表示泛型类型，此属性与从中构造的类型的泛型类型定义。 例如，如果当前<xref:System.Type>表示`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，此属性的值由`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型，此属性始终返回`false`。  
  
   
  
## Examples  
 下面的示例获取字段信息并检查`AnsiClass`属性。  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示类型是否为数组。</summary>
        <value>
          如果当前类型是数组，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsArray%2A>属性返回`false`为<xref:System.Array>类。 它还返回`false`如果当前实例是<xref:System.Type>对象，表示集合类型或接口设计为可以使用集合，如<xref:System.Collections.IEnumerable>或<xref:System.Collections.Generic.IEnumerable%601>。  
  
 若要检查数组，使用如下代码：  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 如果当前类型表示泛型类型或泛型类型或泛型方法定义中的类型参数，此属性始终返回`false`。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Type.IsArray%2A>属性。  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，实现 <see cref="P:System.Type.IsArray" /> 属性并确定 <see cref="T:System.Type" /> 是否为数组。</summary>
        <returns>
          如果 <see langword="true" /> 是数组，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 实例<xref:System.Array>类必须返回`false`因为它是一个对象，而不是数组。  
  
   
  
## Examples  
 下面的示例重写`IsArrayImpl`中的方法`MyTypeDelegator`类检查，如果变量是一个数组，并显示结果。  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">要与当前类型进行比较的类型。</param>
        <summary>确定指定类型的实例是否能分配给当前类型实例。</summary>
        <returns>
          如果满足下列任一条件，则为 <see langword="true" />：  
  
-   <paramref name="c" /> 且当前实例表示相同类型。  
  
-   <paramref name="c" /> 是从当前实例直接或间接派生的。 如果继承于当前实例，则 <paramref name="c" /> 是从当前实例直接派生的；如果继承于从当前实例继承的接连一个或多个类，则 <paramref name="c" /> 是从当前实例间接派生的。  
  
-   当前实例是一个 <paramref name="c" /> 实现的接口。  
  
-   <paramref name="c" /> 是一个泛型类型参数，并且当前实例表示 <paramref name="c" /> 的约束之一。  
  
     在以下示例中，当前实例是表示 <see cref="T:System.IO.Stream" /> 类的 <see cref="T:System.Type" /> 对象。 <c>GenericWithConstraint</c> 是一种泛型类型，其泛型类型参数必须为 <see cref="T:System.IO.Stream" /> 类型。 将其泛型类型参数传递到 <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> 表示可以将泛型类型参数的实例分配给 <see cref="T:System.IO.Stream" /> 对象。  
  
     [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]
     [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  
  
-   <paramref name="c" /> 表示一个值类型，并且当前实例表示 <c>Nullable&lt;c&gt;</c>（在 Visual Basic 中为 <c>Nullable(Of c)</c>）。  
  
 如果不满足上述任何一个条件或者 <paramref name="c" /> 为 <see langword="false" />，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAssignableFrom%2A>方法可以用于确定实例是否`c`可以分配到当前类型的实例，该方法将处理其类型在设计时未知的对象时最有用，并允许条件赋值，如下面的示例演示。  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 此方法因此可确保的一行代码，如以下将在运行时执行而不引发<xref:System.InvalidCastException>异常或类似的异常：  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 此方法由派生类中重写。  
  
> [!NOTE]
>  泛型类型定义不能从封闭式构造类型分配。 也就是说，不能将分配封闭式构造的类型`MyGenericList<int>`(`MyGenericList(Of Integer)`在 Visual Basic 中) 到类型的变量的`MyGenericList<T>`。  
  
 如果`c`形参属于类型<xref:System.Reflection.Emit.TypeBuilder>，结果取决于要生成的类型。 下面的代码示例演示这一使用名为的内置的类型`B`。  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 下面的示例演示`IsAssignableFrom`方法使用定义的类、 整数数组和泛型。  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否为 <see langword="AutoClass" /> 选择了字符串格式属性 <see cref="T:System.Type" />。</summary>
        <value>
          如果为 <see langword="true" /> 选择了字符串格式属性 <see langword="AutoClass" />，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>选择字符串格式属性。 字符串格式属性通过定义字符串的解释方式提高互操作性。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此属性适用于从其构造的类型的泛型类型定义。 例如，如果当前<xref:System.Type>表示`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，此属性的值由`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型，此属性始终返回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示当前类型的字段是否由公共语言运行时自动放置的值。</summary>
        <value>
          如果当前类型的 <see langword="true" /> 属性包括 <see cref="P:System.Type.Attributes" />，则为 <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此属性是为方便起见。 或者，可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>枚举值，可以选择的类型布局属性，然后测试是否<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>设置。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>，<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>，和<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>枚举值指示类型的字段在内存中布局的方式。  
  
 对于动态类型，你可以指定<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>创建类型时。 在代码中，应用<xref:System.Runtime.InteropServices.StructLayoutAttribute>特性与<xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType>于该类型，以让运行时确定适当的方式进行布局的类的枚举值。  
  
> [!NOTE]
>  不能使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法来确定是否<xref:System.Runtime.InteropServices.StructLayoutAttribute>应用于类型。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此属性适用于从其构造的类型的泛型类型定义。 例如，如果当前<xref:System.Type>表示`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，此属性的值由 `MyGenericType<T>.`  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此属性始终返回`false`。  
  
   
  
## Examples  
 下面的示例创建类型的实例，并显示<xref:System.Type.IsAutoLayout%2A>属性。  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否由引用传递。</summary>
        <value>
          如果 <see cref="T:System.Type" /> 按引用传递，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取实际的类型，请取消引用通过引用传递的类型，然后调用<xref:System.Type.GetElementType%2A>对该类型。  
  
   
  
## Examples  
 下面的示例演示使用`IsByRef`属性检查是否按引用传递指定的类型。 该示例定义了类`MyTypeDelegator`，值将覆盖`HasElementTypeImpl`方法。 主类检查`HasElementType`属性并显示的元素类型。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，实现 <see cref="P:System.Type.IsByRef" /> 属性并确定<see cref="T:System.Type" /> 是否通过引用传递。</summary>
        <returns>
          如果 <see cref="T:System.Type" /> 按引用传递，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是一个类或委托；即，不是值类型或接口。</summary>
        <value>
          如果 <see cref="T:System.Type" /> 是类，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回`true`个类，以及委托。 它将返回`false`的值类型 （结构和枚举） 即使它们装箱。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此属性始终返回`true`。如果当前<xref:System.Type>表示构造的泛型类型，此属性返回`true`如果泛型类型定义为类定义; 也就是说，它不定义接口或值类型。  
  
> [!NOTE]
>  此属性返回`true`为`Type`实例表示<xref:System.Enum>和<xref:System.ValueType>类。 这两个类分别枚举的基类型和值类型，但它们不是枚举或值类型本身。 有关详细信息，请参阅<xref:System.Type.IsValueType%2A>和<xref:System.Type.IsEnum%2A>属性。  
  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>枚举值区分类型声明为类或接口。但是，类和值类型都标有<xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType>属性。 如果检索的值类型的特性属性并使用<xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>值以确定是否是类型为类而不是值类型，你还必须调用<xref:System.Type.IsValueType%2A>属性。 例如<xref:System.Reflection.TypeAttributes>枚举包含其他信息，以及 anexample。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例创建类型的实例，并指示类型是否是一个类。  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为 COM 对象。</summary>
        <value>
          如果 <see langword="true" /> 为 COM 对象，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回`false`为 COM 接口，因为它们不是对象。 可以通过 Microsoft.NET Framework 对象实现 COM 接口。  
  
 你还可以加载 COM 类，并获取`Type`为通过使用 COM 该类的对象[Tlbimp.exe （类型库导入程序）](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)工具。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此属性适用于从其构造的类型的泛型类型定义。 例如，如果当前<xref:System.Type>表示`MyGenericType<int`> (`MyGenericType(Of Integer)`在 Visual Basic 中)，此属性的值由`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此属性始终返回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，实现 <see cref="P:System.Type.IsCOMObject" /> 属性并确定 <see cref="T:System.Type" /> 是否为 COM 对象。</summary>
        <returns>
          如果 <see langword="true" /> 为 COM 对象，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回`false`为 COM 接口，因为它们不是对象。 可以通过 Microsoft.NET Framework 对象实现 COM 接口。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示此对象是否表示构造的泛型类型的值。 你可以创建构造型泛型类型的实例。</summary>
        <value>
          如果此对象表示构造泛型类型，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 构造的泛型类型具有为其所有泛型类型参数提供的显式类型。 它也称为封闭式泛型类型。  
  
 当此属性是`true`，你可以创建的当前类型实例; 它时`false`，你不能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 在上下文中是否可以被承载。</summary>
        <value>
          如果 <see cref="T:System.Type" /> 能够在某个上下文中承载，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 上下文截获对类成员的调用，并强制实施策略应用于类，如同步。 有关更多详细远程上下文的信息，请参阅<xref:System.Runtime.Remoting.Contexts.Context>。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此属性始终返回`false`。  
  
   
  
## Examples  
 下面的示例演示`IsContextful`， <xref:System.Type.IsMarshalByRef%2A>，和<xref:System.Type.IsPrimitive%2A>属性<xref:System.Type>类。 它会检查是否可以封送的引用，以及类型是否为基元数据类型，是否可以在上下文中中, 承载的给定的类型。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>实现 <see cref="P:System.Type.IsContextful" /> 属性并确定 <see cref="T:System.Type" /> 在上下文中是否可以被承载。</summary>
        <returns>
          如果 <see cref="T:System.Type" /> 能够在某个上下文中承载，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由派生类中重写。  
  
 上下文截获对类成员的调用，并强制执行策略应用于类，如同步。  
  
   
  
## Examples  
 下面的示例演示使用`IsContextfulImpl`方法。  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前的 <see cref="T:System.Type" /> 是否表示枚举。</summary>
        <value>
          如果当前 <see langword="true" /> 表示枚举，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回`true`枚举，但不是能为<xref:System.Enum>类型本身。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此属性适用于从其构造的类型的泛型类型定义。 例如，如果当前<xref:System.Type>表示`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，此属性的值由`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此属性始终返回`false`。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例演示如何使用`IsEnum`属性。  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要测试的值。</param>
        <summary>返回一个值，该值指示当前的枚举类型中是否存在指定的值。</summary>
        <returns>
          如果指定的值是当前枚举类型的成员，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">当前类型不是一个枚举。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> 的类型不能是枚举的基础类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">要测试是否与当前类型等效的 COM 类型。</param>
        <summary>确定两个 COM 类型是否具有相同的标识，以及是否符合类型等效的条件。</summary>
        <returns>
          如果 COM 类型等效，则为 <see langword="true" />；否则为 <see langword="false" />。 如果一个类型位于为执行加载的程序集中，而另一个类型位于已加载到仅限反射上下文的程序集中，则此方法也返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 开头[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，公共语言运行时支持嵌入 COM 类型的直接为托管程序集，而不是要求互操作从获取 COM 类型的类型信息的托管程序集的类型信息程序集。 由于嵌入式类型信息仅包含托管程序集实际使用的类型和成员，因此两个托管程序集可能具有相同 COM 类型的不同视图。 每个托管程序集都有不同的 <xref:System.Type> 对象来表示其 COM 类型视图。 公共语言运行时支持接口、结构、枚举和委托等不同视图之间的类型等效性。  
  
 类型等效性意味着从一个托管程序集传递到另一个托管程序集的 COM 对象可以转换为接收程序集中适当的托管类型。 <xref:System.Type.IsEquivalentTo%2A>方法将启用的程序集以确定 COM 对象获取从另一个程序集具有相同的 COM 标识作为第一个程序集的自己嵌入互操作类型之一，并因此可以强制转换为该类型。  
  
 有关详细信息，请参阅[类型等效性和嵌入的互操作类型](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示当前类型的字段是否放置在显式指定的偏移量处的值。</summary>
        <value>
          如果当前类型的 <see langword="true" /> 属性包括 <see cref="P:System.Type.Attributes" />，则为 <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此属性是为方便起见。 或者，可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>枚举值，可以选择的类型布局属性，然后测试是否<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>设置。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>， <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>，和<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>枚举值指示类型的字段在内存中布局的方式。  
  
 对于动态类型，你可以指定<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>创建类型时。 在代码中，应用<xref:System.Runtime.InteropServices.StructLayoutAttribute>特性与<xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>到的类型，以指定显式指定字段开始的偏移量的枚举值。  
  
> [!NOTE]
>  不能使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法来确定是否<xref:System.Runtime.InteropServices.StructLayoutAttribute>应用于类型。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此属性适用于从其构造的类型的泛型类型定义。 例如，如果当前<xref:System.Type>表示`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，此属性的值由`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此属性始终返回`false`。  
  
   
  
## Examples  
 下面的示例创建类型的实例，并显示的值其<xref:System.Type.IsExplicitLayout%2A>属性。 它使用`MySystemTime`类，该类也是中的代码示例<xref:System.Runtime.InteropServices.StructLayoutAttribute>。  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Type" /> 是否表示泛型类型或方法的定义中的类型参数。</summary>
        <value>
          如果 <see cref="T:System.Type" /> 对象表示泛型类型定义或泛型方法定义的类型参数，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> 可以通过调用获取对象表示泛型类型参数<xref:System.Type.GetGenericArguments%2A>方法<xref:System.Type>对象，表示泛型类型定义，或<xref:System.Reflection.MethodInfo.GetGenericArguments%2A>方法<xref:System.Reflection.MethodInfo>表示泛型方法的对象定义。  
  
-   对于泛型类型或方法定义<xref:System.Type.IsGenericParameter%2A>属性返回`true`为每个元素生成的数组。  
  
-   封闭式构造的类型或方法，<xref:System.Type.IsGenericParameter%2A>属性返回`false`返回的数组的每个元素<xref:System.Type.GetGenericArguments%2A>方法。  
  
-   开放式构造的类型或方法，该数组的某些元素可能是特定类型和其他人可能是类型参数。 <xref:System.Type.IsGenericParameter%2A> 返回`false`的类型和`true`的类型参数。 代码示例<xref:System.Type.ContainsGenericParameters%2A>属性演示具有混合类型和类型参数的泛型类。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Type.IsGenericParameter%2A>属性要测试其泛型类型中的泛型类型参数。  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前类型是否是泛型类型。</summary>
        <value>
          <see langword="true" /> 如果当前类型是泛型类型;否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Type.IsGenericType%2A>属性来确定是否<xref:System.Type>对象表示泛型类型。 使用<xref:System.Type.ContainsGenericParameters%2A>属性来确定是否<xref:System.Type>对象表示开放构造的类型或封闭式构造的类型。  
  
> [!NOTE]
>  <xref:System.Type.IsGenericType%2A>属性返回`false`如果紧挨的类型不是泛型。 例如，其元素为的类型数组`A<int>`(`A(Of Integer)`在 Visual Basic 中) 本身不是泛型类型。  
  
 下表总结了泛型反射中常用术语的固定条件。  
  
|术语|固定条件|  
|----------|---------------|  
|Generic Type Definition — 泛型类型定义|<xref:System.Type.IsGenericTypeDefinition%2A> 属性为 `true`。<br /><br /> 定义泛型类型。 构造的类型通过调用创建<xref:System.Type.MakeGenericType%2A>方法<xref:System.Type>对象表示泛型类型定义，并指定一个类型参数的字符串数组。<br /><br /> <xref:System.Type.MakeGenericType%2A> 可以调用仅在泛型类型定义。<br /><br /> 任何泛型类型定义是一个泛型类型 (<xref:System.Type.IsGenericType%2A>属性是`true`)，但反之不成立。|  
|Generic Type — 泛型类型|<xref:System.Type.IsGenericType%2A> 属性为 `true`。<br /><br /> 可以是泛型类型定义、 开放构造的类型或封闭式构造的类型。<br /><br /> 请注意的数组类型的元素类型是泛型本身不是泛型类型。 这同样适用的<xref:System.Type>对象表示对泛型类型的指针。|  
|开放构造的类型|<xref:System.Type.ContainsGenericParameters%2A> 属性为 `true`。<br /><br /> 示例包括具有未分配的类型参数的泛型类型，嵌套在泛型类型定义或开放构造类型中的类型或泛型类型具有为其类型自变量<xref:System.Type.ContainsGenericParameters%2A>属性是`true`。<br /><br /> 不能创建开放构造类型的实例。<br /><br /> 请注意，并非所有开放构造的类型是泛型。 例如，其元素类型为泛型类型定义的数组不是泛型，并指向开放构造类型的指针不是泛型。|  
|封闭式构造的类型|<xref:System.Type.ContainsGenericParameters%2A> 属性为 `false`。<br /><br /> 当检查以递归方式，该类型没有任何未分配的泛型参数。|  
|Generic Type Parameter — 泛型类型参数|<xref:System.Type.IsGenericParameter%2A> 属性为 `true`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 属性为 `true`。<br /><br /> 在泛型类型定义中，将在以后赋值的类型的占位符。|  
|Generic Type Argument — 泛型类型变量|可以是任何类型，包括泛型类型参数。<br /><br /> 类型自变量被指定为一个数组<xref:System.Type>对象传递给<xref:System.Type.MakeGenericType%2A>方法创建构造泛型类型时。 如果要创建的生成的类型的实例<xref:System.Type.ContainsGenericParameters%2A>属性必须为`false`对于所有类型参数。|  
  
 下面的代码示例和表说明了其中的某些条款和固定协定。 `Derived`类是特别感兴趣，因为其基类型是具有其类型自变量列表中的类型和类型参数的构造的类型。  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 下表显示了使用和生成的类上`Base`， `Derived`，和`G`。 在 c + + 和 C# 代码都是相同，只有一个条目将显示。  
  
|示例|固定协定|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|对于此类型：<br /><br /> <xref:System.Type.IsGenericType%2A> 为 `true`。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 为 `true`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 为 `true`。|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|对于此类型：<br /><br /> <xref:System.Type.IsGenericType%2A> 为 `true`。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 为 `false`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 为 `true`。|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|类型的变量`d`:<br /><br /> <xref:System.Type.IsGenericType%2A> 是`false`因为`d`是数组。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 为 `false`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 为 `false`。|  
|`T``U`，和`V`（不管它们出现）|<xref:System.Type.IsGenericParameter%2A> 为 `true`。<br /><br /> <xref:System.Type.IsGenericType%2A> 是`false`因为没有方法来约束的泛型类型的类型参数。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 为 `false`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 是`true`因为`T`， `U`，和`V`本身是泛型类型参数。 这并不意味着有关分配给他们更高版本的类型参数的任何信息。|  
|字段的类型 `F`|<xref:System.Type.IsGenericType%2A> 为 `true`。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 是`false`因为类型已分配给类型参数的`G`。 请注意，这等效于调用<xref:System.Type.MakeGenericType%2A>方法。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 是`true`因为字段的类型`F`具有为开放式构造的类型的类型参数。 构造的类型为开放式因为其类型参数 (即， `Base`) 是泛型类型定义。 此关系图演示的递归性质<xref:System.Type.IsGenericType%2A>属性。|  
|嵌套的类 `Nested`|<xref:System.Type.IsGenericType%2A> 是`true`，即使`Nested`类具有其自己的任何泛型类型参数，因为它嵌套在泛型类型。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 为 `true`。 也就是说，可以调用<xref:System.Type.MakeGenericType%2A>方法并提供、 封闭类型的类型参数`Derived`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 是`true`因为封闭类型`Derived`，具有泛型类型参数。 此关系图演示的递归性质<xref:System.Type.ContainsGenericParameters%2A>属性。|  
  
   
  
## Examples  
 下面的代码示例显示的值<xref:System.Type.IsGenericType%2A>， <xref:System.Type.IsGenericTypeDefinition%2A>， <xref:System.Type.IsGenericParameter%2A>，和<xref:System.Type.ContainsGenericParameters%2A>备注部分中描述的类型的属性。 有关的属性值的说明，请参阅备注中随附的表。  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Type" /> 是否表示可以用来构造其他泛型类型的泛型类型定义。</summary>
        <value>
          如果此 <see langword="true" /> 对象表示泛型类型定义，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 泛型类型定义是可从其构造其他类型的模板。 例如，从泛型类型定义`G<T>`（用表示 C# 语法;`G(Of T)`在 Visual Basic 中或`generic <typename T> ref class G`c + + 中) 构造并将其实例化类型`G<int>`(`G(Of Integer)`在 Visual Basic 中)，通过调用<xref:System.Type.MakeGenericType%2A>方法替换泛型自变量列表包含<xref:System.Int32>类型。 给定<xref:System.Type>对象表示此构造类型，<xref:System.Type.GetGenericTypeDefinition%2A>方法的泛型类型定义返回重新获得。  
  
 使用<xref:System.Type.IsGenericTypeDefinition%2A>属性来确定是否可以从当前的类型创建新的类型。 如果<xref:System.Type.IsGenericTypeDefinition%2A>属性返回`true`，可以调用<xref:System.Type.MakeGenericType%2A>方法来创建新的泛型类型。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的示例显示信息的类型，包括是泛型类型定义。 构造类型、 其泛型类型定义，和普通类型，则会显示信息。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否应用了 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 属性，如果应用了该属性，则表示它是从 COM 类型库导入的。</summary>
        <value>
          如果 <see langword="true" /> 具有 <see cref="T:System.Type" />，则为 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示构造的泛型类型，此属性适用于从其构造的类型的泛型类型定义。 例如，如果当前<xref:System.Type>表示`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，此属性的值由 `MyGenericType<T>.`  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此属性始终返回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">要与当前类型进行比较的对象。</param>
        <summary>确定指定的对象是否是当前 <see cref="T:System.Type" /> 的实例。</summary>
        <returns>
          如果满足下列任一条件，则为 <see langword="true" />：当前 <see langword="Type" /> 位于由 <paramref name="o" /> 表示的对象的继承层次结构中；当前 <see langword="Type" /> 是 <paramref name="o" /> 实现的接口。 如果不属于其中任一种情况，<paramref name="o" /> 为 <see langword="null" />，或者当前 <see langword="Type" /> 为开放式泛型类型（即 <see cref="P:System.Type.ContainsGenericParameters" /> 返回 <see langword="true" />），则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由派生类中重写。  
  
> [!NOTE]
>  构造的类型不是其泛型类型定义的实例。 也就是说， `MyGenericList<int>` (`MyGenericList(Of Integer)`在 Visual Basic 中) 不是实例的`MyGenericList<T>`(`MyGenericList(Of T)`在 Visual Basic 中)。  
  
   
  
## Examples  
 下面的示例演示 `IsInstanceOfType` 方法的用法。  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是一个接口；即，不是类或值类型。</summary>
        <value>
          如果 <see langword="true" /> 是接口，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask>区分类型声明为类、 接口或值类型。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此属性始终返回`false`。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例创建一个接口、 检查接口类型，并指示类是否具有`IsInterface`属性集。  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示当前类型的字段是否按顺序（定义顺序或发送到元数据的顺序）放置的值。</summary>
        <value>
          如果当前类型的 <see langword="true" /> 属性包括 <see cref="P:System.Type.Attributes" />，则为 <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此属性是为方便起见。 或者，可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>枚举值，可以选择的类型布局属性，然后测试是否<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>设置。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>， <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>，和<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>枚举值指示类型的字段在内存中布局的方式。  
  
 对于动态类型，你可以指定<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>创建类型时。 在代码中，应用<xref:System.Runtime.InteropServices.StructLayoutAttribute>特性与<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>到的类型，以指定是按顺序进行该布局的枚举值。  
  
> [!NOTE]
>  不能使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法来确定是否<xref:System.Runtime.InteropServices.StructLayoutAttribute>应用于类型。  
  
 有关详细信息，请参阅部分 9.1.2 有关公共语言基础结构 (CLI) 文档，"第 ii 部分： 元数据定义和语义"的规范。 可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](http://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此属性适用于从其构造的类型的泛型类型定义。 例如，如果当前<xref:System.Type>表示`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，此属性的值由`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此属性始终返回`false`。  
  
   
  
## Examples  
 下面的示例创建一个类的实例为其<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>中的枚举值<xref:System.Runtime.InteropServices.StructLayoutAttribute>类已设置，检查<xref:System.Type.IsLayoutSequential%2A>属性，并显示结果。  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否按引用进行封送。</summary>
        <value>
          如果 <see langword="true" /> 是由引用封送的，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示`IsContextful`， <xref:System.Type.IsMarshalByRef%2A>，和<xref:System.Type.IsPrimitive%2A>属性<xref:System.Type>类。 它会检查是否可以封送的引用，以及类型是否为基元数据类型，是否可以在上下文中中, 承载的给定的类型。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>实现 <see cref="P:System.Type.IsMarshalByRef" /> 属性并确定 <see cref="T:System.Type" /> 是否按引用来进行封送。</summary>
        <returns>
          如果 <see langword="true" /> 是由引用封送的，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由派生类中重写。  
  
   
  
## Examples  
 下面的示例确定给定的类型是否按引用进行封送，并显示结果。  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个指示当前 <see cref="T:System.Type" /> 对象是否表示其定义嵌套在另一个类型的定义之内的类型的值。</summary>
        <value>
          如果 <see langword="true" /> 嵌套在另一个类型内，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsNested%2A>属性返回`true`所有嵌套类型，而不考虑可见性。 若要在同一时间测试嵌套和可见性，请使用相关的属性<xref:System.Type.IsNestedAssembly%2A>， <xref:System.Type.IsNestedFamily%2A>， <xref:System.Type.IsNestedFamANDAssem%2A>， <xref:System.Type.IsNestedFamORAssem%2A>， <xref:System.Type.IsNestedPrivate%2A>，或<xref:System.Type.IsNestedPublic%2A>。  
  
> [!NOTE]
>  <xref:System.Reflection.TypeAttributes.VisibilityMask>枚举成员选择一种类型的可见性属性。  
  
   
  
## Examples  
 下面的示例创建了多个具有各种类型的可见性的嵌套类与某一外部类。 然后检索大量的可见性相关的值<xref:System.Type>父类型和每个及其嵌套类型的属性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只能在它自己的程序集内可见。</summary>
        <value>
          如果 <see langword="true" /> 是嵌套的并且仅在它自己的程序集中可见，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示类型参数的泛型类型，此属性始终返回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 选择的可见性属性。  
  
   
  
## Examples  
 下面的示例创建了多个具有各种类型的可见性的嵌套类与某一外部类。 然后检索大量的可见性相关的值<xref:System.Type>父类型和每个及其嵌套类型的属性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只对同时属于自己家族和自己程序集的类可见。</summary>
        <value>
          如果 <see cref="T:System.Type" /> 是嵌套的并且只对同时属于它自己的家族和它自己的程序集的类可见，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示类型参数的泛型类型，此属性始终返回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 选择的可见性属性。  
  
> [!NOTE]
>  C# 和 Visual Basic 语言不包括允许你定义的嵌套的类型，仅对受保护的类型，在其自己的程序集中可见的语义。 `protected internal` 在 C# 中的可见性和`Protected Friend`在 Visual Basic 中的可见性定义的嵌套的类型，同时向受保护的类型和相同的程序集中的类型可见。  
  
 A<xref:System.Type>对象的系列指所有对象的相同<xref:System.Type>和子类型。  
  
   
  
## Examples  
 下面的示例创建了多个具有各种类型的可见性的嵌套类与某一外部类。 然后检索大量的可见性相关的值<xref:System.Type>父类型和每个及其嵌套类型的属性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只能在它自己的家族内可见。</summary>
        <value>
          如果 <see langword="true" /> 是嵌套的并且仅在它自己的家族中可见，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示类型参数的泛型类型，此属性始终返回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 选择的可见性属性。  
  
 A<xref:System.Type>对象的系列指所有对象的准确相同<xref:System.Type>和子类型。  
  
   
  
## Examples  
 下面的示例创建了多个具有各种类型的可见性的嵌套类与某一外部类。 然后检索大量的可见性相关的值<xref:System.Type>父类型和每个及其嵌套类型的属性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只对属于它自己的家族或属于它自己的程序集的类可见。</summary>
        <value>
          如果 <see langword="true" /> 是嵌套的并且只对属于它自己的家族或属于它自己的程序集的类可见，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果类型的可见性是`protected internal`在 C# 或`Protected Friend`在 Visual Basic 中，<xref:System.Type.IsNestedFamORAssem%2A>属性返回`true`。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型，此属性始终返回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 选择的可见性属性。  
  
 A<xref:System.Type>对象的系列指所有对象的准确相同<xref:System.Type>和子类型。  
  
   
  
## Examples  
 下面的示例创建了多个具有各种类型的可见性的嵌套类与某一外部类。 然后检索大量的可见性相关的值<xref:System.Type>父类型和每个及其嵌套类型的属性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并声明为私有。</summary>
        <value>
          如果 <see langword="true" /> 是嵌套的并声明为私有，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示类型参数的泛型类型，此属性始终返回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 选择的可见性属性。  
  
   
  
## Examples  
 下面的示例创建了多个具有各种类型的可见性的嵌套类与某一外部类。 然后检索大量的可见性相关的值<xref:System.Type>父类型和每个及其嵌套类型的属性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示类是否是嵌套的并且声明为公共的。</summary>
        <value>
          如果类是嵌套的并且声明为公共的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示类型参数的泛型类型，此属性始终返回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 选择的可见性属性。  
  
   
  
## Examples  
 下面的示例创建了多个具有各种类型的可见性的嵌套类与某一外部类。 然后检索大量的可见性相关的值<xref:System.Type>父类型和每个及其嵌套类型的属性。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否声明为公共类型。</summary>
        <value>
          如果 <see langword="true" /> 未声明为公共类型且不是嵌套类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用嵌套的类型; 不使用此属性使用<xref:System.Type.IsNestedPublic%2A>属性改为。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型，此属性返回`false`。  
  
   
  
## Examples  
 此示例使用该域`IsNotPublic`要获取类型的可见性属性。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 下面的代码示例演示了为什么你不能使用`IsPublic`和`IsNotPublic`嵌套类。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 对于嵌套类，忽略的结果`IsPublic`和`IsNotPublic`和仅关注的结果`IsNestedPublic`和`IsNestedPrivate`。 此代码段的反射输出将如下所示：  
  
|类|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|包含当前请求的 URL 的|false|true|false|false|  
|B|false|false|true|false|  
|C|false|false|false|true|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为指针。</summary>
        <value>
          如果 <see cref="T:System.Type" /> 是指针，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示泛型类型或类型参数的泛型类型或泛型方法定义中的此属性始终返回`false`。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例演示使用`IsPointer`属性。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，实现 <see cref="P:System.Type.IsPointer" /> 属性并确定 <see cref="T:System.Type" /> 是否为指针。</summary>
        <returns>
          如果 <see cref="T:System.Type" /> 是指针，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为基元类型之一。</summary>
        <value>
          如果 <see langword="true" /> 为基元类型之一，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基元类型是<xref:System.Boolean>， <xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>， <xref:System.IntPtr>， <xref:System.UIntPtr>， <xref:System.Char>，<xref:System.Double>，和<xref:System.Single>。  
  
 如果当前<xref:System.Type>表示泛型类型或类型参数的泛型类型或泛型方法定义中的此属性始终返回`false`。  
  
   
  
## Examples  
 下面的示例演示`IsContextful`， <xref:System.Type.IsMarshalByRef%2A>，和<xref:System.Type.IsPrimitive%2A>属性<xref:System.Type>类。 它会检查是否可以封送的引用，以及类型是否为基元数据类型，是否可以在上下文中中, 承载的给定的类型。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，实现 <see cref="P:System.Type.IsPrimitive" /> 属性并确定 <see cref="T:System.Type" /> 是否为基元类型之一。</summary>
        <returns>
          如果 <see langword="true" /> 为基元类型之一，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基元类型是<xref:System.Boolean>， <xref:System.Byte>， <xref:System.SByte>， <xref:System.Int16>， <xref:System.UInt16>， <xref:System.Int32>， <xref:System.UInt32>， <xref:System.Int64>， <xref:System.UInt64>， <xref:System.Char>， <xref:System.Double>，和<xref:System.Single>。  
  
   
  
## Examples  
 下面的示例确定给定的类型是否为基元类型，并显示结果。  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否声明为公共类型。</summary>
        <value>
          如果 <see langword="true" /> 声明为公共类型且不是嵌套类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不要使用嵌套的类型;使用<xref:System.Type.IsNestedPublic%2A>相反。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型，此属性返回`true`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 选择的可见性属性。  
  
   
  
## Examples  
 下面的示例创建的实例`MyTestClass`，检查`IsPublic`属性，并显示结果。  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 对于嵌套类，忽略的结果`IsPublic`和`IsNotPublic`和仅关注的结果<xref:System.Type.IsNestedPublic%2A>和<xref:System.Type.IsNestedPrivate%2A>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否声明为密封的。</summary>
        <value>
          如果 <see langword="true" /> 被声明为密封的，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示类型参数的泛型类型，此属性始终返回`true`。  
  
   
  
## Examples  
 下面的示例创建的实例`sealed`类，检查`IsSealed`属性，并显示结果。  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前的类型在当前信任级别上是安全关键的还是安全可靠关键的，并因此可以执行关键操作。</summary>
        <value>
          如果当前类型在当前信任级别上是安全关键的或安全可靠关键的，则为 <see langword="true" />；如果它是透明的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>， <xref:System.Type.IsSecuritySafeCritical%2A>，和<xref:System.Type.IsSecurityTransparent%2A>属性报告在其当前的信任级别，由公共语言运行时 (CLR) 类型的透明度级别。 下表中显示的这些属性的组合：  
  
|安全级别|IsSecurityCritical|IsSecurityCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|严重|`true`|`false`|`false`|  
|可靠关键|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
> [!IMPORTANT]
>  对于部分信任程序集，此属性的值取决于程序集的当前信任级别。 如果程序集加载到部分受信任的应用程序域中 （例如，到沙盒应用程序域中），运行时将忽略程序集的安全批注。 程序集和其所有类型被视为透明。 运行时才会注意到部分信任程序集的安全批注仅当该程序集加载到完全信任的应用程序域中 （例如，到桌面应用程序的默认应用程序域）。 与此相反，受信任的程序集 （即，具有强名称程序集安装在全局程序集缓存），是始终以而不考虑应用程序域的信任级别的完全信任方式加载，因此其当前的信任级别始终是完全受信任。 你可以使用来确定程序集和应用程序域的当前信任级别<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>属性。  
  
 有关反射和透明度的详细信息，请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。 透明度有关的信息，请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前类型在当前信任级别上是否是安全可靠关键的；即它是否可以执行关键操作并可以由透明代码访问。</summary>
        <value>
          如果当前类型在当前信任级别上是安全可靠关键的，则为 <see langword="true" />；如果它是安全关键的或透明的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>， <xref:System.Type.IsSecuritySafeCritical%2A>，和<xref:System.Type.IsSecurityTransparent%2A>属性报告在其当前的信任级别，由公共语言运行时 (CLR) 类型的透明度级别。 下表中显示的这些属性的组合：  
  
|安全级别|IsSecurityCritical|IsSecurityCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|严重|`true`|`false`|`false`|  
|可靠关键|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
> [!IMPORTANT]
>  对于部分信任程序集，此属性的值取决于程序集的当前信任级别。 如果程序集加载到部分受信任的应用程序域中 （例如，到沙盒应用程序域中），运行时将忽略程序集的安全批注。 程序集和其所有类型被视为透明。 运行时才会注意到部分信任程序集的安全批注仅当该程序集加载到完全信任的应用程序域中 （例如，到桌面应用程序的默认应用程序域）。 与此相反，受信任的程序集 （即，具有强名称程序集安装在全局程序集缓存），是始终以而不考虑应用程序域的信任级别的完全信任方式加载，因此其当前的信任级别始终是完全受信任。 你可以使用来确定程序集和应用程序域的当前信任级别<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>属性。  
  
 有关反射和透明度的详细信息，请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。 透明度有关的信息，请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前类型在当前信任级别上是否是透明的而无法执行关键操作。</summary>
        <value>
          如果该类型在当前信任级别上是安全透明的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性返回`true`、<xref:System.Type.IsSecurityCritical%2A>和<xref:System.Type.IsSecuritySafeCritical%2A>属性返回`false`。  
  
 <xref:System.Type.IsSecurityCritical%2A>， <xref:System.Type.IsSecuritySafeCritical%2A>，和<xref:System.Type.IsSecurityTransparent%2A>属性报告在其当前的信任级别，由公共语言运行时 (CLR) 类型的透明度级别。 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
> [!IMPORTANT]
>  对于部分信任程序集，此属性的值取决于程序集的当前信任级别。 如果程序集加载到部分受信任的应用程序域中 （例如，到沙盒应用程序域中），运行时将忽略程序集的安全批注。 程序集和其所有类型被视为透明。 运行时才会注意到部分信任程序集的安全批注仅当该程序集加载到完全信任的应用程序域中 （例如，到桌面应用程序的默认应用程序域）。 与此相反，受信任的程序集 （即，具有强名称程序集安装在全局程序集缓存），是始终以而不考虑应用程序域的信任级别的完全信任方式加载，因此其当前的信任级别始终是完全受信任。 你可以使用来确定程序集和应用程序域的当前信任级别<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>属性。  
  
 有关反射和透明度的详细信息，请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。 透明度有关的信息，请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为可序列化的。</summary>
        <value>
          如果 <see cref="T:System.Type" /> 是可序列化的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
在.NET 标准中定义的类型不将标有<xref:System.SerializableAttribute>。 相反，每个.NET 实现确定类型是否为可序列化。 在运行时，可以使用<xref:System.Type.IsSerializable%2A>属性来确定该实现是否支持序列化类型的实例。 有关详细信息及示例，请参阅[如何确定是否可序列化的标准.NET 对象](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)。
  
 如果当前<xref:System.Type>表示构造的泛型类型，此属性适用于从其构造的类型的泛型类型定义。 例如，如果当前<xref:System.Type>表示`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，此属性的值由`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此属性始终返回`false`。  
  
   
  
## Examples  
 下面的示例创建的实例`MyTestClass`类，设置 [Serializable] 特性，并检查`IsSerializable`属性`true`或`false`。  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示该类型是否具有需要特殊处理的名称。</summary>
        <value>
          如果该类型具有需要特殊处理的名称，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 开头或者包含下划线字符 (_)、 属性访问器和运算符重载方法的名称是由一些编译器需要特殊处理的类型的示例。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此属性适用于从其构造的类型的泛型类型定义。 例如，如果当前<xref:System.Type>表示`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，此属性的值由`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此属性始终返回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">要与当前类型进行比较的类型。</param>
        <summary>确定当前 <see cref="T:System.Type" /> 是否派生自指定的 <see cref="T:System.Type" />。</summary>
        <returns>
          如果当前 <see langword="true" /> 派生于 <see langword="Type" />，则为 <paramref name="c" />；否则为 <see langword="false" />。 如果 <see langword="false" /> 和当前 <paramref name="c" /> 相等，此方法也返回 <see langword="Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以调用<xref:System.Type.IsSubclassOf%2A>方法来确定任一项：  
  
-   是否一个类派生自另一个。  
  
-   一种类型是否派生自<xref:System.ValueType>。 但是，<xref:System.Type.IsValueType%2A>是更高效的方法来确定类型是否是值类型。  
  
-   一种类型是否派生自<xref:System.Enum>。 但是，<xref:System.Type.IsEnum%2A>方法是更高效的方法来确定类型是否是一个枚举。  
  
-   某类型是否是一个委托，即，是否从它派生<xref:System.Delegate>或<xref:System.MulticastDelegate>。  
  
 <xref:System.Type.IsSubclassOf%2A>方法不能用于确定接口是否派生自另一个接口，或是否类实现的接口。 使用<xref:System.Type.IsAssignableFrom%2A>出于这个目的，如以下示例所示的方法。  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 如果当前<xref:System.Type>表示类型参数在泛型类型或泛型方法定义中，它派生自其类约束或从<xref:System.Object?displayProperty=nameWithType>是否没有类约束。  
  
> [!NOTE]
>  有了接口，使用时除外<xref:System.Type.IsSubclassOf%2A>截然相反， <xref:System.Type.IsAssignableFrom%2A>。 也就是说，如果`t1.IsSubclassOf(t2)`是`true`，然后`t2.IsAssignableFrom(t1)`也`true`。  
  
 此方法由派生类中重写。  
  
   
  
## Examples  
 下面的示例创建一个名为类`Class1`和派生的类名为`DerivedC1`。 它调用<xref:System.Type.IsSubclassOf%2A>方法显示`DerivedC1`是的一个子类`Class1`。  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否为 <see langword="UnicodeClass" /> 选择了字符串格式属性 <see cref="T:System.Type" />。</summary>
        <value>
          如果为 <see langword="true" /> 选择了字符串格式属性 <see langword="UnicodeClass" />，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>用于选择字符串格式属性。 字符串格式属性通过定义字符串的解释方式提高互操作性。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此属性适用于从其构造的类型的泛型类型定义。 例如，如果当前<xref:System.Type>表示`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，此属性的值由`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此属性始终返回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为值类型。</summary>
        <value>
          如果 <see langword="true" /> 是值类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值类型都是表示为序列的 bits; 的类型值类型不是类或接口。 值类型称为"结构"中的某些编程语言。 枚举是值类型的特殊情况。  
  
 此属性返回`false`为<xref:System.ValueType>类，因为<xref:System.ValueType>不是值类型本身。 它是所有的值类型的基类，并因此可以将任意值类型分配给它。 这将不可能如果<xref:System.ValueType>自身是值类型。 值类型进行装箱时分配给类型的字段，它们<xref:System.ValueType>。  
  
 此属性返回`true`枚举，但不是能为<xref:System.Enum>类型本身。 有关演示此行为的示例，请参阅<xref:System.Type.IsEnum%2A>。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例创建类型的变量的`MyEnum`，检查`IsValueType`属性，并显示结果。  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>实现 <see cref="P:System.Type.IsValueType" /> 属性并确定 <see cref="T:System.Type" /> 是否是值类型；即，它不是值类或接口。</summary>
        <returns>
          如果 <see langword="true" /> 是值类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于启用备用类型系统的实现。 它通常不使用应用程序代码中。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个指示 <see cref="T:System.Type" /> 是否可由程序集之外的代码访问的值。</summary>
        <value>
          如果当前 <see langword="true" /> 是公共类型或公共嵌套类型从而使所有封闭类型都是公共类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性来确定类型是否为组件程序集的公共接口的一部分。  
  
   
  
## Examples  
 下面的代码示例测试两个类，只是其中之一是程序集外部可见。  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回表示当前类型的数组的 <see cref="T:System.Type" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Type" /> 对象，该对象表示当前类型的一维数组（下限为零）。</summary>
        <returns>返回一个表示当前类型的一维数组（下限为零）的 <see cref="T:System.Type" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A>方法提供了如何生成在运行时计算其元素类型的数组类型。  
  
 **请注意**公共语言运行时发出向量 （也就是说，始终从零开始的一维数组） 之间的差异和多维数组。 一个向量，始终具有只有一个维度，不是恰好有一个维度的多维数组相同。 此方法重载仅可用于创建矢量类型，并且它是唯一的方法创建的向量类型。 使用<xref:System.Type.MakeArrayType%28System.Int32%29>方法重载来创建多维数组类型。  
  
   
  
## Examples  
 下面的代码示例创建数组， `ref` (`ByRef`在 Visual Basic 中)，以及指针类型的`Test`类。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。 派生类必须提供一个实现。</exception>
        <exception cref="T:System.TypeLoadException">当前的类型是 <see cref="T:System.TypedReference" />。  
  
 或  
  
 当前的类型是 <see langword="ByRef" /> 类型。 也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">数组的维数。 此数字必须小于或等于 32。</param>
        <summary>返回 <see cref="T:System.Type" /> 对象，该对象表示一个具有指定维数的当前类型的数组。</summary>
        <returns>表示当前类型的指定维数的数组的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A>方法提供了如何生成在运行时计算其元素类型的数组类型。  
  
> [!NOTE]
>  公共语言运行时发出向量 （也就是说，始终从零开始的一维数组） 之间的差异和多维数组。 一个向量，始终具有只有一个维度，不是恰好有一个维度的多维数组相同。 你无法使用此方法重载创建矢量类型;如果`rank`为 1，此方法重载返回恰好有一个维度的多维数组类型。 使用<xref:System.Type.MakeArrayType>方法重载来创建矢量类型。  
  
   
  
## Examples  
 下面的代码示例创建数组， `ref` (`ByRef`在 Visual Basic 中)，以及指针类型的`Test`类。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> 无效。 例如，0 或负数。</exception>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <exception cref="T:System.TypeLoadException">当前的类型是 <see cref="T:System.TypedReference" />。  
  
 或  
  
 当前的类型是 <see langword="ByRef" /> 类型。 也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。  
  
 或  
  
 <paramref name="rank" /> 大于 32。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示作为 <see cref="T:System.Type" /> 参数（在 Visual Basic 中为 <see langword="ref" /> 参数）传递时的当前类型的 <see langword="ByRef" /> 对象。</summary>
        <returns>表示作为 <see cref="T:System.Type" /> 参数（在 Visual Basic 中为 <see langword="ref" /> 参数）传递时的当前类型的 <see langword="ByRef" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeByRefType%2A>方法使您能够生成`ref`类型 (`ByRef`在 Visual Basic 中) 为参数列出。  
  
 如果使用的语法的 Microsoft 中间语言 (MSIL)，当前<xref:System.Type>对象所表示<xref:System.Int32>，此方法返回<xref:System.Type>对象，表示`Int32&`。  
  
   
  
## Examples  
 下面的代码示例创建数组， `ref` (`ByRef`在 Visual Basic 中)，以及指针类型的`Test`类。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <exception cref="T:System.TypeLoadException">当前的类型是 <see cref="T:System.TypedReference" />。  
  
 或  
  
 当前的类型是 <see langword="ByRef" /> 类型。 也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">将代替当前泛型类型的类型参数的类型数组。</param>
        <summary>替代由当前泛型类型定义的类型参数组成的类型数组的元素，并返回表示结果构造类型的 <see cref="T:System.Type" /> 对象。</summary>
        <returns>
          <see cref="T:System.Type" /> 表示的构造类型通过以下方式形成：用 <paramref name="typeArguments" /> 的元素取代当前泛型类型的类型参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeGenericType%2A>方法允许你编写代码，将特定类型分配给类型参数的泛型类型定义，从而形成的<xref:System.Type>表示特定构造的类型的对象。 你可以使用此<xref:System.Type>对象来创建的构造类型的运行时实例。  
  
 使用类型构造<xref:System.Type.MakeGenericType%2A>可以是开放式，即，其类型参数的一些可以是类型参数的封闭式泛型方法或类型。 发出动态程序集时，你可能使用此类开放式构造的类型。 例如，考虑的类`Base`和`Derived`下面的代码中。  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 若要生成`Derived`动态程序集中，就需要构造其基类型。 若要执行此操作，调用<xref:System.Type.MakeGenericType%2A>方法<xref:System.Type>表示类对象`Base`，使用泛型类型参数<xref:System.Int32>和类型参数`V`从`Derived`。 因为类型和泛型类型参数均表示通过<xref:System.Type>对象，同时包含这两者的数组可以传递给<xref:System.Type.MakeGenericType%2A>方法。  
  
> [!NOTE]
>  构造的类型，如`Base<int, V>`有用时发出的代码中，但不能调用<xref:System.Type.MakeGenericType%2A>此类型的方法因为它不是泛型类型定义。 若要创建封闭构造的类型可进行实例化，请先调用<xref:System.Type.GetGenericTypeDefinition%2A>方法以获取<xref:System.Type>对象表示泛型类型定义，然后调用<xref:System.Type.MakeGenericType%2A>并用所需的类型实参。  
  
 <xref:System.Type>返回对象<xref:System.Type.MakeGenericType%2A>相同<xref:System.Type>通过调用获取<xref:System.Object.GetType%2A>方法生成的构造类型，或<xref:System.Object.GetType%2A>构造创建从同一个泛型类型的任一种方法使用相同的类型参数的类型定义。  
  
> [!NOTE]
>  泛型类型的数组本身不是泛型类型。 不能调用<xref:System.Type.MakeGenericType%2A>在数组上键入，如`C<T>[]`(`Dim ac() As C(Of T)`在 Visual Basic 中)。 若要构造封闭式泛型类型从`C<T>[]`，调用<xref:System.Type.GetElementType%2A>来获取泛型类型定义`C<T>`; 调用<xref:System.Type.MakeGenericType%2A>的泛型类型定义，以创建构造的类型; 最后调用<xref:System.Type.MakeArrayType%2A>方法要创建的数组类型的构造的类型。 这同样适用的指针类型和`ref`类型 (`ByRef`在 Visual Basic 中)。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
## <a name="nested-types"></a>嵌套类型  
 如果使用 C#、 c + + 或 Visual Basic 定义泛型类型，则所有泛型及其嵌套的类型。 即使嵌套的类型拥有自己的没有类型参数，因为所有这三种语言包含嵌套类型的类型参数列表中封闭类型的类型参数，也是如此。 请考虑以下类：  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 嵌套类的类型参数列表`Inner`具有两个类型参数，`T`和`U`，其中第一个是其封闭类的类型参数。 同样，类型参数列表的嵌套类`Innermost1`具有三个类型参数， `T`， `U`，和`V`，与`T`和`U`即将其封闭类中。 嵌套的类`Innermost2`具有两个类型参数，`T`和`U`，它们都来自其封闭类。  
  
 如果封闭类型的参数列表有多个类型参数中的嵌套类型的类型参数列表包含在顺序中的所有类型参数。  
  
 若要构造嵌套类型的泛型类型定义中的泛型类型，请调用<xref:System.Type.MakeGenericType%2A>与数组的方法形成通过串联的所有封闭类型，最外面的泛型类型，从开始和结束的类型自变量数组如果它没有自己的类型参数，请键入自身的嵌套类型的自变量数组。 若要创建的实例`Innermost1`，调用<xref:System.Type.MakeGenericType%2A>具有数组，其中包含三种类型，要分配给 T、 U 和 V 方法。若要创建的实例`Innermost2`，调用<xref:System.Type.MakeGenericType%2A>方法替换数组，其中包含两种类型，要分配给 T 和 u。  
  
 语言传播封闭类型以这种方式，因此你可以使用的类型参数的封闭类型定义的嵌套类型的字段的类型参数。 否则，类型参数不是在范围内的嵌套类型的正文中。 可以不传播发出动态程序集中的代码或通过使用封闭类型的类型参数的情况下定义嵌套的类型[Ilasm.exe （IL 汇编程序）](~/docs/framework/tools/ilasm-exe-il-assembler.md)。 MSIL 汇编程序，请考虑下面的代码：  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 在此示例中，它不能定义类型的字段`T`或`U`类中`Innermost`，因为这些类型参数不在作用域。 下面的汇编代码定义的行为的方式会在 c + +、 Visual Basic 和 C# 中定义的嵌套的类：  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 你可以使用[Ildasm.exe （IL 反汇编程序）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查嵌套的类定义中的高级语言并遵循此命名方案。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Type.MakeGenericType%2A>方法来创建从的泛型类型定义的构造的类型<xref:System.Collections.Generic.Dictionary%602>类型。 构造的类型表示<xref:System.Collections.Generic.Dictionary%602>的`Test`具有字符串键的对象。  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前的类型不表示泛型类型定义。 也就是说，<see cref="P:System.Type.IsGenericTypeDefinition" /> 返回 <see langword="false" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="typeArguments" /> 的任意元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeArguments" /> 中元素的个数不等于当前泛型类型定义中类型参数的个数。  
  
 或  
  
 <paramref name="typeArguments" /> 的所有元素都不满足为当前泛型类型的对应类型参数指定的约束。  
  
 或  
  
 <paramref name="typeArguments" />包含元素，它是一个指针类型 (<see cref="P:System.Type.IsPointer" />返回<see langword="true" />），by-ref 类型 (<see cref="P:System.Type.IsByRef" />返回<see langword="true" />)，或 <see cref="T:System.Void" />。</exception>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。 派生类必须提供一个实现。</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示指向当前类型的指针的 <see cref="T:System.Type" /> 对象。</summary>
        <returns>表示指向当前类型的指针的 <see cref="T:System.Type" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakePointerType%2A>方法使您能够生成参数列表的指针类型。  
  
 如果使用的语法的 Microsoft 中间语言 (MSIL)，当前<xref:System.Type>对象所表示<xref:System.Int32>，此方法返回<xref:System.Type>对象，表示`Int32*`。  
  
   
  
## Examples  
 下面的代码示例创建数组， `ref` (`ByRef`在 Visual Basic 中)，以及指针类型的`Test`类。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <exception cref="T:System.TypeLoadException">当前的类型是 <see cref="T:System.TypedReference" />。  
  
 或  
  
 当前的类型是 <see langword="ByRef" /> 类型。 也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个指示此成员是类型还是嵌套类型的 <see cref="T:System.Reflection.MemberTypes" /> 值。</summary>
        <value>一个 <see cref="T:System.Reflection.MemberTypes" /> 值，指示此成员是类型还是嵌套类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性将替代<xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>。 因此，当检查一组<xref:System.Reflection.MemberInfo>对象-例如，返回的数组<xref:System.Type.GetMembers%2A>-<xref:System.Reflection.MemberInfo.MemberType%2A>属性返回<xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType>给定的成员时嵌套的类型。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，此属性适用于从其构造的类型的泛型类型定义。 例如，如果当前<xref:System.Type>表示`MyGenericType<int>`(`MyGenericType(Of Integer)`在 Visual Basic 中)，此属性的值由`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法定义中的类型参数，此属性始终返回<xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的代码示例演示`MemberType`字段作为参数传递给`GetMember`方法：  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="T:System.Type" /> 信息中的缺少值。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`Missing`字段通过反射来获取参数的默认值进行调用。 如果`Missing`字段传入输入参数值，并且没有默认值为该参数，<xref:System.ArgumentException>引发。  
  
   
  
## Examples  
 下面的代码示例演示了利用`Missing`字段来调用具有其默认参数的方法。  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 此代码生成以下输出：  
  
 = 10 b = 55.3 c = 12  
  
 a = 10 b = 1.3 c = 1  
  
 a = 10 b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在其中定义当前 <see cref="T:System.Type" /> 的模块 (DLL)。</summary>
        <value>在其中定义当前 <see cref="T:System.Type" /> 的模块。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示构造的泛型类型，此属性返回在其中定义的泛型类型定义的模块。 例如，如果你创建的实例`MyGenericStack<int>`、<xref:System.Type.Module%2A>的构造类型的属性返回的模块，在其中`MyGenericStack<T>`定义。  
  
 同样，如果当前<xref:System.Type>表示泛型参数`T`，此属性返回包含定义的泛型类型的程序集`T`。  
  
   
  
## Examples  
 下面的示例说明如何使用<xref:System.Type.Namespace%2A>和`Module`属性和<xref:System.Type.ToString%2A>方法<xref:System.Type>。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Type" /> 的命名空间。</summary>
        <value>
          <see cref="T:System.Type" /> 的命名空间；如果当前实例没有命名空间或表示泛型参数，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 命名空间是逻辑设计时命名方便起见，主要用于定义应用程序中的作用域和组织中类和其他类型的单个层次结构。 从运行时的角度来看，有无命名空间。  
  
 如果当前<xref:System.Type>表示构造的泛型类型，则此属性返回包含泛型类型定义的命名空间。 同样，如果当前<xref:System.Type>表示泛型参数`T`，此属性返回包含定义泛型类型定义的命名空间`T`。  
  
 如果当前<xref:System.Type>对象表示泛型参数，则此属性返回`null`。  
  
   
  
## Examples  
 下面的示例说明如何使用`Namespace`和<xref:System.Type.Module%2A>属性和<xref:System.Type.ToString%2A>方法<xref:System.Type>。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个对象。</param>
        <param name="right">要比较的第二个对象。</param>
        <summary>指示两个 <see cref="T:System.Type" /> 对象是否相等。</summary>
        <returns>
          如果 <see langword="true" /> 等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个对象。</param>
        <param name="right">要比较的第二个对象。</param>
        <summary>指示两个 <see cref="T:System.Type" /> 对象是否不相等。</summary>
        <returns>
          如果 <see langword="true" /> 不等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于获取该成员的类对象。</summary>
        <value>
          <see langword="Type" /> 对象，通过它获取了此 <see cref="T:System.Type" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关<xref:System.Type>对象，此属性的值始终是相同的值<xref:System.Type.DeclaringType%2A>属性。  
  
   
  
## Examples  
 此示例中显示的嵌套类反射的类型。  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的 <see cref="T:System.Type" /> 的程序集限定名称。</param>
        <param name="throwIfNotFound">
          如果为 <see langword="true" />，则会在找不到该类型时引发 <see cref="T:System.TypeLoadException" />；如果为 <see langword="false" />，则在找不到该类型时返回 <see langword="null" />。 指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。 请参见“异常”部分。</param>
        <param name="ignoreCase">
          如果为 <see langword="true" />，则执行不区分大小写的 <c>typeName</c> 搜索；如果为 <see langword="false" />，则执行区分大小写的 <c>typeName</c> 搜索。</param>
        <summary>获取具有指定名称的 <see cref="T:System.Type" />，指定是否执行区分大小写的搜索，以及在找不到类型时是否引发异常。 该类型只为反射加载，而不为执行加载。</summary>
        <returns>具有指定名称的类型（如果找到的话）；否则为 <see langword="null" />。 如果找不到该类型，则 <paramref name="throwIfNotFound" /> 参数指定是返回 <see langword="null" /> 还是引发异常。 在某些情况下，将引发异常，而不考虑 <paramref name="throwIfNotFound" /> 的值。 请参见“异常”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果包含类型的程序集不是已加载到只反射上下文的使用<xref:System.Type.ReflectionOnlyGetType%2A>方法是等效于第一个为加载程序集仅，反射使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>方法，并将通过调用其加载类型程序集的<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法。 有关程序集限定名称的信息，请参阅<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>属性。 指定的类型名称的其他详细信息，请参阅<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>方法重载。  
  
 如果已为执行加载程序集，而另一个副本加载到只反射上下文。  
  
 `throwIfNotFound`参数指定时会发生什么情况类型未找到，并还会取消取消某些其他异常条件，如异常部分中所述。 一些例外情况引发而不考虑的值`throwIfNotFound`。 例如，如果程序集无效，<xref:System.BadImageFormatException>引发即使`throwIfNotFound`是`false`。  
  
 有关使用仅限反射上下文的详细信息，请参阅[如何： 将程序集加载到 Reflection-Only 上下文](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwIfNotFound" /> 是 <see langword="true" />，且找不到该类型。  
  
 或  
  
 <paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。  
  
 或  
  
 <paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。  
  
 或  
  
 <paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。  
  
 或  
  
 <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 对象数组。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> 不包括程序集名称。  
  
 或  
  
 <paramref name="throwIfNotFound" /> 为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法（例如 "MyType[,*,]"）。  
  
 或  
  
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
 或  
  
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
 或  
  
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了程序集或其依赖项之一，但无法加载它们。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个描述当前类型的布局的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />。</summary>
        <value>获取一个描述当前类型的大致布局特性的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> 不由返回<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法。 相反，使用此属性来获取它。  
  
   
  
## Examples  
 下面的代码示例首先定义一个类、 结构和具有特殊的布局属性 （结构嵌套在类） 的结构。 然后该示例使用<xref:System.Type.StructLayoutAttribute%2A>属性来获取<xref:System.Runtime.InteropServices.StructLayoutAttribute>每个类型，并显示特性的属性。  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">留待将来使用。 必须为 IID_NULL。</param>
        <param name="rgszNames">要映射的名称的传入数组。</param>
        <param name="cNames">要映射的名称的计数。</param>
        <param name="lcid">要在其中解释名称的区域设置上下文。</param>
        <param name="rgDispId">调用方分配的数组，用于接收与名称对应的 ID。</param>
        <summary>将一组名称映射为对应的一组调度标识符。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于访问托管类从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::GetIDsOfNames`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要返回的类型信息。</param>
        <param name="lcid">类型信息的区域设置标识符。</param>
        <param name="ppTInfo">指向请求的类型信息对象的指针。</param>
        <summary>检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于访问托管类从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::GetTypeInfo`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">指向一个位置，该位置接收对象提供的类型信息接口的数量。</param>
        <summary>检索对象提供的类型信息接口的数量（0 或 1）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于访问托管类从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::GetTypeInfoCount`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">标识成员。</param>
        <param name="riid">留待将来使用。 必须为 IID_NULL。</param>
        <param name="lcid">要在其中解释参数的区域设置上下文。</param>
        <param name="wFlags">描述调用的上下文的标志。</param>
        <param name="pDispParams">指向一个结构的指针，该结构包含一个自变量数组、一个命名自变量的 DISPID 自变量数组和数组中元素数的计数。</param>
        <param name="pVarResult">指向要存储结果的位置的指针。</param>
        <param name="pExcepInfo">指向一个包含异常信息的结构的指针。</param>
        <param name="puArgErr">第一个出错自变量的索引。</param>
        <summary>提供对某一对象公开的属性和方法的访问。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于访问托管类从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::Invoke`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前 <see langword="String" /> 的名称的 <see langword="Type" />。</summary>
        <returns>表示当前 <see cref="T:System.String" /> 的名称的 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的完全限定的公共语言运行时命名空间和所有基元类型的名称。 例如，C# 指令`(long)0.Type().ToString()`返回"System.Int64"而不是仅"Int64"。  
  
 如果当前<xref:System.Type>表示泛型类型、 类型和类型自变量限定命名空间和嵌套类型，而不是由程序集。 如果当前<xref:System.Type>表示泛型类型或泛型方法，则此方法的定义中的类型参数返回的类型参数的非限定的名称。  
  
   
  
## Examples  
 下面的示例说明如何使用<xref:System.Type.Namespace%2A>和<xref:System.Type.Module%2A>属性和`ToString`方法<xref:System.Type>。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 下面的示例对返回的字符串进行比较<xref:System.Type.ToString%2A>方法和`Name`， <xref:System.Type.FullName%2A>，和<xref:System.Type.AssemblyQualifiedName%2A>属性。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的句柄。</summary>
        <value>当前 <see cref="T:System.Type" /> 的句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` 封装一个指向内部数据结构，它表示的类型。 此句柄的进程生存期是唯一的。 句柄仅在已获取的应用程序域有效。  
  
   
  
## Examples  
 下面的示例返回相应的类型的句柄，并将该句柄传递给方法获取的类型从的句柄并将其显示。  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework 当前不支持此属性。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该类型的初始值设定项。</summary>
        <value>包含 <see cref="T:System.Type" /> 的类构造函数的名称的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 类初始值设定项，还提供通过<xref:System.Type.FindMembers%2A>方法，或通过重载<xref:System.Type.GetMember%2A>， <xref:System.Type.GetMembers%2A>， <xref:System.Type.GetConstructor%2A>，和<xref:System.Type.GetConstructors%2A>方法采用<xref:System.Reflection.BindingFlags>作为参数。  
  
 如果当前<xref:System.Type>表示类型参数的泛型类型或泛型方法定义中的此属性返回`null`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示表示该类型的公共语言运行时提供的类型。</summary>
        <value>
          <see cref="T:System.Type" /> 的基础系统类型。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>