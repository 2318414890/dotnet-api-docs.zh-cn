<Type Name="Environment" FullName="System.Environment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b8f2716206a0d7c4bbbc8310b3ec10e214e0d3af" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30730081" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供有关当前环境和平台的信息以及操作它们的方法。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Environment>类中检索信息，如命令行自变量，退出代码、 环境变量设置，内容的调用堆栈、 时间由于上一次系统启动和公共语言运行时的版本。  
  
   
  
## Examples  
 下面的示例演示显示有关当前环境的信息的列表。  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该进程的命令行。</summary>
        <value>包含命令行自变量的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性提供访问权限的程序名称和当前进程启动时在命令行上指定的任何参数。  
  
 程序名称可以包含路径信息，但不需要这样做。 使用<xref:System.Environment.GetCommandLineArgs%2A>方法来检索命令行的信息中分析和存储的字符串数组。  
  
 命令行的缓冲区的最大大小未设置为特定数目的字符;它根据计算机运行的 Windows 操作系统而异。  
  
   
  
## Examples  
 下面的示例显示了其自己的命令行。  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">用于到 PATH 环境变量的读访问。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前工作目录的完全限定路径。</summary>
        <value>包含目录路径的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根据定义，此过程即开始在根目录下的本地或网络驱动器，此属性的值是否尾部反斜杠后接的驱动器名称 (例如，"c:\\")。 如果此过程开始时的子目录，则此属性的值是的驱动器和子目录的路径，而无需尾部反斜杠 (例如，"C:\mySubDirectory")。  
  
   
  
## Examples  
 下面的示例演示了如何设置<xref:System.Environment.CurrentDirectory%2A>属性。  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">已尝试设置为空字符串 ("")。</exception>
        <exception cref="T:System.ArgumentNullException">已尝试设置为 <see langword="null." /></exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">已尝试设置一个找不到的本地路径。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有相应的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于写入到文件或目录在集运算中。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径本身在获取操作中的信息。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前托管线程的唯一标识符。</summary>
        <value>一个整数，表示此托管线程的唯一标识符。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">返回到操作系统的退出代码。 使用 0（零）指示处理已成功完成。</param>
        <summary>终止此进程，并将退出代码返回到操作系统。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关`exitCode`参数，使用非零编号，以指示错误。 在你的应用程序，你可以在枚举中定义你自己的错误代码，并返回基于方案的相应的错误代码。 例如，返回值为 1 以指示所需的文件不存在，以及值为 2，以指示该文件位于错误的格式。 有关使用 Windows 操作系统的退出代码的列表，请参阅[系统错误代码](http://msdn.microsoft.com/library/ms681381.aspx)Windows 文档中。  
  
 调用<xref:System.Environment.Exit%2A>方法不同于使用您的编程语言的`return`语句通过以下方式：  
  
-   <xref:System.Environment.Exit%2A> 始终终止应用程序。 使用`return`语句可能会终止应用程序，仅当在使用该应用程序入口点，如在`Main`方法。  
  
-   <xref:System.Environment.Exit%2A> 应用程序将立即终止，即使其他线程正在运行。 如果`return`语句调用的应用程序入口点，这会导致应用程序终止只有在所有前台线程已都终止后。  
  
-   <xref:System.Environment.Exit%2A> 要求调用方有权调用非托管的代码。 `return`语句却没有。  
  
-   如果<xref:System.Environment.Exit%2A>从调用`try`或`catch`阻止，请在任何代码`finally`块不会执行。 如果`return`使用语句中的代码`finally`块会执行。  
  
-   如果<xref:System.Environment.Exit%2A>时，将调用中的代码[受约束的执行区域](~/docs/framework/performance/constrained-execution-regions.md)(CER) 正在运行，CER 将不会完成执行。 如果`return`使用语句后，CER 完成执行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有足够的安全权限来执行此函数。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示调用非托管的代码的能力。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置进程的退出代码。</summary>
        <value>包含退出代码的 32 位有符号整数。 默认值为 0（零），这指示已成功完成处理。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Main`方法返回`void`，你可以使用此属性设置将返回到调用的环境的退出代码。 如果`Main`不返回`void`，将忽略此属性。 此属性的初始值为零。  
  
> [!WARNING]
>  <xref:System.Environment.ExitCode%2A>属性是一个带符号的 32 位整数。 若要防止该属性返回负的退出代码，不应使用的值大于或等于 0x80000000。  
  
 使用非零数字以指示错误。 在你的应用程序，你可以在枚举中定义你自己的错误代码，并返回基于方案的相应的错误代码。 例如，返回值为 1 以指示所需的文件不存在和值为 2，以指示该文件位于错误的格式。 有关使用 Windows 操作系统的退出代码的列表，请参阅[系统错误代码](http://msdn.microsoft.com/library/ms681381\(v=vs.85\))Windows 文档中。  
  
   
  
## Examples  
 下面是名为 Double.exe 两倍，作为命令行自变量传递给它的整数值的简单应用程序。 值将分配到的错误代码<xref:System.Environment.ExitCode%2A>属性以指示错误条件。 请注意，您必须添加对要成功编译此示例的 System.Numerics.dll 程序集的引用。  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 然后可以从批处理文件，如下所示，使其错误代码可访问通过调用该示例`ERRORLEVEL`命令。  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 下图显示产生通过调用批处理文件的一些示例输出。  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 请注意该代码，Double.exe 为与以下示例中，函数相同，只不过前者定义名为的入口点`Main`，其没有返回值，而此示例定义了名为的入口点`Main`返回一个整数。  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">包含零个或多个环境变量名的字符串。 每个环境变量都用百分号 (%) 引起来。</param>
        <summary>将嵌入到指定字符串中的每个环境变量的名称替换为该变量的值的等效字符串，然后返回结果字符串。</summary>
        <returns>一个字符串，其中的每个环境变量均被替换为该变量的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 COM 互操作用于从操作系统中检索环境变量。 生成一个几个可能的异常; 如果由于 COM 错误，无法检索环境变量，用于说明失败的原因的 HRESULT也就是说，异常取决于相应的 HRESULT。 有关如何处理 HRESULT 的详细信息，请参阅备注部分的<xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType>方法。  
  
 环境变量设置才会被替换。 例如，假设`name`是"MyENV = %myenv%"。 如果环境变量，MyENV，设置为 42，则此方法将返回"MyENV = 42"。 如果未设置 MyENV，不会发生更改;此方法返回"MyENV = %myenv%"。  
  
 返回值的大小被限制为 32k。  
  
   
  
## Examples  
 下面的示例演示如何获取系统驱动器和系统根变量。  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">它能够访问中的环境变量<paramref name="name" />。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 Windows 的应用程序事件日志写入消息后立即终止进程，然后在发往 Microsoft 的错误报告中加入该消息和可选的异常信息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">一条解释进程终止原因的消息；如果未提供解释，则为 <see langword="null" />。</param>
        <summary>向 Windows 的应用程序事件日志写入消息后立即终止进程，然后在发往 Microsoft 的错误报告中加入该消息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法终止进程，而无需运行任何活动`try` / `finally`块或终结器。  
  
 <xref:System.Environment.FailFast%2A>方法写入`message`字符串保存到 Windows 应用程序事件日志中，创建你的应用程序的转储，然后终止当前进程。 `message`字符串还包含在向 Microsoft 报告的错误。  
  
 使用<xref:System.Environment.FailFast%2A>方法而不是<xref:System.Environment.Exit%2A>方法终止你的应用程序，如果你的应用程序的状态已损坏并且无法修复，并执行应用程序的`try` / `finally`块和终结器将损坏程序资源。  
  
 通过使用 Windows 错误报告情况下，信息报告给 Microsoft。 有关详细信息，请参阅[Windows 错误报告： 入门](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx)。  
  
   
  
## Examples  
 下面的示例日志条目写入 Windows 应用程序事件日志，并终止当前进程。  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">一条解释进程终止原因的消息；如果未提供解释，则为 <see langword="null" />。</param>
        <param name="exception">一个异常，表示导致终止的错误。 通常这是 <see langword="catch" /> 块中的异常。</param>
        <summary>向 Windows 的应用程序事件日志写入消息后立即终止进程，然后在发往 Microsoft 的错误报告中加入该消息和异常信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法会终止进程，而无需运行任何活动`try` / `finally`块或终结器。  
  
 <xref:System.Environment.FailFast%2A>方法写入`message`字符串保存到 Windows 应用程序事件日志中，创建你的应用程序的转储，然后终止当前进程。  
  
 通过使用 Windows 错误报告情况下，信息报告给 Microsoft。 有关详细信息，请参阅[Windows 错误报告： 入门](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx)。 向 Microsoft 报告的错误包括`message`和`exception`提供用于对分类错误的详细信息的信息。 尽管`exception`不是处理，因为该进程将终止，仍获取引发异常的上下文信息。  
  
 如果`exception`是`null`，或者如果`exception`是不会引发，此方法的操作与相同<xref:System.Environment.FailFast%28System.String%29>方法重载。  
  
 使用<xref:System.Environment.FailFast%2A>方法而不是<xref:System.Environment.Exit%2A>方法终止你的应用程序，如果你的应用程序的状态已损坏并且无法修复，并执行应用程序的`try` / `finally`块和终结器将损坏程序资源。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回包含当前进程的命令行自变量的字符串数组。</summary>
        <returns>字符串数组，其中的每个元素都包含一个命令行自变量。 第一个元素是可执行文件名，后面的零个或多个元素包含其余的命令行自变量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组中的第一个元素包含执行程序的文件的名称。 如果文件名称不可用，则第一个元素等同于<xref:System.String.Empty?displayProperty=nameWithType>。 剩余的元素包含在命令行中输入任何其他令牌。  
  
 程序文件名称可以但不是需要，包含路径信息。  
  
 命令行参数由空格分隔。 可以使用两个双引号 （"） 包含在参数中的空格。 单引号 （'），但是，不提供此功能。  
  
 如果两个或偶数个反斜杠后跟双引号，每个继续反斜杠对将被替换为一个反斜杠，并且双引号被删除。 如果双引号遵循奇数数目的反斜杠，包括仅仅是一个，每个前面对将被替换为一个反斜杠，并且会删除其余的反斜杠;但是，在这种情况下双引号不删除。  
  
 下表演示了如何命令行自变量可以进行分隔，并假定`MyApp`作为当前正在执行的应用程序。  
  
|在命令行输入|生成命令行参数|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 若要获取作为单个字符串的命令行，使用<xref:System.Environment.CommandLine%2A>属性。  
  
   
  
## Examples  
 下面的示例显示了应用程序的命令行自变量。  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">系统不支持命令行参数。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">用于到 PATH 环境变量的读访问。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检索环境变量的值。</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">环境变量名。</param>
        <summary>从当前进程检索环境变量的值。</summary>
        <returns>
          <paramref name="variable" /> 指定的环境变量的值；或者如果找不到环境变量，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.GetEnvironmentVariable%28System.String%29>方法从当前进程的环境块检索环境变量。 它等效于调用<xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29>方法替换`target`值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>。 当前进程的环境块包括以下环境变量：  
  
-   所有每台计算机在创建的过程，以及它们的值时定义的环境变量。  
  
-   该过程被创建时定义的所有用户每个环境变量，以及它们的值。  
  
-   添加到的处理块中，当进程运行时通过调用任何变量<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29>方法或<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法替换`target`值<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>。  
  
 如果进程启动后创建环境变量，你可以使用此方法来检索已通过调用创建的这些变量<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29>方法或<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法替换`target`的值。<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>。  
  
 若要检索所有环境变量，以及它们的值，调用<xref:System.Environment.GetEnvironmentVariables%2A>方法。  
  
 环境变量名不区分大小写。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Environment.GetEnvironmentVariable%2A>方法来检索`windir`环境变量，其中包含 Windows 目录的路径。  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 以下示例尝试检索名为的环境变量的值`Test1`从进程环境块。 如果不存在该变量，该示例将创建其并检索其值。 此示例显示变量的值。 如果该示例创建变量，它还会调用<xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29>方法的每个成员<xref:System.EnvironmentVariableTarget>枚举，以建立只能从当前进程环境块中，可以检索该变量。 最后，如果该示例创建变量，将其删除。  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有执行此操作所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">它能够读取的值<paramref name="variable" />。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">环境变量名。</param>
        <param name="target">
          <see cref="T:System.EnvironmentVariableTarget" /> 值之一。</param>
        <summary>从当前进程或者从当前用户或本地计算机的 Windows 操作系统注册表项检索环境变量的值。</summary>
        <returns>
          <paramref name="variable" /> 和 <paramref name="target" /> 参数指定的环境变量的值；或者如果找不到环境变量，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `target`参数指定是否从当前进程或者从当前用户或本地计算机的 Windows 操作系统注册表项检索环境变量。 每用户扩展和每台计算机的所有环境变量会自动都复制到当前进程的环境块。 但是，环境变量添加到当前进程的环境块仅保持不变仅过程的持续时间。  
  
 若要检索所有环境变量，以及它们的值，调用<xref:System.Environment.GetEnvironmentVariables%2A>方法。  
  
 环境变量名不区分大小写。  
  
   
  
## Examples  
 下面的示例创建的过程、 用户和计算机的目标的环境变量，检查是否操作系统注册表包含用户和计算机环境变量，则会删除的环境变量。  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> 不是有效的 <see cref="T:System.EnvironmentVariableTarget" /> 值。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有执行此操作所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">它能够读取的值<paramref name="variable" />如果<paramref name="target" />是<see cref="F:System.EnvironmentVariableTarget.Process" />(关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />)，  
  
 或  
  
 对环境变量的完全访问权限如果<paramref name="target" />是<see cref="F:System.EnvironmentVariableTarget.User" />或<see cref="F:System.EnvironmentVariableTarget.Machine" />(关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />)。</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检索所有环境变量名及其值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前进程检索所有环境变量名及其值。</summary>
        <returns>包含所有环境变量名及其值的字典；如果找不到任何环境变量，则返回空字典。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名称和环境变量的值存储为在返回的键 / 值对<xref:System.Collections.IDictionary>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Environment.GetEnvironmentVariables%2A>方法。  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有执行此操作所需的权限。</exception>
        <exception cref="T:System.OutOfMemoryException">缓冲区内存不足。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">它能够读取的名称和环境变量的值。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.EnvironmentVariableTarget" /> 值之一。</param>
        <summary>从当前进程或者从当前用户或本地计算机的 Windows 操作系统注册表项检索所有环境变量名及其值。</summary>
        <returns>包含 <paramref name="target" /> 参数所指定的源中所有环境变量名及其值的字典；否则，如果找不到任何环境变量，则返回空字典。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `target`参数指定的源是当前进程、 当前用户，注册表项或本地计算机的注册表项。  
  
 名称和环境变量的值存储在返回的键/值对为<xref:System.Collections.IDictionary>对象。  
  
   
  
## Examples  
 下面的示例创建的过程、 用户和计算机的目标的环境变量，检查是否操作系统注册表包含用户和计算机环境变量，则会删除的环境变量。  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有为 <paramref name="target" /> 的指定值执行此操作所需具备的权限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> 包含非法值。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">它能够读取的名称和环境变量的值，如果<paramref name="target" />是<see cref="F:System.EnvironmentVariableTarget.Process" />(关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />)，  
  
 或  
  
 对环境变量的完全访问权限如果<paramref name="target" />是<see cref="F:System.EnvironmentVariableTarget.User" />或<see cref="F:System.EnvironmentVariableTarget.Machine" />(关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />)。</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取由指定枚举标识的系统特殊文件夹的路径。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
      </Parameters>
      <Docs>
        <param name="folder">标识系统特殊文件夹的枚举常数。</param>
        <summary>获取由指定枚举标识的系统特殊文件夹的路径。</summary>
        <returns>如果指定的系统特殊文件夹实际存在于您的计算机上，则为到该文件夹的路径；否则为空字符串 ("")。  
  
 如果系统未创建文件夹、已删除现有文件夹，或者文件夹是不对应物理路径的虚拟目录（例如"我的电脑"），则该文件夹不会实际存在。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法检索系统特殊文件夹，例如 Program Files、 程序、 系统或启动时，可用来访问公共信息的路径。 特殊文件夹时设置的默认系统，或显式由用户安装的 Windows 版本。  
  
 `folder`参数指定要检索的特殊文件夹，并且必须位于中的值之一<xref:System.Environment.SpecialFolder>枚举; 任何其他值将引发异常。  
  
 有关特殊文件夹的详细信息，请参阅[CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664)值主题。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Environment.GetFolderPath%2A>方法以返回并显示与关联的路径`folder`参数。  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> 不是 <see cref="T:System.Environment.SpecialFolder" /> 的成员。</exception>
        <exception cref="T:System.PlatformNotSupportedException">不支持当前平台。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径本身中的信息。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" />
      </Parameters>
      <Docs>
        <param name="folder">标识系统特殊文件夹的枚举常数。</param>
        <param name="option">指定用于访问特殊文件夹的选项。</param>
        <summary>获取由指定枚举标识的系统特殊文件夹的路径，并使用用于访问特殊文件夹的指定选项。</summary>
        <returns>如果指定的系统特殊文件夹实际存在于您的计算机上，则为到该文件夹的路径；否则为空字符串 ("")。  
  
 如果系统未创建文件夹、已删除现有文件夹，或者文件夹是不对应物理路径的虚拟目录（例如"我的电脑"），则该文件夹不会实际存在。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法检索系统特殊文件夹，例如 Program Files、 程序、 系统或启动时，可用来访问公共信息的路径。 特殊文件夹时设置的默认系统，或显式由用户安装的 Windows 版本。  
  
 `folder`参数指定要检索的特殊文件夹，并且必须位于中的值之一<xref:System.Environment.SpecialFolder>枚举; 任何其他值将引发异常。  
  
 有关特殊文件夹的详细信息，请参阅[CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664)值主题。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> 不是 <see cref="T:System.Environment.SpecialFolder" /> 的成员。</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.PlatformNotSupportedException" />
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径本身中的信息。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回包含当前计算机中的逻辑驱动器名称的字符串数组。</summary>
        <returns>字符串数组，其中的每个元素都包含逻辑驱动器名称。 例如，如果计算机的硬盘是第一个逻辑驱动器，则返回的第一个元素是“C:\\”。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何显示当前的计算机使用的逻辑驱动器<xref:System.Environment.GetLogicalDrives%2A>方法。  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">用于对受此权限的资源的完全访问。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前的应用程序域是否正在卸载或者公共语言运行时 (CLR) 是否正在关闭。</summary>
        <value>
          如果当前的应用程序域正在卸载或者 CLR 正在关闭，为 <see langword="true" />；否则，为 <see langword="false." /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 CLR 卸载应用程序域时，它将在该应用程序域中具有终结器方法的所有对象运行终结器。 CLR 关闭时，它将启动终结器线程上的一个终结器方法的所有对象。 <xref:System.Environment.HasShutdownStarted%2A>属性返回`true`仅终结器线程已启动。 当该属性返回`true`，你可以确定是否应用程序域是否正在卸载或者 CLR 自行正在通过调用关闭<xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType>方法。 此方法返回`true`如果称为终结器，因为应用程序域正在卸载或`false`如果 CLR 正在关闭。  
  
 <xref:System.Environment.HasShutdownStarted%2A>属性返回`false`如果尚未启动终结器线程。  
  
 通过使用此属性，可以确定是否在终止代码中的静态变量的访问。 如果应用程序域或者 CLR 正在关闭，不能可靠地访问具有完成方法并由静态字段引用的任何对象。 这是因为这些对象可能已终止。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>确定当前操作系统是否为 64 位操作系统。</summary>
        <value>
          如果操作系统为 64 位操作系统，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>确定当前进程是否为 64 位进程。</summary>
        <value>
          如果进程为 64 位进程，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此本地计算机的 NetBIOS 名称。</summary>
        <value>包含此计算机的名称的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从注册表中读取名称时，将在系统启动时建立此计算机的名称。 如果此计算机是群集中的节点，则返回节点的名称。  
  
   
  
## Examples  
 下面的示例显示运行的代码示例的计算机的名称。 （计算机名称中省略出于安全原因，示例输出。）  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">无法获取此计算机的名称。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">用于到 COMPUTERNAME 环境变量的读访问。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为此环境定义的换行字符串。</summary>
        <value>对于非 Unix 平台为包含“\r\n”的字符串，对于 Unix 平台则为包含“\n”的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性值<xref:System.Environment.NewLine%2A>是专门为的当前平台和.NET Framework 实现自定义的常量。 有关中的属性值的转义字符的详细信息，请参阅[字符转义](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)。  
  
 提供的功能<xref:System.Environment.NewLine%2A>通常是条款换行、 换行符、 换行符、 回车、 CRLF、 和行尾的含义。  
  
 <xref:System.Environment.NewLine%2A> 可以与特定于语言的换行符支持，例如的转义字符 '\r' 和 Microsoft C# 和 C/c + + 中的 \n 结合使用或`vbCrLf`在 Microsoft Visual Basic。  
  
 <xref:System.Environment.NewLine%2A> 自动追加到文本处理<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>和<xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例显示三行由换行符分隔。  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含当前平台标识符和版本号的 <see cref="T:System.OperatingSystem" /> 对象。</summary>
        <value>一个包含平台标识符和版本号的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  从 Windows 8<xref:System.Environment.OSVersion%2A>属性返回的相同主版本号和次版本号所有 Windows 平台。 因此，我们不建议你检索此属性来确定操作系统版本的值。  
  
 通常情况下，<xref:System.Environment.OSVersion%2A>属性用于确保在其中引入特定功能的操作系统的一些基础版本上运行应用。 在这种情况下，应进行测试，以返回当前的操作系统版本是否执行版本检查<xref:System.Environment.OSVersion%2A>属性是相同，或大于基本操作系统版本。 有关详细信息，请参阅<xref:System.Version>类主题。  
  
 通过 Windows 8<xref:System.Environment.OSVersion%2A>属性返回报告的 Windows 版本[GetVersionEx](http://msdn.microsoft.com/library/windows/desktop/ms724451\(v=vs.85\).aspx)函数。 Windows 桌面操作系统版本和其相应的版本号的列表，请参阅[操作系统版本](https://msdn.microsoft.com/library/windows/desktop/ms724832.aspx)Windows 开发人员中心中。  
  
> [!NOTE]
>  <xref:System.Environment.OSVersion%2A>属性报告两个相同的版本号 (6.2.0.0)[!INCLUDE[win8](~/includes/win8-md.md)]和[!INCLUDE[win81](~/includes/win81-md.md)]和相同主版本号和次版本号适用于 Windows 10。  
  
 在某些情况下，<xref:System.Environment.OSVersion%2A>属性可能不会返回与匹配的 Windows 程序兼容性模式功能为指定的版本的操作系统版本。  
  
   
  
## Examples  
 下面的示例显示平台标识符和版本号的计算机的运行的代码示例。  
  
 [!code-cpp[environment.osversion#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.OSVersion/CPP/osversion.cpp#1)]
 [!code-csharp[environment.osversion#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.OSVersion/CS/osversion.cs#1)]
 [!code-vb[environment.osversion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.OSVersion/VB/osversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此属性不能获得系统版本。  
  
 或  
  
 获得的平台标识符不是 <see cref="T:System.PlatformID" /> 的成员</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前计算机上的处理器数。</summary>
        <value>指定当前计算机上处理器个数的 32 位有符号整数。 没有默认值。 如果当前计算机包含多个处理器组，则此属性返回可用的逻辑处理器数以供公共语言运行时 (CLR) 使用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理器组和逻辑处理器的详细信息，请参阅[处理器组](http://msdn.microsoft.com/library/windows/desktop/dd405503.aspx)。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Environment.ProcessorCount%2A>属性。  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建、修改或删除环境变量。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">环境变量名。</param>
        <param name="value">要分配给 <c>variable</c> 的值。</param>
        <summary>创建、修改或删除当前进程中存储的环境变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法等效于调用<xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>值为重载<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>为`target`自变量。  
  
 如果`value`自变量不为空 （请参见删除空值的定义本部分中后面的环境变量的讨论） 和命名的环境变量`variable`参数不存在，环境创建变量并将其分配的内容`value`。 如果文件确实存在，则会修改其值。 在当前进程的环境块中定义环境变量，因为它后未保留该过程已结束。  
  
 如果`variable`包含非初始十六进制零字符的零个字符将被视为环境变量名称，并将忽略所有后续字符之前的字符。  
  
 如果`value`包含非初始十六进制零字符的零个字符分配给环境变量并将忽略所有后续字符之前的字符。  
  
 如果`value`为空且命名的环境变量`variable`存在，则删除该环境变量。 如果`variable`不存在，不会发生错误即使无法执行该操作。 `value` 被视为空任何以下条件下：  
  
-   它是`null`。  
  
-   它是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
-   它包含单个字符，其值不在 U + 0000。  
  
   
  
## Examples  
 下面的示例测试是否名为的环境变量`APPDOMAIN`存在于当前进程中。 如果不存在，则它将创建它并设置其值为"True"。 如果值`APPDOMAIN`环境变量为"True"时，它调用`Message.Display`新的应用程序域中的方法。 否则，它会执行`Message.Display`当前的应用程序域中的方法。  
  
 [!code-csharp[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/cs/setenvironmentvariable1.cs#1)]
 [!code-vb[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/vb/setenvironmentvariable1.vb#1)]  
  
 如果首次运行该示例，该消息"正在执行域 Domain2 中的"显示到控制台。 如果使用命令，可以从命令行设置环境变量：  
  
 `Set AppDomain=False`  
  
 该示例显示消息"在域中执行*exeName*.exe"，其中*exeName*是可执行文件的名称。  
  
 以下示例尝试检索名为的环境变量的值`Test1`从进程环境块。 如果不存在该变量，该示例将创建该变量，并检索其值。 此示例显示变量的值。 如果该示例创建变量，它还会调用<xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29>方法的每个成员<xref:System.EnvironmentVariableTarget>枚举，以建立只能从当前进程环境块中，可以检索该变量。 最后，如果该示例创建变量，将其删除。  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> 包含零长度字符串、起始十六进制零字符 (0x00) 或等号（“=”）。  
  
 或  
  
 <paramref name="variable" /> 或 <paramref name="value" /> 的长度大于等于 32,767 个字符。  
  
 或  
  
 执行此操作期间出错。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有执行此操作所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">对环境变量的完全访问权限。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">环境变量名。</param>
        <param name="value">要分配给 <c>variable</c> 的值。</param>
        <param name="target">一个用于指定环境变量的位置的枚举值。</param>
        <summary>创建、修改或删除当前进程中或者为当前用户或本地计算机保留的 Windows 操作系统注册表项中存储的环境变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29>方法使你可以定义可供所有的计算机运行的进程的环境变量 (<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>值) 到所有进程都运行报表的用户 (<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>值)，或到当前进程 (<xref:System.EnvironmentVariableTarget.Process>值)。 每台计算机和每个用户环境变量将复制到当前进程的环境块。 但是，仅在进程结束前，将保留对当前进程环境块是唯一的环境变量。  
  
 如果`value`自变量不为空 （请参见删除空值的定义本部分中后面的环境变量的讨论） 和命名的环境变量`variable`参数不存在，环境创建变量并将其分配的内容`value`。  如果文件确实存在，则会修改其值。  
  
 如果`variable`包含非初始十六进制零字符的零个字符将被视为环境变量名称，并将忽略所有后续字符之前的字符。  
  
 如果`value`包含非初始十六进制零字符的零个字符分配给环境变量并将忽略所有后续字符之前的字符。  
  
 如果`value`为空且命名的环境变量`variable`存在，则删除该环境变量。 `value` 被视为空任何以下条件下：  
  
-   它是`null`。  
  
-   它是<xref:System.String.Empty?displayProperty=nameWithType>。  
  
-   它包含单个字符，其值不在 U + 0000。  
  
 如果`variable`不存在，不会发生错误尽管无法执行该操作。 请注意`target`是<xref:System.EnvironmentVariableTarget.Machine>，这是因为你可以不小心删除影响整个本地计算机，而不仅仅是当前进程或用户的环境变量。  
  
 如果`target`是<xref:System.EnvironmentVariableTarget.User>，存储在本地计算机的注册表 HKEY_CURRENT_USER\Environment 项中的环境变量。 它也会复制到当前用户身份运行的文件资源管理器实例。 然后，用户将从文件资源管理器启动任何新进程继承该环境变量。  
  
 同样，如果`target`是<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>，存储在本地计算机的注册表 HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment 项中的环境变量。 它也会复制到文件资源管理器的所有实例。 然后，从文件资源管理器启动任何新进程继承该环境变量。  
  
 如果`target`是<xref:System.EnvironmentVariableTarget.User>或<xref:System.EnvironmentVariableTarget.Machine>，其他应用程序会通知你的设置操作由 Windows`WM_SETTINGCHANGE`消息。  
  
 如果`target`是<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>或<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>，我们建议的长度`value`小于 2048年个字符。  
  
   
  
## Examples  
 下面的示例创建的环境变量<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>， <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>，和<xref:System.EnvironmentVariableTarget.Machine>面向，检查是否操作系统注册表包含的用户和计算机环境变量，则删除环境变量。  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> 包含零长度字符串、起始十六进制零字符 (0x00) 或等号（“=”）。  
  
 或  
  
 <paramref name="variable" /> 的长度大于等于 32,767 个字符。  
  
 或  
  
 <paramref name="target" /> 不是 <see cref="T:System.EnvironmentVariableTarget" /> 枚举的成员。  
  
 或  
  
 <paramref name="target" /> 为 <see cref="F:System.EnvironmentVariableTarget.Machine" /> 或 <see cref="F:System.EnvironmentVariableTarget.User" />，并且 <paramref name="variable" /> 的长度大于等于 255。  
  
 或  
  
 <paramref name="target" /> 为 <see cref="F:System.EnvironmentVariableTarget.Process" />，并且 <paramref name="value" /> 的长度大于等于 32,767 个字符。  
  
 或  
  
 执行此操作期间出错。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有执行此操作所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">对环境变量的完全访问权限。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前的堆栈跟踪信息。</summary>
        <value>包含堆栈跟踪信息的字符串。 此值可为 <see cref="F:System.String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.StackTrace%2A>属性列出顺序的逆序方法调用、，即首先，描述最新的方法调用和每个方法调用在堆栈上列出的堆栈跟踪信息的一行。 但是，<xref:System.Environment.StackTrace%2A>属性可能不报告任意多个方法调用预期由于优化期间发生代码转换。  
  
> [!NOTE]
>  由类的堆栈跟踪信息的层次结构视图，使用<xref:System.Diagnostics.StackTrace>类。  
  
 <xref:System.Environment.StackTrace%2A>属性设置为每个方法调用的堆栈跟踪信息的格式，如下所示：  
  
 "在`FullClassName`。`MethodName`(`MethodParams`) 中`FileName`： 行`LineNumber`"  
  
 "At"文本前面由三个空格，并且如果调试符号将不可用，则忽略"in"以开始将整个子字符串。 占位符， `FullClassName`， `MethodName`， `MethodParams`， `FileName`，和`LineNumber`、 将替换为实际值和定义，如下所示：  
  
 FullClassName  
 类，包括命名空间的完整名称。  
  
 `MethodName`  
 方法的名称。  
  
 `MethodParams`  
 参数类型/名称对的列表。 用逗号分隔每个对 （"，"）。 如果省略此信息`MethodName`不带任何参数。  
  
 `FileName`  
 源的名称文件，其中`MethodName`声明方法。 如果调试符号不可用，则省略此信息。  
  
 `LineNumber`  
 中的行数`FileName`，其中包含从源代码`MethodName`指令调用堆栈上。 如果调试符号不可用，则省略此信息。  
  
 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>字符串终止的堆栈跟踪每个行。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Environment.StackTrace%2A>属性。  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">用于对权限所保护的资源的完全访问。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取系统目录的完全限定路径。</summary>
        <value>包含目录路径的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的一个示例是值的"C:\WinNT\System32"的字符串。  
  
   
  
## Examples  
 下面的示例显示运行的代码示例的计算机的系统目录。 （系统目录中省略出于安全原因，示例输出。）  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径本身中的信息。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取操作系统的内存页的字节数。</summary>
        <value>系统内存页中的字节数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此信息很有用，在确定是否使用<xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType>选项的内存映射文件时。  
  
 在 Windows 中，此值是`dwPageSize`中的成员`SYSTEM_INFO`结构。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">用于访问系统和用户环境变量。 相关联的异常：  
  
 <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取系统启动后经过的毫秒数。</summary>
        <value>一个 32 位带符号整数，它包含自上次启动计算机以来所经过的时间（以毫秒为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的值派生自系统计时器，存储作为 32 位有符号整数。 请注意，因为它从系统计时器的分辨率派生<xref:System.Environment.TickCount%2A>属性仅限于系统计时器，这通常是在 10 到 16 毫秒的范围内的分辨率。  
  
> [!IMPORTANT]
>  因为的值<xref:System.Environment.TickCount%2A>属性值是一个 32 位带符号的整数，如果系统连续运行，<xref:System.Environment.TickCount%2A>从零到将递增<xref:System.Int32.MaxValue?displayProperty=nameWithType>约 24.9 天内，然后跳转到<xref:System.Int32.MinValue?displayProperty=nameWithType>，这是负号，然后递增回在下一步 24.9 天内的零。 可以通过调用 Windows 来解决此问题[GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx)函数，将重置为零后大约 49.7 天，或通过调用[GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx)函数。  
  
 <xref:System.Environment.TickCount%2A> 不同于<xref:System.DateTime.Ticks%2A?displayProperty=nameWithType>属性，它是 0001 年 1 月 1 日，上午 12:00 以来所经历的 100 毫微秒隔数。  
  
 使用<xref:System.DateTime.Now%2A?displayProperty=nameWithType>属性来获取的当前日期和时间在此计算机上的。  
  
   
  
## Examples  
 下面的示例演示如何检索返回值的正范围<xref:System.Environment.TickCount%2A>属性。 <xref:System.Environment.TickCount%2A>属性周期之间<xref:System.Int32.MinValue?displayProperty=nameWithType>，这是负数，和<xref:System.Int32.MaxValue?displayProperty=nameWithType>49.8 天一次。 此代码示例中移除符号位来产生大量零之间循环的非负和<xref:System.Int32.MaxValue>24.9 天。  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与当前用户关联的网络域名。</summary>
        <value>与当前用户关联的网络域名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用户的域帐户凭据的格式设置为用户的域名称\\字符，并且用户名称。 使用<xref:System.Environment.UserDomainName%2A>属性来获取用户的域名，无需用户名称和<xref:System.Environment.UserName%2A>属性来获取无需域名的用户名。  例如，如果用户的域名和用户名都 CORPORATENETWORK\john，<xref:System.Environment.UserDomainName%2A>属性返回"企业网络"。  
  
 <xref:System.Environment.UserDomainName%2A>属性第一次尝试获取当前用户的 Windows 帐户名称的域名称组件。 如果该尝试失败，此属性尝试获取由提供的用户名相关联的域名<xref:System.Environment.UserName%2A>属性。 如果该尝试失败，因为主机计算机未加入域，则返回的主机计算机名。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">操作系统不支持检索网络域名。</exception>
        <exception cref="T:System.InvalidOperationException">无法检索的网络域名。</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">用于到 USERDOMAIN 环境变量的读访问。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，用以指示当前进程是否在用户交互模式中运行。</summary>
        <value>
          如果当前进程在用户交互模式中运行，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.UserInteractive%2A>属性报表`false`Windows 进程或没有用户界面的情况下运行的 IIS 这样的服务。 如果此属性为`false`、 不显示模式对话框或消息框，因为没有图形用户界面与进行交互的用户。  
  
   
  
## Examples  
 下面的示例显示当前进程是否正运行在用户交互模式中。  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前已登录到 Windows 操作系统的人员的用户名。</summary>
        <value>已登录到 Windows 的人员的用户名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用<xref:System.Environment.UserName%2A>属性来标识当前线程，对系统和安全性或访问目的的应用程序上的用户。 它还可以用于自定义每个用户特定的应用程序。  
  
 <xref:System.Environment.UserName%2A>属性包装对 Windows 的调用[GetUserName](http://msdn.microsoft.com/library/windows/desktop/ms724432.aspx)函数。 用户的域帐户凭据的格式设置为用户的域名称\\字符，并且用户名称。 使用<xref:System.Environment.UserDomainName%2A>属性来获取用户的域名和<xref:System.Environment.UserName%2A>属性来获取用户名称。  
  
 如果 ASP.NET 应用程序运行在开发环境中，<xref:System.Environment.UserName%2A>属性返回当前用户的名称。 在已发布的 ASP.NET 应用程序中，此属性返回的 （如默认应用程序池） 的应用程序池帐户的名称。  
  
   
  
## Examples  
 下面的示例显示启动当前线程的人员的用户名。  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">用于到用户名环境变量的读访问。 关联的枚举： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Version" /> 对象，该对象描述公共语言运行时的主版本、次版本、内部版本和修订号。</summary>
        <value>用于显示公共语言运行时版本的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于 .NET Framework 版本 4、4.5、4.5.1 和 4.5.2，<xref:System.Environment.Version%2A?displayProperty=nameWithType> 属性返回字符串表现形式具有窗体 `4.0.30319.xxxxx` 的 <xref:System.Version> 对象。 对于.NET Framework 4.6 和更高版本，它具有形式`4.0.30319.42000`。  
  
> [!WARNING]
>  有关[!INCLUDE[net_v45](~/includes/net-v45-md.md)]和更高版本，我们不建议使用<xref:System.Environment.Version%2A>属性要检测的版本的运行时; 相反，你可以通过查询注册表来确定公共语言运行时的版本。 有关详细信息，请参阅[如何： 确定安装哪些.NET Framework 版本是](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md)。  
  
 有关与每个版本的.NET Framework 一起安装的公共语言运行时版本的详细信息，请参阅[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
   
  
## Examples  
 下面的示例显示公共语言运行时的版本。 （版本中省略出于安全原因，示例输出。）  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取映射到进程上下文的物理内存量。</summary>
        <value>一个 64 位带符号整数，包含映射到进程上下文的物理内存字节的数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示运行的代码示例的计算机的工作集的大小。  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">用于对受此权限的资源的完全访问。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>