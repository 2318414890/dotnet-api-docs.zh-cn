<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Exception.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86c3e876a1482a23c73451498e9a529b706c17f38a0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3e876a1482a23c73451498e9a529b706c17f38a0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Exception">
          <source>Represents errors that occur during application execution.</source>
          <target state="translated">表示在应用程序执行过程中发生的错误。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This class is the base class for all exceptions.</source>
          <target state="translated">此类是所有异常的基类。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When an error occurs, either the system or the currently executing application reports it by throwing an exception that contains information about the error.</source>
          <target state="translated">发生错误时，系统或当前正在执行的应用程序报告它通过引发异常，其中包含有关错误的信息。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>After an exception is thrown, it is handled by the application or by the default exception handler.</source>
          <target state="translated">引发异常后，它处理应用程序或通过默认异常处理程序。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In this section:</source>
          <target state="translated">本节内容：</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Errors and exceptions<ept id="p1">](#Errors)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>错误和异常<ept id="p1">](#Errors)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Try/catch blocks<ept id="p1">](#TryCatch)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Try/catch 块<ept id="p1">](#TryCatch)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Exception type features<ept id="p1">](#Features)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>异常类型的功能<ept id="p1">](#Features)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Exception class properties<ept id="p1">](#Properties)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>异常类属性<ept id="p1">](#Properties)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Performance considerations<ept id="p1">](#Performance)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>性能注意事项<ept id="p1">](#Performance)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Re-throwing an exception<ept id="p1">](#Rethrow)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>重新引发异常<ept id="p1">](#Rethrow)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Choosing standard exceptions<ept id="p1">](#Standard)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>选择标准异常<ept id="p1">](#Standard)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">[</bpt>Implementing custom exceptions<ept id="p1">](#Custom)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>实现自定义异常<ept id="p1">](#Custom)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Errors and exceptions</source>
          <target state="translated">错误和异常</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Run-time errors can occur for a variety of reasons.</source>
          <target state="translated">运行时错误可能的原因有多种多样。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>However, not all errors should be handled as exceptions in your code.</source>
          <target state="translated">但是，并非所有错误应在代码中作为异常都处理。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Here are some categories of errors that can occur at run time and the appropriate ways to respond to them.</source>
          <target state="translated">以下是一些可以发生在运行的时和合适的方法，可以对其进行响应的错误的类别。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">**</bpt>Usage errors.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>用法错误。<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A usage error represents an error in program logic that can result in an exception.</source>
          <target state="translated">用法错误表示可能会导致异常的程序逻辑中的错误。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>However, the error should be addressed not through exception handling but by modifying the faulty code.</source>
          <target state="translated">但是，不能通过异常处理，但通过修改故障代码，则应该解决该错误。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, the override of the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method in the following example assumes that the <ph id="ph2">`obj`</ph> argument must always be non-null.</source>
          <target state="translated">例如，重写<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>方法在下面的示例假定<ph id="ph2">`obj`</ph>自变量必须始终为非 null。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> exception that results when <ph id="ph2">`obj`</ph> is <ph id="ph3">`null`</ph> can be eliminated by modifying the source code to explicitly test for null before calling the <ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> override and then re-compiling.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>结果的异常时<ph id="ph2">`obj`</ph>是<ph id="ph3">`null`</ph>可通过修改源代码来显式测试之前调用的 null 消除<ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>重写和重新编译。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following example contains the corrected source code that handles a <ph id="ph1">`null`</ph> argument.</source>
          <target state="translated">下面的示例包含处理的已更正的源代码<ph id="ph1">`null`</ph>自变量。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Instead of using exception handling for usage errors, you can use the <ph id="ph1">&lt;xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType&gt;</ph> method to identify usage errors in debug builds, and the <ph id="ph2">&lt;xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType&gt;</ph> method to identify usage errors in both debug and release builds.</source>
          <target state="translated">除了使用异常处理的用法错误，你可以使用<ph id="ph1">&lt;xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType&gt;</ph>的方法来确定在调试版本中的用法错误和<ph id="ph2">&lt;xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType&gt;</ph>的方法来确定在调试和发布的用法错误生成。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For more information, see <bpt id="p1">[</bpt>Assertions in Managed Code<ept id="p1">](/visualstudio/debugger/assertions-in-managed-code)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>托管代码中的断言<ept id="p1">](/visualstudio/debugger/assertions-in-managed-code)</ept>。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">**</bpt>Program errors.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>程序错误。<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A program error is a run-time error that cannot necessarily be avoided by writing bug-free code.</source>
          <target state="translated">程序错误是一个运行时错误，无法一定避免通过编写无 bug 的代码。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In some cases, a program error may reflect an expected or routine error condition.</source>
          <target state="translated">在某些情况下，程序错误可能反映预期或例程错误条件。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In this case, you may want to avoid using exception handling to deal with the program error and instead retry the operation.</source>
          <target state="translated">在这种情况下，你可能想要避免使用异常处理来处理程序错误并改用重试该操作。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, if the user is expected to input a date in a particular format, you can parse the date string by calling the <ph id="ph1">&lt;xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> value that indicates whether the parse operation succeeded, instead of using the <ph id="ph3">&lt;xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType&gt;</ph> method, which throws a <ph id="ph4">&lt;xref:System.FormatException&gt;</ph> exception if the date string cannot be converted to a <ph id="ph5">&lt;xref:System.DateTime&gt;</ph> value.</source>
          <target state="translated">例如，如果用户需要输入特定的格式的日期，你可以分析日期字符串通过调用<ph id="ph1">&lt;xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType&gt;</ph>方法，它返回<ph id="ph2">&lt;xref:System.Boolean&gt;</ph>值，该值指示是否确保分析操作成功，而不是使用<ph id="ph3">&lt;xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType&gt;</ph>方法，将引发<ph id="ph4">&lt;xref:System.FormatException&gt;</ph>异常如果日期字符串不能转换为<ph id="ph5">&lt;xref:System.DateTime&gt;</ph>值。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Similarly, if a user tries to open a file that does not exist, you can first call the <ph id="ph1">&lt;xref:System.IO.File.Exists%2A?displayProperty=nameWithType&gt;</ph> method to check whether the file exists and, if it does not, prompt the user whether he or she wants to create it.</source>
          <target state="translated">同样，如果用户尝试打开不存在的文件，您可以先调用<ph id="ph1">&lt;xref:System.IO.File.Exists%2A?displayProperty=nameWithType&gt;</ph>方法来检查该文件是否存在且，如果不是，提示用户是否他或她想要创建它。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In other cases, a program error reflects an unexpected error condition that can be handled in your code.</source>
          <target state="translated">在其他情况下，程序错误反映可以在你的代码进行处理的意外的错误条件。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, even if you've checked to ensure that a file exists, it may be deleted before you can open it, or it may be corrupted.</source>
          <target state="translated">例如，即使你已检查，以确保存在的文件，它可能会删除之前你可以打开它，或者可能已损坏。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In that case, trying to open the file by instantiating a <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> object or calling the <ph id="ph2">&lt;xref:System.IO.File.Open%2A&gt;</ph> method may throw a <ph id="ph3">&lt;xref:System.IO.FileNotFoundException&gt;</ph> exception.</source>
          <target state="translated">在这种情况下，尝试打开该文件，方法是实例化<ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph>对象或调用<ph id="ph2">&lt;xref:System.IO.File.Open%2A&gt;</ph>方法可能会引发<ph id="ph3">&lt;xref:System.IO.FileNotFoundException&gt;</ph>异常。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In these cases, you should use exception handling to recover from the error.</source>
          <target state="translated">在这些情况下，应使用异常处理来从错误中恢复。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><bpt id="p1">**</bpt>System failures.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>系统故障。<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A system failure is a run-time error that cannot be handled programmatically in a meaningful way.</source>
          <target state="translated">系统故障是一个运行时错误，不能有意义的方式来以编程方式处理。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, any method can throw an <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception if the common language runtime is unable to allocate additional memory.</source>
          <target state="translated">例如，任何方法可能会引发<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>异常如果公共语言运行时无法分配更多内存。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Ordinarily, system failures are not handled by using exception handling.</source>
          <target state="translated">通常，通过使用异常处理不处理系统故障。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Instead, you may be able to use an event such as <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph> and call the <ph id="ph2">&lt;xref:System.Environment.FailFast%2A?displayProperty=nameWithType&gt;</ph> method to log exception information and notify the user of the failure before the application terminates.</source>
          <target state="translated">相反，你可能能够使用事件，如<ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph>并调用<ph id="ph2">&lt;xref:System.Environment.FailFast%2A?displayProperty=nameWithType&gt;</ph>记录异常信息并通知失败的用户，在应用程序终止之前的方法。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Try/catch blocks</source>
          <target state="translated">Try/catch 块</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The common language runtime provides an exception handling model that is based on the representation of exceptions as objects, and the separation of program code and exception handling code into <ph id="ph1">`try`</ph> blocks and <ph id="ph2">`catch`</ph> blocks.</source>
          <target state="translated">公共语言运行时提供了基于异常对象，作为的表示和分离的程序代码和异常处理代码转换为异常处理模型<ph id="ph1">`try`</ph>块和<ph id="ph2">`catch`</ph>块。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>There can be one or more <ph id="ph1">`catch`</ph> blocks, each designed to handle a particular type of exception, or one block designed to catch a more specific exception than another block.</source>
          <target state="translated">可以有一个或多个<ph id="ph1">`catch`</ph>块，每个设计为处理特定类型的异常，或者一个用来过滤掉更具体的异常比另一个块的块。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If an application handles exceptions that occur during the execution of a block of application code, the code must be placed within a <ph id="ph1">`try`</ph> statement and is called a <ph id="ph2">`try`</ph> block.</source>
          <target state="translated">如果应用程序处理的应用程序代码块的执行期间发生的异常，必须将代码放置在<ph id="ph1">`try`</ph>语句称为<ph id="ph2">`try`</ph>块。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Application code that handles exceptions thrown by a <ph id="ph1">`try`</ph> block is placed within a <ph id="ph2">`catch`</ph> statement and is called a <ph id="ph3">`catch`</ph> block.</source>
          <target state="translated">处理引发的异常的应用程序代码<ph id="ph1">`try`</ph>块放在<ph id="ph2">`catch`</ph>语句称为<ph id="ph3">`catch`</ph>块。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Zero or more <ph id="ph1">`catch`</ph> blocks are associated with a <ph id="ph2">`try`</ph> block, and each <ph id="ph3">`catch`</ph> block includes a type filter that determines the types of exceptions it handles.</source>
          <target state="translated">零个或多<ph id="ph1">`catch`</ph>与之关联块<ph id="ph2">`try`</ph>块，和每个<ph id="ph3">`catch`</ph>块包含确定它处理的异常的类型的类型筛选器。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When an exception occurs in a <ph id="ph1">`try`</ph> block, the system searches the associated <ph id="ph2">`catch`</ph> blocks in the order they appear in application code, until it locates a <ph id="ph3">`catch`</ph> block that handles the exception.</source>
          <target state="translated">中发生异常时<ph id="ph1">`try`</ph>块中，系统搜索关联<ph id="ph2">`catch`</ph>阻止，直到它放在应用程序代码中，它们出现的顺序<ph id="ph3">`catch`</ph>处理异常的块。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A <ph id="ph1">`catch`</ph> block handles an exception of type <ph id="ph2">`T`</ph> if the type filter of the catch block specifies <ph id="ph3">`T`</ph> or any type that <ph id="ph4">`T`</ph> derives from.</source>
          <target state="translated">A<ph id="ph1">`catch`</ph>块处理类型的异常<ph id="ph2">`T`</ph>如果 catch 块的类型筛选器指定<ph id="ph3">`T`</ph>或任何类型<ph id="ph4">`T`</ph>派生自。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The system stops searching after it finds the first <ph id="ph1">`catch`</ph> block that handles the exception.</source>
          <target state="translated">系统将停止搜索后找到第一个<ph id="ph1">`catch`</ph>处理异常的块。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For this reason, in application code, a <ph id="ph1">`catch`</ph> block that handles a type must be specified before a <ph id="ph2">`catch`</ph> block that handles its base types, as demonstrated in the example that follows this section.</source>
          <target state="translated">为此，在应用程序代码中，<ph id="ph1">`catch`</ph>之前，必须指定处理某一类型的块<ph id="ph2">`catch`</ph>处理其基类型，如本节后面的示例中所示的块。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A catch block that handles <ph id="ph1">`System.Exception`</ph> is specified last.</source>
          <target state="translated">处理的 catch 块<ph id="ph1">`System.Exception`</ph>最后指定。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If none of the <ph id="ph1">`catch`</ph> blocks associated with the current <ph id="ph2">`try`</ph> block handle the exception, and the current <ph id="ph3">`try`</ph> block is nested within other <ph id="ph4">`try`</ph> blocks in the current call, the <ph id="ph5">`catch`</ph> blocks associated with the next enclosing <ph id="ph6">`try`</ph> block are searched.</source>
          <target state="translated">如果没有任何<ph id="ph1">`catch`</ph>块与当前关联<ph id="ph2">`try`</ph>块处理该异常，且当前<ph id="ph3">`try`</ph>块嵌套在其他<ph id="ph4">`try`</ph>在当前的调用中，阻止<ph id="ph5">`catch`</ph>块与下一步封闭<ph id="ph6">`try`</ph>搜索块。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If no <ph id="ph1">`catch`</ph> block for the exception is found, the system searches previous nesting levels in the current call.</source>
          <target state="translated">如果没有<ph id="ph1">`catch`</ph>异常块找不到，则系统搜索前面的嵌套级别中当前的调用。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If no <ph id="ph1">`catch`</ph> block for the exception is found in the current call, the exception is passed up the call stack, and the previous stack frame is searched for a <ph id="ph2">`catch`</ph> block that handles the exception.</source>
          <target state="translated">如果没有<ph id="ph1">`catch`</ph>阻止对于当前的调用中找到的异常，异常调用堆栈中向上传递，并将上一个堆栈帧，将会搜索<ph id="ph2">`catch`</ph>处理异常的块。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The search of the call stack continues until the exception is handled or until no more frames exist on the call stack.</source>
          <target state="translated">直到处理该异常或不详细帧调用堆栈上存在，将继续调用堆栈的搜索。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If the top of the call stack is reached without finding a <ph id="ph1">`catch`</ph> block that handles the exception, the default exception handler handles it and the application terminates.</source>
          <target state="translated">如果没有找到达到调用堆栈的顶部<ph id="ph1">`catch`</ph>处理异常，默认异常处理程序块对其进行处理和在应用程序终止。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Exception type features</source>
          <target state="translated">异常类型的功能</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Exception types support the following features:</source>
          <target state="translated">异常类型支持以下功能：</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Human-readable text that describes the error.</source>
          <target state="translated">描述错误的用户可读文本。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When an exception occurs, the runtime makes a text message available to inform the user of the nature of the error and to suggest action to resolve the problem.</source>
          <target state="translated">发生异常时，运行时发出通知的错误性质的用户并提供建议操作提供文本消息，来解决该问题。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This text message is held in the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property of the exception object.</source>
          <target state="translated">此文本消息会保留在<ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph>异常对象的属性。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>During the creation of the exception object, you can pass a text string to the constructor to describe the details of that particular exception.</source>
          <target state="translated">在创建期间的异常对象，可以将文本字符串传递给构造函数来描述该特定异常的详细信息。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If no error message argument is supplied to the constructor, the default error message is used.</source>
          <target state="translated">如果没有错误消息参数提供给构造函数，则使用默认的错误消息。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property.</source>
          <target state="translated">有关更多信息，请参见 <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The state of the call stack when the exception was thrown.</source>
          <target state="translated">调用堆栈时抛出异常的状态。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph> property carries a stack trace that can be used to determine where the error occurs in the code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph>属性包含可以用于确定在代码中出现错误的堆栈跟踪。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The stack trace lists all the called methods and the line numbers in the source file where the calls are made.</source>
          <target state="translated">堆栈跟踪列出所有调用的方法和源文件位置的调用中的行号。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Exception class properties</source>
          <target state="translated">异常类属性</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">&lt;xref:System.Exception&gt;</ph> class includes a number of properties that help identify the code location, the type, the help file, and the reason for the exception: <ph id="ph2">&lt;xref:System.Exception.StackTrace%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Exception.Message%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Exception.HelpLink%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Exception.HResult%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Exception.Source%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Exception.TargetSite%2A&gt;</ph>, and <ph id="ph9">&lt;xref:System.Exception.Data%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception&gt;</ph>类包括多个属性可以帮助识别的代码位置、 类型、 帮助文件和异常的原因： <ph id="ph2">&lt;xref:System.Exception.StackTrace%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Exception.Message%2A&gt;</ph>， <ph id="ph5">&lt;xref:System.Exception.HelpLink%2A&gt;</ph>， <ph id="ph6">&lt;xref:System.Exception.HResult%2A&gt;</ph>， <ph id="ph7">&lt;xref:System.Exception.Source%2A&gt;</ph>，<ph id="ph8">&lt;xref:System.Exception.TargetSite%2A&gt;</ph>，和<ph id="ph9">&lt;xref:System.Exception.Data%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When a causal relationship exists between two or more exceptions, the <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property maintains this information.</source>
          <target state="translated">当两个或多个异常，之间存在因果关系时<ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph>属性维护此信息。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The outer exception is thrown in response to this inner exception.</source>
          <target state="translated">将外部异常情况以响应此内部异常。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The code that handles the outer exception can use the information from the earlier inner exception to handle the error more appropriately.</source>
          <target state="translated">处理外部异常的代码可以使用来自前面的内部异常的信息更恰当处理的错误。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Supplementary information about the exception can be stored as a collection of key/value pairs in the <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> property.</source>
          <target state="translated">关于异常的补充信息可以存储为中的键/值对的集合<ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The error message string that is passed to the constructor during the creation of the exception object should be localized and can be supplied from a resource file by using the <ph id="ph1">&lt;xref:System.Resources.ResourceManager&gt;</ph> class.</source>
          <target state="translated">异常对象的创建过程传递给构造函数的错误消息字符串应本地化，并通过使用可以从资源文件中提供<ph id="ph1">&lt;xref:System.Resources.ResourceManager&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For more information about localized resources, see the <bpt id="p1">[</bpt>Creating Satellite Assemblies<ept id="p1">](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)</ept> and <bpt id="p2">[</bpt>Packaging and Deploying Resources<ept id="p2">](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)</ept> topics.</source>
          <target state="translated">本地化资源有关的详细信息，请参阅<bpt id="p1">[</bpt>创建附属程序集<ept id="p1">](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)</ept>和<bpt id="p2">[</bpt>打包和部署资源<ept id="p2">](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)</ept>主题。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>To provide the user with extensive information about why the exception occurred, the <ph id="ph1">&lt;xref:System.Exception.HelpLink%2A&gt;</ph> property can hold a URL (or URN) to a help file.</source>
          <target state="translated">若要为用户提供有关异常发生的原因的大量信息<ph id="ph1">&lt;xref:System.Exception.HelpLink%2A&gt;</ph>属性可以保存到的帮助文件的 URL （或 URN）。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">&lt;xref:System.Exception&gt;</ph> class uses the HRESULT COR_E_EXCEPTION, which has the value 0x80131500.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception&gt;</ph>类使用 HRESULT COR_E_EXCEPTION，其值 0x80131500。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For a list of initial property values for an instance of the <ph id="ph1">&lt;xref:System.Exception&gt;</ph> class, see the <ph id="ph2">&lt;xref:System.Exception.%23ctor%2A&gt;</ph> constructors.</source>
          <target state="translated">有关的实例的初始属性值的列表<ph id="ph1">&lt;xref:System.Exception&gt;</ph>类，请参阅<ph id="ph2">&lt;xref:System.Exception.%23ctor%2A&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Performance considerations</source>
          <target state="translated">性能注意事项</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Throwing or handling an exception consumes a significant amount of system resources and execution time.</source>
          <target state="translated">可以引发或处理异常会消耗大量系统资源和执行时间。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Throw exceptions only to handle truly extraordinary conditions, not to handle predictable events or flow control.</source>
          <target state="translated">引发异常，只是为了处理确实异常的情况，不能处理可预测的事件或流控制。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, in some cases, such as when you're developing a class library, it's reasonable to throw an exception if a method argument is invalid, because you expect your method to be called with valid parameters.</source>
          <target state="translated">例如，在某些情况下，当你要开发一个类库，例如是合理的方法自变量无效，因为你希望你使用有效的参数来调用的方法引发异常。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An invalid method argument, if it is not the result of a usage error, means that something extraordinary has occurred.</source>
          <target state="translated">无效的方法自变量，如果它并不是使用错误的结果意味着，出现了异常。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Conversely, do not throw an exception if user input is invalid, because you can expect users to occasionally enter invalid data.</source>
          <target state="translated">相反，如果用户输入无效，因为会偶尔会输入无效数据的用户确实引发了异常。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Instead, provide a retry mechanism so users can enter valid input.</source>
          <target state="translated">相反，提供重试机制，以便用户可以输入有效的输入。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Nor should you use exceptions to handle usage errors.</source>
          <target state="translated">也不应使用异常来处理用法错误。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Instead, use <bpt id="p1">[</bpt>assertions<ept id="p1">](/visualstudio/debugger/assertions-in-managed-code)</ept> to identify and correct usage errors.</source>
          <target state="translated">请改用<bpt id="p1">[</bpt>断言<ept id="p1">](/visualstudio/debugger/assertions-in-managed-code)</ept>以确定并更正用法错误。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In addition, do not throw an exception when a return code is sufficient; do not convert a return code to an exception; and do not routinely catch an exception, ignore it, and then continue processing.</source>
          <target state="translated">返回代码时足够; 此外，确实引发了异常没有转换为异常，则返回代码并不定期执行 catch 异常，忽略它，然后继续进行处理。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Re-throwing an exception</source>
          <target state="translated">重新引发异常</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In many cases, an exception handler simply wants to pass the exception on to the caller.</source>
          <target state="translated">在许多情况下，异常处理程序只是想要传递到调用方的异常。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This most often occurs in:</source>
          <target state="translated">这通常发生在：</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A class library that in turn wraps calls to methods in the .NET Framework class library or other class libraries.</source>
          <target state="translated">反过来包装对.NET Framework 类库或其他类库中的方法的调用的类库。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An application or library that encounters a fatal exception.</source>
          <target state="translated">应用程序或遇到严重异常的库。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The exception handler can log the exception and then re-throw the exception.</source>
          <target state="translated">异常处理程序可以将异常记录，然后重新引发异常。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The recommended way to re-throw an exception is to simply use the <bpt id="p1">[</bpt>throw<ept id="p1">](~/docs/csharp/language-reference/keywords/throw.md)</ept> statement in C# and the <bpt id="p2">[</bpt>Throw<ept id="p2">](~/docs/visual-basic/language-reference/statements/throw-statement.md)</ept> statement in Visual Basic without including an expression.</source>
          <target state="translated">重新引发异常的建议的方法是只需使用<bpt id="p1">[</bpt>引发<ept id="p1">](~/docs/csharp/language-reference/keywords/throw.md)</ept>C# 中的语句和<bpt id="p2">[</bpt>引发<ept id="p2">](~/docs/visual-basic/language-reference/statements/throw-statement.md)</ept>在 Visual Basic 中不包含表达式的语句。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This ensures that all call stack information is preserved when the exception is propagated to the caller.</source>
          <target state="translated">这可确保当该异常会传播到调用方保留了所有调用堆栈信息。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following example illustrates this.</source>
          <target state="translated">下面的示例阐释了这一点。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A string extension method, <ph id="ph1">`FindOccurrences`</ph>, wraps one or more calls to <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> without validating its arguments beforehand.</source>
          <target state="translated">字符串扩展方法， <ph id="ph1">`FindOccurrences`</ph>，包装到一个或多个调用<ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph>而无需事先验证其参数。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A caller then calls <ph id="ph1">`FindOccurrences`</ph> twice.</source>
          <target state="translated">然后，在调用方调用<ph id="ph1">`FindOccurrences`</ph>两次。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In the second call to <ph id="ph1">`FindOccurrences`</ph>, the caller passes a <ph id="ph2">`null`</ph> as the search string, which cases the <ph id="ph3">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to throw an <ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph> exception.</source>
          <target state="translated">在第二次调用<ph id="ph1">`FindOccurrences`</ph>，调用方传递<ph id="ph2">`null`</ph>作为搜索字符串，哪些用例<ph id="ph3">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph>方法会引发<ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph>异常。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This exception is handled by the <ph id="ph1">`FindOccurrences`</ph> method and passed back to the caller.</source>
          <target state="translated">处理此异常<ph id="ph1">`FindOccurrences`</ph>方法并传递的回调用方。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Because the throw statement is used with no expression, the output from the example shows that the call stack is preserved.</source>
          <target state="translated">由于不使用表达式使用 throw 语句，该示例输出所示保留调用堆栈。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In contrast, if the exception is re-thrown by using the</source>
          <target state="translated">相反，如果通过使用重新引发异常</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>statement, the full call stack is not preserved, and the example would generate the following output:</source>
          <target state="translated">不保留语句，完整的调用堆栈，并且该示例将生成以下输出：</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A slightly more cumbersome alternative is to throw a new exception, and to preserve the original exception's call stack information in an inner exception.</source>
          <target state="translated">稍微繁琐的替代方法是引发一个新的异常，并保留在内部异常的原始异常的调用堆栈信息。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The caller can then use the new exception's <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property to retrieve stack frame and other information about the original exception.</source>
          <target state="translated">然后，调用方可以使用新的异常<ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph>属性检索堆栈帧和有关原始异常的其他信息。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In this case, the throw statement is:</source>
          <target state="translated">在这种情况下，throw 语句是：</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The user code that handles the exception has to know that the <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property contains information about the original exception, as the following exception handler illustrates.</source>
          <target state="translated">处理异常的用户代码必须知道<ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph>属性包含原始异常，有关的信息，如下面的异常处理程序所示。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Choosing standard exceptions</source>
          <target state="translated">选择标准异常</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When you have to throw an exception, you can often use an existing exception type in the .NET Framework instead of implementing a custom exception.</source>
          <target state="translated">如果必须引发异常，通常可以使用.NET Framework 而不是实现自定义异常中的现有异常类型。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>You should use a standard exception type under these two conditions:</source>
          <target state="translated">你应使用这两个条件下的标准异常类型：</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>You are throwing an exception that is caused by a usage error (that is, by an error in program logic made by the developer who is calling your method).</source>
          <target state="translated">引发由用法错误导致的异常的 (即，通过所做的开发人员正在调用你的方法的程序逻辑中的错误)。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Typically, you would throw an exception such as <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>, <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>, <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>, or <ph id="ph4">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">通常情况下，会引发异常如<ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>， <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>， <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>，或<ph id="ph4">&lt;xref:System.NotSupportedException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The string you supply to the exception object's constructor when instantiating the exception object should describe the error so that the developer can fix it.</source>
          <target state="translated">您可以将其提供给异常对象的构造函数时实例化的异常对象应描述错误，以便开发人员可以修复此错误的字符串。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property.</source>
          <target state="translated">有关更多信息，请参见 <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>You are handling an error that can be communicated to the caller with an existing .NET Framework exception.</source>
          <target state="translated">正在处理的错误，可以传递给调用方与现有的.NET Framework 异常。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>You should throw the most derived exception possible.</source>
          <target state="translated">您应引发派生程度最大可能的异常。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, if a method requires an argument to be a valid member of an enumeration type, you should throw an <ph id="ph1">&lt;xref:System.ComponentModel.InvalidEnumArgumentException&gt;</ph> (the most derived class) rather than an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">例如，如果某个方法要求自变量为枚举类型的有效成员，则应引发<ph id="ph1">&lt;xref:System.ComponentModel.InvalidEnumArgumentException&gt;</ph>（大多数派生类） 而非<ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following table lists common exception types and the conditions under which you would throw them.</source>
          <target state="translated">下表列出了常见的异常类型和在其下会引发它们的条件。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Exception</source>
          <target state="translated">例外</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Condition</source>
          <target state="translated">条件</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A non-null argument that is passed to a method is invalid.</source>
          <target state="translated">传递给方法的非 null 参数无效。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An argument that is passed to a method is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">传递给方法的自变量是<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An argument is outside the range of valid values.</source>
          <target state="translated">参数超出有效值的范围。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Part of a directory path is not valid.</source>
          <target state="translated">目录路径的一部分无效。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The denominator in an integer or <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> division operation is zero.</source>
          <target state="translated">整数形式分母或<ph id="ph1">&lt;xref:System.Decimal&gt;</ph>除法运算为零。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A drive is unavailable or does not exist.</source>
          <target state="translated">驱动器不可用或不存在。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A file does not exist.</source>
          <target state="translated">文件不存在。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A value is not in an appropriate format to be converted from a string by a conversion method such as <ph id="ph1">`Parse`</ph>.</source>
          <target state="translated">值不在相应的格式无法转换从字符串转换方法如<ph id="ph1">`Parse`</ph>。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An index is outside the bounds of an array or collection.</source>
          <target state="translated">索引是数组或集合的界限之外。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A method call is invalid in an object's current state.</source>
          <target state="translated">方法调用在对象的当前状态无效。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The specified key for accessing a member in a collection cannot be found.</source>
          <target state="translated">找不到用于访问集合中的成员的指定的键。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A method or operation is not implemented.</source>
          <target state="translated">未实现方法或操作。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A method or operation is not supported.</source>
          <target state="translated">不支持的方法或操作。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An operation is performed on an object that has been disposed.</source>
          <target state="translated">对已释放的对象执行操作。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An arithmetic, casting, or conversion operation results in an overflow.</source>
          <target state="translated">算术、 强制转换或转换运算导致溢出。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>A path or file name exceeds the maximum system-defined length.</source>
          <target state="translated">路径或文件的名称超过了系统定义的最大长度。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The operation is not supported on the current platform.</source>
          <target state="translated">当前平台上不支持该操作。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An array with the wrong number of dimensions is passed to a method.</source>
          <target state="translated">具有错误维数的数组传递到方法。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The time interval allotted to an operation has expired.</source>
          <target state="translated">分配给操作的时间间隔已过期。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>An invalid Uniform Resource Identifier (URI) is used.</source>
          <target state="translated">使用无效的统一资源标识符 (URI)。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Implementing custom exceptions</source>
          <target state="translated">实现自定义异常</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In the following cases, using an existing .NET Framework exception to handle an error condition is not adequate:</source>
          <target state="translated">在以下情况下，使用现有的.NET Framework 异常来处理错误条件不能满足：</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When the exception reflects a unique program error that cannot be mapped to an existing .NET Framework exception.</source>
          <target state="translated">当异常反映唯一程序错误，无法映射到现有的.NET Framework 异常。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>When the exception requires handling that is different from the handling that is appropriate for an existing .NET Framework exception, or the exception must be disambiguated from a similar exception.</source>
          <target state="translated">异常需要处理的是不同于适用于现有的.NET Framework 异常或异常的处理时必须存在类似的例外从消除歧义。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, if you throw an <ph id="ph1">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> exception when parsing the numeric representation of a string that is out of range of the target integral type, you would not want to use the same exception for an error that results from the caller not supplying the appropriate constrained values when calling the method.</source>
          <target state="translated">例如，如果引发了<ph id="ph1">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>异常分析的字符串的目标整数类型的范围超出了数值表示形式时，你不想要使用相同的异常导致的调用方不提供的错误适当约束的值调用该方法时。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">&lt;xref:System.Exception&gt;</ph> class is the base class of all exceptions in the .NET Framework.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception&gt;</ph>类是.NET Framework 中的所有异常的基类。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Many derived classes rely on the inherited behavior of the members of the <ph id="ph1">&lt;xref:System.Exception&gt;</ph> class; they do not override the members of <ph id="ph2">&lt;xref:System.Exception&gt;</ph>, nor do they define any unique members.</source>
          <target state="translated">许多派生的类依赖于的成员的继承行为<ph id="ph1">&lt;xref:System.Exception&gt;</ph>类; 它们不重写的成员<ph id="ph2">&lt;xref:System.Exception&gt;</ph>，也不定义任何唯一的成员。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>To define your own exception class:</source>
          <target state="translated">若要定义你自己的异常类：</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Define a class that inherits from <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</source>
          <target state="translated">定义继承自的类<ph id="ph1">&lt;xref:System.Exception&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If necessary, define any unique members needed by your class to provide additional information about the exception.</source>
          <target state="translated">如有必要，定义你的类提供有关异常的其他信息所需的任何唯一成员。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>For example, the <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> class includes a <ph id="ph2">&lt;xref:System.ArgumentException.ParamName%2A&gt;</ph> property that specifies the name of the parameter whose argument caused the exception, and the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> property includes a <ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A&gt;</ph> property that indicates the time-out interval.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>类包括<ph id="ph2">&lt;xref:System.ArgumentException.ParamName%2A&gt;</ph>指定其参数导致异常的参数的名称的属性和<ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph>属性包括<ph id="ph4">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A&gt;</ph>属性，指示超时间隔。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>If necessary, override any inherited members whose functionality you want to change or modify.</source>
          <target state="translated">如有必要，重写任何继承的成员你想要更改或修改其功能。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Note that most existing derived classes of <ph id="ph1">&lt;xref:System.Exception&gt;</ph> do not override the behavior of inherited members.</source>
          <target state="translated">请注意，大多数现有派生的类<ph id="ph1">&lt;xref:System.Exception&gt;</ph>不重写继承成员的行为。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Determine whether your custom exception object is serializable.</source>
          <target state="translated">确定你的自定义异常对象是否是可序列化。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Serialization enables you to save information about the exception and permits exception information to be shared by a server and a client proxy in a remoting context.</source>
          <target state="translated">序列化可让你保存有关异常的信息，并允许要由服务器和客户端代理在远程处理的上下文中共享的异常信息。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>To make the exception object serializable, mark it with the <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph> attribute.</source>
          <target state="translated">若要使该异常对象可序列化，将其与标记<ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Define the constructors of your exception class.</source>
          <target state="translated">定义异常类的构造函数。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Typically, exception classes have one or more of the following constructors:</source>
          <target state="translated">通常情况下，异常类都有一个或多个以下构造函数：</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><ph id="ph1">&lt;xref:System.Exception.%23ctor&gt;</ph>, which uses default values to initialize the properties of a new exception object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.%23ctor&gt;</ph>它使用默认值初始化新的异常对象的属性。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.String%29&gt;</ph>, which initializes a new exception object with a specified error message.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.String%29&gt;</ph>其中初始化具有指定的错误消息的新异常对象。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29&gt;</ph>, which initializes a new exception object with a specified error message and inner exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29&gt;</ph>其中初始化具有指定的错误消息和内部异常的新异常对象。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29&gt;</ph>, which is a <ph id="ph2">`protected`</ph> constructor that initializes a new exception object from serialized data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29&gt;</ph>即<ph id="ph2">`protected`</ph>初始化中的新异常对象的构造函数的序列化数据。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>You should implement this constructor if you've chosen to make your exception object serializable.</source>
          <target state="translated">如果你选择使异常对象可序列化，则应实现此构造函数。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following example illustrates the use of a custom exception class.</source>
          <target state="translated">下面的示例演示如何使用自定义异常类。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>It defines a <ph id="ph1">`NotPrimeException`</ph> exception that is thrown when a client tries to retrieve a sequence of prime numbers by specifying a starting number that is not prime.</source>
          <target state="translated">它定义<ph id="ph1">`NotPrimeException`</ph>时客户端试图通过指定不是主要起始数字中检索的质数序列引发的异常。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The exception defines a new property, <ph id="ph1">`NonPrime`</ph>, that returns the non-prime number that caused the exception.</source>
          <target state="translated">异常定义一个新属性， <ph id="ph1">`NonPrime`</ph>，返回非质数数字引发异常的异常。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Besides implementing a protected parameterless constructor and a constructor with <ph id="ph1">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;</ph> parameters for serialization, the <ph id="ph3">`NotPrimeException`</ph> class defines three additional constructors to support the <ph id="ph4">`NonPrime`</ph> property.</source>
          <target state="translated">除了实现受保护的无参数构造函数和的构造函数<ph id="ph1">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;</ph>参数对于序列化，<ph id="ph3">`NotPrimeException`</ph>类定义三个其他的构造函数来支持<ph id="ph4">`NonPrime`</ph>属性。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Each constructor calls a base class constructor in addition to preserving the value of the non-prime number.</source>
          <target state="translated">每个构造函数调用除了保留值的非-质数基类构造函数。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">`NotPrimeException`</ph> class is also marked with the <ph id="ph2">&lt;xref:System.SerializableAttribute&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">`NotPrimeException`</ph>类还将标有<ph id="ph2">&lt;xref:System.SerializableAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">`PrimeNumberGenerator`</ph> class shown in the following example uses the Sieve of Eratosthenes to calculate the sequence of prime numbers from 2 to a limit specified by the client in the call to its class constructor.</source>
          <target state="translated"><ph id="ph1">`PrimeNumberGenerator`</ph>类显示在下面的示例使用选筛的埃拉托色尼斯来计算质数从 2 到客户端对其类构造函数的调用中指定的限制的序列。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The <ph id="ph1">`GetPrimesFrom`</ph> method returns all prime numbers that are greater than or equal to a specified lower limit, but throws a <ph id="ph2">`NotPrimeException`</ph> if that lower limit is not a prime number.</source>
          <target state="translated"><ph id="ph1">`GetPrimesFrom`</ph>方法返回大于或等于指定的下限的所有质数但引发<ph id="ph2">`NotPrimeException`</ph>如果该较低的限制不是质数。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following example makes two calls to the <ph id="ph1">`GetPrimesFrom`</ph> method with non-prime numbers, one of which crosses application domain boundaries.</source>
          <target state="translated">下面的示例调用两个<ph id="ph1">`GetPrimesFrom`</ph>方法与非质数，其中之一是跨应用程序域边界。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In both cases, the exception is thrown and successfully handled in client code.</source>
          <target state="translated">在这两种情况下，此异常将引发，并在客户端代码中成功处理。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Windows Runtime and <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph></source>
          <target state="translated">Windows 运行时和 <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>In <ph id="ph1">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph> for <ph id="ph2">[!INCLUDE[win8](~/includes/win8-md.md)]</ph>, some exception information is typically lost when an exception is propagated through non-.NET Framework stack frames.</source>
          <target state="translated">在<ph id="ph1">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]</ph>为<ph id="ph2">[!INCLUDE[win8](~/includes/win8-md.md)]</ph>，通过非.NET Framework 堆栈帧传播异常时会通常丢失某些异常信息。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph> and <ph id="ph2">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, the common language runtime continues to use the original <ph id="ph3">&lt;xref:System.Exception&gt;</ph> object that was thrown unless that exception was modified in a non-.NET Framework stack frame.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>和<ph id="ph2">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>，公共语言运行时将继续使用原始<ph id="ph3">&lt;xref:System.Exception&gt;</ph>抛出除非该异常在非.NET Framework 堆栈帧修改的对象。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>The following example demonstrates a <ph id="ph1">`catch`</ph> block that is defined to handle <ph id="ph2">&lt;xref:System.ArithmeticException&gt;</ph> errors.</source>
          <target state="translated">下面的示例演示<ph id="ph1">`catch`</ph>定义要处理的块<ph id="ph2">&lt;xref:System.ArithmeticException&gt;</ph>错误。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Exception">
          <source>This <ph id="ph1">`catch`</ph> block also catches <ph id="ph2">&lt;xref:System.DivideByZeroException&gt;</ph> errors, because <ph id="ph3">&lt;xref:System.DivideByZeroException&gt;</ph> derives from <ph id="ph4">&lt;xref:System.ArithmeticException&gt;</ph> and there is no <ph id="ph5">`catch`</ph> block explicitly defined for <ph id="ph6">&lt;xref:System.DivideByZeroException&gt;</ph> errors.</source>
          <target state="translated">这<ph id="ph1">`catch`</ph>块还捕捉<ph id="ph2">&lt;xref:System.DivideByZeroException&gt;</ph>错误，因为<ph id="ph3">&lt;xref:System.DivideByZeroException&gt;</ph>派生自<ph id="ph4">&lt;xref:System.ArithmeticException&gt;</ph>并且没有任何<ph id="ph5">`catch`</ph>为显式定义的块<ph id="ph6">&lt;xref:System.DivideByZeroException&gt;</ph>错误。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="T:System.Exception">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>This constructor initializes the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property of the new instance to a system-supplied message that describes the error and takes into account the current system culture.</source>
          <target state="translated">此构造函数将新实例的 <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> 属性初始化为系统提供的消息，该消息描述错误并考虑当前系统区域性。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>All the derived classes should provide this default constructor.</source>
          <target state="translated">所有派生的类应提供此默认构造函数。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</source>
          <target state="translated">下表显示 <ph id="ph1">&lt;xref:System.Exception&gt;</ph> 的实例的初始属性值。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>Property</source>
          <target state="translated">Property</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>Value</source>
          <target state="translated">“值”</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic).</source>
          <target state="translated">空引用（在 Visual Basic 中为 <ph id="ph1">`Nothing`</ph>）。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>A system-supplied localized description.</source>
          <target state="translated">系统提供的本地化说明。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>The following code example derives an <ph id="ph1">`Exception`</ph> that uses a predefined message.</source>
          <target state="translated">下面的代码示例派生<ph id="ph1">`Exception`</ph>，它使用预定义的消息。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor">
          <source>The code demonstrates the use of the parameterless constructor for the derived class and the base <ph id="ph1">`Exception`</ph> class.</source>
          <target state="translated">代码演示了将无参数构造函数用于派生的类和基<ph id="ph1">`Exception`</ph>类。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.String)">
          <source>The message that describes the error.</source>
          <target state="translated">描述错误的消息。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> class with a specified error message.</source>
          <target state="translated">用指定的错误消息初始化 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>This constructor initializes the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property of the new instance by using the <ph id="ph2">`message`</ph> parameter.</source>
          <target state="translated">此构造函数初始化<ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph>通过将新实例属性<ph id="ph2">`message`</ph>参数。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>If the <ph id="ph1">`message`</ph> parameter is <ph id="ph2">`null`</ph>, this is the same as calling the <ph id="ph3">&lt;xref:System.Exception.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">如果<ph id="ph1">`message`</ph>参数是<ph id="ph2">`null`</ph>，这是调用相同<ph id="ph3">&lt;xref:System.Exception.%23ctor%2A&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</source>
          <target state="translated">下表显示 <ph id="ph1">&lt;xref:System.Exception&gt;</ph> 的实例的初始属性值。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>Property</source>
          <target state="translated">Property</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>Value</source>
          <target state="translated">“值”</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic).</source>
          <target state="translated">空引用（在 Visual Basic 中为 <ph id="ph1">`Nothing`</ph>）。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>The error message string.</source>
          <target state="translated">错误消息字符串。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>The following code example derives an <ph id="ph1">`Exception`</ph> for a specific condition.</source>
          <target state="translated">下面的代码示例派生<ph id="ph1">`Exception`</ph>针对特定的条件。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String)">
          <source>The code demonstrates the use of the constructor that takes a caller-specified message as a parameter, for both the derived class and the base <ph id="ph1">`Exception`</ph> class.</source>
          <target state="translated">代码演示了将调用方指定的消息作为参数，派生的类和基构造函数的用法<ph id="ph1">`Exception`</ph>类。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> that holds the serialized object data about the exception being thrown.</source>
          <target state="translated">包含有关所引发异常的序列化对象数据的 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> that contains contextual information about the source or destination.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>，它包含关于源或目标的上下文信息。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> class with serialized data.</source>
          <target state="translated">用序列化数据初始化 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This constructor is called during deserialization to reconstitute the exception object transmitted over a stream.</source>
          <target state="translated">此构造函数在反序列化过程中调用，以便重建通过流传输的异常对象。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>For more information, see <bpt id="p1">[</bpt>XML and SOAP Serialization<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>XML 和 SOAP 序列化<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The following code example defines a derived serializable <ph id="ph1">`Exception`</ph> class.</source>
          <target state="translated">下面的代码示例定义一个派生可序列化<ph id="ph1">`Exception`</ph>类。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The code forces a divide-by-0 error and then creates an instance of the derived exception using the (<ph id="ph1">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;</ph>) constructor.</source>
          <target state="translated">代码强制被零除错误，然后创建派生的异常使用的实例 (<ph id="ph1">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph>， <ph id="ph2">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;</ph>) 构造函数。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The code serializes the instance to a file, deserializes the file into a new exception, which it throws, and then catches and displays the exception's data.</source>
          <target state="translated">代码将序列化到文件的实例，将该文件反序列化为一个新异常，则会引发，然后捕获并显示异常的数据。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;paramref name="info" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The class name is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or <ph id="ph2">&lt;see cref="P:System.Exception.HResult" /&gt;</ph> is zero (0).</source>
          <target state="translated">类名为 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 或者 <ph id="ph2">&lt;see cref="P:System.Exception.HResult" /&gt;</ph> 为零 (0)。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The error message that explains the reason for the exception.</source>
          <target state="translated">解释异常原因的错误消息。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The exception that is the cause of the current exception, or a null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) if no inner exception is specified.</source>
          <target state="translated">导致当前异常的异常；如果未指定内部异常，则是一个 null 引用（在 Visual Basic 中为 <ph id="ph1">&lt;see langword="Nothing" /&gt;</ph>）。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> class with a specified error message and a reference to the inner exception that is the cause of this exception.</source>
          <target state="translated">使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>An exception that is thrown as a direct result of a previous exception should include a reference to the previous exception in the <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property.</source>
          <target state="translated">因前一个异常而直接引发的异常应在 <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> 属性中包含对前一个异常的引用。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property returns the same value that is passed into the constructor, or a null reference (<ph id="ph2">`Nothing`</ph> in Visual Basic) if the <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property does not supply the inner exception value to the constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> 属性返回传递到构造函数中的相同值，或者如果 <ph id="ph2">`Nothing`</ph> 属性不向构造函数提供内部异常值，则为空引用（在 Visual Basic 中为 <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph>）。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.Exception&gt;</ph>.</source>
          <target state="translated">下表显示 <ph id="ph1">&lt;xref:System.Exception&gt;</ph> 的实例的初始属性值。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>Property</source>
          <target state="translated">Property</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>Value</source>
          <target state="translated">“值”</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The inner exception reference.</source>
          <target state="translated">内部异常引用。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The error message string.</source>
          <target state="translated">错误消息字符串。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The following code example derives an <ph id="ph1">`Exception`</ph> for a specific condition.</source>
          <target state="translated">下面的代码示例派生<ph id="ph1">`Exception`</ph>针对特定的条件。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.#ctor(System.String,System.Exception)">
          <source>The code demonstrates the use of the constructor that takes a message and an inner exception as parameters, for both the derived class and the base <ph id="ph1">`Exception`</ph> class.</source>
          <target state="translated">代码演示了接受消息和内部异常作为参数，分别对应派生的类和基构造函数的用法<ph id="ph1">`Exception`</ph>类。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="P:System.Exception.Data">
          <source>Gets a collection of key/value pairs that provide additional user-defined information about the exception.</source>
          <target state="translated">获取提供有关异常的其他用户定义信息的键/值对集合。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>An object that implements the <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> interface and contains a collection of user-defined key/value pairs.</source>
          <target state="translated">一个对象，它实现 <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> 接口并包含用户定义的键/值对的集合。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The default is an empty collection.</source>
          <target state="translated">默认值为空集合。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Use the <ph id="ph1">&lt;xref:System.Collections.IDictionary?displayProperty=nameWithType&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Exception.Data%2A&gt;</ph> property to store and retrieve supplementary information relevant to the exception.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Collections.IDictionary?displayProperty=nameWithType&gt;</ph>返回对象<ph id="ph2">&lt;xref:System.Exception.Data%2A&gt;</ph>属性来存储和检索与异常相关的补充信息。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The information is in the form of an arbitrary number of user-defined key/value pairs.</source>
          <target state="translated">信息是在任意数目的用户定义键/值对的形式。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The key component of each key/value pair is typically an identifying string, whereas the value component of the pair can be any type of object.</source>
          <target state="translated">每个键/值对的关键组件通常是对象的一个标识字符串，而对的值组件可以是对象的任何类型。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Key/Value Pair Security</source>
          <target state="translated">键/值对安全</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The key/value pairs stored in the collection returned by the <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> property are not secure.</source>
          <target state="translated">返回的集合中存储的键/值对<ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph>是不安全的属性。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>If your application calls a nested series of routines, and each routine contains exception handlers, the resulting call stack contains a hierarchy of those exception handlers.</source>
          <target state="translated">如果你的应用程序调用一系列嵌套的例程，并且每个例程包含异常处理程序时，调用堆栈结果将包含这些异常处理程序的层次结构。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>If a lower-level routine throws an exception, any upper-level exception handler in the call stack hierarchy can read and/or modify the key/value pairs stored in the collection by any other exception handler.</source>
          <target state="translated">如果较低级别例程引发了异常，调用堆栈层次结构中的任何高级别的异常处理程序可以读取和/或修改存储在集合中的任何其他异常处理程序的键/值对。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>This means you must guarantee that the information in the key/value pairs is not confidential and that your application will operate correctly if the information in the key/value pairs is corrupted.</source>
          <target state="translated">这意味着必须保证键/值对中的信息不是机密和你的应用程序将运行正确，如果键/值对中的信息已损坏。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Key Conflicts</source>
          <target state="translated">密钥冲突</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>A key conflict occurs when different exception handlers specify the same key to access a key/value pair.</source>
          <target state="translated">键冲突发生时不同的异常处理程序指定相同的键来访问键/值对。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Use caution when developing your application because the consequence of a key conflict is that lower-level exception handlers can inadvertently communicate with higher-level exception handlers, and this communication might cause subtle program errors.</source>
          <target state="translated">你的应用程序的开发，因为键冲突的后果是较低级别的异常处理程序无意中能够与更高级别的异常处理程序，而此通信可能会导致细微程序错误时要格外小心。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>However, if you are cautious you can use key conflicts to enhance your application.</source>
          <target state="translated">但是，如果你是小心你可以使用键冲突可增强应用程序。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Avoiding Key Conflicts</source>
          <target state="translated">避免密钥冲突</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Avoid key conflicts by adopting a naming convention to generate unique keys for key/value pairs.</source>
          <target state="translated">通过采用命名约定生成的键/值对唯一键可以避免键冲突。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>For example, a naming convention might yield a key that consists of the period-delimited name of your application, the method that provides supplementary information for the pair, and a unique identifier.</source>
          <target state="translated">例如，命名约定可能会生成包含句点分隔的你的应用程序名称的密钥，则该方法提供补充信息的对，并将其唯一标识符。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Suppose two applications, named Products and Suppliers, each has a method named Sales.</source>
          <target state="translated">假设两个应用程序，名为产品和供应商，每都有一个名为销售方法。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The Sales method in the Products application provides the identification number (the stock keeping unit or SKU) of a product.</source>
          <target state="translated">产品应用程序中的销售方法提供的产品标识号 （的库存单位或 SKU）。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The Sales method in the Suppliers application provides the identification number, or SID, of a supplier.</source>
          <target state="translated">供应商应用程序中的销售方法提供的标识号或 SID，供应商。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Consequently, the naming convention for this example yields the keys, "Products.Sales.SKU" and "Suppliers.Sales.SID".</source>
          <target state="translated">因此，此示例中的命名约定生成的密钥，"Products.Sales.SKU"和"Suppliers.Sales.SID"。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Exploiting Key Conflicts</source>
          <target state="translated">利用键冲突</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Exploit key conflicts by using the presence of one or more special, prearranged keys to control processing.</source>
          <target state="translated">通过使用一个或多个特殊，预先安排的键存在来控制处理来利用键冲突。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Suppose, in one scenario, the highest level exception handler in the call stack hierarchy catches all exceptions thrown by lower-level exception handlers.</source>
          <target state="translated">假设在一个方案中，调用堆栈层次结构中的最高级别的异常处理程序捕捉所有较低级别异常处理程序处理引发的异常。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>If a key/value pair with a special key exists, the high-level exception handler formats the remaining key/value pairs in the <ph id="ph1">&lt;xref:System.Collections.IDictionary&gt;</ph> object in some nonstandard way; otherwise, the remaining key/value pairs are formatted in some normal manner.</source>
          <target state="translated">如果存在具有的特殊键的键/值对，高级别的异常处理程序格式中的剩余键/值对<ph id="ph1">&lt;xref:System.Collections.IDictionary&gt;</ph>对象以某种非标准的方式; 否则，将剩余的键/值对格式以某种正常方式。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Now suppose, in another scenario, the exception handler at each level of the call stack hierarchy catches the exception thrown by the next lower-level exception handler.</source>
          <target state="translated">现在假设，在另一个方案中，在调用堆栈层次结构的每个级别的异常处理程序捕捉由下一个较低级别的异常处理程序引发的异常。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>In addition, each exception handler knows the collection returned by the <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> property contains a set of key/value pairs that can be accessed with a prearranged set of keys.</source>
          <target state="translated">此外，每个异常处理程序知道返回的集合<ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph>属性包含一组预先安排的项的键/值对的可访问的集。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Each exception handler uses the prearranged set of keys to update the value component of the corresponding key/value pair with information unique to that exception handler.</source>
          <target state="translated">每个异常处理程序使用预先安排的密钥集来与该异常处理程序的唯一信息更新相应的键/值对的值组件。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>After the update process is complete, the exception handler throws the exception to the next higher-level exception handler.</source>
          <target state="translated">更新过程已完成后，异常处理程序将引发到下一步的更高级别的异常处理程序的异常。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>Finally, the highest level exception handler accesses the key/value pairs and displays the consolidated update information from all the lower-level exception handlers.</source>
          <target state="translated">最后，最高级别的异常处理程序访问的键/值对，并显示所有较低级别的异常处理程序中的合并的更新信息。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Data">
          <source>The following example demonstrates how to add and retrieve information using the <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> property.</source>
          <target state="translated">下面的示例演示如何添加和检索信息使用<ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Exception.GetBaseException">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> that is the root cause of one or more subsequent exceptions.</source>
          <target state="translated">当在派生类中重写时，返回 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph>，它是一个或多个并发的异常的根源。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Exception.GetBaseException">
          <source>The first exception thrown in a chain of exceptions.</source>
          <target state="translated">异常链中第一个被引发的异常。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Exception.GetBaseException">
          <source>If the <ph id="ph1">&lt;see cref="P:System.Exception.InnerException" /&gt;</ph> property of the current exception is a null reference (<ph id="ph2">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), this property returns the current exception.</source>
          <target state="translated">如果当前异常的 <ph id="ph1">&lt;see cref="P:System.Exception.InnerException" /&gt;</ph> 属性是 null 引用（Visual Basic 中为 <ph id="ph2">&lt;see langword="Nothing" /&gt;</ph>），则此属性返回当前异常。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>A chain of exceptions consists of a set of exceptions such that each exception in the chain was thrown as a direct result of the exception referenced in its <ph id="ph1">`InnerException`</ph> property.</source>
          <target state="translated">异常链的一组组成的异常，链中的每个异常抛出异常中引用的直接结果作为其<ph id="ph1">`InnerException`</ph>属性。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>For a given chain, there can be exactly one exception that is the root cause of all other exceptions in the chain.</source>
          <target state="translated">对于给定的链，可以有一个是链中的其他所有异常的根本原因的异常。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>This exception is called the base exception and its <ph id="ph1">`InnerException`</ph> property always contains a null reference.</source>
          <target state="translated">此异常被称为使用基异常并将其<ph id="ph1">`InnerException`</ph>属性始终包含一个 null 引用。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>For all exceptions in a chain of exceptions, the <ph id="ph1">`GetBaseException`</ph> method must return the same object (the base exception).</source>
          <target state="translated">所有异常的异常，链中<ph id="ph1">`GetBaseException`</ph>方法必须返回相同的对象 （使用基异常）。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>Use the <ph id="ph1">`GetBaseException`</ph> method when you want to find the root cause of an exception but do not need information about exceptions that may have occurred between the current exception and the first exception.</source>
          <target state="translated">使用<ph id="ph1">`GetBaseException`</ph>方法时您想要查找异常的根本原因，但不是需要有关当前异常的第一个异常期间可能发生的异常的信息。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>The following code example defines two derived <ph id="ph1">`Exception`</ph> classes.</source>
          <target state="translated">下面的代码示例定义了两个派生<ph id="ph1">`Exception`</ph>类。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>It forces an exception and then throws it again with each of the derived classes.</source>
          <target state="translated">它强制异常，然后在与每个派生类重新引发它。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>The code shows the use of the <ph id="ph1">`GetBaseException`</ph> method to retrieve the original exception.</source>
          <target state="translated">代码演示如何使用<ph id="ph1">`GetBaseException`</ph>方法来检索原始异常。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetBaseException">
          <source>The <ph id="ph1">&lt;see langword="GetBaseException" /&gt;</ph> method is overridden in classes that require control over the exception content or format.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="GetBaseException" /&gt;</ph>需要控制的异常内容或格式的类中重写方法。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> that holds the serialized object data about the exception being thrown.</source>
          <target state="translated">包含有关所引发异常的序列化对象数据的 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> that contains contextual information about the source or destination.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>，它包含关于源或目标的上下文信息。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>When overridden in a derived class, sets the <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> with information about the exception.</source>
          <target state="translated">当在派生类中重写时，用关于异常的信息设置 <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">`GetObjectData`</ph> sets a <ph id="ph2">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph> with all the exception object data targeted for serialization.</source>
          <target state="translated"><ph id="ph1">`GetObjectData`</ph> 使用针对于序列化的所有异常对象数据设置 <ph id="ph2">&lt;xref:System.Runtime.Serialization.SerializationInfo&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>During deserialization, the exception is reconstituted from the <ph id="ph1">`SerializationInfo`</ph> transmitted over the stream.</source>
          <target state="translated">反序列化期间，从通过流传输的 <ph id="ph1">`SerializationInfo`</ph> 重建异常。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The following code example defines a derived serializable <ph id="ph1">`Exception`</ph> class that implements <ph id="ph2">`GetObjectData`</ph>, which makes minor changes to two properties and then calls the base class to perform the serialization.</source>
          <target state="translated">下面的代码示例定义一个派生可序列化<ph id="ph1">`Exception`</ph>类，该类实现<ph id="ph2">`GetObjectData`</ph>，从而细微的更改将对两个属性，然后调用的基类执行序列化。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The example forces a divide-by-0 error and then creates an instance of the derived exception.</source>
          <target state="translated">该示例强制被零除错误，然后创建派生的异常的实例。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The code serializes the instance to a file, deserializes the file into a new exception, which it throws, and then catches and displays the exception's data.</source>
          <target state="translated">代码将序列化到文件的实例，将该文件反序列化为一个新异常，则会引发，然后捕获并显示异常的数据。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;paramref name="info" /&gt;</ph> parameter is a null reference (<ph id="ph2">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> 参数为 null 引用（在 Visual Basic 中为 <ph id="ph2">&lt;see langword="Nothing" /&gt;</ph>）。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Exception.GetType">
          <source>Gets the runtime type of the current instance.</source>
          <target state="translated">获取当前实例的运行时类型。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Exception.GetType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the exact runtime type of the current instance.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象，表示当前实例的确切运行时类型。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.GetType">
          <source>The <ph id="ph1">&lt;xref:System.Exception.GetType%2A&gt;</ph> method exists to support the .NET Framework infrastructure, and internally invokes the fundamental method, <ph id="ph2">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.GetType%2A&gt;</ph>方法存在是为了支持.NET Framework 基础结构，并内部调用的基本方法<ph id="ph2">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="P:System.Exception.HelpLink">
          <source>Gets or sets a link to the help file associated with this exception.</source>
          <target state="translated">获取或设置指向与此异常关联的帮助文件链接。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HelpLink">
          <source>The Uniform Resource Name (URN) or Uniform Resource Locator (URL).</source>
          <target state="translated">统一资源名称 (URN) 或统一资源定位器 (URL)。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HelpLink">
          <source>The return value, which represents a help file, is a URN or URL.</source>
          <target state="translated">表示帮助文件的返回值是 URN 或 URL。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HelpLink">
          <source>For example, the <ph id="ph1">`HelpLink`</ph> value could be:</source>
          <target state="translated">例如，<ph id="ph1">`HelpLink`</ph>值可以是：</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HelpLink">
          <source>"file:///C:/Applications/Bazzal/help.html#ErrorNum42"</source>
          <target state="translated">"file:///C:/Applications/Bazzal/help.html#ErrorNum42"</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HelpLink">
          <source>The following code example throws an <ph id="ph1">`Exception`</ph> that sets the <ph id="ph2">`HelpLink`</ph> property in its constructor and then catches the exception and displays <ph id="ph3">`HelpLink`</ph>.</source>
          <target state="translated">下面的代码示例引发<ph id="ph1">`Exception`</ph>设置<ph id="ph2">`HelpLink`</ph>属性在其构造函数，然后捕捉异常并显示<ph id="ph3">`HelpLink`</ph>。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="P:System.Exception.HResult">
          <source>Gets or sets HRESULT, a coded numerical value that is assigned to a specific exception.</source>
          <target state="translated">获取或设置 HRESULT（一个分配给特定异常的编码数字值）。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>The HRESULT value.</source>
          <target state="translated">HRESULT 值。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>HRESULT is a 32-bit value, divided into three different fields: a severity code, a facility code, and an error code.</source>
          <target state="translated">HRESULT 为一个 32 位值，划分为三个不同的字段： 严重性代码、 设施代码和错误代码。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>The severity code indicates whether the return value represents information, warning, or error.</source>
          <target state="translated">严重性代码指示返回的值表示信息、 警告或错误。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>The facility code identifies the area of the system responsible for the error.</source>
          <target state="translated">设施代码标识的系统负责该错误的区域。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>The error code is a unique number that is assigned to represent the exception.</source>
          <target state="translated">错误代码为的分配来表示该异常的唯一编号。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>Each exception is mapped to a distinct HRESULT.</source>
          <target state="translated">每个异常映射到不同的 HRESULT。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>When managed code throws an exception, the runtime passes the HRESULT to the COM client.</source>
          <target state="translated">当托管的代码抛出异常时，运行时将 HRESULT 传递到 COM 客户端。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>When unmanaged code returns an error, the HRESULT is converted to an exception, which is then thrown by the runtime.</source>
          <target state="translated">当非托管的代码将返回错误时，HRESULT 被转换为异常，然后由运行时引发。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>For information about HRESULT values and their corresponding .NET Framework exceptions, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
          <target state="translated">HRESULT 值和其相应的.NET Framework 异常有关的信息，请参阅<bpt id="p1">[</bpt>如何： 映射 Hresult 和异常<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>See <bpt id="p1">[</bpt>Common HRESULT Values<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx)</ept> in the Windows documentation for a list of the values you are most likely to encounter.</source>
          <target state="translated">请参阅<bpt id="p1">[</bpt>常见的 HRESULT 值<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx)</ept>中的最有可能会遇到的值列表的 Windows 文档。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.Exception.HResult%2A&gt;</ph> property's setter is protected, whereas its getter is public.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>、<ph id="ph2">&lt;xref:System.Exception.HResult%2A&gt;</ph>属性的 setter 受到保护，而其 getter 是公共的。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>In previous versions of the .NET Framework, both getter and setter are protected.</source>
          <target state="translated">在以前版本的.NET Framework 中，getter 和 setter 进行保护。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.HResult">
          <source>The following code example defines a derived <ph id="ph1">`Exception`</ph> class that sets the <ph id="ph2">`HResult`</ph> property to a custom value in its constructor.</source>
          <target state="translated">下面的代码示例定义一个派生<ph id="ph1">`Exception`</ph>设置的类<ph id="ph2">`HResult`</ph>属性在其构造函数中的自定义值。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="P:System.Exception.InnerException">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> instance that caused the current exception.</source>
          <target state="translated">获取导致当前异常的 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> 实例。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>An object that describes the error that caused the current exception.</source>
          <target state="translated">描述导致当前异常的错误的一个对象。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The <ph id="ph1">&lt;see cref="P:System.Exception.InnerException" /&gt;</ph> property returns the same value as was passed into the <ph id="ph2">&lt;see cref="M:System.Exception.#ctor(System.String,System.Exception)" /&gt;</ph> constructor, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the inner exception value was not supplied to the constructor.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Exception.InnerException" /&gt;</ph> 属性返回的值与传递到 <ph id="ph2">&lt;see cref="M:System.Exception.#ctor(System.String,System.Exception)" /&gt;</ph> 构造函数中的值相同，如果没有向构造函数提供内部异常值，则为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>This property is read-only.</source>
          <target state="translated">此属性是只读的。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>When an exception <ph id="ph1">`X`</ph> is thrown as a direct result of a previous exception <ph id="ph2">`Y`</ph>, the <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property of <ph id="ph4">`X`</ph> should contain a reference to <ph id="ph5">`Y`</ph>.</source>
          <target state="translated">异常时<ph id="ph1">`X`</ph>引发作为前一个异常的直接结果<ph id="ph2">`Y`</ph>、<ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph>属性<ph id="ph4">`X`</ph>应包含对引用<ph id="ph5">`Y`</ph>。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>Use the <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property to obtain the set of exceptions that led to the current exception.</source>
          <target state="translated">使用 <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> 属性获取导致当前异常的异常集。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>You can create a new exception that catches an earlier exception.</source>
          <target state="translated">你可以创建一个新异常捕获前面的异常。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The code that handles the second exception can make use of the additional information from the earlier exception to handle the error more appropriately.</source>
          <target state="translated">第二个异常可以进行的句柄使用以前的异常的附加信息的错误更恰当地处理代码。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>Suppose that there is a function that reads a file and formats the data from that file.</source>
          <target state="translated">假定有读取文件并格式化该文件中的数据的函数。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>In this example, as the code tries to read the file, an <ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> is thrown.</source>
          <target state="translated">在此示例中，此代码将尝试读取的文件，作为<ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The function catches the <ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> and throws a <ph id="ph2">&lt;xref:System.IO.FileNotFoundException&gt;</ph>.</source>
          <target state="translated">该函数捕捉<ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph>并引发<ph id="ph2">&lt;xref:System.IO.FileNotFoundException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The <ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> could be saved in the <ph id="ph2">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property of the <ph id="ph3">&lt;xref:System.IO.FileNotFoundException&gt;</ph>, enabling the code that catches the <ph id="ph4">&lt;xref:System.IO.FileNotFoundException&gt;</ph> to examine the cause of the initial error.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph>无法保存在<ph id="ph2">&lt;xref:System.Exception.InnerException%2A&gt;</ph>属性<ph id="ph3">&lt;xref:System.IO.FileNotFoundException&gt;</ph>，启用捕获的代码<ph id="ph4">&lt;xref:System.IO.FileNotFoundException&gt;</ph>来检查初始错误的原因。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property, which holds a reference to the inner exception, is set upon initialization of the exception object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph>属性，保存对内部异常的引用，设置进行初始化的异常对象。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.InnerException">
          <source>The following example demonstrates throwing and catching an exception that references an inner exception.</source>
          <target state="translated">下面的示例说明如何引发和捕获引用内部异常的异常。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="P:System.Exception.Message">
          <source>Gets a message that describes the current exception.</source>
          <target state="translated">获取描述当前异常的消息。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The error message that explains the reason for the exception, or an empty string ("").</source>
          <target state="translated">解释异常原因的错误消息或空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Error messages target the developer who is handling the exception.</source>
          <target state="translated">错误消息目标的开发人员正在处理异常。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The text of the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property should completely describe the error and, when possible, should also explain how to correct the error.</source>
          <target state="translated">文本<ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph>属性应当完整地描述该错误，并且如果可能，还应阐释如何更正该错误。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Top-level exception handlers may display the message to end-users, so you should ensure that it is grammatically correct and that each sentence of the message ends with a period.</source>
          <target state="translated">顶级异常处理程序可能会给最终用户，显示消息，因此您应确保它是语法正确，且消息的每个句子分解以句点结尾。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Do not use question marks or exclamation points.</source>
          <target state="translated">不要使用问号或感叹号。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>If your application uses localized exception messages, you should ensure that they are accurately translated.</source>
          <target state="translated">如果你的应用程序使用本地化的异常消息，应确保它们准确地转换。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Do not disclose sensitive information in exception messages without checking for the appropriate permissions.</source>
          <target state="translated">而不检查适当的权限不披露异常消息中的敏感信息。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The value of the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property is included in the information returned by <ph id="ph2">&lt;xref:System.Exception.ToString%2A&gt;</ph>.The <ph id="ph3">&lt;xref:System.Exception.Message%2A&gt;</ph> property is set only when creating an <ph id="ph4">&lt;xref:System.Exception&gt;</ph>.</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph>中返回的信息包括属性<ph id="ph2">&lt;xref:System.Exception.ToString%2A&gt;</ph>。<ph id="ph3">&lt;xref:System.Exception.Message%2A&gt;</ph>属性仅在创建时设置<ph id="ph4">&lt;xref:System.Exception&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>If no message was supplied to the constructor for the current instance, the system supplies a default message that is formatted using the current system culture.</source>
          <target state="translated">如果为当前实例的构造函数不硅酮任何消息，则系统将提供默认消息的格式都是使用当前系统区域性。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Windows Runtime and <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph></source>
          <target state="translated">Windows 运行时和 <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph> and <ph id="ph2">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, the fidelity of error messages from exceptions that are propagated from Windows Runtime types and members that are not part of the .NET Framework is improved.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>和<ph id="ph2">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>，改进了从 Windows 运行时类型和成员不是.NET Framework 的一部分从传播的异常的错误消息的保真度。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>In particular, exception messages from Visual C++ component extensions (C++/CX) are now propagated back into .NET Framework <ph id="ph1">&lt;xref:System.Exception&gt;</ph> objects.</source>
          <target state="translated">具体而言，异常消息从 Visual c + + 组件扩展 (C + + /cli CX) 现在传播回.NET Framework<ph id="ph1">&lt;xref:System.Exception&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The following code example throws and then catches an <ph id="ph1">&lt;xref:System.Exception&gt;</ph> exception and displays the exception's text message using the <ph id="ph2">&lt;xref:System.Exception.Message%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例引发，然后捕捉<ph id="ph1">&lt;xref:System.Exception&gt;</ph>异常并显示异常的文本消息使用<ph id="ph2">&lt;xref:System.Exception.Message%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>If you throw an exception from a property, and you need to refer in the text of <ph id="ph1">&lt;see cref="P:System.Exception.Message" /&gt;</ph> to the property argument that you set or get, use "value" as the name of the property argument.</source>
          <target state="translated">如果你从引发异常的属性，并且你需要引用中的文本<ph id="ph1">&lt;see cref="P:System.Exception.Message" /&gt;</ph>到您设置或获取的属性参数，使用"value"作为属性自变量的名称。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The <ph id="ph1">&lt;see cref="P:System.Exception.Message" /&gt;</ph> property is overridden in classes that require control over message content or format.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Exception.Message" /&gt;</ph>需要控制消息内容或格式的类中重写属性。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>Application code typically accesses this property when it needs to display information about an exception that has been caught.</source>
          <target state="translated">在需要显示有关已捕获的异常的信息时，应用程序代码通常会访问此属性。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Message">
          <source>The error message should be localized.</source>
          <target state="translated">应本地化的错误消息。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="E:System.Exception.SerializeObjectState">
          <source>Occurs when an exception is serialized to create an exception state object that contains serialized data about the exception.</source>
          <target state="translated">当异常被序列化用来创建包含有关该异常的徐列出数据的异常状态对象时会出现该问题。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The exception state object implements the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISafeSerializationData&gt;</ph> interface.</source>
          <target state="translated">异常状态对象实现<ph id="ph1">&lt;xref:System.Runtime.Serialization.ISafeSerializationData&gt;</ph>接口。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>When the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event is subscribed to, the exception is deserialized and created as an empty exception.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph>订阅事件，此异常将反序列化并创建为空的异常。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The exception's constructor is not run, and the exception state is also deserialized.</source>
          <target state="translated">异常的构造函数时不运行，并且还反序列化的异常状态。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A&gt;</ph> callback method of the exception state object is then notified so that it can push deserialized data into the empty exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A&gt;</ph>然后通知有关的异常状态对象的回调方法，以便它可以将反序列化的数据推送到空的例外。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event enables transparent exception types to serialize and deserialize exception data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph>事件启用透明异常类型进行序列化和反序列化异常数据。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>Transparent code can execute commands within the bounds of the permission set it is operating within, but cannot execute, call, derive from, or contain critical code.</source>
          <target state="translated">透明代码可以在其运行的权限集边界内执行命令，但不能执行、 调用、 派生自或包含关键代码。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>If the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event is not subscribed to, deserialization occurs as usual using the <ph id="ph2">&lt;xref:System.Exception.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph>事件未订阅，像往常一样使用反序列化时发生<ph id="ph2">&lt;xref:System.Exception.%23ctor%2A&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>Typically, a handler for the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event is added in the exception's constructor to provide for its serialization.</source>
          <target state="translated">通常情况下，处理程序<ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph>事件被添加为其序列化提供的异常的构造函数中。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>But because the constructor is not executed when the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event handler executes, serializing a deserialized exception can throw a <ph id="ph2">&lt;xref:System.Runtime.Serialization.SerializationException&gt;</ph> exception when you try to deserialize the exception.</source>
          <target state="translated">但是，由于构造函数不是时执行<ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph>事件处理程序执行，则序列化反序列化的异常可以引发<ph id="ph2">&lt;xref:System.Runtime.Serialization.SerializationException&gt;</ph>尝试反序列化异常时出现异常。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>To avoid this, you should also add the handler for the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event in the <ph id="ph2">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">若要避免此问题，则还应添加的处理程序<ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph>中的事件<ph id="ph2">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>See the Examples section for an illustration.</source>
          <target state="translated">请参阅方面的演示示例部分。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The following example defines a <ph id="ph1">`BadDivisionException`</ph> that handles the <ph id="ph2">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event.</source>
          <target state="translated">下面的示例定义<ph id="ph1">`BadDivisionException`</ph>用于处理<ph id="ph2">&lt;xref:System.Exception.SerializeObjectState&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>It also contains a state object, which is a nested structure named <ph id="ph1">`BadDivisionExceptionState`</ph> that implements the <ph id="ph2">&lt;xref:System.Runtime.Serialization.ISafeSerializationData&gt;</ph> interface.</source>
          <target state="translated">它还包含一个状态对象，它是嵌套结构名为<ph id="ph1">`BadDivisionExceptionState`</ph>实现<ph id="ph2">&lt;xref:System.Runtime.Serialization.ISafeSerializationData&gt;</ph>接口。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>The <ph id="ph1">`BadDivisionException`</ph> exception is thrown when a floating-point division by zero occurs.</source>
          <target state="translated"><ph id="ph1">`BadDivisionException`</ph>浮点被零除发生时引发异常。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>During the first division by zero, the example instantiates a <ph id="ph1">`BadDivisionException`</ph> object, serializes it, and throws the exception.</source>
          <target state="translated">在第一个除数为零，该示例实例化<ph id="ph1">`BadDivisionException`</ph>对象，序列化，并引发异常。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>When subsequent divisions by zero occur, the example deserializes the  previously serialized object, reserializes it, and throws the exception.</source>
          <target state="translated">出现被零除的后续部门时，本示例反序列化之前序列化的对象，重新序列化，并引发异常。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>To provide for object serialization, deserialization, reserialization, and deserialization, the example adds the <ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph> event handler both in the <ph id="ph2">`BadDivisionException`</ph> class constructor and in the <ph id="ph3">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">若要提供的对象序列化、 反序列化、 重新，序列化和反序列化，该示例将添加<ph id="ph1">&lt;xref:System.Exception.SerializeObjectState&gt;</ph>中的事件处理程序两个<ph id="ph2">`BadDivisionException`</ph>类构造函数并在<ph id="ph3">&lt;xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType&gt;</ph>实现。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Exception.SerializeObjectState">
          <source>If this event is subscribed to and used, all derived types that follow in the inheritance hierarchy must implement the same serialization mechanism.</source>
          <target state="translated">如果此事件是订阅和使用，请按照在继承层次结构中的所有派生的类型必须实现相同的序列化机制。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="P:System.Exception.Source">
          <source>Gets or sets the name of the application or the object that causes the error.</source>
          <target state="translated">获取或设置导致错误的应用程序或对象的名称。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Source">
          <source>The name of the application or the object that causes the error.</source>
          <target state="translated">导致错误的应用程序或对象的名称。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Source">
          <source>If the <ph id="ph1">&lt;xref:System.Exception.Source%2A&gt;</ph> property is not set explicitly, the runtime automatically sets it to the name of the assembly in which the exception originated.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Exception.Source%2A&gt;</ph>属性未显式设置，运行时自动将其设置为产生异常的程序集的名称。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.Source">
          <source>The following example throws an <ph id="ph1">`Exception`</ph> that sets the <ph id="ph2">`Source`</ph> property in its constructor and then catches the exception and displays <ph id="ph3">`Source`</ph>.</source>
          <target state="translated">下面的示例引发<ph id="ph1">`Exception`</ph>设置<ph id="ph2">`Source`</ph>属性在其构造函数，然后捕捉异常并显示<ph id="ph3">`Source`</ph>。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="P:System.Exception.Source">
          <source>The object must be a runtime <ph id="ph1">&lt;see cref="N:System.Reflection" /&gt;</ph> object</source>
          <target state="translated">对象必须是运行时 <ph id="ph1">&lt;see cref="N:System.Reflection" /&gt;</ph> 对象</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="P:System.Exception.StackTrace">
          <source>Gets a string representation of the immediate frames on the call stack.</source>
          <target state="translated">获取调用堆栈上的即时框架字符串表示形式。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>A string that describes the immediate frames of the call stack.</source>
          <target state="translated">用于描述调用堆栈的直接帧的字符串。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The execution stack keeps track of all the methods that are in execution at a given instant.</source>
          <target state="translated">执行堆栈将跟踪在给定时刻正在执行的所有方法。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>A trace of the method calls is called a stack trace.</source>
          <target state="translated">对方法调用的跟踪称为堆栈跟踪。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The stack trace listing provides a way to follow the call stack to the line number in the method where the exception occurs.</source>
          <target state="translated">堆栈跟踪列表提供了一种方法为跟踪调用堆栈中方法的行号出现异常。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The <ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph> property returns the frames of the call stack that originate at the location where the exception was thrown.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph>属性返回源自引发异常的位置的调用堆栈帧。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>You can obtain information about additional frames in the call stack by creating a new instance of the <ph id="ph1">&lt;xref:System.Diagnostics.StackTrace?displayProperty=nameWithType&gt;</ph> class and using its <ph id="ph2">&lt;xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">可以通过创建的新实例中获取有关调用堆栈中的其他帧的信息<ph id="ph1">&lt;xref:System.Diagnostics.StackTrace?displayProperty=nameWithType&gt;</ph>类并使用其<ph id="ph2">&lt;xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The common language runtime (CLR) updates the stack trace whenever an exception is thrown in application code (by using the <ph id="ph1">`throw`</ph> keyword).</source>
          <target state="translated">每当应用程序代码中引发异常时，公共语言运行时 (CLR) 将更新的堆栈跟踪 (通过使用<ph id="ph1">`throw`</ph>关键字)。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>If the exception was rethrown in a method that is different than the method where it was originally thrown, the stack trace contains both the location in the method where the exception was originally thrown, and the location in the method where the exception was rethrown.</source>
          <target state="translated">如果已将不同于该方法最初抛方法中重新引发异常，堆栈跟踪包含其中最初引发异常，在方法中的位置和方法中异常所在的位置重新引发。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>If the exception is thrown, and later rethrown, in the same method, the stack trace only contains the location where the exception was rethrown and does not include the location where the exception was originally thrown.</source>
          <target state="translated">如果引发，并稍后重新引发，在同一方法中，异常的堆栈跟踪将仅包含的位置重新引发异常并不包括最初引发异常的位置。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The <ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph> property may not report as many method calls as expected because of code transformations, such as inlining, that occur during optimization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.StackTrace%2A&gt;</ph>属性可能不报告的由于代码转换，如预期的任意多个方法调用内联，在优化过程中发生。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The following code example throws an <ph id="ph1">`Exception`</ph> and then catches it and displays a stack trace using the <ph id="ph2">`StackTrace`</ph> property.</source>
          <target state="translated">下面的代码示例引发<ph id="ph1">`Exception`</ph>，捕获它，然后显示堆栈跟踪使用<ph id="ph2">`StackTrace`</ph>属性。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>The <ph id="ph1">&lt;see langword="StackTrace" /&gt;</ph> property is overridden in classes that require control over the stack trace content or format.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="StackTrace" /&gt;</ph>需要控制的堆栈跟踪内容或格式的类中重写属性。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>By default, the stack trace is captured immediately before an exception object is thrown.</source>
          <target state="translated">默认情况下，堆栈跟踪被捕获之前引发的异常对象。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.StackTrace">
          <source>Use <ph id="ph1">&lt;see cref="P:System.Environment.StackTrace" /&gt;</ph> to get stack trace information when no exception is being thrown.</source>
          <target state="translated">使用<ph id="ph1">&lt;see cref="P:System.Environment.StackTrace" /&gt;</ph>时所不引发任何异常获取堆栈跟踪信息。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="P:System.Exception.TargetSite">
          <source>Gets the method that throws the current exception.</source>
          <target state="translated">获取引发当前异常的方法。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.TargetSite">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that threw the current exception.</source>
          <target state="translated">引发当前异常的 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.TargetSite">
          <source>If the method that throws this exception is not available and the stack trace is not a null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic), <ph id="ph2">&lt;xref:System.Exception.TargetSite%2A&gt;</ph> obtains the method from the stack trace.</source>
          <target state="translated">如果引发此异常的方法不可用并且堆栈跟踪不是空引用 (<ph id="ph1">`Nothing`</ph>在 Visual Basic 中)，<ph id="ph2">&lt;xref:System.Exception.TargetSite%2A&gt;</ph>从堆栈跟踪获取该方法。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.TargetSite">
          <source>If the stack trace is a null reference, <ph id="ph1">&lt;xref:System.Exception.TargetSite%2A&gt;</ph> also returns a null reference.</source>
          <target state="translated">如果堆栈跟踪为空引用，<ph id="ph1">&lt;xref:System.Exception.TargetSite%2A&gt;</ph> 也返回空引用。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.TargetSite">
          <source>The <ph id="ph1">&lt;xref:System.Exception.TargetSite%2A&gt;</ph> property may not accurately report the name of the method in which an exception was thrown if the exception handler handles an exception across application domain boundaries.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.TargetSite%2A&gt;</ph>属性可能无法准确报告在其中如果异常处理程序处理的异常跨应用程序域边界引发了异常的方法的名称。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Exception.TargetSite">
          <source>The following code example throws an <ph id="ph1">`Exception`</ph> and then catches it and displays the originating method using the <ph id="ph2">`TargetSite`</ph> property.</source>
          <target state="translated">下面的代码示例引发<ph id="ph1">`Exception`</ph>然后捕获它并显示原始方法使用<ph id="ph2">`TargetSite`</ph>属性。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Exception.ToString">
          <source>Creates and returns a string representation of the current exception.</source>
          <target state="translated">创建并返回当前异常的字符串表示形式。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Exception.ToString">
          <source>A string representation of the current exception.</source>
          <target state="translated">当前异常的字符串表示形式。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source><ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> returns a representation of the current exception that is intended to be understood by humans.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> 返回当前异常，但应为人所理解的表示形式。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>Where the exception contains culture-sensitive data, the string representation returned by <ph id="ph1">`ToString`</ph> is required to take into account the current system culture.</source>
          <target state="translated">当该异常包含区分区域性的数据，返回的字符串表示<ph id="ph1">`ToString`</ph>需要当前系统区域性考虑在内。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>Although there are no exact requirements for the format of the returned string, it should attempt to reflect the value of the object as perceived by the user.</source>
          <target state="translated">虽然没有返回字符串的确切要求的格式，它应尝试反映为从用户的角度对象的值。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>The default implementation of <ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> obtains the name of the class that threw the current exception, the message, the result of calling <ph id="ph2">&lt;xref:System.Exception.ToString%2A&gt;</ph> on the inner exception, and the result of calling <ph id="ph3">&lt;xref:System.Environment.StackTrace%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">默认实现<ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph>获取引发当前异常，消息、 调用的结果的类名称<ph id="ph2">&lt;xref:System.Exception.ToString%2A&gt;</ph>上该内部异常，且调用<ph id="ph3">&lt;xref:System.Environment.StackTrace%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>If any of these members is <ph id="ph1">`null`</ph>, its value is not included in the returned string.</source>
          <target state="translated">如果任何这些成员为<ph id="ph1">`null`</ph>，其值不包括在返回的字符串。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>If there is no error message or if it is an empty string (""), then no error message is returned.</source>
          <target state="translated">如果没有任何错误消息，或如果它是空字符串 ("")，则不返回任何错误消息。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>The name of the inner exception and the stack trace are returned only if they are not <ph id="ph1">`null`</ph>.</source>
          <target state="translated">仅当它们不是返回的内部异常和堆栈跟踪的名称<ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">此方法重写 <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>The following example causes an exception and displays the result of calling <ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph> on that exception.</source>
          <target state="translated">下面的示例导致引发异常并显示调用<ph id="ph1">&lt;xref:System.Exception.ToString%2A&gt;</ph>上该异常。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Exception.ToString">
          <source>Note that the <ph id="ph1">&lt;xref:System.Exception.ToString%2A?displayProperty=nameWithType&gt;</ph> method is called implicitly when the Exception class instance appears in the argument list of the <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">请注意，<ph id="ph1">&lt;xref:System.Exception.ToString%2A?displayProperty=nameWithType&gt;</ph>的参数列表中出现的异常类实例时，方法隐式调用<ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>