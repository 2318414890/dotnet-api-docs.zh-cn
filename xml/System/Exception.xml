<Type Name="Exception" FullName="System.Exception">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d3cd7feda3f45d855645a0e6ecb699bd9f871df9" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34254656" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示在应用程序执行过程中发生的错误。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类是所有异常的基类。 发生错误时，系统或当前正在执行的应用程序报告它通过引发异常，其中包含有关错误的信息。 引发异常后，它处理应用程序或通过默认异常处理程序。  
  
 本节内容：  
  
 [错误和异常](#Errors)   
 [Try/catch 块](#TryCatch)   
 [异常类型的功能](#Features)   
 [异常类属性](#Properties)   
 [性能注意事项](#Performance)   
 [重新引发异常](#Rethrow)   
 [选择标准异常](#Standard)   
 [实现自定义异常](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>错误和异常  
 运行时错误可能的原因有多种多样。 但是，并非所有错误应在代码中作为异常都处理。 以下是一些可以发生在运行的时和合适的方法，可以对其进行响应的错误的类别。  
  
-   **用法错误。** 用法错误表示可能会导致异常的程序逻辑中的错误。 但是，不能通过异常处理，但通过修改故障代码，则应该解决该错误。 例如，重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法在下面的示例假定`obj`自变量必须始终为非 null。  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     <xref:System.NullReferenceException>结果的异常时`obj`是`null`可通过修改源代码来显式测试之前调用的 null 消除<xref:System.Object.Equals%2A?displayProperty=nameWithType>重写和重新编译。 下面的示例包含处理的已更正的源代码`null`自变量。  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     除了使用异常处理的用法错误，你可以使用<xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType>的方法来确定在调试版本中的用法错误和<xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType>的方法来确定在调试和发布的用法错误生成。 有关详细信息，请参阅[托管代码中的断言](/visualstudio/debugger/assertions-in-managed-code)。  
  
-   **程序错误。** 程序错误是一个运行时错误，无法一定避免通过编写无 bug 的代码。  
  
     在某些情况下，程序错误可能反映预期或例程错误条件。 在这种情况下，你可能想要避免使用异常处理来处理程序错误并改用重试该操作。 例如，如果用户需要输入特定的格式的日期，你可以分析日期字符串通过调用<xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType>方法，它返回<xref:System.Boolean>值，该值指示是否确保分析操作成功，而不是使用<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>方法，将引发<xref:System.FormatException>异常如果日期字符串不能转换为<xref:System.DateTime>值。 同样，如果用户尝试打开不存在的文件，您可以先调用<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>方法来检查该文件是否存在且，如果不是，提示用户是否他或她想要创建它。  
  
     在其他情况下，程序错误反映可以在你的代码进行处理的意外的错误条件。 例如，即使你已检查，以确保存在的文件，它可能会删除之前你可以打开它，或者可能已损坏。 在这种情况下，尝试打开该文件，方法是实例化<xref:System.IO.StreamReader>对象或调用<xref:System.IO.File.Open%2A>方法可能会引发<xref:System.IO.FileNotFoundException>异常。 在这些情况下，应使用异常处理来从错误中恢复。  
  
-   **系统故障。** 系统故障是一个运行时错误，不能有意义的方式来以编程方式处理。 例如，任何方法可能会引发<xref:System.OutOfMemoryException>异常如果公共语言运行时无法分配更多内存。 通常，通过使用异常处理不处理系统故障。 相反，你可能能够使用事件，如<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>并调用<xref:System.Environment.FailFast%2A?displayProperty=nameWithType>记录异常信息并通知失败的用户，在应用程序终止之前的方法。  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Try/catch 块  
 公共语言运行时提供了基于异常对象，作为的表示和分离的程序代码和异常处理代码转换为异常处理模型`try`块和`catch`块。 可以有一个或多个`catch`块，每个设计为处理特定类型的异常，或者一个用来过滤掉更具体的异常比另一个块的块。  
  
 如果应用程序处理的应用程序代码块的执行期间发生的异常，必须将代码放置在`try`语句称为`try`块。 处理引发的异常的应用程序代码`try`块放在`catch`语句称为`catch`块。 零个或多`catch`与之关联块`try`块，和每个`catch`块包含确定它处理的异常的类型的类型筛选器。  
  
 中发生异常时`try`块中，系统搜索关联`catch`阻止，直到它放在应用程序代码中，它们出现的顺序`catch`处理异常的块。 A`catch`块处理类型的异常`T`如果 catch 块的类型筛选器指定`T`或任何类型`T`派生自。 系统将停止搜索后找到第一个`catch`处理异常的块。 为此，在应用程序代码中，`catch`之前，必须指定处理某一类型的块`catch`处理其基类型，如本节后面的示例中所示的块。 处理的 catch 块`System.Exception`最后指定。  
  
 如果没有任何`catch`块与当前关联`try`块处理该异常，且当前`try`块嵌套在其他`try`在当前的调用中，阻止`catch`块与下一步封闭`try`搜索块。 如果没有`catch`异常块找不到，则系统搜索前面的嵌套级别中当前的调用。 如果没有`catch`阻止对于当前的调用中找到的异常，异常调用堆栈中向上传递，并将上一个堆栈帧，将会搜索`catch`处理异常的块。 直到处理该异常或不详细帧调用堆栈上存在，将继续调用堆栈的搜索。 如果没有找到达到调用堆栈的顶部`catch`处理异常，默认异常处理程序块对其进行处理和在应用程序终止。  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>异常类型的功能  
 异常类型支持以下功能：  
  
-   描述错误的用户可读文本。 发生异常时，运行时发出通知的错误性质的用户并提供建议操作提供文本消息，来解决该问题。 此文本消息会保留在<xref:System.Exception.Message%2A>异常对象的属性。 在创建期间的异常对象，可以将文本字符串传递给构造函数来描述该特定异常的详细信息。 如果没有错误消息参数提供给构造函数，则使用默认的错误消息。 有关更多信息，请参见 <xref:System.Exception.Message%2A> 属性。  
  
-   调用堆栈时抛出异常的状态。 <xref:System.Exception.StackTrace%2A>属性包含可以用于确定在代码中出现错误的堆栈跟踪。 堆栈跟踪列出所有调用的方法和源文件位置的调用中的行号。  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>异常类属性  
 <xref:System.Exception>类包括多个属性可以帮助识别的代码位置、 类型、 帮助文件和异常的原因： <xref:System.Exception.StackTrace%2A>， <xref:System.Exception.InnerException%2A>， <xref:System.Exception.Message%2A>， <xref:System.Exception.HelpLink%2A>， <xref:System.Exception.HResult%2A>， <xref:System.Exception.Source%2A>，<xref:System.Exception.TargetSite%2A>，和<xref:System.Exception.Data%2A>。  
  
 当两个或多个异常，之间存在因果关系时<xref:System.Exception.InnerException%2A>属性维护此信息。 将外部异常情况以响应此内部异常。 处理外部异常的代码可以使用来自前面的内部异常的信息更恰当处理的错误。 关于异常的补充信息可以存储为中的键/值对的集合<xref:System.Exception.Data%2A>属性。  
  
 异常对象的创建过程传递给构造函数的错误消息字符串应本地化，并通过使用可以从资源文件中提供<xref:System.Resources.ResourceManager>类。 本地化资源有关的详细信息，请参阅[创建附属程序集](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)和[打包和部署资源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)主题。  
  
 若要为用户提供有关异常发生的原因的大量信息<xref:System.Exception.HelpLink%2A>属性可以保存到的帮助文件的 URL （或 URN）。  
  
 <xref:System.Exception>类使用 HRESULT COR_E_EXCEPTION，其值 0x80131500。  
  
 有关的实例的初始属性值的列表<xref:System.Exception>类，请参阅<xref:System.Exception.%23ctor%2A>构造函数。  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>性能注意事项  
 可以引发或处理异常会消耗大量系统资源和执行时间。 引发异常，只是为了处理确实异常的情况，不能处理可预测的事件或流控制。 例如，在某些情况下，当你要开发一个类库，例如是合理的方法自变量无效，因为你希望你使用有效的参数来调用的方法引发异常。 无效的方法自变量，如果它并不是使用错误的结果意味着，出现了异常。 相反，如果用户输入无效，因为会偶尔会输入无效数据的用户确实引发了异常。 相反，提供重试机制，以便用户可以输入有效的输入。 也不应使用异常来处理用法错误。 请改用[断言](/visualstudio/debugger/assertions-in-managed-code)以确定并更正用法错误。  
  
 返回代码时足够; 此外，确实引发了异常没有转换为异常，则返回代码并不定期执行 catch 异常，忽略它，然后继续进行处理。  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>重新引发异常  
 在许多情况下，异常处理程序只是想要传递到调用方的异常。 这通常发生在：  
  
-   反过来包装对.NET Framework 类库或其他类库中的方法的调用的类库。  
  
-   应用程序或遇到严重异常的库。 异常处理程序可以将异常记录，然后重新引发异常。  
  
 重新引发异常的建议的方法是只需使用[引发](~/docs/csharp/language-reference/keywords/throw.md)C# 中的语句和[引发](~/docs/visual-basic/language-reference/statements/throw-statement.md)在 Visual Basic 中不包含表达式的语句。 这可确保当该异常会传播到调用方保留了所有调用堆栈信息。 下面的示例阐释了这一点。 字符串扩展方法， `FindOccurrences`，包装到一个或多个调用<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>而无需事先验证其参数。  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 然后，在调用方调用`FindOccurrences`两次。 在第二次调用`FindOccurrences`，调用方传递`null`作为搜索字符串，哪些用例<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>方法会引发<xref:System.ArgumentNullException>异常。 处理此异常`FindOccurrences`方法并传递的回调用方。 由于不使用表达式使用 throw 语句，该示例输出所示保留调用堆栈。  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 相反，如果通过使用重新引发异常  
  
```csharp  
throw e  
```  
  
```vb  
Throw e  
```  
  
 不保留语句，完整的调用堆栈，并且该示例将生成以下输出：  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 稍微繁琐的替代方法是引发一个新的异常，并保留在内部异常的原始异常的调用堆栈信息。 然后，调用方可以使用新的异常<xref:System.Exception.InnerException%2A>属性检索堆栈帧和有关原始异常的其他信息。 在这种情况下，throw 语句是：  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 处理异常的用户代码必须知道<xref:System.Exception.InnerException%2A>属性包含原始异常，有关的信息，如下面的异常处理程序所示。  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>选择标准异常  
 如果必须引发异常，通常可以使用.NET Framework 而不是实现自定义异常中的现有异常类型。 你应使用这两个条件下的标准异常类型：  
  
-   引发由用法错误导致的异常的 (即，通过所做的开发人员正在调用你的方法的程序逻辑中的错误)。 通常情况下，会引发异常如<xref:System.ArgumentException>， <xref:System.ArgumentNullException>， <xref:System.InvalidOperationException>，或<xref:System.NotSupportedException>。 您可以将其提供给异常对象的构造函数时实例化的异常对象应描述错误，以便开发人员可以修复此错误的字符串。 有关更多信息，请参见 <xref:System.Exception.Message%2A> 属性。  
  
-   正在处理的错误，可以传递给调用方与现有的.NET Framework 异常。 您应引发派生程度最大可能的异常。 例如，如果某个方法要求自变量为枚举类型的有效成员，则应引发<xref:System.ComponentModel.InvalidEnumArgumentException>（大多数派生类） 而非<xref:System.ArgumentException>。  
  
 下表列出了常见的异常类型和在其下会引发它们的条件。  
  
|例外|条件|  
|---------------|---------------|  
|<xref:System.ArgumentException>|传递给方法的非 null 参数无效。|  
|<xref:System.ArgumentNullException>|传递给方法的自变量是`null`。|  
|<xref:System.ArgumentOutOfRangeException>|参数超出有效值的范围。|  
|<xref:System.IO.DirectoryNotFoundException>|目录路径的一部分无效。|  
|<xref:System.DivideByZeroException>|整数形式分母或<xref:System.Decimal>除法运算为零。|  
|<xref:System.IO.DriveNotFoundException>|驱动器不可用或不存在。|  
|<xref:System.IO.FileNotFoundException>|文件不存在。|  
|<xref:System.FormatException>|值不在相应的格式无法转换从字符串转换方法如`Parse`。|  
|<xref:System.IndexOutOfRangeException>|索引是数组或集合的界限之外。|  
|<xref:System.InvalidOperationException>|方法调用在对象的当前状态无效。|  
|<xref:System.Collections.Generic.KeyNotFoundException>|找不到用于访问集合中的成员的指定的键。|  
|<xref:System.NotImplementedException>|未实现方法或操作。|  
|<xref:System.NotSupportedException>|不支持的方法或操作。|  
|<xref:System.ObjectDisposedException>|对已释放的对象执行操作。|  
|<xref:System.OverflowException>|算术、 强制转换或转换运算导致溢出。|  
|<xref:System.IO.PathTooLongException>|路径或文件的名称超过了系统定义的最大长度。|  
|<xref:System.PlatformNotSupportedException>|当前平台上不支持该操作。|  
|<xref:System.RankException>|具有错误维数的数组传递到方法。|  
|<xref:System.TimeoutException>|分配给操作的时间间隔已过期。|  
|<xref:System.UriFormatException>|使用无效的统一资源标识符 (URI)。|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>实现自定义异常  
 在以下情况下，使用现有的.NET Framework 异常来处理错误条件不能满足：  
  
-   当异常反映唯一程序错误，无法映射到现有的.NET Framework 异常。  
  
-   异常需要处理的是不同于适用于现有的.NET Framework 异常或异常的处理时必须存在类似的例外从消除歧义。 例如，如果引发了<xref:System.ArgumentOutOfRangeException>异常分析的字符串的目标整数类型的范围超出了数值表示形式时，你不想要使用相同的异常导致的调用方不提供的错误适当约束的值调用该方法时。  
  
 <xref:System.Exception>类是.NET Framework 中的所有异常的基类。 许多派生的类依赖于的成员的继承行为<xref:System.Exception>类; 它们不重写的成员<xref:System.Exception>，也不定义任何唯一的成员。  
  
 若要定义你自己的异常类：  
  
1.  定义继承自的类<xref:System.Exception>。 如有必要，定义你的类提供有关异常的其他信息所需的任何唯一成员。 例如，<xref:System.ArgumentException>类包括<xref:System.ArgumentException.ParamName%2A>指定其参数导致异常的参数的名称的属性和<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>属性包括<xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A>属性，指示超时间隔。  
  
2.  如有必要，重写任何继承的成员你想要更改或修改其功能。 请注意，大多数现有派生的类<xref:System.Exception>不重写继承成员的行为。  
  
3.  确定你的自定义异常对象是否是可序列化。 序列化可让你保存有关异常的信息，并允许要由服务器和客户端代理在远程处理的上下文中共享的异常信息。 若要使该异常对象可序列化，将其与标记<xref:System.SerializableAttribute>属性。  
  
4.  定义异常类的构造函数。 通常情况下，异常类都有一个或多个以下构造函数：  
  
    -   <xref:System.Exception.%23ctor>它使用默认值初始化新的异常对象的属性。  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>其中初始化具有指定的错误消息的新异常对象。  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>其中初始化具有指定的错误消息和内部异常的新异常对象。  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>即`protected`初始化中的新异常对象的构造函数的序列化数据。 如果你选择使异常对象可序列化，则应实现此构造函数。  
  
 下面的示例演示如何使用自定义异常类。 它定义`NotPrimeException`时客户端试图通过指定不是主要起始数字中检索的质数序列引发的异常。 异常定义一个新属性， `NonPrime`，返回非质数数字引发异常的异常。 除了实现受保护的无参数构造函数和的构造函数<xref:System.Runtime.Serialization.SerializationInfo>和<xref:System.Runtime.Serialization.StreamingContext>参数对于序列化，`NotPrimeException`类定义三个其他的构造函数来支持`NonPrime`属性。  每个构造函数调用除了保留值的非-质数基类构造函数。 `NotPrimeException`类还将标有<xref:System.SerializableAttribute>属性。  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 `PrimeNumberGenerator`类显示在下面的示例使用选筛的埃拉托色尼斯来计算质数从 2 到客户端对其类构造函数的调用中指定的限制的序列。 `GetPrimesFrom`方法返回大于或等于指定的下限的所有质数但引发`NotPrimeException`如果该较低的限制不是质数。  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 下面的示例调用两个`GetPrimesFrom`方法与非质数，其中之一是跨应用程序域边界。 在这两种情况下，此异常将引发，并在客户端代码中成功处理。  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows 运行时和 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 在[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]为[!INCLUDE[win8](~/includes/win8-md.md)]，通过非.NET Framework 堆栈帧传播异常时会通常丢失某些异常信息。 从开始[!INCLUDE[net_v451](~/includes/net-v451-md.md)]和[!INCLUDE[win81](~/includes/win81-md.md)]，公共语言运行时将继续使用原始<xref:System.Exception>抛出除非该异常在非.NET Framework 堆栈帧修改的对象。  
  
   
  
## Examples  
 下面的示例演示`catch`定义要处理的块<xref:System.ArithmeticException>错误。 这`catch`块还捕捉<xref:System.DivideByZeroException>错误，因为<xref:System.DivideByZeroException>派生自<xref:System.ArithmeticException>并且没有任何`catch`为显式定义的块<xref:System.DivideByZeroException>错误。  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Exception" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Exception" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数将新实例的 <xref:System.Exception.Message%2A> 属性初始化为系统提供的消息，该消息描述错误并考虑当前系统区域性。  
  
 所有派生的类应提供此默认构造函数。 下表显示 <xref:System.Exception> 的实例的初始属性值。  
  
|Property|“值”|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|空引用（在 Visual Basic 中为 `Nothing`）。|  
|<xref:System.Exception.Message%2A>|系统提供的本地化说明。|  
  
   
  
## Examples  
 下面的代码示例派生`Exception`，它使用预定义的消息。 代码演示了将无参数构造函数用于派生的类和基`Exception`类。  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">描述错误的消息。</param>
        <summary>用指定的错误消息初始化 <see cref="T:System.Exception" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数初始化<xref:System.Exception.Message%2A>通过将新实例属性`message`参数。 如果`message`参数是`null`，这是调用相同<xref:System.Exception.%23ctor%2A>构造函数。  
  
 下表显示 <xref:System.Exception> 的实例的初始属性值。  
  
|Property|“值”|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|空引用（在 Visual Basic 中为 `Nothing`）。|  
|<xref:System.Exception.Message%2A>|错误消息字符串。|  
  
   
  
## Examples  
 下面的代码示例派生`Exception`针对特定的条件。 代码演示了将调用方指定的消息作为参数，派生的类和基构造函数的用法`Exception`类。  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">包含有关所引发异常的序列化对象数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" />，它包含关于源或目标的上下文信息。</param>
        <summary>用序列化数据初始化 <see cref="T:System.Exception" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数在反序列化过程中调用，以便重建通过流传输的异常对象。 有关详细信息，请参阅[XML 和 SOAP 序列化](~/docs/standard/serialization/xml-and-soap-serialization.md)。  
  
   
  
## Examples  
 下面的代码示例定义一个派生可序列化`Exception`类。 代码强制被零除错误，然后创建派生的异常使用的实例 (<xref:System.Runtime.Serialization.SerializationInfo>， <xref:System.Runtime.Serialization.StreamingContext>) 构造函数。 代码将序列化到文件的实例，将该文件反序列化为一个新异常，则会引发，然后捕获并显示异常的数据。  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">类名为 <see langword="null" /> 或者 <see cref="P:System.Exception.HResult" /> 为零 (0)。</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">解释异常原因的错误消息。</param>
        <param name="innerException">导致当前异常的异常；如果未指定内部异常，则是一个 null 引用（在 Visual Basic 中为 <see langword="Nothing" />）。</param>
        <summary>使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.Exception" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因前一个异常而直接引发的异常应在 <xref:System.Exception.InnerException%2A> 属性中包含对前一个异常的引用。 <xref:System.Exception.InnerException%2A> 属性返回传递到构造函数中的相同值，或者如果 `Nothing` 属性不向构造函数提供内部异常值，则为空引用（在 Visual Basic 中为 <xref:System.Exception.InnerException%2A>）。  
  
 下表显示 <xref:System.Exception> 的实例的初始属性值。  
  
|Property|“值”|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|内部异常引用。|  
|<xref:System.Exception.Message%2A>|错误消息字符串。|  
  
   
  
## Examples  
 下面的代码示例派生`Exception`针对特定的条件。 代码演示了接受消息和内部异常作为参数，分别对应派生的类和基构造函数的用法`Exception`类。  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取提供有关异常的其他用户定义信息的键/值对集合。</summary>
        <value>一个对象，它实现 <see cref="T:System.Collections.IDictionary" /> 接口并包含用户定义的键/值对的集合。 默认值为空集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Collections.IDictionary?displayProperty=nameWithType>返回对象<xref:System.Exception.Data%2A>属性来存储和检索与异常相关的补充信息。 信息是在任意数目的用户定义键/值对的形式。 每个键/值对的关键组件通常是对象的一个标识字符串，而对的值组件可以是对象的任何类型。  
  
## <a name="keyvalue-pair-security"></a>键/值对安全  
 返回的集合中存储的键/值对<xref:System.Exception.Data%2A>是不安全的属性。 如果你的应用程序调用一系列嵌套的例程，并且每个例程包含异常处理程序时，调用堆栈结果将包含这些异常处理程序的层次结构。 如果较低级别例程引发了异常，调用堆栈层次结构中的任何高级别的异常处理程序可以读取和/或修改存储在集合中的任何其他异常处理程序的键/值对。 这意味着必须保证键/值对中的信息不是机密和你的应用程序将运行正确，如果键/值对中的信息已损坏。  
  
## <a name="key-conflicts"></a>密钥冲突  
 键冲突发生时不同的异常处理程序指定相同的键来访问键/值对。 你的应用程序的开发，因为键冲突的后果是较低级别的异常处理程序无意中能够与更高级别的异常处理程序，而此通信可能会导致细微程序错误时要格外小心。 但是，如果你是小心你可以使用键冲突可增强应用程序。  
  
## <a name="avoiding-key-conflicts"></a>避免密钥冲突  
 通过采用命名约定生成的键/值对唯一键可以避免键冲突。 例如，命名约定可能会生成包含句点分隔的你的应用程序名称的密钥，则该方法提供补充信息的对，并将其唯一标识符。  
  
 假设两个应用程序，名为产品和供应商，每都有一个名为销售方法。 产品应用程序中的销售方法提供的产品标识号 （的库存单位或 SKU）。 供应商应用程序中的销售方法提供的标识号或 SID，供应商。 因此，此示例中的命名约定生成的密钥，"Products.Sales.SKU"和"Suppliers.Sales.SID"。  
  
## <a name="exploiting-key-conflicts"></a>利用键冲突  
 通过使用一个或多个特殊，预先安排的键存在来控制处理来利用键冲突。 假设在一个方案中，调用堆栈层次结构中的最高级别的异常处理程序捕捉所有较低级别异常处理程序处理引发的异常。 如果存在具有的特殊键的键/值对，高级别的异常处理程序格式中的剩余键/值对<xref:System.Collections.IDictionary>对象以某种非标准的方式; 否则，将剩余的键/值对格式以某种正常方式。  
  
 现在假设，在另一个方案中，在调用堆栈层次结构的每个级别的异常处理程序捕捉由下一个较低级别的异常处理程序引发的异常。 此外，每个异常处理程序知道返回的集合<xref:System.Exception.Data%2A>属性包含一组预先安排的项的键/值对的可访问的集。  
  
 每个异常处理程序使用预先安排的密钥集来与该异常处理程序的唯一信息更新相应的键/值对的值组件。 更新过程已完成后，异常处理程序将引发到下一步的更高级别的异常处理程序的异常。 最后，最高级别的异常处理程序访问的键/值对，并显示所有较低级别的异常处理程序中的合并的更新信息。  
  
   
  
## Examples  
 下面的示例演示如何添加和检索信息使用<xref:System.Exception.Data%2A>属性。  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，返回 <see cref="T:System.Exception" />，它是一个或多个并发的异常的根源。</summary>
        <returns>异常链中第一个被引发的异常。 如果当前异常的 <see cref="P:System.Exception.InnerException" /> 属性是 null 引用（Visual Basic 中为 <see langword="Nothing" />），则此属性返回当前异常。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异常链的一组组成的异常，链中的每个异常抛出异常中引用的直接结果作为其`InnerException`属性。 对于给定的链，可以有一个是链中的其他所有异常的根本原因的异常。 此异常被称为使用基异常并将其`InnerException`属性始终包含一个 null 引用。  
  
 所有异常的异常，链中`GetBaseException`方法必须返回相同的对象 （使用基异常）。  
  
 使用`GetBaseException`方法时您想要查找异常的根本原因，但不是需要有关当前异常的第一个异常期间可能发生的异常的信息。  
  
   
  
## Examples  
 下面的代码示例定义了两个派生`Exception`类。 它强制异常，然后在与每个派生类重新引发它。 代码演示如何使用`GetBaseException`方法来检索原始异常。  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="GetBaseException" />需要控制的异常内容或格式的类中重写方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">包含有关所引发异常的序列化对象数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" />，它包含关于源或目标的上下文信息。</param>
        <summary>当在派生类中重写时，用关于异常的信息设置 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetObjectData` 使用针对于序列化的所有异常对象数据设置 <xref:System.Runtime.Serialization.SerializationInfo>。 反序列化期间，从通过流传输的 `SerializationInfo` 重建异常。  
  
   
  
## Examples  
 下面的代码示例定义一个派生可序列化`Exception`类，该类实现`GetObjectData`，从而细微的更改将对两个属性，然后调用的基类执行序列化。 该示例强制被零除错误，然后创建派生的异常的实例。 代码将序列化到文件的实例，将该文件反序列化为一个新异常，则会引发，然后捕获并显示异常的数据。  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 参数为 null 引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前实例的运行时类型。</summary>
        <returns>一个 <see cref="T:System.Type" /> 对象，表示当前实例的确切运行时类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.GetType%2A>方法存在是为了支持.NET Framework 基础结构，并内部调用的基本方法<xref:System.Object.GetType%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置指向与此异常关联的帮助文件链接。</summary>
        <value>统一资源名称 (URN) 或统一资源定位器 (URL)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表示帮助文件的返回值是 URN 或 URL。 例如，`HelpLink`值可以是：  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 下面的代码示例引发`Exception`设置`HelpLink`属性在其构造函数，然后捕捉异常并显示`HelpLink`。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 HRESULT（一个分配给特定异常的编码数字值）。</summary>
        <value>HRESULT 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HRESULT 为一个 32 位值，划分为三个不同的字段： 严重性代码、 设施代码和错误代码。 严重性代码指示返回的值表示信息、 警告或错误。 设施代码标识的系统负责该错误的区域。 错误代码为的分配来表示该异常的唯一编号。 每个异常映射到不同的 HRESULT。 当托管的代码抛出异常时，运行时将 HRESULT 传递到 COM 客户端。 当非托管的代码将返回错误时，HRESULT 被转换为异常，然后由运行时引发。 HRESULT 值和其相应的.NET Framework 异常有关的信息，请参阅[如何： 映射 Hresult 和异常](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)。 请参阅[常见的 HRESULT 值](http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx)中的最有可能会遇到的值列表的 Windows 文档。  
  
 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]、<xref:System.Exception.HResult%2A>属性的 setter 受到保护，而其 getter 是公共的。  在以前版本的.NET Framework 中，getter 和 setter 进行保护。  
  
   
  
## Examples  
 下面的代码示例定义一个派生`Exception`设置的类`HResult`属性在其构造函数中的自定义值。  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取导致当前异常的 <see cref="T:System.Exception" /> 实例。</summary>
        <value>描述导致当前异常的错误的一个对象。 <see cref="P:System.Exception.InnerException" /> 属性返回的值与传递到 <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> 构造函数中的值相同，如果没有向构造函数提供内部异常值，则为 <see langword="null" />。 此属性是只读的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异常时`X`引发作为前一个异常的直接结果`Y`、<xref:System.Exception.InnerException%2A>属性`X`应包含对引用`Y`。  
  
 使用 <xref:System.Exception.InnerException%2A> 属性获取导致当前异常的异常集。  
  
 你可以创建一个新异常捕获前面的异常。 第二个异常可以进行的句柄使用以前的异常的附加信息的错误更恰当地处理代码。  
  
 假定有读取文件并格式化该文件中的数据的函数。 在此示例中，此代码将尝试读取的文件，作为<xref:System.IO.IOException>引发。 该函数捕捉<xref:System.IO.IOException>并引发<xref:System.IO.FileNotFoundException>。 <xref:System.IO.IOException>无法保存在<xref:System.Exception.InnerException%2A>属性<xref:System.IO.FileNotFoundException>，启用捕获的代码<xref:System.IO.FileNotFoundException>来检查初始错误的原因。  
  
 <xref:System.Exception.InnerException%2A>属性，保存对内部异常的引用，设置进行初始化的异常对象。  
  
   
  
## Examples  
 下面的示例说明如何引发和捕获引用内部异常的异常。  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取描述当前异常的消息。</summary>
        <value>解释异常原因的错误消息或空字符串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 错误消息目标的开发人员正在处理异常。 文本<xref:System.Exception.Message%2A>属性应当完整地描述该错误，并且如果可能，还应阐释如何更正该错误。 顶级异常处理程序可能会给最终用户，显示消息，因此您应确保它是语法正确，且消息的每个句子分解以句点结尾。 不要使用问号或感叹号。 如果你的应用程序使用本地化的异常消息，应确保它们准确地转换。  
  
> [!IMPORTANT]
>  而不检查适当的权限不披露异常消息中的敏感信息。  
  
 值<xref:System.Exception.Message%2A>中返回的信息包括属性<xref:System.Exception.ToString%2A>。<xref:System.Exception.Message%2A>属性仅在创建时设置<xref:System.Exception>。 如果为当前实例的构造函数不硅酮任何消息，则系统将提供默认消息的格式都是使用当前系统区域性。  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows 运行时和 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 从开始[!INCLUDE[net_v451](~/includes/net-v451-md.md)]和[!INCLUDE[win81](~/includes/win81-md.md)]，改进了从 Windows 运行时类型和成员不是.NET Framework 的一部分从传播的异常的错误消息的保真度。 具体而言，异常消息从 Visual c + + 组件扩展 (C + + /cli CX) 现在传播回.NET Framework<xref:System.Exception>对象。  
  
   
  
## Examples  
 下面的代码示例引发，然后捕捉<xref:System.Exception>异常并显示异常的文本消息使用<xref:System.Exception.Message%2A>属性。
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果你从引发异常的属性，并且你需要引用中的文本<see cref="P:System.Exception.Message" />到您设置或获取的属性参数，使用"value"作为属性自变量的名称。</para>
        </block>
        <block subset="none" type="overrides">
          <para>
            <see cref="P:System.Exception.Message" />需要控制消息内容或格式的类中重写属性。在需要显示有关已捕获的异常的信息时，应用程序代码通常会访问此属性。应本地化的错误消息。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当异常被序列化用来创建包含有关该异常的徐列出数据的异常状态对象时会出现该问题。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异常状态对象实现<xref:System.Runtime.Serialization.ISafeSerializationData>接口。  
  
 当<xref:System.Exception.SerializeObjectState>订阅事件，此异常将反序列化并创建为空的异常。 异常的构造函数时不运行，并且还反序列化的异常状态。 <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A>然后通知有关的异常状态对象的回调方法，以便它可以将反序列化的数据推送到空的例外。  
  
 <xref:System.Exception.SerializeObjectState>事件启用透明异常类型进行序列化和反序列化异常数据。 透明代码可以在其运行的权限集边界内执行命令，但不能执行、 调用、 派生自或包含关键代码。  
  
 如果<xref:System.Exception.SerializeObjectState>事件未订阅，像往常一样使用反序列化时发生<xref:System.Exception.%23ctor%2A>构造函数。  
  
 通常情况下，处理程序<xref:System.Exception.SerializeObjectState>事件被添加为其序列化提供的异常的构造函数中。 但是，由于构造函数不是时执行<xref:System.Exception.SerializeObjectState>事件处理程序执行，则序列化反序列化的异常可以引发<xref:System.Runtime.Serialization.SerializationException>尝试反序列化异常时出现异常。 若要避免此问题，则还应添加的处理程序<xref:System.Exception.SerializeObjectState>中的事件<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>方法。 请参阅方面的演示示例部分。  
  
   
  
## Examples  
 下面的示例定义`BadDivisionException`用于处理<xref:System.Exception.SerializeObjectState>事件。 它还包含一个状态对象，它是嵌套结构名为`BadDivisionExceptionState`实现<xref:System.Runtime.Serialization.ISafeSerializationData>接口。  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 `BadDivisionException`浮点被零除发生时引发异常。 在第一个除数为零，该示例实例化`BadDivisionException`对象，序列化，并引发异常。 出现被零除的后续部门时，本示例反序列化之前序列化的对象，重新序列化，并引发异常。 若要提供的对象序列化、 反序列化、 重新，序列化和反序列化，该示例将添加<xref:System.Exception.SerializeObjectState>中的事件处理程序两个`BadDivisionException`类构造函数并在<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>实现。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果此事件是订阅和使用，请按照在继承层次结构中的所有派生的类型必须实现相同的序列化机制。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置导致错误的应用程序或对象的名称。</summary>
        <value>导致错误的应用程序或对象的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Exception.Source%2A>属性未显式设置，运行时自动将其设置为产生异常的程序集的名称。  
  
   
  
## Examples  
 下面的示例引发`Exception`设置`Source`属性在其构造函数，然后捕捉异常并显示`Source`。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">对象必须是运行时 <see cref="N:System.Reflection" /> 对象</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取调用堆栈上的即时框架字符串表示形式。</summary>
        <value>用于描述调用堆栈的直接帧的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 执行堆栈将跟踪在给定时刻正在执行的所有方法。 对方法调用的跟踪称为堆栈跟踪。 堆栈跟踪列表提供了一种方法为跟踪调用堆栈中方法的行号出现异常。  
  
 <xref:System.Exception.StackTrace%2A>属性返回源自引发异常的位置的调用堆栈帧。 可以通过创建的新实例中获取有关调用堆栈中的其他帧的信息<xref:System.Diagnostics.StackTrace?displayProperty=nameWithType>类并使用其<xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType>方法。  
  
 每当应用程序代码中引发异常时，公共语言运行时 (CLR) 将更新的堆栈跟踪 (通过使用`throw`关键字)。 如果已将不同于该方法最初抛方法中重新引发异常，堆栈跟踪包含其中最初引发异常，在方法中的位置和方法中异常所在的位置重新引发。 如果引发，并稍后重新引发，在同一方法中，异常的堆栈跟踪将仅包含的位置重新引发异常并不包括最初引发异常的位置。  
  
 <xref:System.Exception.StackTrace%2A>属性可能不报告的由于代码转换，如预期的任意多个方法调用内联，在优化过程中发生。  
  
   
  
## Examples  
 下面的代码示例引发`Exception`，捕获它，然后显示堆栈跟踪使用`StackTrace`属性。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="StackTrace" />需要控制的堆栈跟踪内容或格式的类中重写属性。默认情况下，堆栈跟踪被捕获之前引发的异常对象。使用<see cref="P:System.Environment.StackTrace" />时所不引发任何异常获取堆栈跟踪信息。</para>
        </block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取引发当前异常的方法。</summary>
        <value>引发当前异常的 <see cref="T:System.Reflection.MethodBase" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果引发此异常的方法不可用并且堆栈跟踪不是空引用 (`Nothing`在 Visual Basic 中)，<xref:System.Exception.TargetSite%2A>从堆栈跟踪获取该方法。 如果堆栈跟踪为空引用，<xref:System.Exception.TargetSite%2A> 也返回空引用。  
  
> [!NOTE]
>  <xref:System.Exception.TargetSite%2A>属性可能无法准确报告在其中如果异常处理程序处理的异常跨应用程序域边界引发了异常的方法的名称。  
  
   
  
## Examples  
 下面的代码示例引发`Exception`然后捕获它并显示原始方法使用`TargetSite`属性。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建并返回当前异常的字符串表示形式。</summary>
        <returns>当前异常的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A> 返回当前异常，但应为人所理解的表示形式。 当该异常包含区分区域性的数据，返回的字符串表示`ToString`需要当前系统区域性考虑在内。 虽然没有返回字符串的确切要求的格式，它应尝试反映为从用户的角度对象的值。  
  
 默认实现<xref:System.Exception.ToString%2A>获取引发当前异常，消息、 调用的结果的类名称<xref:System.Exception.ToString%2A>上该内部异常，且调用<xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>。 如果任何这些成员为`null`，其值不包括在返回的字符串。  
  
 如果没有任何错误消息，或如果它是空字符串 ("")，则不返回任何错误消息。 仅当它们不是返回的内部异常和堆栈跟踪的名称`null`。  
  
 此方法重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例导致引发异常并显示调用<xref:System.Exception.ToString%2A>上该异常。 请注意，<xref:System.Exception.ToString%2A?displayProperty=nameWithType>的参数列表中出现的异常类实例时，方法隐式调用<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法。  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>