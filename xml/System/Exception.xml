<Type Name="Exception" FullName="System.Exception">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4dc37d06070017412e2ccd0e886f62a2b70f6949" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48595295" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示在应用程序执行过程中发生的错误。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类是所有异常的基类。 出现错误时，系统或当前正在执行的应用程序报告它通过引发异常，其中包含有关错误的信息。 引发异常后，它是由应用程序或默认异常处理程序进行处理。  
  
 本节内容：  
  
 [错误和异常](#Errors)   
 [Try/catch 块](#TryCatch)   
 [异常类型的功能](#Features)   
 [异常类属性](#Properties)   
 [性能注意事项](#Performance)   
 [重新引发异常](#Rethrow)   
 [选择标准异常](#Standard)   
 [实现自定义异常](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>错误和异常  
 运行时错误可能的原因有多种。 但是，并非所有错误应作为在代码中的异常都处理。 以下是一些可以发生在运行的时和适当的方式对其进行响应的错误类别。  
  
-   **用法错误。** 用法错误表示可能会导致异常的程序逻辑中的错误。 但是，不能通过异常处理，但通过修改了错误代码，则应解决该错误。 例如的重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法在下面的示例假设`obj`参数必须始终为非 null。  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     <xref:System.NullReferenceException>产生的异常时`obj`是`null`可通过修改源代码，以显式测试是否为 null 之前，调用来消除<xref:System.Object.Equals%2A?displayProperty=nameWithType>重写和重新编译。 下面的示例包含更正的源代码处理`null`参数。  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     而不是使用异常处理的使用情况的错误，可以使用<xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType>的方法来确定在调试版本中的用法错误和<xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType>的方法来确定在调试和发布中的用法错误生成。 有关详细信息，请参阅[托管代码中的断言](/visualstudio/debugger/assertions-in-managed-code)。  
  
-   **程序错误数。** 程序错误是一定不能通过编写无 bug 的代码来避免运行时错误。  
  
     在某些情况下，程序错误可能会反映预期或例程错误条件。 在这种情况下，你可能想要避免使用异常处理程序错误处理，而是重试该操作。 例如，如果用户需要输入以特定格式的日期，您可以分析日期字符串通过调用<xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType>方法，它返回<xref:System.Boolean>值，该值指示是否分析操作成功，而不是使用<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>方法，将引发<xref:System.FormatException>异常，如果日期字符串无法转换为<xref:System.DateTime>值。 同样，如果用户尝试打开的文件不存在，则可以首先调用<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>方法来检查文件是否存在并，如果不是，提示用户是否要创建它。  
  
     在其他情况下，程序错误反映了可以在代码中处理的异常的错误条件。 例如，即使检查以确保存在的文件，它可能会删除之前您可以打开它，也可能已损坏。 在这种情况下，尝试打开该文件通过实例化<xref:System.IO.StreamReader>对象或调用<xref:System.IO.File.Open%2A>方法可能会引发<xref:System.IO.FileNotFoundException>异常。 在这些情况下，应使用异常处理从错误中恢复。  
  
-   **系统故障。** 在系统出现故障是不能以编程方式处理有意义的方式在运行时错误。 例如，可能会引发任何方法<xref:System.OutOfMemoryException>异常如果公共语言运行时无法分配更多内存。 通常，通过使用异常处理不处理系统故障。 相反，您可能能够使用如下所示事件<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>，并调用<xref:System.Environment.FailFast%2A?displayProperty=nameWithType>方法来记录异常信息，并在应用程序终止之前通知失败的用户。  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Try/catch 块  
 公共语言运行时提供了一个异常处理模型，基于异常对象，作为表示形式和程序代码和异常处理代码的分离`try`块和`catch`块。 可以有一个或多个`catch`阻止，每个设计为处理特定类型的异常，或者将一个块可捕获更具体的异常比另一个块。  
  
 如果应用程序处理的应用程序代码块的执行过程中发生的异常，该代码必须位于`try`语句和称为`try`块。 应用程序代码处理引发的异常`try`块放在`catch`语句，称为`catch`块。 零个或多`catch`块下与相关联`try`块中，并且每个`catch`块包含类型筛选器，用于确定它处理的异常的类型。  
  
 在异常发生时`try`块中，系统将搜索关联`catch`它们出现在应用程序代码中，直到它找到的顺序中的块，`catch`块处理异常。 一个`catch`块处理类型的异常`T`如果 catch 块的类型筛选器指定`T`或任何类型的`T`派生。 系统会停止搜索后查找第一个`catch`块处理异常。 出于此原因，在应用程序代码中，`catch`之前，必须指定处理类型的块`catch`处理其基类型，如本节后面的示例中所示的块。 处理的 catch 块`System.Exception`最后指定。  
  
 如果没有`catch`与当前相关联的块`try`块处理异常，并且当前`try`块嵌套在其他`try`在当前调用中，将阻止`catch`块与下一步封闭`try`块中搜索。 如果没有`catch`找到异常块中，系统将在当前调用中搜索前面的嵌套级别。 如果没有`catch`阻止的当前调用中找到的异常、 调用堆栈中向上传递的异常和上一个堆栈帧中搜索`catch`块处理异常。 调用堆栈的搜索继续，直到处理该异常或没有更多框架位于调用堆栈。 如果调用堆栈的顶部访问而无需查找`catch`处理异常，默认异常处理程序块对其进行处理并在应用程序终止。  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>异常类型的功能  
 异常类型支持以下功能：  
  
-   描述错误的用户可读文本。 异常发生时，运行时使可用以通知用户错误的性质，并建议操作文本消息来解决此问题。 此文本消息保存在<xref:System.Exception.Message%2A>异常对象的属性。 异常对象期间，可以将文本字符串传递给构造函数来描述该特定异常的详细信息。 如果没有错误消息参数提供给构造函数，则使用默认错误消息。 有关更多信息，请参见 <xref:System.Exception.Message%2A> 属性。  
  
-   调用堆栈时引发异常的状态。 <xref:System.Exception.StackTrace%2A>属性包含可用于确定在代码中发生错误的堆栈跟踪。 堆栈跟踪列出了所有调用的方法和源文件位置的调用中的行号。  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>异常类属性  
 <xref:System.Exception>类还包含一些属性，可帮助识别代码位置、 类型、 帮助文件和异常的原因： <xref:System.Exception.StackTrace%2A>， <xref:System.Exception.InnerException%2A>， <xref:System.Exception.Message%2A>， <xref:System.Exception.HelpLink%2A>， <xref:System.Exception.HResult%2A>， <xref:System.Exception.Source%2A>，<xref:System.Exception.TargetSite%2A>，和<xref:System.Exception.Data%2A>。  
  
 当两个或多个异常之间存在因果关系<xref:System.Exception.InnerException%2A>属性维护此信息。 外部异常引发响应此内部异常。 处理外部异常的代码可以使用来自前面的内部异常的信息更恰当地处理错误。 有关异常的补充信息可以存储为集合中的键/值对的<xref:System.Exception.Data%2A>属性。  
  
 在异常对象的创建过程传递给构造函数的错误消息字符串应本地化，并通过使用可以从资源文件中提供<xref:System.Resources.ResourceManager>类。 本地化资源的详细信息，请参阅[创建附属程序集](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)并[打包和部署资源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)主题。  
  
 若要向用户提供有关异常的发生原因的大量信息<xref:System.Exception.HelpLink%2A>属性可以包含到帮助文件的 URL （或 URN）。  
  
 <xref:System.Exception>类使用 HRESULT COR_E_EXCEPTION，其值 0x80131500。  
  
 有关实例的初始属性值的列表<xref:System.Exception>类，请参阅<xref:System.Exception.%23ctor%2A>构造函数。  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>性能注意事项  
 引发或处理的异常会消耗大量系统资源和执行时间。 引发异常，只是为了处理真正异常的情况，不能处理可预测的事件或流控制。 例如，在某些情况下，例如当正在开发类库，是合理的方法参数是无效的因为需要你使用有效的参数来调用的方法引发异常。 无效的方法参数，如果它不是使用错误的结果表示，出现了异常。 相反，如果用户输入无效，因为您可以预期用户偶尔会输入无效的数据确实引发了异常。 相反，提供重试机制，以便用户可以输入有效的输入。 也不应使用异常处理使用情况的错误。 请改用[断言](/visualstudio/debugger/assertions-in-managed-code)以确定并更正用法错误。  
  
 此外，不会引发异常时返回代码是不够的;没有转换为异常，则返回代码并不定期执行 catch 异常、 忽略它，并再继续进行处理。  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>重新引发异常  
 在许多情况下，异常处理程序只是想要传递到调用方的异常。 这通常发生在：  
  
-   包装的.NET Framework 类库或其他类库中的方法调用的类库。  
  
-   应用程序或库遇到严重异常。 异常处理程序可以记录异常，并随后重新引发异常。  
  
 若要重新引发异常的建议的方法是只需使用[引发](~/docs/csharp/language-reference/keywords/throw.md)C# 中的语句和[引发](~/docs/visual-basic/language-reference/statements/throw-statement.md)在 Visual Basic 中不包含表达式的语句。 这可确保当异常传播到调用方保留所有调用堆栈信息。 下面的示例阐释了这一点。 一个字符串扩展方法`FindOccurrences`，包装到一个或多个调用<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>而无需提前验证其参数。  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 然后，调用方调用`FindOccurrences`两次。 在第二次调用`FindOccurrences`，调用方传递`null`作为搜索字符串，哪些用例<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>方法会引发<xref:System.ArgumentNullException>异常。 通过处理此异常`FindOccurrences`方法并传递的回调用方。 因为 throw 语句使用不包含表达式，该示例输出所示保留调用堆栈。  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 相反，如果通过使用重新引发异常  
  
```csharp  
throw e  
```  
  
```vb  
Throw e  
```  
  
 语句中，完整的调用堆栈不会保留，且该示例会生成以下输出：  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 稍微更繁琐的替代方法是引发一个新的异常，并保留在内部异常的原始异常的调用堆栈信息。 然后，调用方可以使用新异常的<xref:System.Exception.InnerException%2A>属性来检索堆栈帧和原始异常有关的其他信息。 在这种情况下，在 throw 语句是：  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 处理异常的用户代码必须知道<xref:System.Exception.InnerException%2A>属性包含有关原始异常，如下面的异常处理程序所示。  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>选择标准异常  
 如果您不得不引发异常，通常可以使用而不是实现自定义异常在.NET Framework 中的现有异常类型。 应使用这两个条件下的标准异常类型：  
  
-   将引发异常导致的用法错误 (即，通过所做的开发人员正在调用您的方法的程序逻辑中的错误)。 通常情况下，会如引发异常<xref:System.ArgumentException>， <xref:System.ArgumentNullException>， <xref:System.InvalidOperationException>，或<xref:System.NotSupportedException>。 该字符串时需要提供对异常对象的构造函数实例化的异常对象应描述该错误，以便开发人员可以修复此错误。 有关更多信息，请参见 <xref:System.Exception.Message%2A> 属性。  
  
-   处理错误，可以传送到现有的.NET Framework 异常的调用方。 您应引发派生程度最高的可能异常。 例如，如果一种方法需要参数是枚举类型的有效成员，则应引发<xref:System.ComponentModel.InvalidEnumArgumentException>（大多数派生类） 而非<xref:System.ArgumentException>。  
  
 下表列出了常见的异常类型和其下会引发它们的条件。  
  
|例外|条件|  
|---------------|---------------|  
|<xref:System.ArgumentException>|传递给方法的非 null 参数无效。|  
|<xref:System.ArgumentNullException>|传递给方法的参数是`null`。|  
|<xref:System.ArgumentOutOfRangeException>|参数是有效的值范围之外。|  
|<xref:System.IO.DirectoryNotFoundException>|目录路径的一部分无效。|  
|<xref:System.DivideByZeroException>|一个整数中的分母或<xref:System.Decimal>除法运算为零。|  
|<xref:System.IO.DriveNotFoundException>|驱动器不可用或不存在。|  
|<xref:System.IO.FileNotFoundException>|文件不存在。|  
|<xref:System.FormatException>|值不在相应的格式将待换算从字符串转换方法如`Parse`。|  
|<xref:System.IndexOutOfRangeException>|索引是数组或集合的界限外。|  
|<xref:System.InvalidOperationException>|方法调用对象的当前状态无效。|  
|<xref:System.Collections.Generic.KeyNotFoundException>|找不到用于访问集合中的成员的指定的键。|  
|<xref:System.NotImplementedException>|未实现方法或操作。|  
|<xref:System.NotSupportedException>|不支持方法或操作。|  
|<xref:System.ObjectDisposedException>|已释放的对象上执行的操作。|  
|<xref:System.OverflowException>|当算术、 强制转换或转换操作会导致溢出。|  
|<xref:System.IO.PathTooLongException>|路径或文件名称超出了系统定义的最大长度。|  
|<xref:System.PlatformNotSupportedException>|在当前平台上不支持该操作。|  
|<xref:System.RankException>|具有错误维数的数组传递给方法。|  
|<xref:System.TimeoutException>|分配给操作的时间间隔已过期。|  
|<xref:System.UriFormatException>|使用无效的统一资源标识符 (URI)。|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>实现自定义异常  
 在以下情况下，使用现有的.NET Framework 异常处理的错误条件不能满足：  
  
-   当异常反映了无法映射到现有的.NET Framework 异常的唯一程序错误。  
  
-   异常时需要处理的是不同于适用于现有的.NET Framework 异常或异常的处理必须从类似的异常消除歧义。 例如，如果引发<xref:System.ArgumentOutOfRangeException>异常分析不在目标整型类型的范围内的字符串的数值表示形式时，您不想要使用相同的异常错误的结果从调用方未提供相应约束的值时调用的方法。  
  
 <xref:System.Exception>类是.NET Framework 中的所有异常的基类。 多个派生的类要依赖于的成员的继承行为<xref:System.Exception>类; 它们不会重写的成员<xref:System.Exception>，也不定义任何唯一成员。  
  
 若要定义自己的异常类：  
  
1.  定义一个类，继承自<xref:System.Exception>。 如果有必要，请定义您的类提供有关异常的其他信息所需的任何唯一成员。 例如，<xref:System.ArgumentException>类包括<xref:System.ArgumentException.ParamName%2A>属性，它指定其参数导致异常的参数的名称和<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>属性包含<xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A>属性，指示在超时间隔。  
  
2.  如有必要，重写任何继承的成员你想要更改或修改它的功能。 请注意，大多数现有派生类的<xref:System.Exception>不会重写继承成员的行为。  
  
3.  确定您的自定义异常对象是可序列化。 序列化使您可以保存有关异常的信息，并允许异常信息在由服务器和客户端代理在远程处理的上下文中共享。 若要使异常对象可序列化，将其与标记<xref:System.SerializableAttribute>属性。  
  
4.  定义异常类的构造函数。 通常情况下，异常类都有一个或多个以下构造函数：  
  
    -   <xref:System.Exception.%23ctor>它使用默认值初始化新的异常对象的属性。  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>其中初始化具有指定的错误消息的新异常对象。  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>其中初始化使用指定的错误消息和内部异常的新异常对象。  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>它是`protected`初始化中的新异常对象的构造函数序列化数据。 如果已选择使异常对象可序列化，则应实现此构造函数。  
  
 下面的示例演示如何使用自定义异常类。 它定义`NotPrimeException`客户端尝试通过指定一个起始数字，不是质数的话检索一系列质数时引发的异常。 异常定义新的属性， `NonPrime`，返回非的-质数，导致了异常。 除了实现受保护的无参数构造函数和一个构造函数与<xref:System.Runtime.Serialization.SerializationInfo>并<xref:System.Runtime.Serialization.StreamingContext>序列化的参数`NotPrimeException`类定义了三个额外的构造函数，以支持`NonPrime`属性。  每个构造函数调用基类构造函数除了保留值的非-质数。 `NotPrimeException`类还带有<xref:System.SerializableAttribute>属性。  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 `PrimeNumberGenerator`类在下面的示例所示使用埃拉托色的埃拉托色尼斯来计算的一系列质数从 2 到客户端对其类构造函数的调用中指定的限制。 `GetPrimesFrom`方法返回大于或等于指定的下限值的所有质数，但会引发`NotPrimeException`如果该较低的限制不是一个素数。  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 下面的示例调用两`GetPrimesFrom`方法与非质数，其中之一是跨应用程序域边界。 在这两种情况下，引发了异常并已成功处理客户端代码中。  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows 运行时和 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 在中[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)]为[!INCLUDE[win8](~/includes/win8-md.md)]，通过.NET Framework 堆栈帧传播异常时会通常丢失一些异常的信息。 从开始[!INCLUDE[net_v451](~/includes/net-v451-md.md)]并[!INCLUDE[win81](~/includes/win81-md.md)]，公共语言运行时仍会继续使用原始<xref:System.Exception>除非已在.NET Framework 堆栈帧中修改该异常引发的对象。  
  
   
  
## Examples  
 下面的示例演示`catch`块定义为处理<xref:System.ArithmeticException>错误。 这`catch`块还捕捉<xref:System.DivideByZeroException>错误，因为<xref:System.DivideByZeroException>派生自<xref:System.ArithmeticException>，并且没有任何`catch`显式定义为块<xref:System.DivideByZeroException>错误。  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/exceptions/index.md">处理和引发异常</related>
    <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">打包和部署桌面应用程序中的资源</related>
    <related type="Article" href="http://msdn.microsoft.com/library/70ab2522-6486-4076-a1a9-e0f11cd0f3a1">托管代码中的断言</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Exception" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Exception" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数将新实例的 <xref:System.Exception.Message%2A> 属性初始化为系统提供的消息，该消息描述错误并考虑当前系统区域性。  
  
 所有派生的类应提供此默认构造函数。 下表显示 <xref:System.Exception> 的实例的初始属性值。  
  
|Property|“值”|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|空引用（在 Visual Basic 中为 `Nothing`）。|  
|<xref:System.Exception.Message%2A>|系统提供的本地化说明。|  
  
   
  
## Examples  
 以下代码示例从`Exception`，它使用预定义的消息。 该代码演示如何使用无参数构造函数派生的类和基`Exception`类。  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">描述错误的消息。</param>
        <summary>用指定的错误消息初始化 <see cref="T:System.Exception" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数初始化<xref:System.Exception.Message%2A>属性使用的新实例的`message`参数。 如果`message`参数是`null`，这是调用相同<xref:System.Exception.%23ctor%2A>构造函数。  
  
 下表显示 <xref:System.Exception> 的实例的初始属性值。  
  
|Property|“值”|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|空引用（在 Visual Basic 中为 `Nothing`）。|  
|<xref:System.Exception.Message%2A>|错误消息字符串。|  
  
   
  
## Examples  
 以下代码示例从`Exception`的特定条件。 该代码演示如何调用指定的消息将作为参数，用于派生的类和基类的构造函数使用`Exception`类。  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">包含有关所引发异常的序列化对象数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" />，它包含关于源或目标的上下文信息。</param>
        <summary>用序列化数据初始化 <see cref="T:System.Exception" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数在反序列化过程中调用，以便重建通过流传输的异常对象。 有关详细信息，请参阅[XML 和 SOAP 序列化](~/docs/standard/serialization/xml-and-soap-serialization.md)。  
  
   
  
## Examples  
 下面的代码示例定义一个派生可序列化`Exception`类。 代码强制被零除错误，然后创建派生的异常使用的实例 (<xref:System.Runtime.Serialization.SerializationInfo>， <xref:System.Runtime.Serialization.StreamingContext>) 构造函数。 代码序列化到文件的实例，则反文件序列化为一个新的异常，则会引发，然后捕获并显示异常的数据。  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">类名为 <see langword="null" /> 或者 <see cref="P:System.Exception.HResult" /> 为零 (0)。</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">XML 和 SOAP 序列化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">解释异常原因的错误消息。</param>
        <param name="innerException">导致当前异常的异常；如果未指定内部异常，则是一个 null 引用（在 Visual Basic 中为 <see langword="Nothing" />）。</param>
        <summary>使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.Exception" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因前一个异常而直接引发的异常应在 <xref:System.Exception.InnerException%2A> 属性中包含对前一个异常的引用。 <xref:System.Exception.InnerException%2A> 属性返回传递到构造函数中的相同值，或者如果 `Nothing` 属性不向构造函数提供内部异常值，则为空引用（在 Visual Basic 中为 <xref:System.Exception.InnerException%2A>）。  
  
 下表显示 <xref:System.Exception> 的实例的初始属性值。  
  
|Property|“值”|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|内部异常引用。|  
|<xref:System.Exception.Message%2A>|错误消息字符串。|  
  
   
  
## Examples  
 以下代码示例从`Exception`的特定条件。 该代码演示如何采用消息和内部异常作为参数，分别对应派生的类和基类的构造函数使用`Exception`类。  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取提供有关异常的其他用户定义信息的键/值对集合。</summary>
        <value>一个对象，它实现 <see cref="T:System.Collections.IDictionary" /> 接口并包含用户定义的键/值对的集合。 默认值为空集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Collections.IDictionary?displayProperty=nameWithType>返回对象<xref:System.Exception.Data%2A>属性来存储和检索与异常相关的补充信息。 信息是在任意数量的用户定义键/值对的形式。 每个键/值对的关键组件通常是对象的一个标识字符串，而该对的值组件可以是对象的任何类型。  
  
## <a name="keyvalue-pair-security"></a>键/值对安全  
 返回的集合中存储的键/值对<xref:System.Exception.Data%2A>是不安全的属性。 如果你的应用程序调用一系列嵌套的例程，并且每个例程包含异常处理程序时，调用堆栈结果将包含这些异常处理程序的层次结构。 如果较低级别例程引发了异常，调用堆栈层次结构中的任何高级别的异常处理程序可以读取和/或修改存储在集合中的任何其他异常处理程序的键/值对。 这意味着您必须保证键/值对中的信息不是机密和你的应用程序将操作正确，如果键/值对中的信息已损坏。  
  
## <a name="key-conflicts"></a>密钥冲突  
 键冲突发生时不同的异常处理程序指定相同的密钥来访问键/值对。 开发应用程序，因为键冲突的结果是较低级别的异常处理程序会无意中能够更高级别的异常处理程序，与和此通信可能会导致难以察觉的程序错误时要格外小心。 但是，如果您不小心您可以使用键冲突可增强应用程序。  
  
## <a name="avoiding-key-conflicts"></a>避免键冲突  
 通过采用命名约定生成的键/值对唯一键可以避免键冲突。 例如，命名约定可能会生成包含句点分隔的应用程序名称的密钥，它提供对和唯一标识符的补充信息的方法。  
  
 假设两个应用程序，名为产品和供应商，每个有一个名为 Sales 方法。 产品应用程序中的销售方法提供的产品标识号 （单品单元或 SKU）。 供应商应用程序中的销售方法提供的标识号或 SID 的供应商。 因此，此示例中的命名约定将生成密钥，"Products.Sales.SKU"和"Suppliers.Sales.SID"。  
  
## <a name="exploiting-key-conflicts"></a>利用键冲突  
 通过使用一个或多个特殊的、 预先安排的键存在来控制处理攻击键冲突。 假设在一个方案中，调用堆栈层次结构中的最高级别的异常处理程序捕获所有异常引发的较低级别的异常处理程序。 如果存在具有特定键的键/值对，高级别的异常处理程序设置中的剩余键/值对格式<xref:System.Collections.IDictionary>对象以某种使用了非标准方式; 否则为剩余的键/值对的格式以某种正常方式。  
  
 现在假设，在另一个方案中，在每个调用堆栈层次结构级别的异常处理程序会捕获由下一个较低级别的异常处理程序引发的异常。 此外，每个异常处理程序知道返回的集合<xref:System.Exception.Data%2A>属性包含与一组预先安排的密钥可访问的键/值对一组。  
  
 每个异常处理程序使用预先安排的键集来为该异常处理程序的唯一信息更新相应的键/值对的值组件。 更新过程完成后，异常处理程序将引发下一个更高级别的异常处理程序的例外。 最后，最高级别的异常处理程序访问的键/值对，并显示来自所有较低级别的异常处理程序的合并的更新信息。  
  
   
  
## Examples  
 下面的示例演示如何添加和检索信息使用<xref:System.Exception.Data%2A>属性。  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，返回 <see cref="T:System.Exception" />，它是一个或多个并发的异常的根源。</summary>
        <returns>异常链中第一个被引发的异常。 如果当前异常的 <see cref="P:System.Exception.InnerException" /> 属性是 null 引用（Visual Basic 中为 <see langword="Nothing" />），则此属性返回当前异常。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异常链包含一组异常，以便为引用中的异常的直接结果引发链中的每个异常其`InnerException`属性。 对于给定的链，可以有且只有一个是链中的其他所有异常的根本原因的异常。 此异常被称为基异常并将其`InnerException`属性始终包含一个 null 引用。  
  
 所有异常的异常，链中`GetBaseException`方法必须返回相同的对象 （基异常）。  
  
 使用`GetBaseException`方法时您想要查找异常的根本原因，但是不需要有关当前异常和第一个异常之间可能发生的异常的信息。  
  
   
  
## Examples  
 下面的代码示例定义了两个派生`Exception`类。 它强制异常，然后在与每个派生的类重新引发它。 该代码演示如何使用`GetBaseException`方法来检索原始异常。  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="GetBaseException" />需要控制异常的内容或格式的类中重写方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">包含有关所引发异常的序列化对象数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" />，它包含关于源或目标的上下文信息。</param>
        <summary>当在派生类中重写时，用关于异常的信息设置 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetObjectData` 使用针对于序列化的所有异常对象数据设置 <xref:System.Runtime.Serialization.SerializationInfo>。 反序列化期间，从通过流传输的 `SerializationInfo` 重建异常。  
  
   
  
## Examples  
 下面的代码示例定义一个派生可序列化`Exception`类，该类实现`GetObjectData`这两个属性对进行次要更改，然后调用基类来执行序列化。 该示例会强制由零除错误，然后创建派生的异常的实例。 代码序列化到文件的实例，则反文件序列化为一个新的异常，则会引发，然后捕获并显示异常的数据。  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 参数为 null 引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前实例的运行时类型。</summary>
        <returns>一个 <see cref="T:System.Type" /> 对象，表示当前实例的确切运行时类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.GetType%2A>方法存在是为了支持.NET Framework 基础结构，并在内部调用的基本方法<xref:System.Object.GetType%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置指向与此异常关联的帮助文件链接。</summary>
        <value>统一资源名称 (URN) 或统一资源定位器 (URL)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表示帮助文件的返回值是 URN 或 URL。 例如，`HelpLink`值可以是：  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 下面的代码示例，则会引发`Exception`，用于设置`HelpLink`属性在其构造函数，然后捕捉异常并显示`HelpLink`。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 HRESULT（一个分配给特定异常的编码数字值）。</summary>
        <value>HRESULT 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HRESULT 是一个 32 位值，划分为三个不同的字段： 一个严重性代码、 一个设备代码和错误代码。 严重性代码指示返回的值表示信息、 警告或错误。 设备代码标识导致错误的系统的区域。 错误代码是分配来表示异常的唯一编号。 每个异常映射到不同的 HRESULT。 当托管的代码引发异常时，运行时将 HRESULT 传递给 COM 客户端。 当非托管的代码将返回错误时，HRESULT 转换为异常，则引发运行时。 有关 HRESULT 值和其相应的.NET Framework 异常的信息，请参阅[如何： 映射 Hresult 和异常](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)。 请参阅[常见的 HRESULT 值](http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx)中最有可能会遇到的值列表的 Windows 文档。  
  
 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，则<xref:System.Exception.HResult%2A>属性的 setter 受到保护，而其 getter 是公共的。  在以前版本的.NET Framework，getter 和 setter 进行保护。  
  
   
  
## Examples  
 下面的代码示例定义一个派生`Exception`类，用于设置`HResult`属性在其构造函数中的自定义值。  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/610b364b-2761-429d-9c4a-afbc3e66f1b9">如何：映射 HRESULT 和异常</related>
        <related type="ExternalDocumentation" href="http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx">常见的 HRESULT 值</related>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取导致当前异常的 <see cref="T:System.Exception" /> 实例。</summary>
        <value>描述导致当前异常的错误的一个对象。 <see cref="P:System.Exception.InnerException" /> 属性返回的值与传递到 <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> 构造函数中的值相同，如果没有向构造函数提供内部异常值，则为 <see langword="null" />。 此属性是只读的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当异常`X`作为前一个异常的直接结果引发`Y`，则<xref:System.Exception.InnerException%2A>的属性`X`应包含对引用`Y`。  
  
 使用 <xref:System.Exception.InnerException%2A> 属性获取导致当前异常的异常集。  
  
 您可以创建一个新的异常捕获的早期异常。 处理第二个异常可以用于从以前的异常的附加信息更恰当地处理错误代码。  
  
 假定有一个函数，读取文件，并从该文件数据的格式。 在此示例中，代码尝试读取该文件，作为<xref:System.IO.IOException>引发。 该函数会捕获<xref:System.IO.IOException>，并引发<xref:System.IO.FileNotFoundException>。 <xref:System.IO.IOException>未能在保存<xref:System.Exception.InnerException%2A>的属性<xref:System.IO.FileNotFoundException>，启用捕获的代码<xref:System.IO.FileNotFoundException>来检查初始错误的原因。  
  
 <xref:System.Exception.InnerException%2A>属性，保存对内部异常的引用，该属性设置的异常对象初始化时。  
  
   
  
## Examples  
 下面的示例演示如何引发和捕获引用内部异常的异常。  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取描述当前异常的消息。</summary>
        <value>解释异常原因的错误消息或空字符串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 错误消息为目标的开发人员处理异常。 文本<xref:System.Exception.Message%2A>属性应当完整地描述该错误，并在可能的情况下，还应说明如何更正此错误。 顶级异常处理程序可能会向最终用户，显示该消息，因此应确保它的语法正确，并且消息的每个句子有以句点结尾。 不要使用问号或感叹号。 如果你的应用程序使用本地化的异常消息，应确保它们准确地转换。  
  
> [!IMPORTANT]
>  而不检查相应的权限不披露异常消息中的敏感信息。  
  
 值<xref:System.Exception.Message%2A>属性包含在返回的信息<xref:System.Exception.ToString%2A>。<xref:System.Exception.Message%2A>属性仅在创建时设置<xref:System.Exception>。 如果没有消息提供给当前实例的构造函数，则系统将提供的默认消息使用当前系统区域性进行格式化。  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows 运行时和 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 从开始[!INCLUDE[net_v451](~/includes/net-v451-md.md)]和[!INCLUDE[win81](~/includes/win81-md.md)]，改进了从 Windows 运行时类型和成员的不是.NET Framework 的一部分从传播的异常错误消息的保真度。 具体而言，异常消息从 Visual c + + 组件扩展 (C + + /cli CX) 现在传播回.NET Framework<xref:System.Exception>对象。  
  
   
  
## Examples  
 下面的代码示例将引发，然后<xref:System.Exception>异常，并显示异常的文本消息使用<xref:System.Exception.Message%2A>属性。
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果引发异常的属性，并且需要进行的文本中，请参阅<see cref="P:System.Exception.Message" />到设置或获取的属性参数，将"值"用作属性参数的名称。</para>
        </block>
        <block subset="none" type="overrides">
          <para>
            <see cref="P:System.Exception.Message" />需要控制消息内容或格式的类中重写属性。 需要显示有关已捕获异常的信息时，应用程序代码通常会访问此属性。  
  
应本地化错误消息。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当异常被序列化用来创建包含有关该异常的徐列出数据的异常状态对象时会出现该问题。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异常状态对象实现<xref:System.Runtime.Serialization.ISafeSerializationData>接口。  
  
 当<xref:System.Exception.SerializeObjectState>订阅事件时，此异常将反序列化并创建为空的异常。 异常的构造函数时不运行，并且还反序列化的异常状态。 <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A>异常状态对象的回调方法然后通知，以便它可以将反序列化的数据推送到空的异常。  
  
 <xref:System.Exception.SerializeObjectState>事件使透明异常类型进行序列化和反序列化异常数据。 透明代码可以执行命令，在其运行的权限集的边界内，但不能执行、 调用、 派生，或包含关键代码。  
  
 如果<xref:System.Exception.SerializeObjectState>事件未订阅，像往常一样使用反序列化时发生<xref:System.Exception.%23ctor%2A>构造函数。  
  
 通常情况下，处理程序<xref:System.Exception.SerializeObjectState>异常的构造函数提供的序列化过程中添加事件。 但是，由于构造函数不是执行时<xref:System.Exception.SerializeObjectState>事件处理程序执行时，序列化反序列化的异常可能会引发<xref:System.Runtime.Serialization.SerializationException>时尝试反序列化异常的异常。 若要避免此问题，您应添加的处理程序<xref:System.Exception.SerializeObjectState>中的事件<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>方法。 请参阅示例部分的说明。  
  
   
  
## Examples  
 下面的示例定义`BadDivisionException`用于处理<xref:System.Exception.SerializeObjectState>事件。 它还包含一个状态对象，它是嵌套结构名为`BadDivisionExceptionState`实现<xref:System.Runtime.Serialization.ISafeSerializationData>接口。  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 `BadDivisionException`浮点除数为零发生时引发异常。 在第一个除数为零，该示例实例化`BadDivisionException`对象，将其，序列化，则引发异常。 出现被零后续部门，示例反序列化之前序列化的对象、 重新序列化该它，并引发异常。 若要提供的对象序列化、 反序列化、 重新，序列化和反序列化，该示例将添加<xref:System.Exception.SerializeObjectState>中的事件处理程序这两个`BadDivisionException`类构造函数并在<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>实现。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果此事件是订阅和使用，请遵循中的继承层次结构的所有派生的类型必须实现相同的序列化机制。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置导致错误的应用程序或对象的名称。</summary>
        <value>导致错误的应用程序或对象的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Exception.Source%2A>属性未显式设置，则运行时自动将其设置为产生异常的程序集的名称。  
  
   
  
## Examples  
 下面的示例将引发`Exception`，用于设置`Source`属性在其构造函数，然后捕捉异常并显示`Source`。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">对象必须是运行时 <see cref="N:System.Reflection" /> 对象</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取调用堆栈上的即时框架字符串表示形式。</summary>
        <value>用于描述调用堆栈的直接帧的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 执行堆栈将跟踪在给定时刻正在执行的所有方法。 对方法调用的跟踪称为堆栈跟踪。 堆栈跟踪列表提供了一种方法的调用堆栈跟踪到方法中的行号出现异常。  
  
 <xref:System.Exception.StackTrace%2A>属性返回在引发异常的位置发出的调用堆栈帧。 可以通过创建的新实例来获取有关其他帧调用堆栈中的信息<xref:System.Diagnostics.StackTrace?displayProperty=nameWithType>类并使用其<xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType>方法。  
  
 公共语言运行时 (CLR) 更新的堆栈跟踪，每当应用程序代码中引发异常时 (通过使用`throw`关键字)。 如果在方法的不同方法比最初引发异常时，堆栈跟踪包含其中最初引发异常，方法中的位置和方法中的位置，其中的异常为再次引发。 如果引发，并且稍后再次引发异常的情况下，在同一方法中，异常堆栈跟踪仅包含的位置重新引发异常并不包括最初引发异常的位置。  
  
 <xref:System.Exception.StackTrace%2A>属性可能不会报告任意多个方法调用如预期，因为代码转换为内联，优化过程中发生的。  
  
   
  
## Examples  
 下面的代码示例，则会引发`Exception`捕捉该异常并显示堆栈跟踪使用`StackTrace`属性。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="StackTrace" />需要控制堆栈跟踪内容或格式的类中重写属性。  
  
默认情况下，堆栈跟踪被捕获之前引发的异常对象。 使用<see cref="P:System.Environment.StackTrace" />会不引发任何异常时获取堆栈跟踪信息。</para>
        </block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取引发当前异常的方法。</summary>
        <value>引发当前异常的 <see cref="T:System.Reflection.MethodBase" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果会引发此异常的方法不可用并且堆栈跟踪不是 null 引用 (`Nothing`在 Visual Basic 中)，<xref:System.Exception.TargetSite%2A>从堆栈跟踪获取该方法。 如果堆栈跟踪为空引用，<xref:System.Exception.TargetSite%2A> 也返回空引用。  
  
> [!NOTE]
>  <xref:System.Exception.TargetSite%2A>属性可能无法准确报告中如果异常处理程序处理的异常跨应用程序域边界引发异常的方法的名称。  
  
   
  
## Examples  
 下面的代码示例，则会引发`Exception`捕捉该异常并显示原始的方法使用`TargetSite`属性。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建并返回当前异常的字符串表示形式。</summary>
        <returns>当前异常的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A> 返回用于为人所理解的当前异常的表示形式。 当该异常包含区分区域性的数据，返回的字符串表示形式`ToString`所需的当前系统区域性考虑在内。 虽然没有返回字符串的确切格式要求，但它应尝试反映形式从用户的角度的对象的值。  
  
 默认实现<xref:System.Exception.ToString%2A>获取引发当前异常、 消息、 调用的结果的类的名称<xref:System.Exception.ToString%2A>上的内部异常，并因调用<xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>。 如果任何这些成员为`null`，其值不包括在返回的字符串。  
  
 如果没有任何错误消息或为空字符串 ("")，则不返回任何错误消息。 仅当它们不是返回的内部异常和堆栈跟踪名称`null`。  
  
 此方法重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例会导致异常，并显示调用的结果<xref:System.Exception.ToString%2A>上该异常。 请注意，<xref:System.Exception.ToString%2A?displayProperty=nameWithType>的参数列表中出现的异常类实例时，方法隐式调用<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法。  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>