<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="649dc28c23dbde95771a5a23c8feb6e1086637c4" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683957" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">列表中元素的类型。</typeparam>
    <summary>表示可通过索引访问的对象的强类型列表。 提供用于对列表进行搜索、排序和操作的方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>类是泛型等效于<xref:System.Collections.ArrayList>类。 它实现<xref:System.Collections.Generic.IList%601>所需使用作为动态增加其大小的数组的泛型接口。  
  
 你可以将项添加到<xref:System.Collections.Generic.List%601>使用<xref:System.Collections.Generic.List%601.Add%2A>或<xref:System.Collections.Generic.List%601.AddRange%2A>方法。  
  
 <xref:System.Collections.Generic.List%601>类使用相等比较器和排序比较器。  
  
-   等方法<xref:System.Collections.Generic.List%601.Contains%2A>， <xref:System.Collections.Generic.List%601.IndexOf%2A>， <xref:System.Collections.Generic.List%601.LastIndexOf%2A>，和<xref:System.Collections.Generic.Dictionary%602.Remove%2A>将相等比较器用于列表元素。 类型的默认相等比较器`T`确定，如下所示。 如果类型`T`实现<xref:System.IEquatable%601>泛型接口，则相等比较器是<xref:System.IEquatable%601.Equals%28%600%29>方法的该接口; 否则，默认相等比较器是<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>。  
  
-   等方法<xref:System.Collections.Generic.List%601.BinarySearch%2A>和<xref:System.Collections.Generic.List%601.Sort%2A>将排序比较器用于列表元素。 类型的默认比较器`T`确定，如下所示。  如果类型`T`实现<xref:System.IComparable%601>泛型接口，则默认比较器是<xref:System.IComparable%601.CompareTo%28%600%29>方法的该接口; 否则为如果类型`T`实现非泛型<xref:System.IComparable>接口，则默认值比较器是<xref:System.IComparable.CompareTo%28System.Object%29>该接口的方法。 如果类型`T`实现两个接口，则没有默认比较器，并比较器或比较委托必须显式提供。  
  
 <xref:System.Collections.Generic.List%601>不一定进行排序。  您必须对进行排序<xref:System.Collections.Generic.List%601>之前执行操作 (如<xref:System.Collections.Generic.List%601.BinarySearch%2A>) 需要<xref:System.Collections.Generic.List%601>进行排序。  
  
 可以使用整数索引访问此集合中的元素。  在此集合中的索引是从零开始。  
  
 对于非常大<xref:System.Collections.Generic.List%601>对象，你可以通过设置增加到 20 亿元素在 64 位系统上的最大容量`enabled`到的配置元素的属性`true`在运行时环境中。  
  
 <xref:System.Collections.Generic.List%601> 接受`null`引用为有效的值类型，并允许重复的元素。  
  
 不可变的版本<xref:System.Collections.Generic.List%601>类，请参阅<xref:System.Collections.Immutable.ImmutableList%601>。  
  
## <a name="performance-considerations"></a>性能注意事项  
 在决定是否使用<xref:System.Collections.Generic.List%601>或<xref:System.Collections.ArrayList>类，这两种具有类似的功能，请记住，<xref:System.Collections.Generic.List%601>类在大多数情况下更好地执行，并且是类型安全。 如果引用类型用于类型`T`的<xref:System.Collections.Generic.List%601>类，这两个类的行为是相同。 但是，如果使用值类型是类型`T`，你需要考虑实现和装箱问题。  
  
 如果使用值类型是类型`T`，编译器将生成的实现<xref:System.Collections.Generic.List%601>专门针对该值类型的类。 这意味着的一个列表元素<xref:System.Collections.Generic.List%601>对象不具有可以使用该元素，并会创建大约 500 个列表元素后保存未装箱列表元素的内存大于用来生成的类实现的内存之前进行装箱。  
  
 确保用于类型的值类型`T`实现<xref:System.IEquatable%601>泛型接口。 如果不是，等的方法<xref:System.Collections.Generic.List%601.Contains%2A>必须调用<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法，框受影响的列表元素。 如果值类型实现<xref:System.IComparable>接口，并且您拥有源代码，则还应实现<xref:System.IComparable%601>泛型接口，以防止<xref:System.Collections.Generic.List%601.BinarySearch%2A>和<xref:System.Collections.Generic.List%601.Sort%2A>从装箱列表元素的方法。 如果您不拥有的源代码，将传递<xref:System.Collections.Generic.IComparer%601>对象传递给<xref:System.Collections.Generic.List%601.BinarySearch%2A>和<xref:System.Collections.Generic.List%601.Sort%2A>方法  
  
 它是你使用的特定类型实现的最好<xref:System.Collections.Generic.List%601>类而不是使用<xref:System.Collections.ArrayList>类或自己编写的强类型包装器集合。 原因是您的实现必须执行.NET Framework 的用途为你已，并公共语言运行时可共享 Microsoft 中间语言代码和元数据，不能实现。  
  
## <a name="f-considerations"></a>F # 注意事项  
 <xref:System.Collections.Generic.List%601> F # 代码中不常使用类。  相反，[列出](http://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d)，这是不可变、 单向链接列表，通常最好是。 F # 列表提供有序的、 不可变的一系列值，并支持在函数样式开发中使用。 如果从 F # 中，使用<xref:System.Collections.Generic.List%601>类通常由所引用[ResizeArray\<' T >](https://msdn.microsoft.com/library/ee353447.aspx)类型缩写，以避免与 F # 列出发生命名冲突  
  
   
  
## Examples  
 下面的示例演示如何添加、 删除和插入中的简单的业务对象<xref:System.Collections.Generic.List%601>。  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 下面的示例演示几个属性和方法的<xref:System.Collections.Generic.List%601>字符串类型的泛型类。 (有关的示例<xref:System.Collections.Generic.List%601>的复杂类型，请参阅<xref:System.Collections.Generic.List%601.Contains%2A>方法。)  
  
 默认构造函数用于具有默认容量创建的字符串列表。 <xref:System.Collections.Generic.List%601.Capacity%2A>显示属性，然后<xref:System.Collections.Generic.List%601.Add%2A>方法用于将添加多个项。 项被列出，和<xref:System.Collections.Generic.List%601.Capacity%2A>属性显示再次，连同<xref:System.Collections.Generic.List%601.Count%2A>属性，以显示具有已增加容量，根据需要。  
  
 <xref:System.Collections.Generic.List%601.Contains%2A>方法用于测试是否存在某个项在列表中，<xref:System.Collections.Generic.List%601.Insert%2A>方法可用于插入新项中间列表中，并再次显示列表的内容。  
  
 默认值<xref:System.Collections.Generic.List%601.Item%2A>使用属性 （C# 中的索引器） 来检索某一项，<xref:System.Collections.Generic.List%601.Remove%2A>方法可用于删除更早版本，添加的重复项的第一个实例，并再次显示内容。 <xref:System.Collections.Generic.List%601.Remove%2A>方法始终中删除它所遇到的第一个实例。  
  
 <xref:System.Collections.Generic.List%601.TrimExcess%2A>方法用于减少容量以匹配计数，和<xref:System.Collections.Generic.List%601.Capacity%2A>和<xref:System.Collections.Generic.List%601.Count%2A>属性显示。 如果未使用的容量过小于 10%的总容量，列表将不具有已调整大小。  
  
 最后，<xref:System.Collections.Generic.List%601.Clear%2A>方法用于从列表中，删除所有项和<xref:System.Collections.Generic.List%601.Capacity%2A>和<xref:System.Collections.Generic.List%601.Count%2A>属性显示。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>公共静态 (<see langword="Shared" />在 Visual Basic 中) 的此类型的成员都是线程安全。 但不保证所有实例成员都是线程安全的。  
  
 则可以安全地执行多个读取的操作<see cref="T:System.Collections.Generic.List`1" />，但如果在读取时修改集合，可能会出现问题。 若要确保线程安全，读取期间锁定集合，或写操作。 若要启用访问集合以进行读取和写入的多个线程，则必须实现自己的同步。 具有内置同步的集合，请参阅中的类<see cref="N:System.Collections.Concurrent" />命名空间。 本质上就是线程 – 安全替代方法，请参阅<see cref="T:System.Collections.Immutable.ImmutableList`1" />类。</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Collections.Generic.List`1" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Collections.Generic.List`1" /> 类的新实例，该实例为空并且具有默认初始容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 容量<xref:System.Collections.Generic.List%601>是元素的数目，<xref:System.Collections.Generic.List%601>可以保存。 如元素添加到<xref:System.Collections.Generic.List%601>，自动增加容量通过重新分配在内部数组所需的方式。  
  
 如果可以估计集合的大小，使用<xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29>构造函数和指定的初始容量消除了需要执行大量的大小将元素添加到时调整操作<xref:System.Collections.Generic.List%601>。  
  
 可以通过调用减少容量<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法或通过设置<xref:System.Collections.Generic.List%601.Capacity%2A>属性显式。 减少容量重新分配内存并将复制中的所有元素<xref:System.Collections.Generic.List%601>。  
  
 此构造函数是 o （1） 操作。  
  
   
  
## Examples  
 下面的示例演示的默认构造函数<xref:System.Collections.Generic.List%601>泛型类。 默认构造函数创建默认的容量，列表通过显示所示<xref:System.Collections.Generic.List%601.Capacity%2A>属性。  
  
 该示例将添加、 插入、 和中移除项，显示这些方法在容量的变化方式。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">一个集合，其元素被复制到新列表中。</param>
        <summary>初始化 <see cref="T:System.Collections.Generic.List`1" /> 类的新实例，该实例包含从指定集合复制的元素并且具有足够的容量来容纳所复制的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将元素复制到<xref:System.Collections.Generic.List%601>与它们的集合的枚举器会读取相同的顺序。  
  
 此构造函数是 O (*n*) 操作，其中*n*是中的元素数`collection`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.%23ctor%2A>构造函数以及各种方法<xref:System.Collections.Generic.List%601>对范围进行操作的类。 创建并传递到构造函数，填充数组的元素列表的字符串数组。 <xref:System.Collections.Generic.List%601.Capacity%2A>属性然后会显示，显示的初始容量正是来保存的输入的元素的要求。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">新列表最初可以存储的元素数。</param>
        <summary>初始化 <see cref="T:System.Collections.Generic.List`1" /> 类的新实例，该实例为空并且具有指定的初始容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 容量<xref:System.Collections.Generic.List%601>是元素的数目，<xref:System.Collections.Generic.List%601>可以保存。 如元素添加到<xref:System.Collections.Generic.List%601>，自动增加容量通过重新分配在内部数组所需的方式。  
  
 如果可以估计集合的大小，指定的初始容量，则无需执行大量的大小将元素添加到时调整操作<xref:System.Collections.Generic.List%601>。  
  
 可以通过调用减少容量<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法或通过设置<xref:System.Collections.Generic.List%601.Capacity%2A>属性显式。 减少容量重新分配内存并将复制中的所有元素<xref:System.Collections.Generic.List%601>。  
  
 此构造函数是 O (*n*) 操作，其中*n*是`capacity`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29>构造函数。 A<xref:System.Collections.Generic.List%601>容量为 4 的字符串的创建后，由于大家都知道列表的最终大小恰好为 4。 列表中填充了四个字符串，并且通过使用创建只读副本<xref:System.Collections.Generic.List%601.AsReadOnly%2A>方法。  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> 小于 0。</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要添加到 <see cref="T:System.Collections.Generic.List`1" /> 末尾的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>将对象添加到 <see cref="T:System.Collections.Generic.List`1" /> 的结尾处。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 接受`null`引用为有效的值类型，并允许重复的元素。  
  
 如果<xref:System.Collections.Generic.List%601.Count%2A>已经等于<xref:System.Collections.Generic.List%601.Capacity%2A>、 容量的<xref:System.Collections.Generic.List%601>增加通过自动重新分配在内部数组和现有元素被复制到新数组中，在添加新的元素之前。  
  
 如果<xref:System.Collections.Generic.List%601.Count%2A>是小于<xref:System.Collections.Generic.List%601.Capacity%2A>，此方法为 o （1） 运算。 如果容量需要增加以容纳新元素，此方法会成为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示如何添加、 删除和插入中的简单的业务对象<xref:System.Collections.Generic.List%601>。  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 下面的示例演示几个属性和方法的<xref:System.Collections.Generic.List%601>泛型类，包括<xref:System.Collections.Generic.List%601.Add%2A>方法。 默认构造函数用于创建的字符串列表具有的容量为 0。 <xref:System.Collections.Generic.List%601.Capacity%2A>属性显示，然后<xref:System.Collections.Generic.List%601.Add%2A>方法用于将添加多个项。 项被列出，和<xref:System.Collections.Generic.List%601.Capacity%2A>属性显示再次，连同<xref:System.Collections.Generic.List%601.Count%2A>属性，以显示具有已增加容量，根据需要。  
  
 其他属性和方法用于搜索、 插入和删除元素从列表中，最后要清除列表。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">应将其元素添加到 <see cref="T:System.Collections.Generic.List`1" /> 的末尾的集合。 集合自身不能为 <see langword="null" />，但它可以包含为 <see langword="null" /> 的元素（如果类型 <c>T</c> 为引用类型）。</param>
        <summary>将指定集合的元素添加到 <see cref="T:System.Collections.Generic.List`1" /> 的末尾。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 集合中的元素的顺序均保留在<xref:System.Collections.Generic.List%601>。  
  
 如果新<xref:System.Collections.Generic.List%601.Count%2A>(当前<xref:System.Collections.Generic.List%601.Count%2A>plus 集合的大小) 将大于<xref:System.Collections.Generic.List%601.Capacity%2A>、 容量的<xref:System.Collections.Generic.List%601>增加通过自动重新分配以容纳新元素，在内部数组和在添加新的元素之前，现有元素被复制到新数组。  
  
 如果<xref:System.Collections.Generic.List%601>可以容纳新元素，而无需增加<xref:System.Collections.Generic.List%601.Capacity%2A>，此方法为 O (*n*) 操作，其中*n*是要添加的元素数。 如果增加以容纳新元素所需的容量，此方法会成为 O (*n* + *m*) 操作，其中*n*是元素的数目要添加和*m*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.AddRange%2A>方法以及各种其他方法<xref:System.Collections.Generic.List%601>对范围进行操作的类。 创建并传递到构造函数，填充数组的元素列表的字符串数组。 <xref:System.Collections.Generic.List%601.AddRange%2A>调用方法时，与作为其自变量列表。 结果是，列表中的当前元素添加到列表中，复制的所有元素的末尾。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前集合的只读 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 包装器。</summary>
        <returns>一个对象，作为围绕当前 <see cref="T:System.Collections.Generic.List`1" /> 的只读包装器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止对<xref:System.Collections.Generic.List%601>对象，仅通过此包装器将其公开。 A<xref:System.Collections.ObjectModel.ReadOnlyCollection%601>对象未公开修改该集合的方法。 但是，如果更改到基础<xref:System.Collections.Generic.List%601>对象，只读集合反映这些更改。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.AsReadOnly%2A>方法。 A<xref:System.Collections.Generic.List%601>容量为 4 的字符串的创建后，由于大家都知道列表的最终大小恰好为 4。 列表中填充了四个字符串和<xref:System.Collections.Generic.List%601.AsReadOnly%2A>方法用于获取只读<xref:System.Collections.Generic.IList%601>包装原始列表的泛型接口实现。  
  
 原始列表的元素设置为"Coelophysis"使用<xref:System.Collections.Generic.List%601.Item%2A>属性 （索引器在 C# 中），只读的列表的内容将显示和再次以演示它是只是原始列表的包装器。  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用对分检索算法在已排序的 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中查找特定元素。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>使用默认的比较器在整个已排序的 <see cref="T:System.Collections.Generic.List`1" /> 中搜索元素，并返回该元素从零开始的索引。</summary>
        <returns>如果找到 <paramref name="item" />，则为已排序的 <see cref="T:System.Collections.Generic.List`1" /> 中 <paramref name="item" /> 的从零开始的索引；否则为一个负数，该负数是大于 <paramref name="item" /> 的下一个元素的索引的按位求补。如果没有更大的元素，则为 <see cref="P:System.Collections.Generic.List`1.Count" /> 的按位求补。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用默认比较器<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>类型`T`以确定列表元素的顺序。 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>属性检查是否键入`T`实现<xref:System.IComparable%601>泛型接口，并使用该实现中，如果可用。  如果没有，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否键入`T`实现<xref:System.IComparable>接口。  如果类型`T`不实现任何接口，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>引发<xref:System.InvalidOperationException>。  
  
 <xref:System.Collections.Generic.List%601>必须已排序根据比较器实现中; 否则，结果是不正确。  
  
 比较`null`使用任何引用类型可以允许并且使用时不会生成异常<xref:System.IComparable%601>泛型接口。 在排序时，`null`被视为小于任何其他对象。  
  
 如果<xref:System.Collections.Generic.List%601>多个元素具有相同的值，该方法返回仅包含一个匹配项，并且可能会返回任何一个匹配项，不一定是第一个。  
  
 如果<xref:System.Collections.Generic.List%601>不包含指定的值，该方法返回负整数。 你可以应用于此负的整数，以获取大于搜索值的第一个元素的索引的按位求补运算 （~）。 插入到的值时<xref:System.Collections.Generic.List%601>，此索引应使用的插入点，若要维护的排序顺序。  
  
 此方法为 O (日志*n*) 操作，其中*n*是范围中元素数。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Sort>方法重载与<xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>方法重载。 A<xref:System.Collections.Generic.List%601>的字符串创建并填充了四个字符串，顺序不分先后。 该列表是显示、 排序，并再次显示。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>方法重载然后用于搜索的两个字符串的不在列表中，与<xref:System.Collections.Generic.List%601.Insert%2A>方法用于将其插入。 返回值<xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>方法中是负数每种情况下，由于字符串不是在列表中。 执行按位求补 (~ 中 C# 和 Visual c + + 中，运算符`Xor`在 Visual Basic 中的为-1) 的此负的数字生成大于整个搜索字符串，且插入此位置中的列表中的第一个元素的索引保留排序顺序。 第二个搜索字符串是大于在列表中，任何元素，因此插入位置位于列表的末尾。  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 无法找到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">要定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现。  
  
 或  
  
 如果使用默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" />，则为 <see langword="null" />。</param>
        <summary>使用指定的比较器在整个已排序的 <see cref="T:System.Collections.Generic.List`1" /> 中搜索元素，并返回该元素从零开始的索引。</summary>
        <returns>如果找到 <paramref name="item" />，则为已排序的 <see cref="T:System.Collections.Generic.List`1" /> 中 <paramref name="item" /> 的从零开始的索引；否则为一个负数，该负数是大于 <paramref name="item" /> 的下一个元素的索引的按位求补。如果没有更大的元素，则为 <see cref="P:System.Collections.Generic.List`1.Count" /> 的按位求补。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比较器自定义如何比较元素。 例如，你可以使用<xref:System.Collections.CaseInsensitiveComparer>实例作为要执行不区分大小写的字符串搜索的比较器。  
  
 如果`comparer`提供的元素<xref:System.Collections.Generic.List%601>与使用指定的指定值进行比较<xref:System.Collections.Generic.IComparer%601>实现。  
  
 如果`comparer`是`null`，默认比较器<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否键入`T`实现<xref:System.IComparable%601>泛型接口，并使用该实现中，如果可用。  如果没有，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否键入`T`实现<xref:System.IComparable>接口。  如果类型`T`不实现任何接口，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>引发<xref:System.InvalidOperationException>。  
  
 <xref:System.Collections.Generic.List%601>必须已排序根据比较器实现中; 否则，结果是不正确。  
  
 比较`null`使用任何引用类型可以允许并且使用时不会生成异常<xref:System.IComparable%601>泛型接口。 在排序时，`null`被视为小于任何其他对象。  
  
 如果<xref:System.Collections.Generic.List%601>多个元素具有相同的值，该方法返回仅包含一个匹配项，并且可能会返回任何一个匹配项，不一定是第一个。  
  
 如果<xref:System.Collections.Generic.List%601>不包含指定的值，该方法返回负整数。 你可以应用于此负的整数，以获取大于搜索值的第一个元素的索引的按位求补运算 （~）。 插入到的值时<xref:System.Collections.Generic.List%601>，此索引应使用的插入点，若要维护的排序顺序。  
  
 此方法为 O (日志*n*) 操作，其中*n*是范围中元素数。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29>方法重载与<xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载。  
  
 该示例定义了名为 DinoCompare，实现的字符串将备用比较器`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。 比较器的工作方式如下： 首先，测试比较是否为`null`，并为空引用被视为小于非空。 其次，比较字符串的长度，和较长的字符串被认为更高版本。 第三，如果长度相等，则使用普通字符串比较。  
  
 A<xref:System.Collections.Generic.List%601>的字符串创建并填充了四个字符串，顺序不分先后。 列表，排序使用备用的比较器，并显示再次显示。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载然后用于搜索不在列表中，采用的备用的比较器的多个字符串。 <xref:System.Collections.Generic.List%601.Insert%2A>方法用于插入字符串。 这两种方法都位于名为函数`SearchAndInsert`，以及代码要执行按位求补 (~ 中 C# 和 Visual c + + 中，运算符`Xor`在 Visual Basic 中的为-1) 的返回的负数<xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>并将其用作的索引插入新的字符串。  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，并且默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 找不到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">要搜索范围的从零开始的起始索引。</param>
        <param name="count">要搜索的范围的长度。</param>
        <param name="item">要定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现，若要使用默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" />，则为 <see langword="null" />。</param>
        <summary>使用指定的比较器在已排序 <see cref="T:System.Collections.Generic.List`1" /> 的某个元素范围中搜索元素，并返回该元素从零开始的索引。</summary>
        <returns>如果找到 <paramref name="item" />，则为已排序的 <see cref="T:System.Collections.Generic.List`1" /> 中 <paramref name="item" /> 的从零开始的索引；否则为一个负数，该负数是大于 <paramref name="item" /> 的下一个元素的索引的按位求补。如果没有更大的元素，则为 <see cref="P:System.Collections.Generic.List`1.Count" /> 的按位求补。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比较器自定义如何比较元素。 例如，你可以使用<xref:System.Collections.CaseInsensitiveComparer>实例作为要执行不区分大小写的字符串搜索的比较器。  
  
 如果`comparer`提供的元素<xref:System.Collections.Generic.List%601>与使用指定的指定值进行比较<xref:System.Collections.Generic.IComparer%601>实现。  
  
 如果`comparer`是`null`，默认比较器<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否键入`T`实现<xref:System.IComparable%601>泛型接口，并使用该实现中，如果可用。  如果没有，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否键入`T`实现<xref:System.IComparable>接口。  如果类型`T`不实现任何接口，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>引发<xref:System.InvalidOperationException>。  
  
 <xref:System.Collections.Generic.List%601>必须已排序根据比较器实现中; 否则，结果是不正确。  
  
 比较`null`使用任何引用类型可以允许并且使用时不会生成异常<xref:System.IComparable%601>泛型接口。 在排序时，`null`被视为小于任何其他对象。  
  
 如果<xref:System.Collections.Generic.List%601>多个元素具有相同的值，该方法返回仅包含一个匹配项，并且可能会返回任何一个匹配项，不一定是第一个。  
  
 如果<xref:System.Collections.Generic.List%601>不包含指定的值，该方法返回负整数。 你可以应用于此负的整数，以获取大于搜索值的第一个元素的索引的按位求补运算 （~）。 插入到的值时<xref:System.Collections.Generic.List%601>，此索引应使用的插入点，若要维护的排序顺序。  
  
 此方法为 O (日志*n*) 操作，其中*n*是范围中元素数。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载与<xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载。  
  
 该示例定义了名为 DinoCompare，实现的字符串将备用比较器`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。 比较器的工作方式如下： 首先，测试比较是否为`null`，并为空引用被视为小于非空。 其次，比较字符串的长度，和较长的字符串被认为更高版本。 第三，如果长度相等，则使用普通字符串比较。  
  
 A<xref:System.Collections.Generic.List%601>的字符串是创建并填充一个和示例的名称。 在两个组中，名称不按任何特定的排序顺序。 显示的列表，该进行排序使用备用的比较器，并再次显示的列表。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载然后用于搜索"Brachiosaurus"仅草食范围。 未找到该字符串，并按位求补 (~ 中 C# 和 Visual c + + 中，运算符`Xor`在 Visual Basic 中的为-1) 返回的负数的<xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法用于插入新的字符串用作索引。  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 0。  
  
 或  
  
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.Generic.List`1" /> 中的有效范围。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，并且默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 找不到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置该内部数据结构在不调整大小的情况下能够容纳的元素总数。</summary>
        <value>在需要调整大小之前 <see cref="T:System.Collections.Generic.List`1" /> 可包含的元素数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 是的元素数的<xref:System.Collections.Generic.List%601>可以存储需要，调整大小之前而<xref:System.Collections.Generic.List%601.Count%2A>是中的实际的元素数目<xref:System.Collections.Generic.List%601>。  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 大于或等于始终是<xref:System.Collections.Generic.List%601.Count%2A>。 如果<xref:System.Collections.Generic.List%601.Count%2A>超过<xref:System.Collections.Generic.List%601.Capacity%2A>时添加元素，通过在复制旧元素和添加新的元素之前自动重新分配在内部数组增加容量。  
  
 如果容量将显著大于计数，并且你想要减少所使用的内存<xref:System.Collections.Generic.List%601>，你可以通过调用减少容量<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法或通过设置<xref:System.Collections.Generic.List%601.Capacity%2A>显式到较低的值的属性。 时的值<xref:System.Collections.Generic.List%601.Capacity%2A>设置显式，在内部数组还重新分配以适应指定的容量，并复制所有元素。  
  
 检索此属性的值的运算 o （1）;将属性设置为 O (*n*) 操作，其中*n*新容量。  
  
   
  
## Examples  
 下面的示例演示如何检查的容量和计数<xref:System.Collections.Generic.List%601>，其中包含一个简单的业务对象，对象，说明如何使用<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法以删除额外的容量。  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 下面的示例演示<xref:System.Collections.Generic.List%601.Capacity%2A>生活中的列表的几个点属性。 默认构造函数用于创建带有的容量为 0，字符串的列表和<xref:System.Collections.Generic.List%601.Capacity%2A>属性显示为了说明这点。 后<xref:System.Collections.Generic.List%601.Add%2A>方法已被使用，以添加多个项，会列出各项，然后<xref:System.Collections.Generic.List%601.Capacity%2A>属性显示再次，连同<xref:System.Collections.Generic.List%601.Count%2A>属性，以显示具有已增加容量，根据需要。  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A>属性显示后再次<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法用于减少容量以匹配计数。 最后，<xref:System.Collections.Generic.List%601.Clear%2A>方法用于从列表中，删除所有项和<xref:System.Collections.Generic.List%601.Capacity%2A>和<xref:System.Collections.Generic.List%601.Count%2A>再次显示属性。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Collections.Generic.List`1.Capacity" /> 已设置为一个小于 <see cref="P:System.Collections.Generic.List`1.Count" /> 的值。</exception>
        <exception cref="T:System.OutOfMemoryException">系统上没有足够的可用内存。</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从 <see cref="T:System.Collections.Generic.List`1" /> 中移除所有元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> 设置为 0，并且集合的元素对其他对象的引用也被释放。  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 保持不变。 若要重置的容量<xref:System.Collections.Generic.List%601>，调用<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法或一组<xref:System.Collections.Generic.List%601.Capacity%2A>直接属性。 减少容量重新分配内存并将复制中的所有元素<xref:System.Collections.Generic.List%601>。 截去空<xref:System.Collections.Generic.List%601>的容量设置<xref:System.Collections.Generic.List%601>到默认的容量。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Clear%2A>方法和各种其他属性和方法的<xref:System.Collections.Generic.List%601>泛型类。 <xref:System.Collections.Generic.List%601.Clear%2A>方法在程序中，末尾使用要从列表中，删除所有项和<xref:System.Collections.Generic.List%601.Capacity%2A>和<xref:System.Collections.Generic.List%601.Count%2A>属性将显示。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>确定某元素是否在 <see cref="T:System.Collections.Generic.List`1" /> 中。</summary>
        <returns>
          如果在 <see langword="true" /> 中找到 <paramref name="item" />，则为 <see cref="T:System.Collections.Generic.List`1" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法通过使用默认的相等比较，确定相等性，该对象的实现定义<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>方法`T`（列表中的值的类型）。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Contains%2A>和<xref:System.Collections.Generic.List%601.Exists%2A>方法<xref:System.Collections.Generic.List%601>，其中包含实现一个简单的业务对象<xref:System.IEquatable%601.Equals%2A>。  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 下面的示例包含的复杂类型的对象列表`Cube`。 `Cube`类实现<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>方法，以便两个多维数据集可视为相等，如果其尺寸相同。 在此示例中，<xref:System.Collections.Generic.List%601.Contains%2A>方法返回`true`，因为具有指定的维度的多维数据集已在集合中。  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">目标数组元素的类型。</typeparam>
        <param name="converter">一个 <see cref="T:System.Converter`2" /> 委托，可将每个元素从一种类型转换为另一种类型。</param>
        <summary>将当前 <see cref="T:System.Collections.Generic.List`1" /> 中的元素转换为另一种类型，并返回包含已转换元素的列表。</summary>
        <returns>目标类型的 <see cref="T:System.Collections.Generic.List`1" />，包含当前 <see cref="T:System.Collections.Generic.List`1" /> 中转换后的元素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602>是将对象转换为目标类型的方法的委托。  当前元素<xref:System.Collections.Generic.List%601>单独传递给<xref:System.Converter%602>委托和转换后的元素都保存在新<xref:System.Collections.Generic.List%601>。  
  
 当前<xref:System.Collections.Generic.List%601>保持不变。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例定义一个名为方法`PointFToPoint`，用于将转换<xref:System.Drawing.PointF>结构<xref:System.Drawing.Point>结构。 然后，示例创建<xref:System.Collections.Generic.List%601>的<xref:System.Drawing.PointF>结构，创建`Converter\<PointF, Point>`委托 (`Converter(Of PointF, Point)`在 Visual Basic 中) 来表示`PointFToPoint`方法，并将传递到委托<xref:System.Collections.Generic.List%601.ConvertAll%2A>方法。 <xref:System.Collections.Generic.List%601.ConvertAll%2A>方法将传递到输入列表的每个元素`PointFToPoint`方法并将转换后的元素放入一个新的列表<xref:System.Drawing.Point>结构。 显示这两个列表。  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="converter" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分复制到一个数组中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Generic.List`1" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <summary>从目标数组的开头开始，将整个 <see cref="T:System.Collections.Generic.List`1" /> 复制到兼容的一维数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Copy%2A?displayProperty=nameWithType>要复制的元素。  
  
 元素被复制到<xref:System.Array>枚举数循环访问的相同顺序<xref:System.Collections.Generic.List%601>。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.CopyTo%2A>方法。 A<xref:System.Collections.Generic.List%601>的字符串创建并填充了 5 的字符串。 在创建空的字符串数组的 15 元素，与<xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29>使用方法重载将列表中的所有元素复制到数组的第一个元素开始的数组。 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29>方法重载用于复制的所有元素的数组索引 6 开始的数组到列表 （将索引 5 留为空）。 最后，<xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用方法重载来复制从列表中，索引 2 开始的 3 个元素，使用到数组开始的数组索引 12 （将索引 11 留为空）。 数组的内容将显示。  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">源 <see cref="T:System.Collections.Generic.List`1" /> 中的元素个数大于目标 <paramref name="array" /> 可以包含的元素个数。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Generic.List`1" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <param name="arrayIndex">
          <c>array</c> 中从零开始的索引，在此处开始复制。</param>
        <summary>从目标数组的指定索引处开始，将整个 <see cref="T:System.Collections.Generic.List`1" /> 复制到兼容的一维数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Copy%2A?displayProperty=nameWithType>要复制的元素。  
  
 元素被复制到<xref:System.Array>枚举数循环访问的相同顺序<xref:System.Collections.Generic.List%601>。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.CopyTo%2A>方法。 A<xref:System.Collections.Generic.List%601>的字符串创建并填充了 5 的字符串。 在创建空的字符串数组的 15 元素，与<xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29>使用方法重载将列表中的所有元素复制到数组的第一个元素开始的数组。 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29>方法重载用于复制的所有元素的数组索引 6 开始的数组到列表 （将索引 5 留为空）。 最后，<xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用方法重载来复制从列表中，索引 2 开始的 3 个元素，使用到数组开始的数组索引 12 （将索引 11 留为空）。 数组的内容将显示。  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException">源 <see cref="T:System.Collections.Generic.List`1" /> 中的元素个数大于从 <paramref name="arrayIndex" /> 到目标 <paramref name="array" /> 末尾之间的可用空间。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">复制即从源 <see cref="T:System.Collections.Generic.List`1" /> 中从零开始的索引开始。</param>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.Generic.List`1" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <param name="arrayIndex">
          <c>array</c> 中从零开始的索引，在此处开始复制。</param>
        <param name="count">要复制的元素数。</param>
        <summary>从目标数组的指定索引处开始，将元素的范围从 <see cref="T:System.Collections.Generic.List`1" /> 复制到兼容的一维数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Copy%2A?displayProperty=nameWithType>要复制的元素。  
  
 元素被复制到<xref:System.Array>枚举数循环访问的相同顺序<xref:System.Collections.Generic.List%601>。  
  
 此方法为 O (*n*) 操作，其中*n*是`count`。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.CopyTo%2A>方法。 A<xref:System.Collections.Generic.List%601>的字符串创建并填充了 5 的字符串。 在创建空的字符串数组的 15 元素，与<xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29>使用方法重载将列表中的所有元素复制到数组的第一个元素开始的数组。 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29>方法重载用于复制的所有元素的数组索引 6 开始的数组到列表 （将索引 5 留为空）。 最后，<xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>使用方法重载来复制从列表中，索引 2 开始的 3 个元素，使用到数组开始的数组索引 12 （将索引 11 留为空）。 数组的内容将显示。  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 0。  
  
 或  
  
 <paramref name="arrayIndex" /> 小于 0。  
  
 或  
  
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 等于或大于源 <see cref="P:System.Collections.Generic.List`1.Count" /> 的 <see cref="T:System.Collections.Generic.List`1" />。  
  
 或  
  
 从 <paramref name="index" /> 到源 <see cref="T:System.Collections.Generic.List`1" /> 的末尾的元素数大于从 <paramref name="arrayIndex" /> 到目标 <paramref name="array" /> 的末尾的可用空间。</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Collections.Generic.List`1" /> 中包含的元素数。</summary>
        <value>
          <see cref="T:System.Collections.Generic.List`1" /> 中包含的元素数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 是的元素数的<xref:System.Collections.Generic.List%601>需要调整大小之前可以存储。 <xref:System.Collections.Generic.List%601.Count%2A> 是中的实际的元素数目<xref:System.Collections.Generic.List%601>。  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 大于或等于始终是<xref:System.Collections.Generic.List%601.Count%2A>。 如果<xref:System.Collections.Generic.List%601.Count%2A>超过<xref:System.Collections.Generic.List%601.Capacity%2A>时添加元素，通过在复制旧元素和添加新的元素之前自动重新分配在内部数组增加容量。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的示例演示如何检查的容量和计数<xref:System.Collections.Generic.List%601>，其中包含一个简单的业务对象，对象，说明如何使用<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法以删除额外的容量。  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 下面的示例显示的值<xref:System.Collections.Generic.List%601.Count%2A>生活中的列表的各个点的属性。 创建了列表并将其填充并显示其元素后,<xref:System.Collections.Generic.List%601.Capacity%2A>和<xref:System.Collections.Generic.List%601.Count%2A>属性显示。 这些属性显示后再次<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法已被清除被调用，并在该列表的内容后再次。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素应满足的条件。</param>
        <summary>确定 <see cref="T:System.Collections.Generic.List`1" /> 是否包含与指定谓词定义的条件匹配的元素。</summary>
        <returns>
          如果 <see cref="T:System.Collections.Generic.List`1" /> 包含一个或多个元素与指定谓词定义的条件匹配，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>单独传递给<xref:System.Predicate%601>找到匹配项的委托，然后处理已停止。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Contains%2A>和<xref:System.Collections.Generic.List%601.Exists%2A>方法<xref:System.Collections.Generic.List%601>，其中包含实现一个简单的业务对象<xref:System.IEquatable%601.Equals%2A>。  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 下面的示例演示<xref:System.Collections.Generic.List%601.Exists%2A>方法和使用的其他几个方法<xref:System.Predicate%601>泛型委托。  
  
 A<xref:System.Collections.Generic.List%601>字符串的创建，包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。 该示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Collections.Generic.List%601.Find%2A>， <xref:System.Collections.Generic.List%601.FindLast%2A>，和<xref:System.Collections.Generic.List%601.FindAll%2A>方法用于使用搜索谓词的方法，在列表中搜索，然后<xref:System.Collections.Generic.List%601.RemoveAll%2A>方法用于删除以"saurus"结尾的所有条目。  
  
 最后，<xref:System.Collections.Generic.List%601.Exists%2A>调用方法。 它从开始时，将每个元素传递给反过来遍历此列表`EndsWithSaurus`方法。 搜索将停止并且该方法返回`true`如果`EndsWithSaurus`方法返回`true`任何元素。 <xref:System.Collections.Generic.List%601.Exists%2A>方法返回`false`因为已经删除了所有此类元素。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中的第一个匹配元素。</summary>
        <returns>如果找到与指定谓词定义的条件匹配的第一个元素，则为该元素；否则为类型 <paramref name="T" /> 的默认值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>单独传递给<xref:System.Predicate%601>委托，接着<xref:System.Collections.Generic.List%601>，从第一个元素开始和结束的最后一个元素。  找到匹配项，已停止处理。  
  
> [!IMPORTANT]
>  在搜索时包含值类型的列表，请确保类型的默认值不满足搜索谓词。 否则，是无法区分默认值，指示未找到任何匹配项和碰巧有类型的默认值的列表元素。 默认值满足搜索谓词，如果使用<xref:System.Collections.Generic.List%601.FindIndex%2A>方法相反。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 以下示例演示包含简单上下文对象的 <xref:System.Collections.Generic.List%601.Find%2A> 上的 <xref:System.Collections.Generic.List%601> 方法。  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 下面的示例演示的查找方法<xref:System.Collections.Generic.List%601>类。 例如<xref:System.Collections.Generic.List%601>类包含`book`类的对象`Book`，使用来自数据[示例 XML 文件： 书籍 (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)。 `FillList`方法在示例中使用[LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)要分析的属性值的值从 XML`book`对象。  
  
 下表描述为 find 方法提供的示例。  
  
|方法|示例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|查找 ID 使用书`IDToFind`谓词的委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|查找所有丛书该其`Genre`属性是"计算机"使用`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|在具有发布日期早于 2001，使用集合中查找最后一本书`PubBefore2001`谓词的委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|查找第一个计算机簿使用的索引`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|查找的最后一个计算机簿使用索引`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|在集合的后半部分在第二个查找第一个计算机书的索引使用`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|在集合的后半部分在第二个查找最后一个计算机书的索引使用`FindComputer`谓词的委托。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素应满足的条件。</param>
        <summary>检索与指定谓词定义的条件匹配的所有元素。</summary>
        <returns>如果找到一个 <see cref="T:System.Collections.Generic.List`1" />，其中所有元素均与指定谓词定义的条件匹配，则为该数组；否则为一个空 <see cref="T:System.Collections.Generic.List`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>单独传递给<xref:System.Predicate%601>委托，以及与的条件匹配的元素都将保存在返回<xref:System.Collections.Generic.List%601>。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的查找方法<xref:System.Collections.Generic.List%601>类。 例如<xref:System.Collections.Generic.List%601>类包含`book`类的对象`Book`，使用来自数据[示例 XML 文件： 书籍 (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)。 `FillList`方法在示例中使用[LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)要分析的属性值的值从 XML`book`对象。  
  
 下表描述为 find 方法提供的示例。  
  
|方法|示例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|查找 ID 使用书`IDToFind`谓词的委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|查找所有丛书该其`Genre`属性是"计算机"使用`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|在具有发布日期早于 2001，使用集合中查找最后一本书`PubBefore2001`谓词的委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|查找第一个计算机簿使用的索引`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|查找的最后一个计算机簿使用索引`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|在集合的后半部分在第二个查找第一个计算机书的索引使用`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|在集合的后半部分在第二个查找最后一个计算机书的索引使用`FindComputer`谓词的委托。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，返回 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中第一个匹配项的从零开始的索引。 如果未找到与条件匹配的项，则此方法返回 -1。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中第一个匹配元素的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>搜索向前从第一个元素开始和结束时间的最后一个元素。  
  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>单独传递给<xref:System.Predicate%601>委托。 委托具有签名：  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例定义`Employee`类具有两个字段，`Name`和`Id`。 它还定义`EmployeeSearch`与一个方法，类`StartsWith`，，该值指示是否`Employee.Name`字段开头指定的子字符串提供给`EmployeeSearch`类构造函数。 请注意此方法的签名  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 对应于可以传递给委托的签名<xref:System.Collections.Generic.List%601.FindIndex%2A>方法。 该示例实例化`List<Employee>`对象，添加了大量`Employee`到，，然后调用 objets<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>方法两次以在整个集合，首次为第一个中搜索`Employee`对象，其`Name`字段开始使用"J"和第二次的第一个`Employee`对象，其`Name`字段开头"Ju"。  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从指定索引到最后一个元素的元素范围内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>处开始向前搜索`startIndex`和结束时间的最后一个元素。  
  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>单独传递给<xref:System.Predicate%601>委托。 委托具有签名：  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是中的元素数`startIndex`到末尾<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下面的示例定义`Employee`类具有两个字段，`Name`和`Id`。 它还定义`EmployeeSearch`与一个方法，类`StartsWith`，，该值指示是否`Employee.Name`字段开头指定的子字符串提供给`EmployeeSearch`类构造函数。 请注意此方法的签名  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 对应于可以传递给委托的签名<xref:System.Collections.Generic.List%601.FindIndex%2A>方法。 该示例实例化`List<Employee>`对象，添加了大量`Employee`到，，然后调用 objets<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>方法两次以其第五个成员 （即，成员在索引 4） 开始在集合中搜索。 第一次搜索的第一个`Employee`对象，其`Name`字段开头"J"; 它的第一个搜索的第二次`Employee`对象，其`Name`字段开头"Ju"。  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的一个元素，并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从指定的索引开始、包含指定元素个数的元素范围内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>处开始向前搜索`startIndex`结束`startIndex`加上`count`减 1，如果`count`大于 0。  
  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>单独传递给<xref:System.Predicate%601>委托。 委托具有签名：  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是`count`。  
  
   
  
## Examples  
 下面的示例定义`Employee`类具有两个字段，`Name`和`Id`。 它还定义`EmployeeSearch`与一个方法，类`StartsWith`，，该值指示是否`Employee.Name`字段开头指定的子字符串提供给`EmployeeSearch`类构造函数。 请注意此方法的签名  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 对应于可以传递给委托的签名<xref:System.Collections.Generic.List%601.FindIndex%2A>方法。 该示例实例化`List<Employee>`对象，添加了大量`Employee`到，，然后调用 objets<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>方法两次以在整个集合中搜索 (即，成员从索引 0 处与索引<xref:System.Collections.Generic.List%601.Count%2A>-1)。 第一次搜索的第一个`Employee`对象，其`Name`字段开头"J"; 它的第一个搜索的第二次`Employee`对象，其`Name`字段开头"Ju"。  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。  
  
 或  
  
 <paramref name="count" /> 小于 0。  
  
 或  
  
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未指定 <see cref="T:System.Collections.Generic.List`1" /> 中的有效部分。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中的最后一个匹配元素。</summary>
        <returns>如果找到，则为与指定谓词所定义的条件相匹配的最后一个元素；否则为类型 <paramref name="T" /> 的默认值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>单独传递给<xref:System.Predicate%601>委托，向后移动<xref:System.Collections.Generic.List%601>，从最后一个元素开始和结束的第一个元素。  找到匹配项，已停止处理。  
  
> [!IMPORTANT]
>  在搜索时包含值类型的列表，请确保类型的默认值不满足搜索谓词。 否则，是无法区分默认值，指示未找到任何匹配项和碰巧有类型的默认值的列表元素。 默认值满足搜索谓词，如果使用<xref:System.Collections.Generic.List%601.FindLastIndex%2A>方法相反。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的查找方法<xref:System.Collections.Generic.List%601>类。 例如<xref:System.Collections.Generic.List%601>类包含`book`类的对象`Book`，使用来自数据[示例 XML 文件： 书籍 (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)。 `FillList`方法在示例中使用[LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)要分析的属性值的值从 XML`book`对象。  
  
 下表描述为 find 方法提供的示例。  
  
|方法|示例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|查找 ID 使用书`IDToFind`谓词的委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|查找所有丛书该其`Genre`属性是"计算机"使用`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|在具有发布日期早于 2001，使用集合中查找最后一本书`PubBefore2001`谓词的委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|查找第一个计算机簿使用的索引`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|查找的最后一个计算机簿使用索引`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|在集合的后半部分在第二个查找第一个计算机书的索引使用`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|在集合的后半部分在第二个查找最后一个计算机书的索引使用`FindComputer`谓词的委托。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，返回 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中最后一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中最后一个匹配元素的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>向后搜索的最后一个元素开始，在第一个元素结束。  
  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>单独传递给<xref:System.Predicate%601>委托。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的查找方法<xref:System.Collections.Generic.List%601>类。 例如<xref:System.Collections.Generic.List%601>类包含`book`类的对象`Book`，使用来自数据[示例 XML 文件： 书籍 (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)。 `FillList`方法在示例中使用[LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)要分析的属性值的值从 XML`book`对象。  
  
 下表描述为 find 方法提供的示例。  
  
|方法|示例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|查找 ID 使用书`IDToFind`谓词的委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|查找所有丛书该其`Genre`属性是"计算机"使用`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|在具有发布日期早于 2001，使用集合中查找最后一本书`PubBefore2001`谓词的委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|查找第一个计算机簿使用的索引`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|查找的最后一个计算机簿使用索引`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|在集合的后半部分在第二个查找第一个计算机书的索引使用`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|在集合的后半部分在第二个查找最后一个计算机书的索引使用`FindComputer`谓词的委托。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与由指定谓词定义的条件相匹配的元素，并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从第一个元素到指定索引的元素范围内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>是搜索向后开始`startIndex`和结束的第一个元素。  
  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>单独传递给<xref:System.Predicate%601>委托。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是从开始处的元素数目<xref:System.Collections.Generic.List%601>到`startIndex`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> 委托，用于定义要搜索的元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Collections.Generic.List`1" /> 中包含指定元素个数、到指定索引结束的元素范围内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>是搜索向后开始`startIndex`结束`startIndex`减`count`加上 1，如果`count`大于 0。  
  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>单独传递给<xref:System.Predicate%601>委托。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是`count`。  
  
   
  
## Examples  
 下面的示例演示的查找方法<xref:System.Collections.Generic.List%601>类。 例如<xref:System.Collections.Generic.List%601>类包含`book`类的对象`Book`，使用来自数据[示例 XML 文件： 书籍 (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)。 `FillList`方法在示例中使用[LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)要分析的属性值的值从 XML`book`对象。  
  
 下表描述为 find 方法提供的示例。  
  
|方法|示例|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|查找 ID 使用书`IDToFind`谓词的委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|查找所有丛书该其`Genre`属性是"计算机"使用`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|在具有发布日期早于 2001，使用集合中查找最后一本书`PubBefore2001`谓词的委托。<br /><br /> C# 示例使用匿名委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|查找第一个计算机簿使用的索引`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|查找的最后一个计算机簿使用索引`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|在集合的后半部分在第二个查找第一个计算机书的索引使用`FindComputer`谓词的委托。|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|在集合的后半部分在第二个查找最后一个计算机书的索引使用`FindComputer`谓词的委托。|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。  
  
 或  
  
 <paramref name="count" /> 小于 0。  
  
 或  
  
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未指定 <see cref="T:System.Collections.Generic.List`1" /> 中的有效部分。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="action">要对 <see cref="T:System.Collections.Generic.List`1" /> 的每个元素执行的 <see cref="T:System.Action`1" /> 委托。</param>
        <summary>对 <see cref="T:System.Collections.Generic.List`1" /> 的每个元素执行指定操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601>向其传递对对象执行的操作方法的委托。  当前元素<xref:System.Collections.Generic.List%601>单独传递给<xref:System.Action%601>委托。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 修改基础集合的正文中<xref:System.Action%601>委托不受支持，并且会导致未定义的行为。  
  
   
  
## Examples  
 下面的示例演示了利用<xref:System.Action%601>要打印的内容委托<xref:System.Collections.Generic.List%601>对象。 在此示例中`Print`方法用于向控制台显示列表的内容。  
  
> [!NOTE]
>  除了使用这些内容显示`Print`方法，C# 示例演示如何使用以向控制台显示的结果。  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">已修改集合中的某个元素。</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回循环访问 <see cref="T:System.Collections.Generic.List`1" /> 的枚举数。</summary>
        <returns>用于 <see cref="T:System.Collections.Generic.List`1.Enumerator" /> 的 <see cref="T:System.Collections.Generic.List`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` C# 语言的语句 (`for each` c + + 中`For Each`在 Visual Basic 中) 隐藏了枚举数的复杂性。 因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 在此位置上，<xref:System.Collections.Generic.List%601.Enumerator.Current%2A>属性是不确定。 因此，必须调用<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>方法将枚举数前移到集合，然后再读取的值的第一个元素<xref:System.Collections.Generic.List%601.Enumerator.Current%2A>。  
  
 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>属性返回相同的对象，直到<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>调用。 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 将 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 设置为下一个元素。  
  
 如果<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>越过的末尾的集合，枚举数定位在集合中的最后一个元素的后面和<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>返回`false`。 当枚举器位于此位置上，后续调用<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>还返回`false`。 如果最后一次调用到<xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>返回`false`，<xref:System.Collections.Generic.List%601.Enumerator.Current%2A>是不确定的。 无法再次将 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 设置为集合的第一个元素；必须改为创建新的枚举器实例。  
  
 只要集合保持不变，枚举数就保持有效。 如果对集合进行更改（如添加、修改或删除元素），则枚举数将失效且不可恢复，而且其行为是不确定的。  
  
 枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。 若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。  
  
 此方法为 o （1） 运算。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">范围开始处的从零开始的 <see cref="T:System.Collections.Generic.List`1" /> 索引。</param>
        <param name="count">范围中的元素数。</param>
        <summary>在源 <see cref="T:System.Collections.Generic.List`1" /> 中创建元素范围的浅表复制。</summary>
        <returns>源 <see cref="T:System.Collections.Generic.List`1" /> 中的元素范围的浅表副本复制。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引用类型的集合，或者该集合的子集的浅表复制包含仅对集合的元素的引用。 对象本身不会复制。 新列表中的引用将指向相同的对象中的原始列表的引用。  
  
 值类型的集合，或者该集合的子集的浅表复制包含集合中的元素。 但是，如果集合中的元素包含对其他对象的引用，这些对象不会复制。 新集合的元素中引用都指向相同的对象中在原始集合的元素的引用。  
  
 与此相反，集合的深层副本复制这些元素，以及由这些元素直接或间接引用的所有内容。  
  
 此方法为 O (*n*) 操作，其中*n*是`count`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.GetRange%2A>方法和其他方法<xref:System.Collections.Generic.List%601>对范围进行操作的类。 在本示例中，末尾<xref:System.Collections.Generic.List%601.GetRange%2A>方法用于从列表中，从开始的索引位置 2 获取三个项。 <xref:System.Collections.Generic.List%601.ToArray%2A>方法调用所生成<xref:System.Collections.Generic.List%601>，创建三个元素的数组。 数组的元素的显示。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 0。  
  
 或  
  
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.Generic.List`1" /> 中元素的有效范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中某个值的第一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>搜索指定的对象，并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中第一个匹配项的从零开始的索引。</summary>
        <returns>如果在整个 <paramref name="item" /> 中找到 <see cref="T:System.Collections.Generic.List`1" /> 的匹配项，则为第一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>搜索向前从第一个元素开始和结束时间的最后一个元素。  
  
 此方法可确定使用的默认相等比较器的相等性<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.IndexOf%2A>方法。 A<xref:System.Collections.Generic.List%601>字符串的创建后，使用显示两次，在索引位置 0 和索引位置 5 的一个条目。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%29>方法重载从开始，在列表中搜索并查找字符串的第一个匹配项。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29>方法重载可用于搜索索引位置 3 开头的列表，直至左边缘列表中，并查找字符串的第二个匹配项。 最后，<xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置两处开头的两个条目范围; 它将返回 – 1，因为没有在该范围内的搜索字符串的实例。  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="index">从零开始的搜索的起始索引。 空列表中 0（零）为有效值。</param>
        <summary>搜索指定对象并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从指定索引到最后一个元素这部分元素中第一个匹配项的从零开始索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.Generic.List`1" /> 中从 <paramref name="index" /> 到最后一个元素的元素范围内找到 <paramref name="item" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>处开始向前搜索`index`和结束时间的最后一个元素。  
  
 此方法可确定使用的默认相等比较器的相等性<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是中的元素数`index`到末尾<xref:System.Collections.Generic.List%601>。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.IndexOf%2A>方法。 A<xref:System.Collections.Generic.List%601>字符串的创建后，使用显示两次，在索引位置 0 和索引位置 5 的一个条目。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%29>方法重载从开始，在列表中搜索并查找字符串的第一个匹配项。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29>方法重载可用于搜索索引位置 3 开头的列表，直至左边缘列表中，并查找字符串的第二个匹配项。 最后，<xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置两处开头的两个条目范围; 它将返回 – 1，因为没有在该范围内的搜索字符串的实例。  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="index">从零开始的搜索的起始索引。 空列表中 0（零）为有效值。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定对象并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从指定索引开始并包含指定元素数的这部分元素中第一个匹配项的从零开始索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.Generic.List`1" /> 中从 <paramref name="index" /> 开始并包含 <paramref name="count" /> 个元素的元素范围内找到 <paramref name="item" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>处开始向前搜索`index`结束`index`加上`count`减 1，如果`count`大于 0。  
  
 此方法可确定使用的默认相等比较器的相等性<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是`count`。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.IndexOf%2A>方法。 A<xref:System.Collections.Generic.List%601>字符串的创建后，使用显示两次，在索引位置 0 和索引位置 5 的一个条目。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%29>方法重载从开始，在列表中搜索并查找字符串的第一个匹配项。 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29>方法重载可用于搜索索引位置 3 开头的列表，直至左边缘列表中，并查找字符串的第二个匹配项。 最后，<xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置两处开头的两个条目范围; 它将返回 – 1，因为没有在该范围内的搜索字符串的实例。  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。  
  
 或  
  
 <paramref name="count" /> 小于 0。  
  
 或  
  
 <paramref name="index" /> 和 <paramref name="count" /> 未指定 <see cref="T:System.Collections.Generic.List`1" /> 中的有效部分。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">从零开始的索引，应在该位置插入 <c>item</c>。</param>
        <param name="item">要插入的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>将元素插入 <see cref="T:System.Collections.Generic.List`1" /> 的指定索引处。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 接受`null`引用为有效的值类型，并允许重复的元素。  
  
 如果<xref:System.Collections.Generic.List%601.Count%2A>已经等于<xref:System.Collections.Generic.List%601.Capacity%2A>、 容量的<xref:System.Collections.Generic.List%601>增加通过自动重新分配在内部数组和现有元素被复制到新数组中，在添加新的元素之前。  
  
 如果`index`等同于<xref:System.Collections.Generic.List%601.Count%2A>，`item`添加到末尾<xref:System.Collections.Generic.List%601>。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示如何添加、 删除和插入中的简单的业务对象<xref:System.Collections.Generic.List%601>。  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 下面的示例演示<xref:System.Collections.Generic.List%601.Insert%2A>方法，以及各种其他属性和方法的<xref:System.Collections.Generic.List%601>泛型类。 创建列表后，将被添加元素。 <xref:System.Collections.Generic.List%601.Insert%2A>方法用于将项插入到列表的中间。 项插入是有重复，将在稍后删除使用<xref:System.Collections.Generic.List%601.Remove%2A>方法。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 0。  
  
 或  
  
 <paramref name="index" /> 大于 <see cref="P:System.Collections.Generic.List`1.Count" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">应在此处插入新元素的从零开始的索引。</param>
        <param name="collection">应将其元素插入到 <see cref="T:System.Collections.Generic.List`1" /> 中的集合。 集合自身不能为 <see langword="null" />，但它可以包含为 <see langword="null" /> 的元素（如果类型 <c>T</c> 为引用类型）。</param>
        <summary>将集合中的元素插入 <see cref="T:System.Collections.Generic.List`1" /> 的指定索引处。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 接受`null`引用为有效的值类型，并允许重复的元素。  
  
 如果新<xref:System.Collections.Generic.List%601.Count%2A>(当前<xref:System.Collections.Generic.List%601.Count%2A>plus 集合的大小) 将大于<xref:System.Collections.Generic.List%601.Capacity%2A>、 容量的<xref:System.Collections.Generic.List%601>增加通过自动重新分配以容纳新元素，在内部数组和在添加新的元素之前，现有元素被复制到新数组。  
  
 如果`index`等同于<xref:System.Collections.Generic.List%601.Count%2A>，元素添加到末尾<xref:System.Collections.Generic.List%601>。  
  
 集合中的元素的顺序均保留在<xref:System.Collections.Generic.List%601>。  
  
 此方法为 O (*n* * *m*) 操作，其中*n*是要添加的元素的数目和*m*是<xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.InsertRange%2A>方法以及各种其他方法<xref:System.Collections.Generic.List%601>对范围进行操作的类。 创建和使用的名称的多个和平工厂饮食历史舞台，填充列表之后<xref:System.Collections.Generic.List%601.InsertRange%2A>方法用于将三个凶恶肉饮食恐龙数组插入到列表中，索引位置 3 开始。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 0。  
  
 或  
  
 <paramref name="index" /> 大于 <see cref="P:System.Collections.Generic.List`1.Count" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要获取或设置的元素的从零开始的索引。</param>
        <summary>获取或设置指定索引处的元素。</summary>
        <value>指定索引处的元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 接受`null`引用为有效的值类型，并允许重复的元素。  
  
 可以使用下面的语法通过此属性访问集合中的特定元素：`myCollection[index]`。  
  
 检索此属性的值的运算 o （1）;设置属性也是 o （1） 运算。  
  
   
  
## Examples  
 本部分中的示例演示了<xref:System.Collections.Generic.List%601.Item%2A>属性 （C# 中的索引器） 和各种其他属性和方法的<xref:System.Collections.Generic.List%601>泛型类。 后的列表已被创建并填充使用<xref:System.Collections.Generic.List%601.Add%2A>方法，元素将检索，显示使用<xref:System.Collections.Generic.List%601.Item%2A>属性。 (有关的示例，使用<xref:System.Collections.Generic.List%601.Item%2A>属性设置的值列表的元素，请参阅<xref:System.Collections.Generic.List%601.AsReadOnly%2A>。)  
  
> [!NOTE]
>  Visual Basic、 C# 和 c + + 所有具有访问的语法<xref:System.Collections.Generic.List%601.Item%2A>而无需使用其名称的属性。 相反，变量包含<xref:System.Collections.Generic.List%601>就像它是数组使用。  
  
 C# 语言使用关键字进行定义而不是实现索引器<xref:System.Collections.Generic.List%601.Item%2A>属性。 Visual Basic 将 <xref:System.Collections.Generic.List%601.Item%2A> 实现为默认属性，该属性提供相同的索引功能。  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 0。  
  
 或  
  
 <paramref name="index" /> 等于或大于 <see cref="P:System.Collections.Generic.List`1.Count" />。</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中某个值的最后一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>搜索指定对象并返回整个 <see cref="T:System.Collections.Generic.List`1" /> 中最后一个匹配项的从零开始索引。</summary>
        <returns>如果在整个 <see cref="T:System.Collections.Generic.List`1" /> 中找到 <paramref name="item" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>向后搜索的最后一个元素开始，在第一个元素结束。  
  
 此方法可确定使用的默认相等比较器的相等性<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.LastIndexOf%2A>方法。 A<xref:System.Collections.Generic.List%601>字符串的创建后，使用显示两次，在索引位置 0 和索引位置 5 的一个条目。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29>方法重载从结束时，在整个列表中搜索并查找字符串的第二个匹配项。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29>方法重载用于搜索向后从索引位置 3 开始，然后继续到列表中的开头，因此它在列表中查找字符串的第一个匹配项的列表。 最后，<xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置 4 处开始并扩展向后的四个条目范围 （即，搜索位置 4、 3、 2 和 1 处的项）; 此搜索返回 – 1，因为没有的搜索的实例在该范围内的字符串。  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="index">向后搜索的从零开始的起始索引。</param>
        <summary>搜索指定对象并返回 <see cref="T:System.Collections.Generic.List`1" /> 中从第一个元素到指定索引这部分元素中最后一个匹配项的从零开始的索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.Generic.List`1" /> 中从第一个元素到 <paramref name="index" /> 的元素范围内找到 <paramref name="item" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>是搜索向后开始`index`和结束的第一个元素。  
  
 此方法可确定使用的默认相等比较器的相等性<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是从开始处的元素数目<xref:System.Collections.Generic.List%601>到`index`。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.LastIndexOf%2A>方法。 A<xref:System.Collections.Generic.List%601>字符串的创建后，使用显示两次，在索引位置 0 和索引位置 5 的一个条目。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29>方法重载从结束时，在整个列表中搜索并查找字符串的第二个匹配项。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29>方法重载用于搜索向后从索引位置 3 开始，然后继续到列表中的开头，因此它在列表中查找字符串的第一个匹配项的列表。 最后，<xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的索引位置 4 处开始并扩展向后的四个条目范围 （即，搜索位置 4、 3、 2 和 1 处的项）; 此搜索返回 – 1，因为没有的搜索的实例在该范围内的字符串。  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.Generic.List`1" /> 中定位的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <param name="index">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定对象并返回 <see cref="T:System.Collections.Generic.List`1" /> 中到指定索引为止包含指定元素数的这部分元素中最后一个匹配项的从零开始索引。</summary>
        <returns>如果找到包含 <paramref name="count" /> 个元素、到 <paramref name="index" /> 为止的索引，则为 <see cref="T:System.Collections.Generic.List`1" /> 中元素范围内 <paramref name="item" /> 的最后一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>是搜索向后开始`index`结束`index`减`count`加上 1，如果`count`大于 0。  
  
 此方法可确定使用的默认相等比较器的相等性<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是`count`。  
  
   
  
## Examples  
 下面的示例演示的所有三个重载<xref:System.Collections.Generic.List%601.LastIndexOf%2A>方法。 A<xref:System.Collections.Generic.List%601>字符串的创建后，使用显示两次，在索引位置 0 和索引位置 5 的一个条目。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29>方法重载从结束时，在整个列表中搜索并查找字符串的第二个匹配项。 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29>方法重载用于搜索向后从索引位置 3 开始，然后继续到列表中的开头，因此它在列表中查找字符串的第一个匹配项的列表。 最后，<xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索的 4 个条目，索引位置 4 处开始，并向后扩展范围 （即，搜索位置 4、 3、 2 和 1 处的项）; 此搜索返回 – 1，因为没有的搜索的实例在该范围内的字符串。  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 超出了 <see cref="T:System.Collections.Generic.List`1" /> 的有效索引范围。  
  
 或  
  
 <paramref name="count" /> 小于 0。  
  
 或  
  
 <paramref name="index" /> 和 <paramref name="count" /> 未指定 <see cref="T:System.Collections.Generic.List`1" /> 中的有效部分。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">要从 <see cref="T:System.Collections.Generic.List`1" /> 中删除的对象。 对于引用类型，该值可以为 <see langword="null" />。</param>
        <summary>从 <see cref="T:System.Collections.Generic.List`1" /> 中移除特定对象的第一个匹配项。</summary>
        <returns>
          如果成功移除了 <paramref name="item" />，则为 <see langword="true" />；否则为 <see langword="false" />。  如果在 <see langword="false" /> 中没有找到 <paramref name="item" />，则此方法也会返回 <see cref="T:System.Collections.Generic.List`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果类型`T`实现<xref:System.IEquatable%601>泛型接口，则相等比较器是<xref:System.IEquatable%601.Equals%2A>方法的该接口; 否则，默认相等比较器是<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示如何添加、 删除和插入中的简单的业务对象<xref:System.Collections.Generic.List%601>。  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 下面的示例演示<xref:System.Collections.Generic.List%601.Remove%2A>方法。 一些属性和方法的<xref:System.Collections.Generic.List%601>泛型类用于添加、 插入和搜索列表。 这些在操作后，该列表包含重复。 <xref:System.Collections.Generic.List%601.Remove%2A>方法可用于删除重复项，第一个实例，并显示内容。 <xref:System.Collections.Generic.List%601.Remove%2A>方法始终中删除它所遇到的第一个实例。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <see cref="T:System.Predicate`1" /> 委托，用于定义要移除的元素应满足的条件。</param>
        <summary>移除与指定的谓词所定义的条件相匹配的所有元素。</summary>
        <returns>从 <see cref="T:System.Collections.Generic.List`1" /> 中移除的元素数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>单独传递给<xref:System.Predicate%601>委托，并且与的条件匹配的元素会从<xref:System.Collections.Generic.List%601>。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.RemoveAll%2A>方法和使用的其他几个方法<xref:System.Predicate%601>泛型委托。  
  
 A<xref:System.Collections.Generic.List%601>字符串的创建，包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。 该示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Collections.Generic.List%601.Find%2A>， <xref:System.Collections.Generic.List%601.FindLast%2A>，和<xref:System.Collections.Generic.List%601.FindAll%2A>方法用于在列表中搜索与搜索谓词方法。  
  
 <xref:System.Collections.Generic.List%601.RemoveAll%2A>方法用于删除以"saurus"结尾的所有条目。 它从开始时，将每个元素传递给反过来遍历此列表`EndsWithSaurus`方法。 如果移除元素`EndsWithSaurus`方法返回`true`。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推导出的上下文中，从正确的委托，自动创建。  
  
 最后，<xref:System.Collections.Generic.List%601.Exists%2A>方法验证是否在列表中没有以"saurus"结尾的字符串。  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的元素的从零开始的索引。</param>
        <summary>移除 <see cref="T:System.Collections.Generic.List`1" /> 的指定索引处的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用<xref:System.Collections.Generic.List%601.RemoveAt%2A>要删除某个项，请在列表中的其余项目会重新编号来替换已移除的项。 例如，如果删除索引 3 处的项，则索引 4 处的项移到 3 的位置。 此外，在列表中的项的数目 (由表示<xref:System.Collections.Generic.List%601.Count%2A>属性) 会减少 1。  
  
 此方法为 O (*n*) 操作，其中*n*是 (<xref:System.Collections.Generic.List%601.Count%2A> - `index`)。  
  
   
  
## Examples  
 下面的示例演示如何添加、 删除和插入中的简单的业务对象<xref:System.Collections.Generic.List%601>。  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 0。  
  
 或  
  
 <paramref name="index" /> 等于或大于 <see cref="P:System.Collections.Generic.List`1.Count" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的元素范围的从零开始的起始索引。</param>
        <param name="count">要移除的元素数。</param>
        <summary>从 <see cref="T:System.Collections.Generic.List`1" /> 中移除一定范围的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 删除的项和以下它们中的所有元素<xref:System.Collections.Generic.List%601>索引都通过减小`count`。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.RemoveRange%2A>方法以及各种其他方法<xref:System.Collections.Generic.List%601>对范围进行操作的类。 创建和修改，列表之后<xref:System.Collections.Generic.List%601.RemoveRange%2A>方法用于删除两个元素从列表中，索引位置 2 开始。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 0。  
  
 或  
  
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.Generic.List`1" /> 中元素的有效范围。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中元素的顺序反转。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将整个 <see cref="T:System.Collections.Generic.List`1" /> 中元素的顺序反转。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Reverse%2A?displayProperty=nameWithType>若要反转的元素的顺序。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示这两个重载<xref:System.Collections.Generic.List%601.Reverse%2A>方法。 该示例创建<xref:System.Collections.Generic.List%601>的字符串，并将添加六个字符串。 <xref:System.Collections.Generic.List%601.Reverse>方法重载用于反向列表中，然后<xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29>方法重载用于反向列表中，与元素 1 开始并包含四个元素的中间。  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要反转的范围的从零开始的起始索引。</param>
        <param name="count">要反转的范围内的元素数。</param>
        <summary>将指定范围中元素的顺序反转。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Reverse%2A?displayProperty=nameWithType>若要反转的元素的顺序。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示这两个重载<xref:System.Collections.Generic.List%601.Reverse%2A>方法。 该示例创建<xref:System.Collections.Generic.List%601>的字符串，并将添加六个字符串。 <xref:System.Collections.Generic.List%601.Reverse>方法重载用于反向列表中，然后<xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29>方法重载用于反向列表中，与元素 1 开始并包含四个元素的中间。  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 0。  
  
 或  
  
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.Generic.List`1" /> 中元素的有效范围。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>对 <see cref="T:System.Collections.Generic.List`1" /> 或它的一部分中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="overloaded-method-syntax"></a>重载的方法语法  
 <xref:System.Collections.Generic.List%601.Sort%2A>方法让你可以使用默认比较器在列表中，对对象类型排序，或指定的客户排序方法。  
  
 [列表\<T >。Sort （)](xref:System.Collections.Generic.List`1.Sort*)排序中使用的对象类型的默认比较器的整个列表的元素保留在列表中。  
  
 [列表\<T >。排序 M (比较\<T > 比较)](xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29)整个使用指定的比较器的列表中的元素进行排序。  
  
 [列表\<T >。排序 (IComparer\<T > 比较器)](xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29)整个使用指定的列表中的元素进行排序<xref:System.Comparison%601?displayProperty=nameWithType>。  
  
 [列表\<T >。排序 (Int32 索引，Int32 计数 IComparer\<T > 比较器)](xref:System.Collections.Generic.List%601.Sort%28System.Int32,System.Int32,System.Collections.Generic.IComparer%7B%600%7D%29)使用指定的比较器的列表中的元素范围中的元素进行排序。  
  
## <a name="parameters"></a>参数  
  
|参数|类型|描述|  
|---------------|----------|-----------------|  
|`comparison`|<xref:System.Comparison%601>|要比较元素时使用的委托方法|  
|比较器|<xref:System.Collections.Generic.IComparer%601>|<xref:System.Collections.Generic.IComparer%601>要比较元素时使用，或为 null，表示使用默认比较器实现<xref:System.Collections.Generic.Comparer%601.Default>。|  
|`index`|<xref:System.Int32>|要排序范围的从零开始的起始索引。|  
|`count`|<xref:System.Int32>|要排序的范围的长度。|  
  
## <a name="exceptions"></a>异常  
  
|例外|条件|  
|---------------|---------------|  
|<xref:System.InvalidOperationException>|`comparer` 未指定或`null`，和默认比较器<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>找不到实现<xref:System.IComparable%601?displayProperty=nameWithType>泛型接口或<xref:System.IComparable?displayProperty=nameWithType>接口的类型为 t。|  
|<xref:System.ArgumentNullException>|`comparison` 为 `null`。|  
|<xref:System.ArgumentException>|实现`comparison`或`comparer`导致排序时出错。 例如，将某个项与其自身比较时，`comparison` 可能不返回 0。<br /><br /> 或<br /><br /> `index` 和 `count` 未在 <xref:System.Collections.Generic.List%601> 中指定有效范围。|  
|<xref:System.ArgumentOutOfRangeException>|`index` 小于 0 或`count`小于 0。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用默认比较器对整个 <see cref="T:System.Collections.Generic.List`1" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用默认比较器<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>类型`T`以确定列表元素的顺序。 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>属性检查是否键入`T`实现<xref:System.IComparable%601>泛型接口，并使用该实现中，如果可用。  如果没有，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否键入`T`实现<xref:System.IComparable>接口。  如果类型`T`不实现任何接口，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>引发<xref:System.InvalidOperationException>。  
  
 此方法使用<xref:System.Array.Sort%2A?displayProperty=nameWithType>方法，它适用反省排序，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用插入排序算法。  
  
-   如果分区数超过两个日志*n*，其中*n*是范围的输入数组，它使用 Heapsort 算法。  
  
-   否则，它使用快速排序算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 一般情况下，此方法为 O (*n*日志*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>; 在最坏情况下它复杂度为 O (*n* <sup>2</sup>) 操作。  
  
   
  
## Examples  
 下面的示例将添加到某些名称`List<String>`未排序顺序中的列表对象、 显示调用<xref:System.Collections.Generic.List%601.Sort%2A>方法，然后显示已排序的列表。  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 下面的代码演示<xref:System.Collections.Generic.List%601.Sort>和<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>简单的业务对象上的方法重载。 调用<xref:System.Collections.Generic.List%601.Sort>方法会导致部件类型的默认比较器用于与<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>方法实现通过使用匿名方法。  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 下面的示例演示<xref:System.Collections.Generic.List%601.Sort>方法重载与<xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>方法重载。 A<xref:System.Collections.Generic.List%601>的字符串创建并填充了四个字符串，顺序不分先后。 该列表是显示、 排序，并再次显示。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>方法重载然后用于搜索的两个字符串的不在列表中，与<xref:System.Collections.Generic.List%601.Insert%2A>方法用于将其插入。 返回值<xref:System.Collections.Generic.List%601.BinarySearch%2A>方法中是负数每种情况下，由于字符串不是在列表中。 执行按位求补 (~ 中 C# 和 Visual c + + 中，运算符`Xor`在 Visual Basic 中的为-1) 的此负的数字生成大于整个搜索字符串，且插入此位置中的列表中的第一个元素的索引保留排序顺序。 第二个搜索字符串是大于在列表中，任何元素，因此插入位置位于列表的末尾。  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 无法找到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现，若要使用默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" />，则为 <see langword="null" />。</param>
        <summary>使用指定的比较器对整个 <see cref="T:System.Collections.Generic.List`1" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`提供的元素<xref:System.Collections.Generic.List%601>使用指定排序<xref:System.Collections.Generic.IComparer%601>实现。  
  
 如果`comparer`是`null`，默认比较器<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否键入`T`实现<xref:System.IComparable%601>泛型接口，并使用该实现中，如果可用。  如果没有，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否键入`T`实现<xref:System.IComparable>接口。  如果类型`T`不实现任何接口，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>引发<xref:System.InvalidOperationException>。  
  
 此方法使用<xref:System.Array.Sort%2A?displayProperty=nameWithType>方法，它适用反省排序，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用插入排序算法。  
  
-   如果分区数超过两个日志*n*，其中*n*是范围的输入数组，它使用 Heapsort 算法。  
  
-   否则，它使用快速排序算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 一般情况下，此方法为 O (*n*日志*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>; 在最坏情况下它复杂度为 O (*n* <sup>2</sup>) 操作。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29>方法重载与<xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载。  
  
 该示例定义了名为 DinoCompare，实现的字符串将备用比较器`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。 比较器的工作方式如下： 首先，测试比较是否为`null`，并为空引用被视为小于非空。 其次，比较字符串的长度，和较长的字符串被认为更高版本。 第三，如果长度相等，则使用普通字符串比较。  
  
 A<xref:System.Collections.Generic.List%601>的字符串创建并填充了四个字符串，顺序不分先后。 列表，排序使用备用的比较器，并显示再次显示。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载然后用于搜索不在列表中，采用的备用的比较器的多个字符串。 <xref:System.Collections.Generic.List%601.Insert%2A>方法用于插入字符串。 这两种方法都位于名为函数`SearchAndInsert`，以及代码要执行按位求补 (~ 中 C# 和 Visual c + + 中，运算符`Xor`在 Visual Basic 中的为-1) 的返回的负数<xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>并将其用作的索引插入新的字符串。  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，且默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 找不到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">比较元素时要使用的 <see cref="T:System.Comparison`1" />。</param>
        <summary>使用指定的 <see cref="T:System.Comparison`1" />，对整个 <see cref="T:System.Collections.Generic.List`1" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparison`提供的元素<xref:System.Collections.Generic.List%601>使用委托所表示的方法进行排序。  
  
 如果`comparison`是`null`、<xref:System.ArgumentNullException>引发。  
  
 此方法使用<xref:System.Array.Sort%2A?displayProperty=nameWithType>，这适用于反省排序，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用插入排序算法  
  
-   如果分区数超过两个日志*n*，其中*n*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用快速排序算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 一般情况下，此方法为 O (*n*日志*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>; 在最坏情况下它复杂度为 O (*n* <sup>2</sup>) 操作。  
  
   
  
## Examples  
 下面的代码演示<xref:System.Collections.Generic.List%601.Sort%2A>和<xref:System.Collections.Generic.List%601.Sort%2A>简单的业务对象上的方法重载。 调用<xref:System.Collections.Generic.List%601.Sort%2A>方法会导致部件类型的默认比较器用于与<xref:System.Collections.Generic.List%601.Sort%2A>使用匿名方法实现方法。  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 下面的示例演示<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>方法重载。  
  
 该示例定义的命名的字符串替换比较方法`CompareDinosByLength`。 此方法的工作方式如下： 首先，测试比较是否为`null`，并为空引用被视为小于非空。 其次，比较字符串的长度，和较长的字符串被认为更高版本。 第三，如果长度相等，则使用普通字符串比较。  
  
 A<xref:System.Collections.Generic.List%601>的字符串创建并填充了四个字符串，顺序不分先后。 列表还包括一个空字符串和 null 引用。 显示的列表，使用排序<xref:System.Comparison%601>泛型委托表示`CompareDinosByLength`方法，然后再次显示。  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="comparison" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparison" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparison" /> 可能不返回 0。</exception>
        <altmember cref="T:System.Comparison`1" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">要排序范围的从零开始的起始索引。</param>
        <param name="count">要排序的范围的长度。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现，若要使用默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" />，则为 <see langword="null" />。</param>
        <summary>使用指定的比较器对 <see cref="T:System.Collections.Generic.List`1" /> 中某个范围内的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`提供的元素<xref:System.Collections.Generic.List%601>使用指定排序<xref:System.Collections.Generic.IComparer%601>实现。  
  
 如果`comparer`是`null`，默认比较器<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否键入`T`实现<xref:System.IComparable%601>泛型接口，并使用该实现中，如果可用。  如果没有，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>检查是否键入`T`实现<xref:System.IComparable>接口。  如果类型`T`不实现任何接口，<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>引发<xref:System.InvalidOperationException>。  
  
 此方法使用<xref:System.Array.Sort%2A?displayProperty=nameWithType>，这适用于反省排序，如下所示：  
  
-   分区大小是否少于 16 个元素，它使用插入排序算法  
  
-   如果分区数超过两个日志*n*，其中*n*是范围的输入数组，它使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则，它使用快速排序算法。  
  
 此实现将执行不稳定排序;也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。  
  
 一般情况下，此方法为 O (*n*日志*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>; 在最坏情况下它复杂度为 O (*n* <sup>2</sup>) 操作。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载与<xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载。  
  
 该示例定义了名为 DinoCompare，实现的字符串将备用比较器`IComparer<string>`(`IComparer(Of String)`在 Visual Basic 中， `IComparer<String^>` Visual c + +) 泛型接口。 比较器的工作方式如下： 首先，测试比较是否为`null`，并为空引用被视为小于非空。 其次，比较字符串的长度，和较长的字符串被认为更高版本。 第三，如果长度相等，则使用普通字符串比较。  
  
 A<xref:System.Collections.Generic.List%601>的字符串是创建并填充一个和示例的名称。 在两个组中，名称不按任何特定的排序顺序。 显示的列表，该进行排序使用备用的比较器，并再次显示的列表。  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法重载然后用于搜索"Brachiosaurus"仅草食范围。 未找到该字符串，并按位求补 (~ 中 C# 和 Visual c + + 中，运算符`Xor`在 Visual Basic 中的为-1) 返回的负数的<xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>方法用于插入新的字符串用作索引。  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于 0。  
  
 或  
  
 <paramref name="count" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.Generic.List`1" /> 中指定有效范围。  
  
 或  
  
 <paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，且默认比较器 <see cref="P:System.Collections.Generic.Comparer`1.Default" /> 找不到 <see cref="T:System.IComparable`1" /> 泛型接口或类型为 <paramref name="T" /> 的 <see cref="T:System.IComparable" /> 接口的实现。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Collections.Generic.ICollection`1" /> 是否为只读。</summary>
        <value>
          如果 <see langword="true" /> 是只读的，则为 <see cref="T:System.Collections.Generic.ICollection`1" />；否则为 <see langword="false" />。  在 <see cref="T:System.Collections.Generic.List`1" /> 的默认实现中，此属性始终返回 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在创建只读集合后，该集合不允许添加、移除或修改元素。  
  
 集合是只读的是只是一个集合与防止集合; 进行修改的包装因此，如果对基础集合进行更改，只读集合将反映这些更改。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回循环访问集合的枚举数。</summary>
        <returns>可用于循环访问集合的 <see cref="T:System.Collections.Generic.IEnumerator`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` C# 语言的语句 (`for each` c + + 中`For Each`在 Visual Basic 中) 隐藏了枚举数的复杂性。 因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 在此位置上，<xref:System.Collections.Generic.IEnumerator%601.Current%2A>属性是不确定。 因此，必须调用<xref:System.Collections.IEnumerator.MoveNext%2A>方法将枚举数前移到集合，然后再读取的值的第一个元素<xref:System.Collections.Generic.IEnumerator%601.Current%2A>。  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A>属性返回相同的对象，直到<xref:System.Collections.IEnumerator.MoveNext%2A>调用。 <xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 设置为下一个元素。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过的末尾的集合，枚举数定位在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。 当枚举器位于此位置上，后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.Generic.IEnumerator%601.Current%2A>是不确定的。 无法再次将 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 设置为集合的第一个元素；必须改为创建新的枚举器实例。  
  
 只要集合保持不变，枚举数就保持有效。 如果对集合进行更改（如添加、修改或删除元素），则枚举数将失效且不可恢复，而且其行为是不确定的。  
  
 枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。 若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。  
  
 此方法为 o （1） 运算。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.ICollection" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <param name="arrayIndex">
          <c>array</c> 中从零开始的索引，在此处开始复制。</param>
        <summary>从特定的 <see cref="T:System.Collections.ICollection" /> 索引处开始，将 <see cref="T:System.Array" /> 的元素复制到一个 <see cref="T:System.Array" /> 中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果源类型<xref:System.Collections.ICollection>无法自动转换为目标的类型`array`的非泛型实现<xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType>引发<xref:System.InvalidCastException>，而泛型实现将引发<xref:System.ArgumentException>。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> 小于 0。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> 是多维的。  
  
 或  
  
 <paramref name="array" /> 没有从零开始的索引。  
  
 或  
  
 源 <see cref="T:System.Collections.ICollection" /> 中的元素个数大于从 <paramref name="arrayIndex" /> 到目标 <paramref name="array" /> 末尾之间的可用空间。  
  
 或  
  
 无法自动将源 <see cref="T:System.Collections.ICollection" /> 的类型转换为目标 <paramref name="array" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否同步对 <see cref="T:System.Collections.ICollection" /> 的访问（线程安全）。</summary>
        <value>
          如果对 <see langword="true" /> 的访问是同步的（线程安全），则为 <see cref="T:System.Collections.ICollection" />；否则为 <see langword="false" />。  在 <see cref="T:System.Collections.Generic.List`1" /> 的默认实现中，此属性始终返回 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。  
  
 枚举整个集合本质上不是一个线程安全的过程。  在枚举与写访问的竞争其中罕见的情况下，你可以锁定集合在整个枚举期间。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> 返回可以用于对访问进行同步的对象<xref:System.Collections.ICollection>。 同步是仅当所有线程在访问该集合之前都锁定此对象有效。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可用于同步对 <see cref="T:System.Collections.ICollection" /> 的访问的对象。</summary>
        <value>可用于同步对 <see cref="T:System.Collections.ICollection" /> 的访问的对象。  在 <see cref="T:System.Collections.Generic.List`1" /> 的默认实现中，此属性始终返回当前实例。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。  
  
 枚举整个集合本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> 返回可以用于对访问进行同步的对象<xref:System.Collections.ICollection>。 同步是仅当所有线程在访问该集合之前都锁定此对象有效。 下面的代码演示如何使用<xref:System.Collections.ICollection.SyncRoot%2A>C#、 c + + 和 Visual Basic 的属性。  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回循环访问集合的枚举数。</summary>
        <returns>可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` C# 语言的语句 (`for each` c + + 中`For Each`在 Visual Basic 中) 隐藏了枚举数的复杂性。 因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 <xref:System.Collections.IEnumerator.Reset%2A> 也会将枚举器放回此位置。  在此位置上，<xref:System.Collections.IEnumerator.Current%2A>属性是不确定。 因此，必须调用<xref:System.Collections.IEnumerator.MoveNext%2A>方法将枚举数前移到集合，然后再读取的值的第一个元素<xref:System.Collections.IEnumerator.Current%2A>。  
  
 <xref:System.Collections.IEnumerator.Current%2A>属性返回相同的对象之前<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>调用。 <xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.IEnumerator.Current%2A> 设置为下一个元素。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过的末尾的集合，枚举数定位在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。 当枚举器位于此位置上，后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。 若要再次将 <xref:System.Collections.IEnumerator.Current%2A> 设置为集合的第一个元素，可以调用 <xref:System.Collections.IEnumerator.Reset%2A> 并接着调用 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合保持不变，枚举数就保持有效。 如果对集合进行更改（如添加、修改或删除元素），则枚举数将失效且不可恢复，而且其行为是不确定的。  
  
 枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间中集合的默认实现是不同步的。  
  
 此方法为 o （1） 运算。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要添加到 <see cref="T:System.Object" /> 的 <see cref="T:System.Collections.IList" />。</param>
        <summary>将某项添加到 <see cref="T:System.Collections.IList" /> 中。</summary>
        <returns>新元素的插入位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Collections.Generic.List%601.Count%2A>是小于<xref:System.Collections.Generic.List%601.Capacity%2A>，此方法为 o （1） 运算。 如果容量需要增加以容纳新元素，此方法会成为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> 属于不能分配给 <see cref="T:System.Collections.IList" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.IList" />。</param>
        <summary>确定 <see cref="T:System.Collections.IList" /> 是否包含特定值。</summary>
        <returns>
          如果在 <see langword="true" /> 中找到 <paramref name="item" />，则为 <see cref="T:System.Collections.IList" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可确定使用的默认相等比较器的相等性<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Collections.IList" /> 中定位的对象。</param>
        <summary>确定 <see cref="T:System.Collections.IList" /> 中特定项的索引。</summary>
        <returns>如果在列表中找到，则为 <paramref name="item" /> 的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可确定使用的默认相等比较器的相等性<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> 属于不能分配给 <see cref="T:System.Collections.IList" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">从零开始的索引，应在该位置插入 <c>item</c>。</param>
        <param name="item">要插入到 <see cref="T:System.Collections.IList" /> 中的对象。</param>
        <summary>在 <see cref="T:System.Collections.IList" /> 中的指定索引处插入一个项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `index` 等于 <xref:System.Collections.IList> 中的项数，则将 `item` 追加到末尾。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> 属于不能分配给 <see cref="T:System.Collections.IList" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Collections.IList" /> 是否具有固定大小。</summary>
        <value>
          如果 <see langword="true" /> 具有固定大小，则为 <see cref="T:System.Collections.IList" />；否则为 <see langword="false" />。  在 <see cref="T:System.Collections.Generic.List`1" /> 的默认实现中，此属性始终返回 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 具有固定大小的集合在创建之后不能再添加或移除元素，但是允许修改现有元素。  
  
 具有固定大小的集合是只是一个集合的包装器防止添加和移除元素;因此，如果对基础集合，包括添加或移除元素，进行更改的固定大小的集合将反映这些更改。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Collections.IList" /> 是否为只读。</summary>
        <value>
          如果 <see langword="true" /> 是只读的，则为 <see cref="T:System.Collections.IList" />；否则为 <see langword="false" />。  在 <see cref="T:System.Collections.Generic.List`1" /> 的默认实现中，此属性始终返回 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在创建只读集合后，该集合不允许添加、移除或修改元素。  
  
 集合是只读的是只是一个集合与防止集合; 进行修改的包装因此，如果对基础集合进行更改，只读集合将反映这些更改。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要获取或设置的元素的从零开始的索引。</param>
        <summary>获取或设置指定索引处的元素。</summary>
        <value>指定索引处的元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C# 语言使用[这](~/docs/csharp/language-reference/keywords/this.md)关键字来定义而不是实现索引器<xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A>属性。 Visual Basic 将 <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> 实现为默认属性，该属性提供相同的索引功能。  
  
 检索此属性的值的运算 o （1）;设置属性也是 o （1） 运算。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</exception>
        <exception cref="T:System.ArgumentException">已设置属性，且 <paramref name="value" /> 属于不能对 <see cref="T:System.Collections.IList" /> 赋值的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要从 <see cref="T:System.Collections.IList" /> 中删除的对象。</param>
        <summary>从 <see cref="T:System.Collections.IList" /> 中移除特定对象的第一个匹配项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可确定使用的默认相等比较器的相等性<xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>为`T`，列表中的值的类型。  
  
 此方法执行的线性搜索;因此，此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> 属于不能分配给 <see cref="T:System.Collections.IList" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将 <see cref="T:System.Collections.Generic.List`1" /> 的元素复制到新数组中。</summary>
        <returns>一个包含 <see cref="T:System.Collections.Generic.List`1" /> 的元素副本的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用复制元素<xref:System.Array.Copy%2A?displayProperty=nameWithType>，这是 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.ToArray%2A>方法和其他方法<xref:System.Collections.Generic.List%601>对范围进行操作的类。 在本示例中，末尾<xref:System.Collections.Generic.List%601.GetRange%2A>方法用于从列表中，从开始的索引位置 2 获取三个项。 <xref:System.Collections.Generic.List%601.ToArray%2A>方法调用所生成<xref:System.Collections.Generic.List%601>，创建三个元素的数组。 数组的元素的显示。  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将容量设置为 <see cref="T:System.Collections.Generic.List`1" /> 中元素的实际数目（如果该数目小于某个阈值）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可以用于降低集合的内存开销，如果没有新的元素将添加到集合。 重新分配和复制较大的成本<xref:System.Collections.Generic.List%601>但是，可能很大，因此<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法不执行任何操作如果列表为在多个容量的 90%。 这样可以避免产生的相对较小有所提高大型重新分配费用。  
  
> [!NOTE]
>  当前阈值的 90%可能会更改在将来的版本。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
 若要重置<xref:System.Collections.Generic.List%601>为其初始状态，请在调用<xref:System.Collections.Generic.List%601.Clear%2A>方法之前调用<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法。 截去空<xref:System.Collections.Generic.List%601>的容量设置<xref:System.Collections.Generic.List%601>到默认的容量。  
  
 此外可以使用设置容量<xref:System.Collections.Generic.List%601.Capacity%2A>属性。  
  
   
  
## Examples  
 下面的示例演示如何检查的容量和计数<xref:System.Collections.Generic.List%601>，其中包含一个简单的业务对象，对象，说明如何使用<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法以删除额外的容量。  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 下面的示例演示<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法。 一些属性和方法的<xref:System.Collections.Generic.List%601>类用于添加、 插入和删除的字符串列表中的项。 则<xref:System.Collections.Generic.List%601.TrimExcess%2A>方法用于减少容量以匹配计数，和<xref:System.Collections.Generic.List%601.Capacity%2A>和<xref:System.Collections.Generic.List%601.Count%2A>属性显示。 如果未使用的容量过小于 10%的总容量，列表将不具有已调整大小。 最后，该列表的内容将被清除。  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">用于定义检查元素时要对照条件的 <see cref="T:System.Predicate`1" /> 委托。</param>
        <summary>确定 <see cref="T:System.Collections.Generic.List`1" /> 中的每个元素是否都与指定谓词定义的条件匹配。</summary>
        <returns>
          如果 <see cref="T:System.Collections.Generic.List`1" /> 中的每个元素都与指定的谓词所定义的条件相匹配，则为 <see langword="true" />；否则为 <see langword="false" />。 如果列表没有元素，则返回值为 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601>是返回方法的委托`true`如果该对象传递给委托中定义的条件匹配。  当前元素<xref:System.Collections.Generic.List%601>单独传递给<xref:System.Predicate%601>委托，并处理在委托返回时已停止`false`任何元素。 元素的处理顺序情况下，和的所有调用都都是在单个线程上。  
  
 此方法为 O (*n*) 操作，其中*n*是<xref:System.Collections.Generic.List%601.Count%2A>。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Collections.Generic.List%601.TrueForAll%2A>方法和使用的其他几个方法<xref:System.Predicate%601>泛型委托。  
  
 A<xref:System.Collections.Generic.List%601>字符串的创建，包含 8 不复存在名称，其中 （在位置 1 和 5） 两个以"saurus"结尾。 该示例还定义一个名为搜索谓词的方法`EndsWithSaurus`、 它接受字符串参数和返回一个布尔值，该值指示是否以"saurus"结尾的输入的字符串。  
  
 <xref:System.Collections.Generic.List%601.TrueForAll%2A>方法遍历此列表的开头，将每个元素传递给反过来`EndsWithSaurus`方法。 搜索将停止时`EndsWithSaurus`方法返回`false`。  
  
> [!NOTE]
>  在 C# 和 Visual Basic 中，它不需要创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中) 显式。 这些语言推断从上下文正确的委托，并自动创建。  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>