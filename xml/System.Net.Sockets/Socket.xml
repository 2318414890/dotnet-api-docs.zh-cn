<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="853f59d82c93a1b22f4873b07aed3315c6946bea" />
    <Meta Name="ms.sourcegitcommit" Value="01f28caab7b3f23878dd07b402a8dd48b9478c8c" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="07/19/2018" />
    <Meta Name="ms.locfileid" Value="39142404" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>实现 Berkeley 套接字接口。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>类提供一组丰富的方法和属性的网络通信。 <xref:System.Net.Sockets.Socket>类使您能够同时同步和异步数据传输使用的任何通信协议中列出<xref:System.Net.Sockets.ProtocolType>枚举。  
  
 <xref:System.Net.Sockets.Socket>类遵循异步方法的.NET Framework 命名模式。 例如，同步<xref:System.Net.Sockets.Socket.Receive%2A>方法对应于异步<xref:System.Net.Sockets.Socket.BeginReceive%2A>和<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。  
  
 如果你的应用程序在执行期间只需要一个线程，使用以下方法，适用于同步操作模式。  
  
-   如果使用的面向连接的 TCP 协议，你的服务器可以使用侦听连接<xref:System.Net.Sockets.Socket.Listen%2A>方法。 <xref:System.Net.Sockets.Socket.Accept%2A>方法处理任何传入连接请求并返回<xref:System.Net.Sockets.Socket>可用来与远程主机通信数据。 使用此返回<xref:System.Net.Sockets.Socket>来调用<xref:System.Net.Sockets.Socket.Send%2A>或<xref:System.Net.Sockets.Socket.Receive%2A>方法。 调用<xref:System.Net.Sockets.Socket.Bind%2A>方法之前调用<xref:System.Net.Sockets.Socket.Listen%2A>方法如果你想要指定本地 IP 地址和端口号。 如果你想要为你分配了可用端口的基础服务提供程序，请使用端口号 0。 如果你想要连接到侦听主机，则调用<xref:System.Net.Sockets.Socket.Connect%2A>方法。 若要进行通信的数据，调用<xref:System.Net.Sockets.Socket.Send%2A>或<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
-   如果使用如 UDP 是无连接协议，你不需要在所有侦听连接。 调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法以接受任何传入的数据报。 使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法以将数据报发送到远程主机。  
  
 若要处理在执行期间使用单独的线程通信，请使用以下方法，适用于异步操作模式。  
  
-   如果使用的面向连接的 TCP 协议，使用<xref:System.Net.Sockets.Socket>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>，和<xref:System.Net.Sockets.Socket.EndConnect%2A>方法来侦听主机的连接。 使用<xref:System.Net.Sockets.Socket.BeginSend%2A>并<xref:System.Net.Sockets.Socket.EndSend%2A>或<xref:System.Net.Sockets.Socket.BeginReceive%2A>和<xref:System.Net.Sockets.Socket.EndReceive%2A>方法进行异步通信数据。 可以使用处理传入的连接请求<xref:System.Net.Sockets.Socket.BeginAccept%2A>和<xref:System.Net.Sockets.Socket.EndAccept%2A>。  
  
-   如果使用如 UDP 是无连接协议，则可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>并<xref:System.Net.Sockets.Socket.EndSendTo%2A>来发送数据报，并<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>和<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>来接收数据报。  
  
 如果执行套接字上的多个异步操作，它们不一定会完成启动它们的顺序中。  
  
 当你已完成发送和接收数据，请使用<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以禁用<xref:System.Net.Sockets.Socket>。 在调用<xref:System.Net.Sockets.Socket.Shutdown%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法来释放与关联的所有资源<xref:System.Net.Sockets.Socket>。  
  
 <xref:System.Net.Sockets.Socket>类允许您配置您<xref:System.Net.Sockets.Socket>使用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。 检索这些设置，请使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
> [!NOTE]
>  如果您正在编写相对简单的应用程序并不需要最大的性能，请考虑使用<xref:System.Net.Sockets.TcpClient>， <xref:System.Net.Sockets.TcpListener>，和<xref:System.Net.Sockets.UdpClient>。 这些类提供的更简单并且更加用户友好界面<xref:System.Net.Sockets.Socket>通信。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket>类可用于将数据发送到 HTTP 服务器并接收响应。 此示例中阻止，直到收到整个页面。  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">若要建立传出连接，或接受传入的请求。</permission>
    <threadsafe>此类的实例都是线程安全。</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">
          <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 返回的套接字信息。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 返回的指定的值初始化 <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您调用<xref:System.Net.Sockets.Socket.%23ctor%2A>多次使用相同的字节数组，作为每个调用的参数的构造函数，您将创建多个托管<xref:System.Net.Sockets.Socket>与同一个基础套接字。 这种做法是强烈建议不要使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType">
          <see cref="T:System.Net.Sockets.SocketType" /> 值之一。</param>
        <param name="protocolType">
          <see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</param>
        <summary>使用指定的地址族、套接字类型和协议初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `socketType`参数指定的类型<xref:System.Net.Sockets.Socket>类和`protocolType`参数指定使用的协议<xref:System.Net.Sockets.Socket>。 两个参数不是独立的。 通常<xref:System.Net.Sockets.Socket>类型是隐式的协议。 如果的组合<xref:System.Net.Sockets.Socket>类型和协议类型结果无效<xref:System.Net.Sockets.Socket>，此构造函数引发<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果此构造函数将引发<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketType" /> 和 <paramref name="protocolType" /> 组合将导致套接字无效。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">
          <see cref="T:System.Net.Sockets.AddressFamily" /> 值之一。</param>
        <param name="socketType">
          <see cref="T:System.Net.Sockets.SocketType" /> 值之一。</param>
        <param name="protocolType">
          <see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</param>
        <summary>使用指定的地址族、套接字类型和协议初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addressFamily`参数指定的寻址方案<xref:System.Net.Sockets.Socket>类使用，`socketType`参数指定的类型<xref:System.Net.Sockets.Socket>类，并且`protocolType`参数指定使用的协议<xref:System.Net.Sockets.Socket>。 三个参数不是独立的。 有些地址族限制可以使用哪些协议，使用它们，并经常<xref:System.Net.Sockets.Socket>类型是隐式的协议。 如果地址族的组合<xref:System.Net.Sockets.Socket>类型和协议类型无效<xref:System.Net.Sockets.Socket>，此构造函数引发<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果此构造函数将引发<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何创建的实例<xref:System.Net.Sockets.Socket>类。  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="addressFamily" />、<paramref name="socketType" /> 和 <paramref name="protocolType" /> 的组合会导致无效套接字。</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为新建连接创建新的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>新建连接的 <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> 以同步方式从侦听套接字，在连接请求队列中提取第一个挂起的连接请求，然后创建并返回一个新<xref:System.Net.Sockets.Socket>。 不能使用此返回<xref:System.Net.Sockets.Socket>为接受任何其他连接的连接队列。 但是，可以调用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>方法所返回的<xref:System.Net.Sockets.Socket>来标识远程主机的网络地址和端口号。  
  
 在阻止模式下，<xref:System.Net.Sockets.Socket.Accept%2A>阻止，直到传入的连接尝试排入队列。 连接被接受后，原始<xref:System.Net.Sockets.Socket>继续队列传入的连接请求直到您关闭它。  
  
 如果调用此方法使用非阻塞<xref:System.Net.Sockets.Socket>，并请求排队，没有连接<xref:System.Net.Sockets.Socket.Accept%2A>引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  然后再调用<xref:System.Net.Sockets.Socket.Accept%2A>方法，必须首先调用<xref:System.Net.Sockets.Socket.Listen%2A>方法来侦听并对传入连接请求进行排队。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例接受简单<xref:System.Net.Sockets.Socket>连接。  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.Accept" />。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个异步操作来接受一个传入的连接尝试。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用面向连接的协议<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法以异步处理传入的连接尝试。 以异步方式接受连接使你能够发送和接收单独的执行线程中的数据。 然后再调用<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法时，必须调用<xref:System.Net.Sockets.Socket.Listen%2A>方法来侦听并对传入连接请求进行排队。  
  
 若要在完成时得到通知，必须创建实现事件处理程序的回调方法\<SocketAsyncEventArgs > 委托并将其到挂钩<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>对象所需：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以选择指定的现有<xref:System.Net.Sockets.Socket>要通过指定用于将传入连接<xref:System.Net.Sockets.Socket>用于<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>属性。  
  
 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>属性为 null，一个新<xref:System.Net.Sockets.Socket>具有相同构造<xref:System.Net.Sockets.Socket.AddressFamily%2A>， <xref:System.Net.Sockets.Socket.SocketType%2A>，并<xref:System.Net.Sockets.Socket.ProtocolType%2A>与当前<xref:System.Net.Sockets.Socket>并将设置为<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>属性。  
  
 调用方可能会设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>属性设置为在调用之前所需的任何用户状态对象<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法，以便可在回调方法中检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小类来保存作为成员的其他所需的状态信息。  
  
 （可选） 一个缓冲区可能会提供用来接收后的套接字上的数据的初始块<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法成功。 在这种情况下，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>属性应设置为包含数据的缓冲区，以接收和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>属性应设置为的最大的数据的字节数，以接收缓冲区中。 这些属性可以设置使用<xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType>方法。 在传递的缓冲区的一部分将使用在内部用于基础 Winsock AcceptEx 调用。 这意味着返回的数据量始终为的值小于<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>属性上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>提供实例。 在内部使用的缓冲区数量根据不同而异的套接字地址族。 所需的最小缓冲区大小是 288 个字节。 如果指定较大的缓冲区大小，则<xref:System.Net.Sockets.Socket>希望一些额外的数据以外的 Winsock AcceptEx 调用收到的地址数据，并且将等待，直到收到此额外数据。 如果发生超时，将重置连接。 因此如果特定量的预期额外的数据，则应缓冲区大小设置为最小缓冲区大小加上此段中。  
  
 完成回调方法应检查<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>属性来确定如果<xref:System.Net.Sockets.Socket.AcceptAsync%2A>操作是否成功。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件可能在某些情况下不接受任何连接时发生，并导致<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>属性设置为<xref:System.Net.Sockets.SocketError.ConnectionReset>。 这可以导致端口扫描使用半开 SYN 类型扫描 (SYN-> SYN ACK-> RST 序列)。 使用应用程序<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法应准备好处理这种情况。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">自变量无效。 如果所提供的缓冲区不够大，将会发生此异常。 缓冲区必须至少为 2 * (sizeof(SOCKADDR_STORAGE + 16) 字节。  如果指定了多个缓冲区，即 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性不为 null，也会发生此异常。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">参数超出范围。 如果 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> 小于 0，将会发生此异常。</exception>
        <exception cref="T:System.InvalidOperationException">请求了无效操作。 如果接收方 <see cref="T:System.Net.Sockets.Socket" /> 未侦听连接或者绑定了接受的套接字，将发生此异常。  <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 和 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 方法必须先于 <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 方法调用。  如果套接字已连接或使用指定的 <paramref name="e" /> 参数的套接字操作已经在进行中，也会发生此异常。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的地址族。</summary>
        <value>
          <see cref="T:System.Net.Sockets.AddressFamily" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.AddressFamily>指定的寻址方案的一个实例<xref:System.Net.Sockets.Socket>类可以使用。 此属性是只读的则会设置<xref:System.Net.Sockets.Socket>创建。  
  
   
  
## Examples  
 下面的代码示例显示<xref:System.Net.Sockets.AddressFamily>， <xref:System.Net.Sockets.SocketType>，和<xref:System.Net.Sockets.ProtocolType>到控制台。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已经从网络接收且可供读取的数据量。</summary>
        <value>从网络接收的、可供读取的数据的字节数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用非阻塞<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Available%2A>是好的方法，以确定是否将数据排队以进行读取，然后才能调用<xref:System.Net.Sockets.Socket.Receive%2A>。 可用的数据是在读取的网络缓冲区中对排队的总数据量。 如果无数据排队网络缓冲区中<xref:System.Net.Sockets.Socket.Available%2A>返回 0。  
  
 如果远程主机关闭，或关闭的连接<xref:System.Net.Sockets.Socket.Available%2A>可能会引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例将调用 IOControl 使用 FIONREAD 和可用属性的结果进行比较。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个异步操作来接受一个传入的连接尝试。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始一个异步操作来接受一个传入的连接尝试。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它引用异步 <see cref="T:System.Net.Sockets.Socket" /> 创建。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用面向连接的协议<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法以异步处理传入的连接尝试。 以异步方式接受连接使你能够发送和接收单独的执行线程中的数据。 然后再调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法时，必须调用<xref:System.Net.Sockets.Socket.Listen%2A>方法来侦听并对传入连接请求进行排队。  
  
 必须创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 为此，请在最低限度下，必须通过侦听<xref:System.Net.Sockets.Socket>对象传递给<xref:System.Net.Sockets.Socket.BeginAccept%2A>通过`state`参数。 如果回调需要详细信息，可以创建一个小类来保存<xref:System.Net.Sockets.Socket>和其他所需的信息。 传递到此类的实例<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法通过`state`参数。  
  
 回调方法应该调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法。 当应用程序调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>，系统通常使用一个单独的线程来执行指定的回调方法，并阻止上<xref:System.Net.Sockets.Socket.EndAccept%2A>直到检索到挂起的连接。 <xref:System.Net.Sockets.Socket.EndAccept%2A> 将返回一个新<xref:System.Net.Sockets.Socket>对象可用于发送和接收数据与远程主机。 不能使用此返回<xref:System.Net.Sockets.Socket>为接受任何其他连接的连接队列。 如果你想要阻止调用后的原始线程<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 在调用 Set 方法<xref:System.Threading.ManualResetEvent>在回调方法时所需的原始线程继续执行。  
  
 系统还可能使用调用线程来调用该回调方法。 在这种情况下，<xref:System.IAsyncResult.CompletedSynchronously%2A>对返回的属性<xref:System.IAsyncResult>会将设置为指示<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法以同步方式完成。  
  
 编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 若要取消挂起调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，关闭<xref:System.Net.Sockets.Socket>。 当<xref:System.Net.Sockets.Socket.Close%2A>回调的异步操作正在进行中时，调用方法，提供给<xref:System.Net.Sockets.Socket.BeginAccept%2A>调用方法。  随后调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法将引发<xref:System.ObjectDisposedException>以指示已取消该操作。  
  
> [!NOTE]
>  可以使用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>属性所返回的<xref:System.Net.Sockets.Socket>来标识远程主机的网络地址和端口号。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 中有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
   
  
## Examples  
 下面的代码示例尝试以异步方式接收传入连接。  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  - 或 -  已接受的套接字是绑定的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> 小于 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">要从发送方读取的字节数。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始异步操作以接受传入的连接尝试并接收客户端应用程序发送的第一个数据块。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它引用异步 <see cref="T:System.Net.Sockets.Socket" /> 创建。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用面向连接的协议<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法以异步处理传入的连接尝试。 以异步方式接受连接，可发送和接收单独的执行线程中的数据。 此重载允许您指定要接受初始传输中的字节数`receiveSize`参数。  
  
 然后再调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法时，必须调用<xref:System.Net.Sockets.Socket.Listen%2A>方法来侦听并对传入连接请求进行排队。  
  
 必须创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 为此，请在最低限度下，必须通过侦听<xref:System.Net.Sockets.Socket>对象传递给<xref:System.Net.Sockets.Socket.BeginAccept%2A>通过`state`参数。 如果回调需要详细信息，可以创建一个小类来保存<xref:System.Net.Sockets.Socket>和其他所需的信息。 传递到此类的实例<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法通过`state`参数。  
  
 回调方法应该调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法。 当应用程序调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>，系统通常使用一个单独的线程来执行指定的回调方法，并阻止上<xref:System.Net.Sockets.Socket.EndAccept%2A>直到检索到挂起的连接。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 返回一个新<xref:System.Net.Sockets.Socket>可用于发送和接收数据与远程主机。 不能使用此返回<xref:System.Net.Sockets.Socket>为接受任何其他连接的连接队列。 如果你想要阻止调用后的原始线程<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 在调用 Set 方法<xref:System.Threading.ManualResetEvent>在回调方法时所需的原始线程继续执行。  
  
 系统还可能使用调用线程来调用该回调方法。 在这种情况下，<xref:System.IAsyncResult.CompletedSynchronously%2A>对返回的属性<xref:System.IAsyncResult>会将设置为指示<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法以同步方式完成。  
  
 编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 若要取消挂起调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，关闭<xref:System.Net.Sockets.Socket>。  当<xref:System.Net.Sockets.Socket.Close%2A>回调的异步操作正在进行中时，调用方法，提供给<xref:System.Net.Sockets.Socket.BeginAccept%2A>调用方法。  随后调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法将引发<xref:System.ObjectDisposedException>以指示已取消该操作。  
  
> [!NOTE]
>  您可以调用使用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>属性所返回的<xref:System.Net.Sockets.Socket>对象来标识远程主机的网络地址和端口号。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
   
  
## Examples  
 下面的代码示例打开一个套接字并接受异步连接。 在此示例中，套接字接受前 10 个字节的数据。 接收的字节数和数据的回调委托显示在控制台上。 请参阅<xref:System.Net.Sockets.Socket.BeginReceive%2A>如何接收剩余数据的说明。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  - 或 -  已接受的套接字是绑定的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> 小于 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">接受的 <see cref="T:System.Net.Sockets.Socket" /> 对象。 此值可为 <see langword="null" />。</param>
        <param name="receiveSize">要接收的最大字节数。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始异步操作以接受从指定套接字传入的连接尝试并接收客户端应用程序发送的第一个数据块。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它引用异步 <see cref="T:System.Net.Sockets.Socket" /> 对象创建。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用面向连接的协议<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法以异步处理传入的连接尝试。 以异步方式接受连接使你能够发送和接收单独的执行线程中的数据。 此重载允许您指定在接受的套接字`acceptSocket`参数。 如果此参数为`null`，通过创建接受的套接字<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 可以指定要接受初始传输中的字节数`receiveSize`参数。  
  
 然后再调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法时，必须调用<xref:System.Net.Sockets.Socket.Listen%2A>方法来侦听并对传入连接请求进行排队。  
  
 必须创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 为此，请在最低限度下，必须通过侦听<xref:System.Net.Sockets.Socket>对象传递给<xref:System.Net.Sockets.Socket.BeginAccept%2A>通过`state`参数。 如果回调需要详细信息，可以创建一个小类来保存<xref:System.Net.Sockets.Socket>和其他所需的信息。 传递到此类的实例<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法通过`state`参数。  
  
 回调方法应该调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法。 当应用程序调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>，系统通常使用一个单独的线程来执行指定的回调方法，并阻止上<xref:System.Net.Sockets.Socket.EndAccept%2A>直到检索到挂起的连接。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 返回一个新<xref:System.Net.Sockets.Socket>对象可用于发送和接收数据与远程主机。 不能使用此返回<xref:System.Net.Sockets.Socket>为接受任何其他连接的连接队列。 如果你想要阻止调用后的原始线程<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 在调用 Set 方法<xref:System.Threading.ManualResetEvent>在回调方法时所需的原始线程继续执行。  
  
 系统还可能使用调用线程来调用该回调方法。 在这种情况下，<xref:System.IAsyncResult.CompletedSynchronously%2A>对返回的属性<xref:System.IAsyncResult>会将设置为指示<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法以同步方式完成。  
  
 有关编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 若要取消挂起调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，关闭<xref:System.Net.Sockets.Socket>。 当<xref:System.Net.Sockets.Socket.Close%2A>回调的异步操作正在进行中时，调用方法，提供给<xref:System.Net.Sockets.Socket.BeginAccept%2A>调用方法。  随后调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法将引发<xref:System.ObjectDisposedException>以指示已取消该操作。  
  
> [!NOTE]
>  可以使用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>属性所返回的<xref:System.Net.Sockets.Socket>对象来标识远程主机的网络地址和端口号。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
   
  
## Examples  
 下面的代码示例打开一个套接字并接受异步连接。 在此示例中，套接字接受前 10 个字节的数据并`acceptSocket`参数是`null`，这将强制<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法来创建接受的套接字。 接收的字节数和数据的回调委托显示在控制台上。 请参阅<xref:System.Net.Sockets.Socket.BeginReceive%2A>如何接收剩余数据的说明。  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  - 或 -  已接受的套接字是绑定的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> 小于 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个对远程主机连接的异步请求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" />
        <Parameter Name="state" Type="System.Object" Index="2" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />，它表示远程主机。</param>
        <param name="end_point">
          <see cref="T:System.Net.EndPoint" />，它表示远程主机。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始一个对远程主机连接的异步请求。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法启动的连接的异步请求`remoteEP`参数。 如果您使用的是无连接协议，<xref:System.Net.Sockets.Socket.BeginConnect%2A>建立默认远程主机。 连接或以异步方式设置默认远程主机使你能够发送和接收单独的执行线程中的数据。  
  
 可以创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法。 至少，您必须传递<xref:System.Net.Sockets.Socket>到<xref:System.Net.Sockets.Socket.BeginConnect%2A>通过`state`参数。 如果回调需要详细信息，可以创建一个小类来保存<xref:System.Net.Sockets.Socket>，和其他所需的信息。 传递到此类的实例<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法通过`state`参数。  
  
 回调方法应该调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 当应用程序调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>，系统将使用一个单独的线程来执行指定的回调方法，并阻止<xref:System.Net.Sockets.Socket.EndConnect%2A>直到<xref:System.Net.Sockets.Socket>已成功连接或引发异常。 如果你想要阻止调用后的原始线程<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A>。 在调用 Set 方法<xref:System.Threading.ManualResetEvent>在回调方法时所需的原始线程继续执行。 编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 如果使用如 UDP 是无连接协议，不需要调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>之前发送和接收数据。 可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>和<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>与远程主机通信。 如果调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>，将丢弃来自指定的默认值以外的地址的任何数据报。 如果你想要将默认远程主机到广播地址，必须先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>设置为广播和`true`。 如果您不能<xref:System.Net.Sockets.Socket.BeginConnect%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果您使用的是面向连接的协议，并且不会调用<xref:System.Net.Sockets.Socket.Bind%2A>之前调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>，基础服务提供程序将分配的最合适的本地网络地址和端口号。 如果您使用的是无连接协议，直到您调用，服务提供程序将不分配本地网络地址和端口号<xref:System.Net.Sockets.Socket.BeginSend%2A>或<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 如果你想要更改默认远程主机，则调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法再次使用所需终结点。  
  
 若要取消挂起调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，关闭<xref:System.Net.Sockets.Socket>。 当<xref:System.Net.Sockets.Socket.Close%2A>回调的异步操作正在进行中时，调用方法，提供给<xref:System.Net.Sockets.Socket.BeginConnect%2A>调用方法。  随后调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法将引发<xref:System.ObjectDisposedException>以指示已取消该操作。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  如果以前已断开此套接字，然后<xref:System.Net.Sockets.Socket.BeginConnect%2A>必须在操作完成之前不会退出的线程上调用。 这是基础提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">将委托作为回调方法进行封送</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">异步客户端套接字示例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="address">远程主机的 <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">远程主机的端口号。</param>
        <param name="requestCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="state">一个用户定义对象，其中包含连接操作的相关信息。 操作完成后，此对象会被传递给 <c>requestCallback</c> 委托。</param>
        <summary>开始一个对远程主机连接的异步请求。 主机由 <see cref="T:System.Net.IPAddress" /> 和端口号指定。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步<xref:System.Net.Sockets.Socket.BeginConnect%2A>完成操作，必须通过调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 通常情况下，通过调用该方法`requestCallback`委托。  
  
 此方法不会阻止，直到完成该操作。 若要阻止，直到完成该操作后，使用之一<xref:System.Net.Sockets.Socket.Connect%2A>方法重载或<xref:System.Net.Sockets.Socket.EndConnect%2A>。  
  
 若要取消挂起调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，关闭<xref:System.Net.Sockets.Socket>。 当<xref:System.Net.Sockets.Socket.Close%2A>回调的异步操作正在进行中时，调用方法，提供给<xref:System.Net.Sockets.Socket.BeginConnect%2A>调用方法。  随后调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法将引发<xref:System.ObjectDisposedException>以指示已取消该操作。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  如果以前已断开此套接字，然后<xref:System.Net.Sockets.Socket.BeginConnect%2A>必须在操作完成之前不会退出的线程上调用。 这是基础提供程序的限制。 此外<xref:System.Net.EndPoint>，它是使用必须不同。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Net.Sockets.Socket" /> 不在套接字族中。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">将委托作为回调方法进行封送</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">异步客户端套接字示例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="addresses">至少一个用于指定远程主机的 <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">远程主机的端口号。</param>
        <param name="requestCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="state">一个用户定义对象，其中包含连接操作的相关信息。 操作完成后，此对象会被传递给 <c>requestCallback</c> 委托。</param>
        <summary>开始一个对远程主机连接的异步请求。 主机由 <see cref="T:System.Net.IPAddress" /> 数组和端口号指定。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步<xref:System.Net.Sockets.Socket.BeginConnect%2A>完成操作，必须通过调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 通常情况下，通过调用该方法`requestCallback`委托。  
  
 此方法不会阻止，直到完成该操作。 若要阻止，直到完成该操作后，使用之一<xref:System.Net.Sockets.Socket.Connect%2A>方法重载。  
  
 若要取消挂起调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，关闭<xref:System.Net.Sockets.Socket>。 当<xref:System.Net.Sockets.Socket.Close%2A>回调的异步操作正在进行中时，调用方法，提供给<xref:System.Net.Sockets.Socket.BeginConnect%2A>调用方法。  随后调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法将引发<xref:System.ObjectDisposedException>以指示已取消该操作。  
  
 有关使用异步编程模型的详细信息，请参阅[Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  如果以前已断开此套接字，然后<xref:System.Net.Sockets.Socket.BeginConnect%2A>必须在操作完成之前不会退出的线程上调用。 这是基础提供程序的限制。 此外<xref:System.Net.EndPoint>，它是使用必须不同。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对使用 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 的套接字有效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">将委托作为回调方法进行封送</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">异步客户端套接字示例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="host">远程主机的名称。</param>
        <param name="port">远程主机的端口号。</param>
        <param name="requestCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</param>
        <param name="state">一个用户定义对象，其中包含连接操作的相关信息。 操作完成后，此对象会被传递给 <c>requestCallback</c> 委托。</param>
        <summary>开始一个对远程主机连接的异步请求。 主机由主机名和端口号指定。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步<xref:System.Net.Sockets.Socket.BeginConnect%2A>完成操作，必须通过调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 通常情况下，通过调用该方法`requestCallback`委托。  
  
 此方法不会阻止，直到完成该操作。 若要阻止，直到完成该操作后，使用之一<xref:System.Net.Sockets.Socket.Connect%2A>方法重载。  
  
 若要取消挂起调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，关闭<xref:System.Net.Sockets.Socket>。 当<xref:System.Net.Sockets.Socket.Close%2A>回调的异步操作正在进行中时，调用方法，提供给<xref:System.Net.Sockets.Socket.BeginConnect%2A>调用方法。  随后调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法将引发<xref:System.ObjectDisposedException>以指示已取消该操作。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  如果以前已断开此套接字，然后<xref:System.Net.Sockets.Socket.BeginConnect%2A>必须在操作完成之前不会退出的线程上调用。 这是基础提供程序的限制。 此外<xref:System.Net.EndPoint>，它是使用必须不同。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">将委托作为回调方法进行封送</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">异步客户端套接字示例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">如果关闭该连接后可以重用此套接字，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始异步请求从远程终结点断开连接。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它引用异步操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用的是面向连接的协议，则可以调用<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>方法来请求从远程终结点断开连接。 如果`reuseSocket`是`true`，可以重复使用套接字。  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>方法使用一个单独的线程来调用指定的回调方法。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>方法进行阻止，直到挂起的断开连接已完成。 有关编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>异常，请使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例创建的套接字进行异步通信，并将一些数据发送到远程主机。 已发送数据，<xref:System.Net.Sockets.Socket.Shutdown%2A>调用来停止发送和接收活动。 然后<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>调用以开始断开连接请求。 完成请求后，<xref:System.Net.Sockets.Socket.Connected%2A>属性进行查询，以测试是否已断开连接的套接字。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">操作系统为 Windows 2000 或更低版本，而此方法需要在 Windows XP 中使用。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步<xref:System.Net.Sockets.Socket.BeginReceive%2A>完成操作，必须通过调用<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 通常情况下，通过调用该方法`callback`委托。  
  
 此方法不会阻止，直到完成该操作。 若要阻止，直到完成该操作后，使用之一<xref:System.Net.Sockets.Socket.Receive%2A>方法重载。  
  
 若要取消挂起<xref:System.Net.Sockets.Socket.BeginReceive%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 有关使用异步编程模型的详细信息，请参阅[Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  由给定线程启动的所有 i/o 操作被取消时该线程退出。 如果在线程退出该操作完成之前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步<xref:System.Net.Sockets.Socket.BeginReceive%2A>完成操作，必须通过调用<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 通常情况下，通过调用该方法`callback`委托。  
  
 此方法不会阻止，直到完成该操作。 若要阻止，直到完成该操作后，使用之一<xref:System.Net.Sockets.Socket.Receive%2A>方法重载。  
  
 若要取消挂起<xref:System.Net.Sockets.Socket.BeginReceive%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 有关使用异步编程模型的详细信息，请参阅[Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  由给定线程启动的所有 i/o 操作被取消时该线程退出。 如果在线程退出该操作完成之前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset">
          <c>buffer</c> 参数中存储所接收数据的位置，该位置从零开始计数。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="socket_flags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步<xref:System.Net.Sockets.Socket.BeginReceive%2A>完成操作，必须通过调用<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 通常情况下，通过调用该方法`callback`委托。  
  
 此方法不会阻止，直到完成该操作。 若要阻止，直到完成该操作后，使用之一<xref:System.Net.Sockets.Socket.Receive%2A>方法重载。  
  
 若要取消挂起<xref:System.Net.Sockets.Socket.BeginReceive%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 有关使用异步编程模型的详细信息，请参阅[Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  由给定线程启动的所有 i/o 操作被取消时该线程退出。 如果在线程退出该操作完成之前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
   
  
## Examples  
 下面的代码示例开始以异步方式从连接接收数据<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">将委托作为回调方法进行封送</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">异步客户端套接字示例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset">
          <c>buffer</c> 中存储所接收数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="flags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="error">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步<xref:System.Net.Sockets.Socket.BeginReceive%2A>完成操作，必须通过调用<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 通常情况下，通过调用该方法`callback`委托。  
  
 此方法不会阻止，直到完成该操作。 若要阻止，直到完成该操作后，使用之一<xref:System.Net.Sockets.Socket.Receive%2A>方法重载。  
  
 若要取消挂起<xref:System.Net.Sockets.Socket.BeginReceive%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 有关使用异步编程模型的详细信息，请参阅[Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  由给定线程启动的所有 i/o 操作被取消时该线程退出。 如果在线程退出该操作完成之前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">将委托作为回调方法进行封送</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">异步客户端套接字示例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset">
          <c>buffer</c> 参数中存储数据的位置，该位置从零开始计数。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="socket_flags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">一个 <see cref="T:System.Net.EndPoint" />，它表示数据的来源。</param>
        <param name="remote_end">一个 <see cref="T:System.Net.EndPoint" />，它表示数据的来源。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始从指定网络设备中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法开始以异步方式从远程主机中读取无连接的数据报。 调用<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法使您能够收到单独的执行线程中的数据。  
  
 可以创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 为此，至少，你`state`参数必须包含已连接或默认<xref:System.Net.Sockets.Socket>正用于通信。 如果回调需要详细信息，可以创建一个小类来保存<xref:System.Net.Sockets.Socket>和其他所需的信息。 传递到此类的实例<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法通过`state`参数。  
  
 回调方法应该调用<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法。 当应用程序调用<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，系统将使用一个单独的线程来执行指定的回调方法，且它将阻止上<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>直到<xref:System.Net.Sockets.Socket>读取数据或引发异常。 如果你想要阻止调用后的原始线程<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 当你想要继续执行的原始线程时请在回调方法调用 Set 方法。 有关编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
> [!NOTE]
>  然后再调用<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，则必须显式将绑定<xref:System.Net.Sockets.Socket>到本地终结点使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，或<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 此方法将数据读入`buffer`参数，并捕获的远程主机终结点从其发送数据。 有关如何检索此终结点的信息，请参阅<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>。 此方法是最有用，如果你想要以异步方式从未知的主机或多个主机接收无连接的数据报。 在这些情况下，<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>将读取第一个排队数据报接收到的本地网络缓冲区。 如果你收到的数据报大于的大小`buffer`，则<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法将填充`buffer`太多的是，且引发的消息与<xref:System.Net.Sockets.SocketException>。 如果使用的不可靠的协议，则多余的数据将丢失。 如果您使用的是可靠的协议，多余的数据将保留由服务提供商可以通过调用检索它<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法使用一个足够大的缓冲区。  
  
 若要保证始终返回远程主机终结点、 应用程序应显式将绑定<xref:System.Net.Sockets.Socket>到本地终结点使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，然后调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法替换`optionLevel`参数设置为<xref:System.Net.Sockets.SocketOptionLevel.IP>或<xref:System.Net.Sockets.SocketOptionLevel.IPv6>根据需要，`optionName`参数设置为<xref:System.Net.Sockets.SocketOptionName.PacketInformation>，并`optionValue`参数来启用此选项之前，调用<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 否则，它是可能的远程主机终结点以接收方已调用之前，发件人已发送的数据报的数量时不会返回<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。  
  
 尽管<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>适用于无连接协议，你可以使用面向连接的协议也。 如果你选择这样做，则必须首先可以建立远程主机连接通过调用<xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A>方法或通过调用接受传入连接请求<xref:System.Net.Sockets.Socket.Accept%2A>或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 如果您调用<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法之前建立或接受的连接时，你将获取<xref:System.Net.Sockets.SocketException>。 您还可以建立默认远程主机之前调用的无连接协议<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法将忽略`remoteEP`参数和仅接收来自连接的数据或默认远程主机。  
  
 使用面向连接的套接字<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>将读取的数据，可最多指定的字节数`size`参数。  
  
 若要取消挂起<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
   
  
## Examples  
 下面的代码示例以异步方式从远程主机接收无连接的数据报。  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">将委托作为回调方法进行封送</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset">
          <c>buffer</c> 参数中存储数据的位置，该位置从零开始计数。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">一个 <see cref="T:System.Net.EndPoint" />，它表示数据的来源。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定字节数的数据异步接收到数据缓冲区的指定位置，然后存储终结点和数据包信息。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步接收操作必须通过调用完成<xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A>方法。 通常情况下，通过调用该方法`asyncCallback`委托。  
  
 此方法不会阻止，直到操作完成。 若要阻止在操作完成之前，请使用<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法。  
  
 若要取消挂起<xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 此方法将数据读入`buffer`参数，并捕获的远程主机终结点从其发送数据，以及有关接收的数据包的信息。 有关如何检索此终结点的信息，请参阅<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>。 此方法是最有用，如果你想要以异步方式从未知的主机或多个主机接收无连接的数据报。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">操作系统为 Windows 2000 或更低版本，而此方法需要在 Windows XP 中使用。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法启动异步发送操作中建立的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果不首先调用将引发异常<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 调用<xref:System.Net.Sockets.Socket.BeginSend%2A>方法使你能够发送单独的执行线程中的数据。  
  
 可以创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 为此，至少，你`state`参数必须包含已连接或默认<xref:System.Net.Sockets.Socket>正用于通信。 如果回调需要详细信息，可以创建较小的类或结构，用于保存<xref:System.Net.Sockets.Socket>和其他所需的信息。 传递到此类的实例<xref:System.Net.Sockets.Socket.BeginSend%2A>方法通过`state`参数。  
  
 回调方法应该调用<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 当应用程序调用<xref:System.Net.Sockets.Socket.BeginSend%2A>，系统将使用一个单独的线程来执行指定的回调方法，并阻止<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>发送请求的字节数或引发异常。 如果你想要阻止调用后的原始线程<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 当你想要继续执行的原始线程时请在回调方法调用 Set 方法。 编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 适用于面向连接的协议，尽管<xref:System.Net.Sockets.Socket.BeginSend%2A>无连接协议，也适用，前提是先调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法以建立默认远程主机。 如果使用无连接协议，并且打算将数据发送到多个不同的主机，则应使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 您还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.BeginSend%2A>到另一个调用，从而<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 使用无连接协议时，您还必须确保在缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，将不发送数据报并<xref:System.Net.Sockets.Socket.BeginSend%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，不会将路由发送的数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  由给定线程启动的所有 i/o 操作被取消时该线程退出。 如果在线程退出该操作完成之前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  发送的成功完成并不表示数据已成功传递。 如果任何缓冲区空间以容纳要传输的数据在传输系统中不不可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法启动异步发送操作中建立的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果不首先调用将引发异常<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 调用<xref:System.Net.Sockets.Socket.BeginSend%2A>方法使你能够发送单独的执行线程中的数据。  
  
 可以创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 为此，至少，你`state`参数必须包含已连接或默认<xref:System.Net.Sockets.Socket>正用于通信。 如果回调需要详细信息，可以创建较小的类或结构，用于保存<xref:System.Net.Sockets.Socket>和其他所需的信息。 传递到此类的实例<xref:System.Net.Sockets.Socket.BeginSend%2A>方法通过`state`参数。  
  
 回调方法应该调用<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 当应用程序调用<xref:System.Net.Sockets.Socket.BeginSend%2A>，系统将使用一个单独的线程来执行指定的回调方法，并阻止<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>发送请求的字节数或引发异常。 如果你想要阻止调用后的原始线程<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 在调用 Set 方法<xref:System.Threading.ManualResetEvent>在回调方法时所需的原始线程继续执行。 编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 适用于面向连接的协议，尽管<xref:System.Net.Sockets.Socket.BeginSend%2A>无连接协议，也适用，前提是先调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法以建立默认远程主机。 如果使用无连接协议，并且打算将数据发送到多个不同的主机，则应使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 您还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.BeginSend%2A>到另一个调用，从而<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 使用无连接协议时，您还必须确保在缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，将不发送数据报并<xref:System.Net.Sockets.Socket.BeginSend%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，不会将路由发送的数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  由给定线程启动的所有 i/o 操作被取消时该线程退出。 如果在线程退出该操作完成之前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  发送的成功完成并不表示数据已成功传递。 如果任何缓冲区空间以容纳要传输的数据在传输系统中不不可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="offset">
          <c>buffer</c> 参数中开始发送数据的位置，该位置从零开始计数。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法启动异步发送操作中建立的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果不首先调用将引发异常<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 调用<xref:System.Net.Sockets.Socket.BeginSend%2A>方法使你能够发送单独的执行线程中的数据。  
  
 可以创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 为此，至少，你`state`参数必须包含已连接或默认<xref:System.Net.Sockets.Socket>正用于通信。 如果回调需要详细信息，可以创建较小的类或结构，用于保存<xref:System.Net.Sockets.Socket>和其他所需的信息。 传递到此类的实例<xref:System.Net.Sockets.Socket.BeginSend%2A>方法通过`state`参数。  
  
 回调方法应该调用<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 当应用程序调用<xref:System.Net.Sockets.Socket.BeginSend%2A>，系统将使用一个单独的线程来执行指定的回调方法，并阻止<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>发送请求的字节数或引发异常。 如果你想要阻止调用后的原始线程<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 当你想要继续执行的原始线程时请在回调方法调用 Set 方法。 编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 适用于面向连接的协议，尽管<xref:System.Net.Sockets.Socket.BeginSend%2A>无连接协议，也适用，前提是先调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法以建立默认远程主机。 如果使用无连接协议，并且打算将数据发送到多个不同的主机，则应使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 您还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.BeginSend%2A>到另一个调用，从而<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 使用无连接协议时，您还必须确保在缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，将不发送数据报并<xref:System.Net.Sockets.Socket.BeginSend%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，不会将路由发送的数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  由给定线程启动的所有 i/o 操作被取消时该线程退出。 如果在线程退出该操作完成之前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  发送的成功完成并不表示数据已成功传递。 如果任何缓冲区空间以容纳要传输的数据在传输系统中不不可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 小于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="offset">
          <c>buffer</c> 参数中开始发送数据的位置，该位置从零开始计数。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="socket_flags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法启动异步发送操作中建立的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果不首先调用将引发异常<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 调用<xref:System.Net.Sockets.Socket.BeginSend%2A>方法使你能够发送单独的执行线程中的数据。  
  
 可以创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 为此，至少，你`state`参数必须包含已连接或默认<xref:System.Net.Sockets.Socket>正用于通信。 如果回调需要详细信息，可以创建较小的类或结构，用于保存<xref:System.Net.Sockets.Socket>和其他所需的信息。 传递到此类的实例<xref:System.Net.Sockets.Socket.BeginSend%2A>方法通过`state`参数。  
  
 回调方法应该调用<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 当应用程序调用<xref:System.Net.Sockets.Socket.BeginSend%2A>，系统将使用一个单独的线程来执行指定的回调方法，并阻止<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>发送请求的字节数或引发异常。 如果你想要阻止调用后的原始线程<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 当你想要继续执行的原始线程时请在回调方法调用 Set 方法。 编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 适用于面向连接的协议，尽管<xref:System.Net.Sockets.Socket.BeginSend%2A>无连接协议，也适用，前提是先调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法以建立默认远程主机。 如果使用无连接协议，并且打算将数据发送到多个不同的主机，则应使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 您还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.BeginSend%2A>到另一个调用，从而<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 使用无连接协议时，您还必须确保在缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，将不发送数据报并<xref:System.Net.Sockets.Socket.BeginSend%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，不会将路由发送的数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  由给定线程启动的所有 i/o 操作被取消时该线程退出。 如果在线程退出该操作完成之前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  发送的成功完成并不表示数据已成功传递。 如果任何缓冲区空间以容纳要传输的数据在传输系统中不不可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
   
  
## Examples  
 下面的代码示例开始以异步方式将数据发送到远程主机。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 小于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">将委托作为回调方法进行封送</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">异步客户端套接字示例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">异步服务器套接字示例</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将文件异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">一个字符串，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 标志，将文件 <paramref name="fileName" /> 发送到连接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 对象。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它表示异步发送。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载将该文件发送`fileName`到连接的套接字。 如果`fileName`是在本地目录中，它可能会标识只是该文件的名称; 否则，必须指定完整路径和文件的名称。 通配符 ("...\\\myfile.txt") 和 UNC 共享名 ("\\\\\\\shared directory\\\myfile.txt") 支持。 如果未找到文件，该异常<xref:System.IO.FileNotFoundException>引发。  
  
 此方法使用`TransmitFile`Windows Sockets 2 API 中找到函数。 有关详细信息`TransmitFile`函数和它的标志，请参阅 MSDN 库中的 Windows 套接字文档。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法启动异步发送操作中建立的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>，<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 如果不首先调用将引发异常<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 调用<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法使您能够发送单独的执行线程中的文件。  
  
 若要完成该操作，可以创建由调用的回调方法<xref:System.AsyncCallback>委托参数。 为此，在最低限度下，`state`参数必须包含<xref:System.Net.Sockets.Socket>对象用于进行通信。 如果回调需要详细信息，可以创建类或结构，用于保存<xref:System.Net.Sockets.Socket>和其他所需的信息。 传递到此自定义对象的实例<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法通过`state`参数。  
  
 回调方法必须调用<xref:System.Net.Sockets.Socket.EndSendFile%2A>方法。 当应用程序调用<xref:System.Net.Sockets.Socket.BeginSendFile%2A>，系统使用一个单独的线程来执行指定的回调方法，并阻止上<xref:System.Net.Sockets.Socket.EndSendFile%2A>直到<xref:System.Net.Sockets.Socket>发送整个文件或引发异常。 编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 适用于面向连接的协议，尽管<xref:System.Net.Sockets.Socket.BeginSendFile%2A>无连接协议，也适用，前提是先调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法以建立默认远程主机。 使用无连接协议时，您必须确保文件的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，不发送数据报并<xref:System.Net.Sockets.Socket.BeginSendFile%2A>引发<xref:System.Net.Sockets.SocketException>异常。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>异常，请使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
   
  
## Examples  
 下面的代码示例创建并连接的套接字进行异步通信。 首先，"text.txt"的文件是以异步方式发送，到远程主机。 回调委托调用<xref:System.Net.Sockets.Socket.EndSendFile%2A>完成传输。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">套接字未连接到远程主机。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">一个字符串，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <param name="preBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件前要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="postBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件后要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="flags">
          <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值的按位组合。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，将在此操作完成时调用它。 此参数可以为 <see langword="null" />。</param>
        <param name="state">一个用户定义的对象，它包含此请求的状态信息。 此参数可以为 <see langword="null" />。</param>
        <summary>将文件和数据缓冲区异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它表示异步操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载需要的名称以及你想要发送的文件的按位组合<xref:System.Net.Sockets.TransmitFileOptions>值。 `preBuffer`参数包含你想要前加上该文件的任何数据。 `postBuffer` 包含你想要遵照该文件的数据。 如果`fileName`是在本地目录中，它可能会标识只是该文件的名称; 否则，必须指定完整路径和文件的名称。 通配符 ("...\\\myfile.txt") 和 UNC 共享名 ("\\\\\\\shared directory\\\myfile.txt") 支持。 如果未找到文件，该异常<xref:System.IO.FileNotFoundException>引发。  
  
 `flags`参数提供了关于文件传输的其他信息的窗口套接字服务提供程序。 有关如何使用此参数的详细信息，请参阅<xref:System.Net.Sockets.TransmitFileOptions>。  
  
 此方法使用`TransmitFile`Windows Sockets 2 API 中找到函数。 有关详细信息`TransmitFile`函数和它的标志，请参阅 MSDN 库中的 Windows 套接字文档。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法启动异步发送操作中建立的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 如果不首先调用将引发异常<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 调用<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法使你能够发送单独的执行线程中的文件。  
  
 若要完成该操作，可以创建由调用的回调方法<xref:System.AsyncCallback>委托参数。 为此，在最低限度下，`state`参数必须包含<xref:System.Net.Sockets.Socket>对象用于进行通信。 如果回调需要详细信息，可以创建类或结构，用于保存<xref:System.Net.Sockets.Socket>和其他所需的信息。 传递到此自定义对象的实例<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法通过`state`参数。  
  
 回调方法必须调用<xref:System.Net.Sockets.Socket.EndSendFile%2A>方法。 当应用程序调用<xref:System.Net.Sockets.Socket.BeginSendFile%2A>，系统使用一个单独的线程来执行指定的回调方法，并阻止上<xref:System.Net.Sockets.Socket.EndSendFile%2A>直到<xref:System.Net.Sockets.Socket>发送整个文件或引发异常。 编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 适用于面向连接的协议，尽管<xref:System.Net.Sockets.Socket.BeginSendFile%2A>无连接协议，也适用，前提是先调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法以建立默认远程主机。 使用无连接协议时，您还必须确保文件的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，不发送数据报并<xref:System.Net.Sockets.Socket.BeginSendFile%2A>引发<xref:System.Net.Sockets.SocketException>异常。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>异常，请使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
   
  
## Examples  
 下面的代码示例创建和连接进行异步通信套接字并开始将文件"text.txt"以异步方式发送到远程主机。 在此示例中，`preBuffer`和一个`postBuffer`的数据创建要与文件和默认值一起发送<xref:System.Net.Sockets.TransmitFileOptions>使用值。 回调委托调用<xref:System.Net.Sockets.Socket.EndSendFile%2A>完成传输。  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.NotSupportedException">操作系统不是 Windows NT 或更高版本。  \- 或 -  套接字未连接到远程主机。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="offset">
          <c>buffer</c> 中开始发送数据的位置，该位置从零开始计数。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="socket_flags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">表示远程设备的 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="remote_end">表示远程设备的 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>以异步方式将数据发送到特定远程主机。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法启动异步发送操作中指定的远程主机到`remoteEP`参数。 调用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法使你能够发送单独的执行线程中的数据。 适用于无连接协议，尽管<xref:System.Net.Sockets.Socket.BeginSendTo%2A>适用于无连接和面向连接的协议。  
  
 可以创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法。 为此，至少，你`state`参数必须包含已连接或默认<xref:System.Net.Sockets.Socket>正用于通信。 如果回调需要详细信息，可以创建一个小类来保存<xref:System.Net.Sockets.Socket>，和其他所需的信息。 传递到此类的实例<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法通过`state`参数。  
  
 回调方法应该调用<xref:System.Net.Sockets.Socket.EndSendTo%2A>方法。 当应用程序调用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>，系统将使用一个单独的线程来执行指定的回调方法，并阻止<xref:System.Net.Sockets.Socket.EndSendTo%2A>直到<xref:System.Net.Sockets.Socket>发送请求的字节数或引发异常。 如果你想要阻止调用后的原始线程<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 当你想要继续执行的原始线程时请在回调方法调用 Set 方法。 有关编写回调方法的其他信息请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 如果使用的是面向连接的协议，必须首先调用<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，或<xref:System.Net.Sockets.Socket.BeginSendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 将忽略`remoteEP`参数并将数据发送到<xref:System.Net.EndPoint>中建立<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。  
  
 如果使用的是无连接协议，不需要建立默认远程主机使用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>。 只需执行此操作，如果你想要调用<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，然后调用<xref:System.Net.Sockets.Socket.SendTo%2A>，则`remoteEP`参数将替代指定的默认远程主机，只为发送操作。 也不需要调用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 在这种情况下，基础服务提供程序将分配的最合适的本地网络地址和端口号。 如果你想要选择可用端口的基础服务提供程序，请使用端口号 0。 如果你需要标识分配的本地网络地址和端口号，则可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性后的<xref:System.Net.Sockets.Socket.EndSendTo%2A>方法成功完成。  
  
 如果你想要将数据发送到的广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，设置套接字选项设为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 -您还必须确保在缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，将不发送数据报并<xref:System.Net.Sockets.Socket.EndSendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，不会将路由发送的数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  为异步缓存的执行上下文 （的安全上下文中，被模拟的用户，并在调用上下文）<xref:System.Net.Sockets.Socket>方法。 后首次使用特定的上下文 (特定于异步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将看到性能的改进。  
  
   
  
## Examples  
 下面的代码示例以异步方式将数据发送到指定的远程主机。  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">将委托作为回调方法进行封送</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">要与 <see cref="T:System.Net.EndPoint" /> 关联的本地 <see cref="T:System.Net.Sockets.Socket" />。</param>
        <summary>使 <see cref="T:System.Net.Sockets.Socket" /> 与一个本地终结点相关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Net.Sockets.Socket.Bind%2A>方法如果你需要使用特定的本地终结点。 必须调用<xref:System.Net.Sockets.Socket.Bind%2A>调用之前<xref:System.Net.Sockets.Socket.Listen%2A>方法。 不需要调用<xref:System.Net.Sockets.Socket.Bind%2A>之前使用<xref:System.Net.Sockets.Socket.Connect%2A>方法除非您需要使用特定的本地终结点。 可以使用<xref:System.Net.Sockets.Socket.Bind%2A>上无连接和面向连接的协议方法。  
  
 然后再调用<xref:System.Net.Sockets.Socket.Bind%2A>，必须先创建本地<xref:System.Net.IPEndPoint>从想要进行数据通信。 如果您不介意分配的本地地址，则可以创建<xref:System.Net.IPEndPoint>使用<xref:System.Net.IPAddress.Any?displayProperty=nameWithType>地址参数，以及基础的服务提供程序将分配的最合适的网络地址。 这可能有助于简化您的应用程序，如果有多个网络接口。 如果你不关心使用哪个本地端口，可以创建<xref:System.Net.IPEndPoint>使用 0 作为端口号。 在这种情况下，服务提供商将分配可用的端口号介于 1024年和 5000 之间。  
  
 如果使用上述方法，可以发现哪些本地网络地址和端口号已分配通过调用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>。 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>进行调用后不会返回之前的本地分配的网络地址<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 如果使用的是无连接协议，将不具有访问此信息，直到已完成发送或接收。  
  
 如果 UDP 套接字想要接收接口上接收数据包的信息<xref:System.Net.Sockets.Socket.SetSocketOption%2A>套接字选项设置为应显式调用方法<xref:System.Net.Sockets.SocketOptionName.PacketInformation>后立即调用<xref:System.Net.Sockets.Socket.Bind%2A>方法。  
  
> [!NOTE]
>  如果您想要接收多播数据报，必须调用<xref:System.Net.Sockets.Socket.Bind%2A>方法具有多路广播的端口号。  
  
> [!NOTE]
>  必须调用<xref:System.Net.Sockets.Socket.Bind%2A>方法，如果你想要接收无连接的数据报使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>调用时<xref:System.Net.Sockets.Socket.Bind%2A>方法，请使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例绑定<xref:System.Net.Sockets.Socket>使用指定的本地终结点。  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自定义的主机的连接<paramref name="localEP" />。 关联的枚举： <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Net.Sockets.Socket" /> 是否处于阻止模式。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 将阻止，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Blocking%2A>属性指示是否<xref:System.Net.Sockets.Socket>处于阻止模式。  
  
 如果您是在阻止模式下，并且进行方法调用这不会立即完成，你的应用程序将请求的操作完成之前阻止执行。 如果要继续执行，即使请求的操作未完成，更改执行<xref:System.Net.Sockets.Socket.Blocking%2A>属性设置为`false`。 <xref:System.Net.Sockets.Socket.Blocking%2A>属性不起对异步方法。 如果是发送和接收数据以异步方式并且想要阻止执行，使用<xref:System.Threading.ManualResetEvent>类。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象，该对象用于通过调用 <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> 方法之一，请求与远程主机的连接。</param>
        <summary>取消一个对远程主机连接的异步请求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A>方法取消对远程主机连接的异步请求。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> 参数不能为 null，并且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>关闭 <see cref="T:System.Net.Sockets.Socket" /> 连接并释放所有关联的资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭 <see cref="T:System.Net.Sockets.Socket" /> 连接并释放所有关联的资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>方法关闭远程主机连接和版本的所有托管和非托管资源与关联<xref:System.Net.Sockets.Socket>。 在关闭之后<xref:System.Net.Sockets.Socket.Connected%2A>属性设置为`false`。  
  
 对于面向连接的协议，建议您调用<xref:System.Net.Sockets.Socket.Shutdown%2A>之前调用<xref:System.Net.Sockets.Socket.Close%2A>方法。 这可确保发送和关闭之前连接的套接字上接收到的所有数据。  
  
 如果您需要调用<xref:System.Net.Sockets.Socket.Close%2A>没有首先调用<xref:System.Net.Sockets.Socket.Shutdown%2A>，可以确保数据的情况下设置发送传出传输排入队列<xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket>选项设为`false`并指定非零的超时间隔。 <xref:System.Net.Sockets.Socket.Close%2A> 然后会阻止发送此数据之前或直到指定的超时时间已到。 如果您设置<xref:System.Net.Sockets.SocketOptionName.DontLinger>到`false`并指定为零的超时间隔、<xref:System.Net.Sockets.Socket.Close%2A>释放连接，并会自动放弃传出队列的数据。  
  
> [!NOTE]
>  若要设置<xref:System.Net.Sockets.SocketOptionName.DontLinger>套接字选项`false`，创建<xref:System.Net.Sockets.LingerOption>，将启用的属性设置为`true`，并设置<xref:System.Net.Sockets.LingerOption.LingerTime%2A>属性设置为所需的超时时间。 使用此<xref:System.Net.Sockets.LingerOption>连同<xref:System.Net.Sockets.SocketOptionName.DontLinger>套接字选项调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例关闭<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">等待最多 <c>timeout</c> 秒后，即可发送任何剩余数据，然后关闭套接字。</param>
        <summary>关闭 <see cref="T:System.Net.Sockets.Socket" /> 连接并释放所有与指定超时关联的资源，以允许要发送的数据排队。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>方法关闭远程主机连接和版本的所有托管和非托管资源与关联<xref:System.Net.Sockets.Socket>。 在关闭之后<xref:System.Net.Sockets.Socket.Connected%2A>属性设置为`false`。  
  
 对于面向连接的协议，建议您调用<xref:System.Net.Sockets.Socket.Shutdown%2A>之前调用<xref:System.Net.Sockets.Socket.Close%2A>。 这可确保发送和关闭之前连接的套接字上接收到的所有数据。  
  
 如果您需要调用<xref:System.Net.Sockets.Socket.Close%2A>没有首先调用<xref:System.Net.Sockets.Socket.Shutdown%2A>，可以确保数据的情况下设置发送传出传输排入队列<xref:System.Net.Sockets.SocketOptionName.DontLinger>选项设为`false`并指定非零的超时间隔。 <xref:System.Net.Sockets.Socket.Close%2A> 然后会阻止发送此数据之前或直到指定的超时时间已到。 如果您设置<xref:System.Net.Sockets.SocketOptionName.DontLinger>到`false`并指定为零的超时间隔、<xref:System.Net.Sockets.Socket.Close%2A>释放连接，并会自动放弃传出队列的数据。  
  
> [!NOTE]
>  若要设置<xref:System.Net.Sockets.SocketOptionName.DontLinger>套接字选项`false`，创建<xref:System.Net.Sockets.LingerOption>，将启用的属性设置为`true`，并设置<xref:System.Net.Sockets.LingerOption.LingerTime%2A>属性设置为所需的超时期限。 使用此<xref:System.Net.Sockets.LingerOption>连同<xref:System.Net.Sockets.SocketOptionName.DontLinger>套接字选项调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何关闭<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>与远程主机建立连接。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">表示远程设备的 <see cref="T:System.Net.EndPoint" />。</param>
        <summary>与远程主机建立连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议 TCP，如<xref:System.Net.Sockets.Socket.Connect%2A>方法以同步方式建立网络连接之间<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的远程终结点。 如果您使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机。 调用后<xref:System.Net.Sockets.Socket.Connect%2A>，可以将数据发送到远程设备与<xref:System.Net.Sockets.Socket.Send%2A>方法，或从使用的远程设备接收数据<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果使用如 UDP 是无连接协议，不需要调用<xref:System.Net.Sockets.Socket.Connect%2A>之前发送和接收数据。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>能够与远程主机同步通信。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>，将丢弃来自指定的默认值以外的地址的任何数据报。 如果你想要将默认远程主机到广播地址，必须先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，设置套接字选项设置为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>方法将阻止，除非专门设置了相应<xref:System.Net.Sockets.Socket.Blocking%2A>属性设置为`false`之前调用<xref:System.Net.Sockets.Socket.Connect%2A>。 如果要使用面向连接的协议 TCP，并且确实禁用阻塞等<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>因为它需要时间来建立连接。 无连接协议将引发异常，因为它们只需建立默认远程主机。 可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>若要获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。 如果 WSAEWOULDBLOCK 返回的错误，已通过面向连接的发起远程主机连接<xref:System.Net.Sockets.Socket>，但未尚未成功完成。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法来确定何时<xref:System.Net.Sockets.Socket>完成连接。  
  
> [!NOTE]
>  如果使用的是面向连接的协议和未调用<xref:System.Net.Sockets.Socket.Bind%2A>之前调用<xref:System.Net.Sockets.Socket.Connect%2A>，基础服务提供程序将分配的本地网络地址和端口号。 如果使用的是无连接协议，服务提供程序将不会分配本地网络地址和端口号，直到完成发送或接收操作。 如果你想要更改默认远程主机，则调用<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需终结点。  
  
> [!NOTE]
>  如果之前断开连接的套接字，则不能使用此方法以还原连接。 使用异步之一<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法来重新连接。 这是基础提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并接着验证连接。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
        <permission cref="T:System.Net.SocketPermission">用于连接到远程主机。 关联的枚举： <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">远程主机的 IP 地址。</param>
        <param name="port">远程主机的端口号。</param>
        <summary>与远程主机建立连接。 主机由 IP 地址和端口号指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议 TCP，如<xref:System.Net.Sockets.Socket.Connect%2A>方法以同步方式建立网络连接之间<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的远程终结点。 如果您使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机。 调用后<xref:System.Net.Sockets.Socket.Connect%2A>可以将数据发送到远程设备与<xref:System.Net.Sockets.Socket.Send%2A>方法，或从使用的远程设备接收数据<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果使用如 UDP 是无连接协议，不需要调用<xref:System.Net.Sockets.Socket.Connect%2A>之前发送和接收数据。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>能够与远程主机同步通信。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>将丢弃来自指定的默认值以外的地址的任何数据报。 如果你想要将默认远程主机到广播地址，必须先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，设置套接字选项设置为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法将阻止，除非专门设置了<xref:System.Net.Sockets.Socket.Blocking%2A>属性设置为`false`之前调用<xref:System.Net.Sockets.Socket.Connect%2A>。 如果要使用面向连接的协议 TCP，并且确实禁用阻塞等<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>因为它需要时间来建立连接。 无连接协议将引发异常，因为它们只需建立默认远程主机。 可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>若要获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。 如果 WSAEWOULDBLOCK 返回的错误，已通过面向连接的发起远程主机连接<xref:System.Net.Sockets.Socket>，但未尚未成功完成。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法来确定何时<xref:System.Net.Sockets.Socket>完成连接。  
  
> [!NOTE]
>  如果使用的是面向连接的协议和未调用<xref:System.Net.Sockets.Socket.Bind%2A>之前调用<xref:System.Net.Sockets.Socket.Connect%2A>，基础服务提供程序将分配的本地网络地址和端口号。 如果使用的是无连接协议，服务提供程序将不会分配本地网络地址和端口号，直到完成发送或接收操作。 如果你想要更改默认远程主机，则调用<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需终结点。  
  
> [!NOTE]
>  如果之前断开连接的套接字，则不能使用此方法以还原连接。 使用异步之一<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法来重新连接。 这是基础提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并接着验证连接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">远程主机的 IP 地址。</param>
        <param name="port">远程主机的端口号。</param>
        <summary>与远程主机建立连接。 主机由 IP 地址数组和端口号指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法通常用于调用后立即<xref:System.Net.Dns.GetHostAddresses%2A>，这可以为单个主机返回多个 IP 地址。 如果使用面向连接的协议 TCP，如<xref:System.Net.Sockets.Socket.Connect%2A>方法以同步方式建立网络连接之间<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的远程终结点。 如果您使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机。 调用后<xref:System.Net.Sockets.Socket.Connect%2A>可以将数据发送到远程设备与<xref:System.Net.Sockets.Socket.Send%2A>方法，或从使用的远程设备接收数据<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果使用如 UDP 是无连接协议，不需要调用<xref:System.Net.Sockets.Socket.Connect%2A>之前发送和接收数据。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>能够与远程主机同步通信。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>将丢弃来自指定的默认值以外的地址的任何数据报。 如果你想要将默认远程主机到广播地址，必须先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，设置套接字选项设置为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法将阻止，除非专门设置了<xref:System.Net.Sockets.Socket.Blocking%2A>属性设置为`false`之前调用<xref:System.Net.Sockets.Socket.Connect%2A>。 如果要使用面向连接的协议 TCP，并且确实禁用阻塞等<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>因为它需要时间来建立连接。 无连接协议将引发异常，因为它们只需建立默认远程主机。 可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>若要获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。 如果 WSAEWOULDBLOCK 返回的错误，已通过面向连接的发起远程主机连接<xref:System.Net.Sockets.Socket>，但未尚未成功完成。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法来确定何时<xref:System.Net.Sockets.Socket>完成连接。  
  
> [!NOTE]
>  如果使用的是面向连接的协议和未调用<xref:System.Net.Sockets.Socket.Bind%2A>之前调用<xref:System.Net.Sockets.Socket.Connect%2A>，基础服务提供程序将分配的本地网络地址和端口号。 如果使用的是无连接协议，服务提供程序将不会分配本地网络地址和端口号，直到完成发送或接收操作。 如果你想要更改默认远程主机，则调用<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需终结点。  
  
> [!NOTE]
>  如果之前断开连接的套接字，则不能使用此方法以还原连接。 使用异步之一<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法来重新连接。 这是基础提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并接着验证连接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">远程主机的名称。</param>
        <param name="port">远程主机的端口号。</param>
        <summary>与远程主机建立连接。 主机由主机名和端口号指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议 TCP，如<xref:System.Net.Sockets.Socket.Connect%2A>方法以同步方式建立网络连接之间<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的远程主机。 如果您使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机。 调用后<xref:System.Net.Sockets.Socket.Connect%2A>可以将数据发送到远程设备与<xref:System.Net.Sockets.Socket.Send%2A>方法，或从使用的远程设备接收数据<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果使用如 UDP 是无连接协议，不需要调用<xref:System.Net.Sockets.Socket.Connect%2A>之前发送和接收数据。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>能够与远程主机同步通信。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>将丢弃来自指定的默认值以外的地址的任何数据报。 如果你想要将默认远程主机到广播地址，必须先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，设置套接字选项设置为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法将阻止，除非专门设置了<xref:System.Net.Sockets.Socket.Blocking%2A>属性设置为`false`之前调用<xref:System.Net.Sockets.Socket.Connect%2A>。 如果要使用面向连接的协议 TCP，并且确实禁用阻塞等<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>因为它需要时间来建立连接。 无连接协议将引发异常，因为它们只需建立默认远程主机。 可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>若要获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。 如果 WSAEWOULDBLOCK 返回的错误，已通过面向连接的发起远程主机连接<xref:System.Net.Sockets.Socket>，但未尚未成功完成。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法来确定何时<xref:System.Net.Sockets.Socket>完成连接。  
  
 如果启用了 IPv6 和<xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29>调用方法来连接到的主机，解析为 IPv6 和 IPv4 地址、 IPv6 地址将与连接尝试之前的 IPv4 地址的第一个。 这可能会延迟的时间来建立连接，如果主机未侦听 IPv6 地址。  
  
> [!NOTE]
>  如果使用的是面向连接的协议和未调用<xref:System.Net.Sockets.Socket.Bind%2A>之前调用<xref:System.Net.Sockets.Socket.Connect%2A>，基础服务提供程序将分配的本地网络地址和端口号。 如果使用的是无连接协议，服务提供程序将不会分配本地网络地址和端口号，直到完成发送或接收操作。 如果你想要更改默认远程主机，则调用<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需终结点。  
  
> [!NOTE]
>  如果之前断开连接的套接字，则不能使用此方法以还原连接。 使用异步之一<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法来重新连接。 这是基础提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并接着验证连接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个对远程主机连接的异步请求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个对远程主机连接的异步请求。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法启动与远程主机的连接的异步请求。 如果您使用的是无连接协议，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>建立默认远程主机。  
  
 若要在完成时得到通知，必须创建实现事件处理程序的回调方法\<SocketAsyncEventArgs > 委托并将附加到回调<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 调用方必须设置<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>属性设置为<xref:System.Net.IPEndPoint>要连接到的远程主机。  
  
 调用方可能会设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>属性设置为在调用之前所需的任何用户状态对象<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，以便可在回调方法中检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小类来保存作为成员的其他所需的状态信息。  
  
 如果使用如 UDP 是无连接协议，不需要调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>之前发送和接收数据。 可以使用<xref:System.Net.Sockets.Socket.SendToAsync%2A>和<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>与远程主机通信。 如果调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，将丢弃来自指定的默认值以外的地址的任何数据报。 如果你想要更改默认远程主机，则调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法再次使用所需终结点。  
  
 如果你想要设置默认远程主机与广播地址，必须先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>设置为广播和`true`。 如果不执行此操作，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法将引发<xref:System.Net.Sockets.SocketException>。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>对象所需：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 （可选） 一个缓冲区可能会提供它以原子方式发送后在套接字上<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法成功。 在这种情况下，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>属性应设置为包含数据的缓冲区，以发送和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>属性应设置为的数据的字节数，以从缓冲区发送。 一旦建立的连接，该缓冲区中的数据会被发送。  
  
 如果您使用的是面向连接的协议，并且不会调用<xref:System.Net.Sockets.Socket.Bind%2A>之前调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，基础服务提供程序将分配的最合适的本地网络地址和端口号。  
  
 如果您使用的是无连接协议，直到您调用，服务提供程序将不分配本地网络 IP 地址和端口号<xref:System.Net.Sockets.Socket.SendAsync%2A>或<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法会抛出<xref:System.NotSupportedException>如果的地址族<xref:System.Net.Sockets.Socket>和<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>不是同一地址系列。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>调用此方法时，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">自变量无效。 如果指定了多个缓冲区，即 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性不为 null，将会发生此异常。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> 参数不能为 null，并且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为空。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> 正在侦听或已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。 如果本地终结点和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是相同的地址族，也会发生此异常。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType">
          <see cref="T:System.Net.Sockets.SocketType" /> 值之一。</param>
        <param name="protocolType">
          <see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</param>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个对远程主机连接的异步请求。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用的是面向连接的协议，M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) 方法启动的异步请求连接到远程主机。 如果使用的是无连接协议<xref:System.Net.Sockets.Socket.ConnectAsync%2A>建立默认远程主机由指定`socketType`和`protocolType`参数。  
  
 若要在完成时得到通知，必须创建实现事件处理程序的回调方法\<SocketAsyncEventArgs > 委托并将附加到回调<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 调用方必须设置<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>属性设置为<xref:System.Net.IPEndPoint>要连接到的远程主机。  
  
 调用方可能会设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>属性设置为在调用之前所需的任何用户状态对象<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，以便可在回调方法中检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小类来保存作为成员的其他所需的状态信息。  
  
 如果使用如 UDP 是无连接协议，不需要调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>之前发送和接收数据。 可以使用<xref:System.Net.Sockets.Socket.SendToAsync%2A>和<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>与远程主机通信。 如果调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，将丢弃来自指定的默认值以外的地址的任何数据报。 如果你想要更改默认远程主机，则调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法再次使用所需终结点。  
  
 如果你想要设置默认远程主机与广播地址，必须先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>设置为广播和`true`。 如果不执行此操作，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法将引发<xref:System.Net.Sockets.SocketException>。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>对象所需：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 （可选） 一个缓冲区可能会提供它以原子方式发送后在套接字上<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法成功。 在这种情况下，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>属性应设置为包含数据的缓冲区，以发送和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>属性应设置为的数据的字节数，以从缓冲区发送。 一旦建立的连接，该缓冲区中的数据会被发送。  
  
 如果您使用的是面向连接的协议，并且不会调用<xref:System.Net.Sockets.Socket.Bind%2A>之前调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，基础服务提供程序将分配的最合适的本地网络地址和端口号。  
  
 如果您使用的是无连接协议，直到您调用，服务提供程序将不分配本地网络 IP 地址和端口号<xref:System.Net.Sockets.Socket.SendAsync%2A>或<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法会抛出<xref:System.NotSupportedException>如果的地址族<xref:System.Net.Sockets.Socket>和<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>不是同一地址系列。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>调用此方法时，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">自变量无效。 如果指定了多个缓冲区，即 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性不为 null，将会发生此异常。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> 参数不能为 null，并且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为空。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> 正在侦听或已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。 如果本地终结点和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是相同的地址族，也会发生此异常。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Net.Sockets.Socket" /> 是在上次 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 还是 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 操作时连接到远程主机。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 在最近操作时连接到远程资源，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Connected`属性获取的连接状态<xref:System.Net.Sockets.Socket>截止到最后一个 I/O 操作。 如果该属性返回`false`，则<xref:System.Net.Sockets.Socket>要么从未连接，或已断开连接。  
  
 值<xref:System.Net.Sockets.Socket.Connected%2A>属性反映最新操作时的连接的状态。 如果您需要确定连接的当前状态，请调用非阻止性、 零字节发送。 如果调用成功返回或引发 WAEWOULDBLOCK 错误代码 (10035)，则仍连接套接字;否则，无法再连接套接字。  
  
 如果您调用<xref:System.Net.Sockets.Socket.Connect%2A>对用户数据报协议 (UDP) 套接字<xref:System.Net.Sockets.Socket.Connected%2A>属性始终返回`true`; 但是，此操作不会更改无连接的固有 UDP 性质。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，检查<xref:System.Net.Sockets.Socket.Connected%2A>属性，并检查连接的当前状态。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">如果关闭当前连接后可以重用此套接字，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>关闭套接字连接并允许重用套接字。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用的是面向连接的协议，可以使用此方法以关闭套接字。 此方法结束连接和集<xref:System.Net.Sockets.Socket.Connected%2A>属性设置为`false`。 但是，如果`reuseSocket`是`true`，可以重复使用套接字。  
  
 若要确保发送和接收套接字关闭之前的所有数据，应调用<xref:System.Net.Sockets.Socket.Shutdown%2A>之前调用<xref:System.Net.Sockets.Socket.Disconnect%2A>方法。  
  
 如果您需要调用<xref:System.Net.Sockets.Socket.Disconnect%2A>没有首先调用<xref:System.Net.Sockets.Socket.Shutdown%2A>，可以设置<xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket>选项设为`false`而指定的非零的超时间隔，以确保排队等待发送传出的传输的数据。 <xref:System.Net.Sockets.Socket.Disconnect%2A> 然后阻止，直到发送数据或直到指定的超时时间已到。 如果您设置<xref:System.Net.Sockets.SocketOptionName.DontLinger>到`false`并指定为零的超时间隔、<xref:System.Net.Sockets.Socket.Close%2A>释放连接，并会自动放弃传出队列的数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例创建同步通信套接字，并将一些数据发送到远程主机。 然后，它调用<xref:System.Net.Sockets.Socket.Shutdown%2A>，以停止发送和接收活动，并<xref:System.Net.Sockets.Socket.Disconnect%2A>以关闭套接字连接。  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">此方法需要 Windows 2000 或更低版本，否则将引发异常。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始异步请求从远程终结点断开连接。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用面向连接的协议时，调用<xref:System.Net.Sockets.Socket.DisconnectAsync%2A>方法请求从远程终结点断开连接。 如果您设置<xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType>到`true`中`e`参数，可以重复使用套接字。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> 参数不能为 null。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>释放 <see cref="T:System.Net.Sockets.Socket" /> 类的当前实例所使用的所有资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Net.Sockets.Socket" /> 类的当前实例所使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完成使用 `Dispose` 后，应调用 <xref:System.Net.Sockets.Socket>。 `Dispose` 方法使 <xref:System.Net.Sockets.Socket> 处于不可用状态。 在调用`Dispose`，必须释放对所有引用<xref:System.Net.Sockets.Socket>这样垃圾回收器才能收回内存的<xref:System.Net.Sockets.Socket>占用。  
  
 有关详细信息，请参阅[清理了非托管资源](~/docs/standard/garbage-collection/unmanaged.md)并[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
> [!NOTE]
>  每次释放对 `Dispose` 的最后一个引用前，均应调用 <xref:System.Net.Sockets.Socket>。 否则，在垃圾回收器调用 <xref:System.Net.Sockets.Socket> 对象的 `Finalize` 方法之前，该对象正在使用的资源不会被释放。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">如果释放托管资源和非托管资源，则为 <see langword="true" />；如果仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放由 <see cref="T:System.Net.Sockets.Socket" /> 使用的非托管资源，并可根据需要释放托管资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法由公共`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。 `Dispose()` 调用受保护`Dispose(Boolean)`方法替换`disposing`参数设置为`true`。 <xref:System.Object.Finalize%2A> 调用`Dispose`与`disposing`设置为`false`。  
  
 当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.Net.Sockets.Socket> 引用的、由任何托管对象持有的全部资源。 此方法调用每个引用对象的 `Dispose()` 方法。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> 可以多次调用由其他对象。重写 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> 时，请注意不要引用在以前调用 <see langword="Dispose" /> 时已释放的对象。有关如何实现详细信息<see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />，请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。有关详细信息<see langword="Dispose" />并<see cref="M:System.Object.Finalize" />，请参阅[清理了非托管资源](~/docs/standard/garbage-collection/unmanaged.md)并[重写 Finalize 方法](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否允许将 Internet 协议 (IP) 数据报分段。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 允许数据报分段，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 其大小超过最大传输单元 (MTU) 的传输媒体时，数据报要求碎片。 数据报可能通过发送主机 （所有 Internet 协议版本） 或中间路由器 (Internet 协议版本 4 仅) 分段。 如果必须碎片数据报，和<xref:System.Net.Sockets.Socket.DontFragment%2A>选项设置、 数据报将被放弃，并且 Internet 控制消息协议 (ICMP) 错误消息发送回发送方的数据报。  
  
 传输控制协议 (TCP) 套接字上设置此属性不会影响。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.DontFragment%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">只有对于在 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 族中的套接字，才可以设置此属性。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否是用于 IPv4 和 IPv6 的双模式套接字。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 是双模式套接字，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">从中创建重复套接字引用的目标进程的 ID。</param>
        <summary>重复目标进程的套接字引用，并关闭此进程的套接字。</summary>
        <returns>要传递到目标进程的套接字引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目标进程应使用<xref:System.Net.Sockets.Socket.%23ctor%2A>创建重复套接字实例。  
  
 如果您调用<xref:System.Net.Sockets.Socket.%23ctor%2A>多次使用相同的字节数组，作为每个调用的参数的构造函数，您将创建多个托管<xref:System.Net.Sockets.Socket>具有相同的基础套接字的实例。 这种做法是强烈建议不要使用。  
  
 如果进程创建套接字使用的异步方法 (<xref:System.Net.Sockets.Socket.BeginReceive%2A>或<xref:System.Net.Sockets.Socket.BeginSend%2A>)，该过程必须首先设置<xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A>属性设置为 true; 否则为套接字绑定到完成端口的创建过程中，这可能会导致<xref:System.ArgumentNullException>目标进程中抛出。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="targetProcessID" /> 不是有效的进程 ID。  - 或 -  套接字引用的复制失败。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否可以发送或接收广播数据包。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 允许广播数据包，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 广播仅限于特定的子网，并且必须使用用户数据报协议 (UDP)。有关 Internet 协议版本 4，您可以通过将数据包发送到 255.255.255.255; 广播本地子网或者，可以使用定向广播的地址，这是使用中的主机部分设置的所有位的 Internet 协议 (IP) 地址的网络部分。 例如，如果你的 IP 地址为 192.168.1.40 （C 类地址，网络掩码为 255.255.255.0-网络部分是前三个八位字节，而主机部分是最后一个八进制数），则定向广播的地址是 192.168.1.255。  
  
 传输控制协议 (TCP) 套接字上设置此属性不会影响。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.EnableBroadcast%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">此选项仅对数据报套接字有效。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>异步接受传入的连接尝试。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">包含所传输字节的类型 <see cref="T:System.Byte" /> 的数组。</param>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息以及任何用户定义数据。</param>
        <summary>异步接受传入的连接尝试，并创建新的 <see cref="T:System.Net.Sockets.Socket" /> 对象来处理远程主机通信。 此方法返回包含所传输的初始数据的缓冲区。</summary>
        <returns>一个 <see cref="T:System.Net.Sockets.Socket" /> 对象，它处理与远程主机的通信。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成对调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>。 然后再调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>，你需要创建一个回调方法，它通过调用<xref:System.AsyncCallback>委托。 该回调方法在一个单独的线程中执行并由系统后调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法返回。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法`asyncResult`参数来获取<xref:System.Net.Sockets.Socket>上可由连接尝试。 获取后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法才能成功完成连接尝试。 `buffer`的此重载的参数包含对的调用中收到的数据<xref:System.Net.Sockets.Socket.BeginAccept%2A>和`bytesTransferred`参数包含已传输的调用中的字节数。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法进行阻止，直到挂起的连接，传入的连接队列中。 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法接受传入连接，并返回一个新<xref:System.Net.Sockets.Socket>可用来将数据发送到和从远程主机接收数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.Sockets.Socket.BeginAccept%2A>可创建和连接套接字接受前 10 个字节的数据。 回调委托调用<xref:System.Net.Sockets.Socket.EndAccept%2A>结束异步请求。 在返回传输的字节数和数据`buffer`和`bytesTransferred`此方法的参数并在控制台上显示。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为空。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的调用创建的。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法以前被调用过。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问 <see cref="T:System.Net.Sockets.Socket" /> 时出错</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及任何用户定义数据。</param>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及任何用户定义数据。</param>
        <summary>异步接受传入的连接尝试，并创建新的 <see cref="T:System.Net.Sockets.Socket" /> 来处理远程主机通信。</summary>
        <returns>一个 <see cref="T:System.Net.Sockets.Socket" />，它处理与远程主机的通信。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成对调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>。 然后再调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 该回调方法在一个单独的线程中执行并由系统后调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法返回。 必须接受`asyncResult`参数从返回<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法`asyncResult`参数来获取<xref:System.Net.Sockets.Socket>上可由连接尝试。 获取后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法才能成功完成连接尝试。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法进行阻止，直到挂起的连接，传入的连接队列中。 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法接受传入连接，并返回一个新<xref:System.Net.Sockets.Socket>可用来将数据发送到和从远程主机接收数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例结束的异步请求并创建一个新<xref:System.Net.Sockets.Socket>以接受传入连接请求。 有关演示如何使用套接字的异步通信的完整示例，请参阅[套接字代码示例](~/docs/framework/network-programming/socket-code-examples.md)。  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的调用创建的。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 有关详细信息，请参阅备注部分。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法以前被调用过。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">包含所传输字节的类型 <see cref="T:System.Byte" /> 的数组。</param>
        <param name="bytesTransferred">已传输的字节数。</param>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息以及任何用户定义数据。</param>
        <summary>异步接受传入的连接尝试，并创建新的 <see cref="T:System.Net.Sockets.Socket" /> 对象来处理远程主机通信。 此方法返回一个缓冲区，其中包含初始数据和传输的字节数。</summary>
        <returns>一个 <see cref="T:System.Net.Sockets.Socket" /> 对象，它处理与远程主机的通信。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成对调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>。 然后再调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>，你需要创建一个回调方法，它通过调用<xref:System.AsyncCallback>委托。 该回调方法在一个单独的线程中执行并由系统后调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法返回。 必须接受`asyncResult`参数从返回<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法`asyncResult`参数来获取<xref:System.Net.Sockets.Socket>上可由连接尝试。 获取后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法才能成功完成连接尝试。 `buffer`的此重载的参数包含对的调用中收到的数据<xref:System.Net.Sockets.Socket.BeginAccept%2A>和`bytesTransferred`参数包含已传输的调用中的字节数。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法进行阻止，直到挂起的连接，传入的连接队列中。 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法接受传入连接，并返回一个新<xref:System.Net.Sockets.Socket>可用来将数据发送到和从远程主机接收数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.Sockets.Socket.BeginAccept%2A>可创建和连接套接字接受前 10 个字节的数据。 回调委托调用<xref:System.Net.Sockets.Socket.EndAccept%2A>结束异步请求。 在返回传输的字节数和数据`buffer`和`bytesTransferred`此方法的参数并在控制台上显示。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为空。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的调用创建的。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法以前被调用过。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问 <see cref="T:System.Net.Sockets.Socket" /> 时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <summary>结束挂起的异步连接请求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> 在中启动阻止方法，在完成异步远程主机连接请求<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法。  
  
 然后再调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 该回调方法在一个单独的线程中执行，并由系统后调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回的<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法作为参数。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>参数来获取<xref:System.Net.Sockets.Socket>上可由连接尝试。 获取后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法才能成功完成连接尝试。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例结束异步连接尝试。 有关演示如何使用套接字的异步通信的完整示例，请参阅[套接字代码示例](~/docs/framework/network-programming/socket-code-examples.md)。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步连接调用过 <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息以及所有用户定义数据。</param>
        <summary>结束挂起的异步断开连接请求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 完成对调用<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>方法进行阻止，直到完成断开连接。 有关异步操作的信息，请参阅 MSDN library 中的异步编程的概述主题。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例创建的套接字进行异步通信，并将一些数据发送到远程主机。 已发送数据，<xref:System.Net.Sockets.Socket.Shutdown%2A>调用来停止发送和接收活动。 然后<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>调用以开始断开连接请求。 回调委托调用<xref:System.Net.Sockets.Socket.EndDisconnect%2A>结束异步请求。 完成请求后，<xref:System.Net.Sockets.Socket.Connected%2A>属性进行查询，以测试是否已断开连接的套接字。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">操作系统为 Windows 2000 或更低版本，而此方法需要在 Windows XP 中使用。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步连接调用过 <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.Net.WebException">断开连接请求已超时。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>结束挂起的异步读取。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <summary>结束挂起的异步读取。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法完成异步读取的操作以启动<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。  
  
 然后再调用<xref:System.Net.Sockets.Socket.BeginReceive%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 该回调方法在一个单独的线程中执行，并由系统后调用<xref:System.Net.Sockets.Socket.BeginReceive%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回的<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法作为参数。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>若要获取状态对象传递给<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 提取接收<xref:System.Net.Sockets.Socket>从该状态对象。 获取后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndReceive%2A>方法成功完成读取的操作，并返回读取的字节数。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法将阻塞，直到有可用数据。 如果您使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndReceive%2A>将读取传入的网络缓冲区中有可用的第一个排队数据报。 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.EndReceive%2A>方法将读取的数据，可在指定的字节数目可高达`size`参数的<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到了方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法将立即完成并返回零字节。  
  
 若要获取所接收的数据，请调用<xref:System.IAsyncResult.AsyncState%2A>方法的<xref:System.IAsyncResult>，然后提取生成的状态对象中包含的缓冲区。  
  
 若要取消挂起<xref:System.Net.Sockets.Socket.BeginReceive%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  由给定线程启动的所有 i/o 操作被取消时该线程退出。 如果在线程退出该操作完成之前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例结束挂起的异步读取。 有关演示如何使用套接字的异步通信的完整示例，请参阅[套接字代码示例](~/docs/framework/network-programming/socket-code-examples.md)。  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>结束挂起的异步读取。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法完成异步读取的操作以启动<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。  
  
 然后再调用<xref:System.Net.Sockets.Socket.BeginReceive%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 该回调方法在一个单独的线程中执行，并由系统后调用<xref:System.Net.Sockets.Socket.BeginReceive%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回的<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法作为参数。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>若要获取状态对象传递给<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 提取接收<xref:System.Net.Sockets.Socket>从该状态对象。 获取后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndReceive%2A>方法成功完成读取的操作，并返回读取的字节数。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法将阻塞，直到有可用数据。 如果您使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndReceive%2A>将读取传入的网络缓冲区中有可用的第一个排队数据报。 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.EndReceive%2A>方法将读取的数据，可在指定的字节数目可高达`size`参数的<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到了方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法将立即完成并返回零字节。  
  
 若要获取所接收的数据，请调用<xref:System.IAsyncResult.AsyncState%2A>方法的<xref:System.IAsyncResult>，然后提取生成的状态对象中包含的缓冲区。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  由给定线程启动的所有 i/o 操作被取消时该线程退出。 如果在线程退出该操作完成之前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="endPoint">源 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="end_point">源 <see cref="T:System.Net.EndPoint" />。</param>
        <summary>结束挂起的、从特定终结点进行异步读取。</summary>
        <returns>如果成功，则返回已接收的字节数。 如果不成功，则返回 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法完成异步读取的操作以启动<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。  
  
 然后再调用<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 该回调方法在一个单独的线程中执行，并由系统后调用<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回的<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法作为参数。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>若要获取状态对象传递给<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 提取接收<xref:System.Net.Sockets.Socket>从该状态对象。 获取后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法成功完成读取的操作，并返回读取的字节数。  
  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法将阻塞，直到有可用数据。 如果您使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>将读取传入的网络缓冲区中有可用的第一个排队数据报。 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法将读取的数据，可在指定的字节数目可高达`size`参数的<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到了方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法将立即完成并返回零字节。 若要获取所接收的数据，请调用<xref:System.IAsyncResult.AsyncState%2A>方法的<xref:System.IAsyncResult>对象，并提取生成的状态对象中包含的缓冲区。 若要标识原始主机，提取<xref:System.Net.EndPoint>将其转换为<xref:System.Net.IPEndPoint>。 使用<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>方法来获取 IP 地址和<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>方法来获取端口号。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例结束挂起的异步读取从特定<xref:System.Net.EndPoint>。  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="socketFlags">所接收数据包的 <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="endPoint">源 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation">所接收数据包的 <see cref="T:System.Net.IPAddress" /> 和接口。</param>
        <summary>结束挂起的、从特定终结点进行异步读取。 此方法还显示有关数据包而不是 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> 的更多信息。</summary>
        <returns>如果成功，则返回已接收的字节数。 如果不成功，则返回 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该操作未完成，此方法阻止，直至它。  
  
 若要以同步方式执行此操作，请使用<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法。  
  
 检查`ipPacketInformation`如果您需要了解是否使用单播、 多播或广播地址发送数据报。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />  - 或 -   <paramref name="endPoint" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>结束挂起的异步发送。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息。</param>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息。</param>
        <summary>结束挂起的异步发送。</summary>
        <returns>如果成功，则将返回向 <see cref="T:System.Net.Sockets.Socket" /> 发送的字节数；否则会返回无效 <see cref="T:System.Net.Sockets.Socket" /> 错误。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 完成异步发送操作中启动<xref:System.Net.Sockets.Socket.BeginSend%2A>。  
  
 然后再调用<xref:System.Net.Sockets.Socket.BeginSend%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 该回调方法在一个单独的线程中执行，并由系统后调用<xref:System.Net.Sockets.Socket.BeginSend%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回的<xref:System.Net.Sockets.Socket.BeginSend%2A>方法作为参数。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>参数来获取发送<xref:System.Net.Sockets.Socket>。 获取后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndSend%2A>方法成功完成发送操作并返回发送的字节数。  
  
 如果您使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndSend%2A>会阻塞，直到发送数据报。 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.EndSend%2A>会阻塞，直到某些缓冲区已发送。 如果的返回值<xref:System.Net.Sockets.Socket.EndSend%2A>指示的缓冲区不是完全发送，调用<xref:System.Net.Sockets.Socket.BeginSend%2A>方法同样，修改要保存的未发送的数据的缓冲区。  
  
 则您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.BeginSend%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  由给定线程启动的所有 i/o 操作被取消时该线程退出。 如果在线程退出该操作完成之前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  发送的成功完成并不表示数据已成功传递。 如果任何缓冲区空间以容纳要传输的数据在传输系统中不不可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例结束挂起的异步发送。  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前为异步发送已调用过 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>结束挂起的异步发送。</summary>
        <returns>如果成功，则将返回向 <see cref="T:System.Net.Sockets.Socket" /> 发送的字节数；否则会返回无效 <see cref="T:System.Net.Sockets.Socket" /> 错误。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 完成异步发送操作中启动<xref:System.Net.Sockets.Socket.BeginSend%2A>。  
  
 然后再调用<xref:System.Net.Sockets.Socket.BeginSend%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 该回调方法在一个单独的线程中执行，并由系统后调用<xref:System.Net.Sockets.Socket.BeginSend%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回的<xref:System.Net.Sockets.Socket.BeginSend%2A>方法作为参数。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>参数来获取发送<xref:System.Net.Sockets.Socket>。 获取后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndSend%2A>方法成功完成发送操作并返回发送的字节数。  
  
 如果您使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndSend%2A>会阻塞，直到发送数据报。 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.EndSend%2A>会阻塞，直到某些缓冲区已发送。 如果的返回值<xref:System.Net.Sockets.Socket.EndSend%2A>指示的缓冲区不是完全发送，调用<xref:System.Net.Sockets.Socket.BeginSend%2A>方法同样，修改要保存的未发送的数据的缓冲区。  
  
 则您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.BeginSend%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  由给定线程启动的所有 i/o 操作被取消时该线程退出。 如果在线程退出该操作完成之前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  发送的成功完成并不表示数据已成功传递。 如果任何缓冲区空间以容纳要传输的数据在传输系统中不不可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前为异步发送已调用过 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息。</param>
        <summary>结束文件的挂起异步发送。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 完成异步发送操作中启动<xref:System.Net.Sockets.Socket.BeginSendFile%2A>。  
  
 然后再调用<xref:System.Net.Sockets.Socket.BeginSendFile%2A>，必须创建实现一个回调方法<xref:System.AsyncCallback>委托。 该回调方法在一个单独的线程中执行，并由系统后调用<xref:System.Net.Sockets.Socket.BeginSendFile%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回对象<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法作为参数。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>参数来获取发送<xref:System.Net.Sockets.Socket>。 获取后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndSendFile%2A>方法才能成功完成发送操作。  
  
 如果您使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndSendFile%2A>阻止，直到发送数据报。 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.EndSendFile%2A>阻止，直到发送整个文件。 则您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例创建和连接进行异步通信套接字并开始将文件"text.txt"以异步方式发送到远程主机。 回调委托调用<xref:System.Net.Sockets.Socket.EndSendFile%2A>完成传输。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为空。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步 <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> 调用过 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <summary>结束挂起的、向指定位置进行的异步发送。</summary>
        <returns>如果成功，则返回已发送的字节数；否则会返回无效 <see cref="T:System.Net.Sockets.Socket" /> 错误。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 完成异步发送操作中启动<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。  
  
 然后再调用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 该回调方法在一个单独的线程中执行，并由系统后调用<xref:System.Net.Sockets.Socket.BeginReceive%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回的<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法作为参数。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>参数来获取发送<xref:System.Net.Sockets.Socket>。 获取后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndSendTo%2A>方法成功完成发送操作并返回发送的字节数。  
  
 如果您使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndSendTo%2A>会阻塞，直到发送数据报。 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.EndSendTo%2A>会阻塞，直到发送请求的字节数。 则您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例结束异步发送到特定位置。  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前为异步发送已调用过 <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否仅允许一个进程绑定到端口。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 仅允许一个套接字绑定到特定端口，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值是<see langword="true" />Windows Server 2003 和 Windows XP Service Pack 2 和<see langword="false" />对于所有其他版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>是`false`，可以使用多个套接字<xref:System.Net.Sockets.Socket.Bind%2A>方法绑定到特定端口; 但是只有一个套接字可以执行对发送到端口的网络流量的操作。 如果尝试使用多个套接字<xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29>方法绑定到特殊端口时，则使用更具体的 IP 地址之一将处理发送到该端口的网络流量。  
  
 如果<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>是`true`，首次使用<xref:System.Net.Sockets.Socket.Bind%2A>方法来尝试绑定到特定端口，而不考虑 Internet 协议 (IP) 地址，将会成功; 的所有后续使用<xref:System.Net.Sockets.Socket.Bind%2A>方法来尝试绑定到该端口将失败，直到销毁原始绑定套接字。  
  
 此属性必须设置前<xref:System.Net.Sockets.Socket.Bind%2A>被调用; 否则为<xref:System.InvalidOperationException>将引发。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">已为此 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 调用了 <see cref="T:System.Net.Sockets.Socket" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Net.Sockets.Socket" /> 类使用的资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>类终结器调用<xref:System.Net.Sockets.Socket.Close%2A>方法以关闭<xref:System.Net.Sockets.Socket>并释放与关联的资源<xref:System.Net.Sockets.Socket>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Net.Sockets.Socket" /> 选项的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <summary>返回指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项的值，表示为一个对象。</summary>
        <returns>一个对象，表示选项的值。 当将 <paramref name="optionName" /> 参数设置为 <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> 时，返回值为 <see cref="T:System.Net.Sockets.LingerOption" /> 类的一个实例。 当将 <paramref name="optionName" /> 设置为 <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> 或 <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> 时，返回值为 <see cref="T:System.Net.Sockets.MulticastOption" /> 类的一个实例。 当 <paramref name="optionName" /> 为其他任何值时，返回值为整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项将确定当前的行为<xref:System.Net.Sockets.Socket>。 使用此重载来获取<xref:System.Net.Sockets.SocketOptionName.Linger>， <xref:System.Net.Sockets.SocketOptionName.AddMembership>，并<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>选项。 有关<xref:System.Net.Sockets.SocketOptionName.Linger>选项，请使用<xref:System.Net.Sockets.Socket>为`optionLevel`参数。 有关<xref:System.Net.Sockets.SocketOptionName.AddMembership>并<xref:System.Net.Sockets.SocketOptionName.DropMembership>，使用<xref:System.Net.Sockets.SocketOptionLevel.IP>。 如果你想要设置任何上面列出的选项的值，请使用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例检索<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>超时值，并显示到控制台。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。  - 或 -  <paramref name="optionName" /> 设置为不支持的值 <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">
          <see cref="T:System.Byte" /> 类型的数组，用于接收选项设置。</param>
        <summary>返回指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置，表示为字节数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项将确定当前的行为<xref:System.Net.Sockets.Socket>。 此方法成功完成后，通过将指定的数组`optionValue`参数包含指定的值<xref:System.Net.Sockets.Socket>选项。  
  
 时的长度`optionValue`数组是比存储指定的值所需的字节数小<xref:System.Net.Sockets.Socket>选项，<xref:System.Net.Sockets.Socket.GetSocketOption%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。 对于任何由布尔值或整数表示的套接字使用此重载。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例检索<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>超时值，并显示到控制台。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。  \- 或 -  在 .NET Compact Framework 应用程序中，Windows CE 默认缓冲区的空间被设置为 32768 字节。 通过调用 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，可以更改每个套接字缓冲区的空间。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionLength">所需返回值的长度（以字节为单位）。</param>
        <summary>返回数组中指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项的值。</summary>
        <returns>
          <see cref="T:System.Byte" /> 类型的数组，它包含套接字选项的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength`参数设置返回的字节数组的最大大小。 如果该选项的值需要较少的字节，该数组将包含仅的字节数。 如果该选项的值需要更多字节<xref:System.Net.Sockets.Socket.GetSocketOption%2A>将引发<xref:System.Net.Sockets.SocketException>。 对于任何由布尔值或整数表示的套接字使用此重载。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例检索<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>超时值，并显示到控制台。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。  \- 或 -  在 .NET Compact Framework 应用程序中，Windows CE 默认缓冲区的空间被设置为 32768 字节。 通过调用 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，可以更改每个套接字缓冲区的空间。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的操作系统句柄。</summary>
        <value>一个 <see cref="T:System.IntPtr" />，它表示 <see cref="T:System.Net.Sockets.Socket" /> 的操作系统句柄。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为 <see cref="T:System.Net.Sockets.Socket" /> 设置低级别操作模式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">一个 <see cref="T:System.Int32" /> 值，该值指定要执行的操作的控制代码。</param>
        <param name="optionInValue">一个 <see cref="T:System.Byte" /> 数组，它包含操作需要的输入数据。</param>
        <param name="optionOutValue">一个 <see cref="T:System.Byte" /> 数组，它包含操作返回的输出数据。</param>
        <summary>使用数字控制代码，为 <see cref="T:System.Net.Sockets.Socket" /> 设置低级操作模式。</summary>
        <returns>
          <paramref name="optionOutValue" /> 参数中的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.IOControl%2A>方法提供对操作系统的低级别访问权限<xref:System.Net.Sockets.Socket>基础的当前实例<xref:System.Net.Sockets.Socket>类。 有关详细信息，请参阅 MSDN 库中的 WSAIoctl 文档。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例将 FIONREAD 和可用属性的结果进行比较。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">尝试不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 属性更改阻止模式。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要执行非托管的代码。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">一个 <see cref="T:System.Net.Sockets.IOControlCode" /> 值，它指定要执行的操作的控制代码。</param>
        <param name="optionInValue">
          <see cref="T:System.Byte" /> 类型的数组，包含操作要求的输入数据。</param>
        <param name="optionOutValue">
          <see cref="T:System.Byte" /> 类型的数组，包含由操作返回的输出数据。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 枚举指定控制代码，为 <see cref="T:System.Net.Sockets.IOControlCode" /> 设置低级操作模式。</summary>
        <returns>
          <paramref name="optionOutValue" /> 参数中的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法提供对操作系统的低级别访问权限<xref:System.Net.Sockets.Socket>基础的当前实例<xref:System.Net.Sockets.Socket>类。 有关详细信息，请参阅 MSDN 库中的 WSAIoctl 文档。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例将调用的结果进行比较<xref:System.Net.Sockets.Socket.IOControl%2A>与<xref:System.Net.Sockets.IOControlCode.DataToRead>和<xref:System.Net.Sockets.Socket.Available%2A>属性。  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">尝试不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 属性更改阻止模式。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要执行非托管的代码。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Net.Sockets.Socket" /> 是否绑定到特定本地端口。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 绑定到本地端口，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个套接字被视为绑定到本地端口，如果它显式绑定通过调用<xref:System.Net.Sockets.Socket.Bind%2A>方法，或通过调用成员，例如隐式绑定<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.SendTo%2A>，或<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，它使用临时的本地端口 （了可用端口大于1024，由操作系统选择。)服务器使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，以便客户端可能会连接到其绑定到的已知端口。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.IsBound%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 在尝试发送所有挂起数据时是否延迟关闭套接字。</summary>
        <value>一个 <see cref="T:System.Net.Sockets.LingerOption" />，它指定关闭套接字时如何逗留。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LingerState%2A>属性更改的方式<xref:System.Net.Sockets.Socket.Close%2A>方法的行为。 当集修改的条件下的连接可以重置通过 Winsock 时此属性。 连接重置仍会发生基于 IP 协议行为。  
  
 此属性控制的面向连接的连接是在调用后仍保持打开的时间长度<xref:System.Net.Sockets.Socket.Close%2A>仍然要发送数据时。  
  
 当调用方法以将数据发送到对等方时，此数据位于传出的网络缓冲区中。 此属性可以用于确保此数据发送到远程主机之前<xref:System.Net.Sockets.TcpClient.Close%2A>方法用于删除连接。  
  
 若要启用延迟，创建<xref:System.Net.Sockets.LingerOption>实例包含所需的值，并设置<xref:System.Net.Sockets.Socket.LingerState%2A>指向此实例的属性。  
  
 下表描述的行为<xref:System.Net.Sockets.Socket.Close%2A>的可能值的方法<xref:System.Net.Sockets.LingerOption.Enabled%2A>属性和<xref:System.Net.Sockets.LingerOption.LingerTime%2A>属性存储在<xref:System.Net.Sockets.Socket.LingerState%2A>属性。  
  
|LingerState.Enabled|LingerState.LingerTime|行为|  
|-------------------------|----------------------------|--------------|  
|`false` （禁用），默认值|不适用，超时值 （默认值）。|尝试发送挂起的数据，直到默认 IP 协议超时时间已到。|  
|`true` （已启用）|非零值超时|尝试发送挂起的数据，直到指定的超时时间已到，如果该尝试失败，然后 Winsock 重置连接。|  
|`true` （已启用）|零个超时时间。|将放弃所有挂起的数据。 对于面向连接的套接字 (例如 TCP)，Winsock 重置连接。|  
  
 IP 堆栈计算默认 IP 协议的超时期限为使用基于连接的往返行程时间。 在大多数情况下，计算堆栈的超时值是个应用程序定义的更多相关。 这是一个套接字的默认行为时<xref:System.Net.Sockets.Socket.LingerState%2A>未设置属性。  
  
 当<xref:System.Net.Sockets.LingerOption.LingerTime%2A>属性存储在<xref:System.Net.Sockets.Socket.LingerState%2A>属性设置为大于默认 IP 协议超时时间，则默认 IP 协议超时时间仍将应用，并替代。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.LingerState%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">挂起连接队列的最大长度。</param>
        <summary>将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> 会导致一个面向连接的<xref:System.Net.Sockets.Socket>来侦听传入的连接尝试。 `backlog`参数指定可排队等待接受的传入连接的数量。 若要确定最大可以指定的连接数，请检索<xref:System.Net.Sockets.SocketOptionName.MaxConnections>值。 <xref:System.Net.Sockets.Socket.Listen%2A> 不会阻止。  
  
 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。 使用<xref:System.Net.Sockets.Socket.Accept%2A>或<xref:System.Net.Sockets.Socket.BeginAccept%2A>以接受来自队列的连接。  
  
> [!NOTE]
>  必须调用<xref:System.Net.Sockets.Socket.Bind%2A>方法之前调用<xref:System.Net.Sockets.Socket.Listen%2A>，或<xref:System.Net.Sockets.Socket.Listen%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  积压工作参数被限制为不同的值，具体取决于操作系统。 可以指定较高的值，但在积压工作将受到限制的基于在操作系统上。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.Sockets.Socket>来侦听传入连接。  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取本地终结点。</summary>
        <value>
          <see cref="T:System.Net.EndPoint" /> 当前用以进行通信的 <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性获取<xref:System.Net.EndPoint>，其中包含到其中的本地 IP 地址和端口号在<xref:System.Net.Sockets.Socket>绑定。 您必须将此对象转换<xref:System.Net.EndPoint>到<xref:System.Net.IPEndPoint>之前检索的任何信息。 然后，可以调用<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>方法来检索本地<xref:System.Net.IPAddress>，和<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>方法来检索本地端口号。  
  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>进行调用后，属性通常设置<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果你允许系统将套接字的本地 IP 地址和端口号分配<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性将设置后第一次 I/O 操作。 对于面向连接的协议，第一次 I/O 操作将是调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 对于无连接协议，第一次 I/O 操作将是任何发送或接收调用。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例检索并显示本地和远程终结点。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定传出的多路广播数据包是否传递到发送应用程序。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 接收传出的多路广播数据包，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多播是在 Internet 上的多对多通信的可缩放方法。 处理订阅的多播地址;然后，可由其他每个订阅的多播地址的过程接收已订阅进程发送任何数据包。  
  
 传输控制协议 (TCP) 套接字上设置此属性不会影响。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.MulticastLoopback%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Boolean" /> 值，该值指定流 <see cref="T:System.Net.Sockets.Socket" /> 是否正在使用 Nagle 算法。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 使用 Nagle 算法，则为 <see langword="false" />；否则为 <see langword="true" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagle 算法设计为套接字缓冲小数据包，然后组合并在某些情况下一个数据包中发送，从而减少网络流量。 TCP 数据包包含 40 个字节的标头以及发送的数据。 与 TCP 发送的数据的小数据包，从而从 TCP 标头的开销会变为网络流量的重要组成部分。在负载较重的网络上导致这种开销的拥塞可能会导致丢失的数据报和重传现象，以及由阻塞导致过多的传播时间。 Nagle 算法禁止发送的新 TCP segmentswhen 新传出数据到达从用户中，如果在连接上的任何处数据仍未确认。  
  
 大多数网络应用程序应使用 Nagle 算法。  
  
 用户数据报协议 (UDP) 套接字上设置此属性不会影响。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.NoDelay%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问 <see cref="T:System.Net.Sockets.Socket" /> 时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示基础操作系统和网络适配器是否支持 Internet 协议第 4 版 (IPv4)。</summary>
        <value>如果操作系统和网络适配器支持 IPv4 协议，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能会支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示基础操作系统和网络适配器是否支持 Internet 协议第 6 版 (IPv6)。</summary>
        <value>如果操作系统和网络适配器支持 IPv6 协议，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能会支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">等待响应的时间（以微秒为单位）。</param>
        <param name="mode">
          <see cref="T:System.Net.Sockets.SelectMode" /> 值之一。</param>
        <summary>确定 <see cref="T:System.Net.Sockets.Socket" /> 的状态。</summary>
        <returns>基于 <paramref name="mode" /> 参数中传递的轮询模式值的 <see cref="T:System.Net.Sockets.Socket" /> 的状态。  
  
 <list type="table"><listheader><term> 模式  </term><description> 返回值  </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" /> 如果已调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 并且连接正在挂起；  - 或 -  如果数据可供读取，则为 <see langword="true" />；  - 或 -  如果已关闭、重置或终止连接，则为 <see langword="true" />；  否则，返回 <see langword="false" />。  </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description>，如果正在处理 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> 且已成功连接，则为 <see langword="true" />；  - 或 -  如果已发送数据，则为 <see langword="true" />；  否则，返回 <see langword="false" />。  </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description> 如果正在处理未阻止的 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />并且连接已失败，则为 <see langword="true" />；  - 或 -  如果未设置 <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> 并且带外数据可用，则为 <see langword="true" />；  否则，返回 <see langword="false" />。  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Poll%2A>方法将检查的状态<xref:System.Net.Sockets.Socket>。 指定<xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType>有关`selectMode`参数，以确定如果<xref:System.Net.Sockets.Socket>是可读。 指定<xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType>来确定如果<xref:System.Net.Sockets.Socket>是可写。 使用<xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType>检测错误条件。 <xref:System.Net.Sockets.Socket.Poll%2A> 将阻止执行，直到指定的时间段，以测量`microseconds`，结束。 设置`microSeconds`参数为负的整数，如果你想要无限期地等待响应。 如果你想要检查的多个套接字的状态，您可能更倾向于使用<xref:System.Net.Sockets.Socket.Select%2A>方法。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  此方法无法检测到某些类型的连接问题，例如断开的网络电缆，或远程主机意外关闭。 您必须尝试发送或接收数据，以检测这些类型的错误。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例创建一个套接字，连接到服务器，并使用<xref:System.Net.Sockets.Socket.Poll%2A>检查套接字的状态。  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="mode" /> 参数不是一个 <see cref="T:System.Net.Sockets.SelectMode" /> 值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参阅下面的备注。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的协议类型。</summary>
        <value>
          <see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A>时设置属性<xref:System.Net.Sockets.Socket>创建，并指定使用的协议<xref:System.Net.Sockets.Socket>。  
  
   
  
## Examples  
 下面的代码示例显示<xref:System.Net.Sockets.AddressFamily>， <xref:System.Net.Sockets.SocketType>，和<xref:System.Net.Sockets.ProtocolType>到控制台。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收来自绑定的 <see cref="T:System.Net.Sockets.Socket" /> 的数据。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <summary>从绑定的 <see cref="T:System.Net.Sockets.Socket" /> 套接字接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入缓冲区参数并返回已成功读取的字节数。 您可以调用<xref:System.Net.Sockets.Socket.Receive%2A>从面向连接的和无连接套接字。  
  
 此重载仅要求您提供接收缓冲区。 缓冲区偏移量的默认值为 0，默认大小为缓冲区参数的长度并<xref:System.Net.Sockets.SocketFlags>默认值为<xref:System.Net.Sockets.SocketFlags.None>。  
  
 如果使用的是面向连接的协议，必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立的远程主机连接，或<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接之前调用<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将只读取数据中建立的远程主机发送过来<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用的是无连接协议，还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有任何数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将阻塞，直到数据不可用，除非使用设置的超时值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果超过超时值，<xref:System.Net.Sockets.Socket.Receive%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 如果您是在非阻止模式下，并且没有在可用的数据中的协议堆栈缓冲区<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定数据是否可供读取。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>，则<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取数量是可用，直到达到缓冲区的大小的数据。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到了方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果您使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>会从在指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffer`参数，`buffer`进行填充与该消息的第一部分，过多的数据都将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例接收上连接的数据<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 类型的一个 <see cref="T:System.Byte" /> 列表，包含接收的数据。</param>
        <summary>从绑定的 <see cref="T:System.Net.Sockets.Socket" /> 接收数据，将数据存入接收缓冲区列表中。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将数据读入的缓冲区参数并返回已成功读取的字节数。 您可以调用从面向连接的和无连接套接字。  
  
 此重载要求您提供一个或多个接收缓冲区。  
  
 如果使用的是面向连接的协议，必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立的远程主机连接，或<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接之前调用<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将只读取来自中建立的远程主机连接的数据<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用的是无连接协议，还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有任何数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将阻塞，直到数据不可用，除非使用设置的超时值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果超过超时值，<xref:System.Net.Sockets.Socket.Receive%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 如果您是在非阻止模式下，并且没有在可用的数据中的协议堆栈缓冲区<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定数据是否可供读取。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>，则<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取数量是可用，直到达到缓冲区的大小的数据。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到了方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果您使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>会从在指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffers`参数，`buffers`进行填充与该消息的第一部分，过多的数据都将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
 **请注意**此成员时应用程序中启用网络跟踪输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入缓冲区参数并返回已成功读取的字节数。 您可以调用<xref:System.Net.Sockets.Socket.Receive%2A>从面向连接的和无连接套接字。  
  
 此重载仅要求您提供接收缓冲区和所需<xref:System.Net.Sockets.SocketFlags>。 缓冲区偏移量的默认值为 0，并且大小默认为字节参数的长度。  
  
 如果使用的是面向连接的协议，必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立的远程主机连接，或<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接之前调用<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将只读取数据中建立的远程主机发送过来<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用的是无连接协议，还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有任何数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将阻塞，直到有可用数据。 如果您处于非阻止模式，并且没有可用协议堆栈缓冲区中的数据<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定数据是否可供读取。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试您的接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>，则<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取的数据，可最大的缓冲区的大小。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到了方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果您使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>会从在指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffer`参数，`buffer`进行填充与该消息的第一部分，过多的数据都将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例指定数据缓冲区并<xref:System.Net.Sockets.SocketFlags>上连接接收数据的<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 类型的一个 <see cref="T:System.Byte" /> 列表，包含接收的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区列表中。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将数据读入`buffers`参数，并返回已成功读取的字节数。 您可以调用从面向连接的和无连接套接字。  
  
 此重载要求您提供一个或多个接收缓冲区。 <xref:System.Net.Sockets.SocketFlags>默认值为<xref:System.Net.Sockets.SocketFlags.None>。  
  
 如果使用的是面向连接的协议，必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立的远程主机连接，或<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接之前调用<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将只读取来自中建立的远程主机连接的数据<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用的是无连接协议，还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有任何数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将阻塞，直到数据不可用，除非使用设置的超时值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果超过超时值，<xref:System.Net.Sockets.Socket.Receive%2A>调用，则会引发<xref:System.Net.Sockets.SocketException>。 如果您是在非阻止模式下，并且没有在可用的数据中的协议堆栈缓冲区<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定数据是否可供读取。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>，则<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取数量是可用，直到达到缓冲区的大小的数据。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到了方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果您使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>会从在指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffers`参数，`buffers`进行填充与该消息的第一部分，过多的数据都将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何在连接上接收数据<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 为 <see langword="null" />。  - 或 -  <paramref name="buffers" />.Count 是零。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收指定字节数的数据，并将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入`buffer`参数，并返回已成功读取的字节数。 您可以调用<xref:System.Net.Sockets.Socket.Receive%2A>从面向连接的和无连接套接字。  
  
 此重载仅要求您提供接收缓冲区中，你想要接收的字节数和所需的数量<xref:System.Net.Sockets.SocketFlags>。  
  
 如果使用的是面向连接的协议，必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立的远程主机连接，或<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接之前调用<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将只读取数据中建立的远程主机发送过来<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用的是无连接协议，还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有任何数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将阻塞，直到数据不可用，除非使用设置的超时值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果超过超时值，<xref:System.Net.Sockets.Socket.Receive%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 如果您是在非阻止模式下，并且没有在可用的数据中的协议堆栈缓冲区<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定数据是否可供读取。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试您的接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>，则<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取的数据是可用，直到达到指定的字节数`size`参数。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到了方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果您使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>会从在指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffer`参数，`buffer`进行填充与该消息的第一部分，过多的数据都将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 以下接收到找到的数据`buffer`，并指定<xref:System.Net.Sockets.SocketFlags.None>为<xref:System.Net.Sockets.SocketFlags>。  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> 超出了 <paramref name="buffer" /> 的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 类型的一个 <see cref="T:System.Byte" /> 列表，包含接收的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区列表中。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将数据读入`buffers`参数，并返回已成功读取的字节数。 您可以调用从面向连接的和无连接套接字。  
  
 此重载要求您提供一个或多个接收缓冲区。 <xref:System.Net.Sockets.SocketFlags>默认值为<xref:System.Net.Sockets.SocketFlags.None>。  
  
 如果使用的是面向连接的协议，必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立的远程主机连接，或<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接之前调用<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将只读取来自中建立的远程主机连接的数据<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用的是无连接协议，还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有任何数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将阻塞，直到数据不可用，除非使用设置的超时值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果超过超时值，<xref:System.Net.Sockets.Socket.Receive%2A>调用，则会引发<xref:System.Net.Sockets.SocketException>。 如果您是在非阻止模式下，并且没有在可用的数据中的协议堆栈缓冲区<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定数据是否可供读取。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>，则<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取数量是可用，直到达到缓冲区的大小的数据。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到了方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果您使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>会从在指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffers`参数，`buffers`进行填充与该消息的第一部分，过多的数据都将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 为 <see langword="null" />。  - 或 -  <paramref name="buffers" />.Count 是零。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="offset">
          <c>buffer</c> 中存储所接收数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收指定的字节数，存入接收缓冲区的指定偏移量位置。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入缓冲区参数并返回已成功读取的字节数。 您可以调用<xref:System.Net.Sockets.Socket.Receive%2A>从面向连接的和无连接套接字。  
  
 如果使用的是面向连接的协议，必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立的远程主机连接，或<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接之前调用<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将只读取数据中建立的远程主机发送过来<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用的是无连接协议，还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有任何数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将阻塞，直到数据不可用，除非使用设置的超时值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果超过超时值，<xref:System.Net.Sockets.Socket.Receive%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 如果您是在非阻止模式下，并且没有在可用的数据中的协议堆栈缓冲区<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 尝试访问套接字时出错。 请参阅下面的备注。 可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定数据是否可供读取。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>，则<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取所有可用的最多指定大小参数的字节数的数量的数据。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到了方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果您使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>会从在指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffer`参数，`buffer`进行填充与该消息的第一部分，过多的数据都将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例上连接接收数据之前指定数据缓冲区、 偏移、 大小和套接字标志<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  - 或 -  访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset">
          <c>buffer</c> 参数中用于存储所接收数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入缓冲区参数并返回已成功读取的字节数。 您可以调用<xref:System.Net.Sockets.Socket.Receive%2A>从面向连接的和无连接套接字。  
  
 如果使用的是面向连接的协议，必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立的远程主机连接，或<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接之前调用<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将只读取数据中建立的远程主机发送过来<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用的是无连接协议，还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有任何数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将阻塞，直到数据不可用，除非使用设置的超时值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果超过超时值，<xref:System.Net.Sockets.Socket.Receive%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 如果您是在非阻止模式下，并且没有在可用的数据中的协议堆栈缓冲区<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 尝试访问套接字时出错。 请参阅下面的备注。 可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定数据是否可供读取。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>，则<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取所有可用的最多指定大小参数的字节数的数量的数据。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到了方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果您使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>会从在指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffer`参数，`buffer`进行填充与该消息的第一部分，过多的数据都将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  - 或 -  访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个异步请求以便从连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象中接收数据。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法使用在套接字或绑定无连接的套接字连接，用于读取传入的数据。 必须知道套接字的本地地址。  
  
 对于绑定无连接的套接字，此函数将限制从其接受已收到的消息的地址。 该函数仅返回从连接中指定的远程地址的消息。 从其他地址的消息将以无提示方式被丢弃。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>属性上的`e`参数提供了关于读取请求的其他信息的窗口套接字服务提供程序。 有关如何使用此参数的详细信息，请参阅<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>成功调用此方法所需的对象：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>设置  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>设置  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可能会设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>属性设置为在调用之前所需的任何用户状态对象<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法，以便可在回调方法中检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小类来保存作为成员的其他所需的状态信息。  
  
 对于字节流样式套接字，传入的数据被放入缓冲区中直到填充缓冲区，连接将关闭，或用完内部缓冲的数据。  
  
 对于面向消息的套接字传入的消息会放入缓冲区中直到与关联的缓冲区的总大小`e`参数。 如果大于缓冲区消息，消息的第一个部分填充缓冲区。  
  
 对于面向连接的套接字，<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法可以指示依赖于套接字是字节流或面向消息的两种方式之一中的虚拟线路正常终止。 对于字节流，已读零字节指示正常结束，并且将不会读取任何字节。 对于面向消息的套接字，其中零字节的消息通常是允许的<xref:System.Net.Sockets.SocketException>与<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>设置为本机 Winsock WSAEDISCON 错误代码 (10101) 用于指示正常结束。 在任何情况下，<xref:System.Net.Sockets.SocketException>与<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>错误代码 (10054) 设置为本机 Winsock WSAECONNRESET 指示硬性关闭已发生。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">参数无效。 <paramref name="e" /> 参数的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 或 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性必须引用有效的缓冲区。 可以设置这两个属性中的某一个，但不能同时设置这两个属性。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，它指定 <see cref="T:System.Net.Sockets.Socket" /> 接收缓冲区的大小。</summary>
        <value>
          <see cref="T:System.Int32" />，它包含接收缓冲区的大小（以字节为单位）。 默认值为 8192。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 更大的缓冲区大小可能会减少了空确认 （不包含数据部分的 TCP 数据包），但也可能会延迟连接问题的识别。 请考虑增加缓冲区大小，如果传输大型文件，或者使用的高带宽、 高延迟连接 （如机顶盒宽带提供商。）  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 0。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收数据报并存储源终结点。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>将数据报接收到数据缓冲区并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将数据读入`buffer`参数，返回已成功读取的字节数和捕获从其发送数据的远程主机终结点。 此方法很有用，如果你想要从未知的主机或多个主机接收无连接的数据报。  
  
 此重载仅要求您提供一个接收`buffer`，和一个<xref:System.Net.EndPoint>表示远程主机。 缓冲区偏移量的默认值为 0。 大小默认值的长度`buffer`参数和`socketFlags`默认值为<xref:System.Net.Sockets.SocketFlags.None>。  
  
> [!NOTE]
>  然后再调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，则必须显式将绑定<xref:System.Net.Sockets.Socket>到本地终结点使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果不，这样做<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 使用无连接协议时，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取第一个排队数据报接收到的本地网络缓冲区。 如果你收到的数据报大于的大小`buffer`，则<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将填充`buffer`太多的是，且引发的消息与<xref:System.Net.Sockets.SocketException>。 如果使用的不可靠的协议，则多余的数据将丢失。 如果您使用的是可靠的协议，多余的数据将保留由服务提供商可以通过调用检索它<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法使用一个足够大的缓冲区。  
  
 如果没有任何数据可供读取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将阻塞，直到有可用数据。 如果您是在非阻止模式下，并且没有在可用的数据中的协议堆栈缓冲区<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定数据是否可供读取。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 尽管<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>适用于无连接协议，你可以使用面向连接的协议也。 如果你选择这样做，则必须首先可以建立远程主机连接通过调用<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受传入的远程主机连接，通过调用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果没有建立或接受连接，然后调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法时，将获取<xref:System.Net.Sockets.SocketException>。 您还可以建立默认远程主机之前调用的无连接协议<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将忽略`remoteEP`参数和仅接收来自连接的数据或默认远程主机。  
  
 使用面向连接的套接字<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取的数据，可最大的大小`buffer`。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到了方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并返回零字节。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必须与匹配<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将数据报接收到数据缓冲区并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将数据读入`buffer`参数，返回已成功读取的字节数和捕获从其发送数据的远程主机终结点。 此方法很有用，如果你想要从未知的主机或多个主机接收无连接的数据报。  
  
 此重载仅要求您提供接收缓冲区，所需<xref:System.Net.Sockets.SocketFlags>，和一个<xref:System.Net.EndPoint>表示远程主机。 偏移量默认值为 0 并默认大小为缓冲区参数的长度。  
  
> [!NOTE]
>  然后再调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，则必须显式将绑定<xref:System.Net.Sockets.Socket>到本地终结点使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果不，这样做<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 使用无连接协议时，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取第一个排队数据报接收到的本地网络缓冲区。 如果你收到的数据报大于的大小`buffer`，则<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将填充`buffer`太多的是，且引发的消息与<xref:System.Net.Sockets.SocketException>。 如果使用的不可靠的协议，则多余的数据将丢失。 如果您使用的是可靠的协议，多余的数据将保留由服务提供商可以通过调用检索它<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法使用一个足够大的缓冲区。  
  
 如果没有任何数据可供读取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将阻塞，直到有可用数据。 如果您是在非阻止模式下，并且没有在可用的数据中的协议堆栈缓冲区<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定数据是否可供读取。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 尽管<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>适用于无连接协议，你可以使用面向连接的协议也。 如果你选择这样做，则必须首先可以建立远程主机连接通过调用<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受传入的远程主机连接，通过调用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果没有建立或接受连接，然后调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法时，将获取<xref:System.Net.Sockets.SocketException>。 您还可以建立默认远程主机之前调用的无连接协议<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将忽略`remoteEP`参数和仅接收来自连接的数据或默认远程主机。  
  
 使用面向连接的套接字<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取的数据，可最大的大小`buffer`。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到了方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并返回零字节。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必须与匹配<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。 <xref:System.Net.Sockets.SocketFlags> 传递给<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定的字节数接收到数据缓冲区并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将数据读入`buffer`参数，返回已成功读取的字节数和捕获从其发送数据的远程主机终结点。 此方法很有用，如果你想要从未知的主机或多个主机接收无连接的数据报。  
  
 此重载仅要求您提供接收缓冲区中，你想要接收所需的字节数<xref:System.Net.Sockets.SocketFlags>，和一个<xref:System.Net.EndPoint>表示远程主机。 缓冲区偏移量的默认值为 0。  
  
 使用无连接协议时，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取第一个排队数据报接收到的本地网络缓冲区。 如果你收到的数据报大于的大小`buffer`，则<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将填充`buffer`太多的是，且引发的消息与<xref:System.Net.Sockets.SocketException>。 如果使用的不可靠的协议，则多余的数据将丢失。 如果您使用的是可靠的协议，多余的数据将保留由服务提供商可以通过调用检索它<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法使用一个足够大的缓冲区。  
  
 如果没有任何数据可供读取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将阻塞，直到有可用数据。 如果您是在非阻止模式下，并且没有在可用的数据中的协议堆栈缓冲区<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定数据是否可供读取。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 尽管<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>适用于无连接协议，你可以使用面向连接的协议也。 如果你选择这样做，则必须首先可以建立远程主机连接通过调用<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受传入的远程主机连接，通过调用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果没有建立或接受连接，然后调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法时，将获取<xref:System.Net.Sockets.SocketException>。 您还可以建立默认远程主机之前调用的无连接协议<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将忽略`remoteEP`参数和仅接收来自连接的数据或默认远程主机。  
  
 使用面向连接的套接字<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取的数据，可最多指定的字节数`size`参数。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到了方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并返回零字节。  
  
> [!NOTE]
>  然后再调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，则必须显式将绑定<xref:System.Net.Sockets.Socket>到本地终结点使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果不，这样做<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必须与匹配<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。 缓冲区大小，并<xref:System.Net.Sockets.SocketFlags>传递给<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  - 或 -  访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="offset">
          <c>buffer</c> 参数中用于存储所接收数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定的数据字节数接收到数据缓冲区的指定位置，并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将数据读入`buffer`参数，返回已成功读取的字节数和捕获从其发送数据的远程主机终结点。 此方法很有用，如果你想要从未知的主机或多个主机接收无连接的数据报。  
  
 使用无连接协议时，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取第一个排队数据报接收到的本地网络缓冲区。 如果你收到的数据报大于的大小`buffer`，则<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将填充`buffer`太多的是，且引发的消息与<xref:System.Net.Sockets.SocketException>。 如果使用的不可靠的协议，则多余的数据将丢失。 如果您使用的是可靠的协议，多余的数据将保留由服务提供商可以通过调用检索它<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法使用一个足够大的缓冲区。  
  
 如果没有任何数据可供读取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将阻塞，直到有可用数据。 如果您是在非阻止模式下，并且没有在可用的数据中的协议堆栈缓冲区<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定数据是否可供读取。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 尽管<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>适用于无连接协议，你可以使用面向连接的协议也。 如果你选择这样做，则必须首先可以建立远程主机连接通过调用<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受传入的远程主机连接，通过调用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果没有建立或接受连接，然后调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法时，将获取<xref:System.Net.Sockets.SocketException>。 您还可以建立默认远程主机之前调用的无连接协议<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将忽略`remoteEP`参数和仅接收来自连接的数据或默认远程主机。  
  
 使用面向连接的套接字<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取的数据，可最多指定的字节量`size`参数。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到了方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并返回零字节。  
  
> [!NOTE]
>  然后再调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，则必须显式将绑定<xref:System.Net.Sockets.Socket>到本地终结点使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果不，这样做<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必须与匹配<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。 偏移量、 缓冲区大小，并<xref:System.Net.Sockets.SocketFlags>传递给<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去偏移量参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  - 或 -  尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始从指定网络设备中异步接收数据。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>方法主要用于在无连接的套接字上接收数据。 必须知道套接字的本地地址。  
  
 调用方必须设置<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>属性设置为<xref:System.Net.IPEndPoint>，数据将从其接收的远程主机。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>属性上的`e`参数提供了关于读取请求的其他信息的窗口套接字服务提供程序。 有关如何使用此参数的详细信息，请参阅<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>成功调用此方法所需的对象：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可能会设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>属性设置为在调用之前所需的任何用户状态对象<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>方法，以便可在回调方法中检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小类来保存作为成员的其他所需的状态信息。  
  
 对于面向消息的套接字，传入的消息会放入缓冲区中直到缓冲区的总大小。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>属性确定在缓冲区中数据的放置位置和数据量。  
  
 对于字节流样式套接字，传入的数据被放入缓冲区中直到填充缓冲区，连接将关闭，或用完内部缓冲的数据。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>属性确定在缓冲区中数据的放置位置和数据量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为 null。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="offset">
          <c>buffer</c> 参数中用于存储所接收数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <param name="ipPacketInformation">保存地址和接口信息的 <see cref="T:System.Net.Sockets.IPPacketInformation" />。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定字节数的数据接收到指定的数据缓冲区位置，并存储终结点和数据包信息。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法将数据读入`buffer`参数，返回已成功读取的字节数和捕获从其发送数据，以及有关接收到的数据包的信息的远程主机终结点。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法主要用于接收无连接的套接字上的消息数据。 必须知道套接字的本地地址。 此方法仅可用于数据报和原始套接字。 必须使用套接字类型设置为初始化套接字<xref:System.Net.Sockets.SocketType.Dgram>或<xref:System.Net.Sockets.SocketType.Raw>之前调用此方法。 这可以使用构造套接字时<xref:System.Net.Sockets.Socket.%23ctor%2A>。  
  
 对于面向消息的套接字，传入的消息放入`buffer`最大总大小中指定的参数`size`参数。 `offset`参数确定在何处`buffer`放置数据。 实际的数据量放入`buffer`返回的<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法会自动方法设置<xref:System.Net.Sockets.SocketOptionName.PacketInformation>套接字选项`true`第一次调用时为给定<xref:System.Net.Sockets.Socket>。 但是，返回<xref:System.Net.Sockets.IPPacketInformation>对象只能是有效的数据包到达本地计算机后已设置的套接字选项。 如果套接字在绑定到的本地终结点发送之间的数据包 (显式<xref:System.Net.Sockets.Socket.Bind%2A>方法或由其中一个隐式<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.ConnectAsync%2A>， <xref:System.Net.Sockets.Socket.SendTo%2A>，或<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法) 和其第一次调用<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法中，调用<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法将返回无效<xref:System.Net.Sockets.IPPacketInformation>这些数据包的对象。  
  
 若要确保所有<xref:System.Net.Sockets.IPPacketInformation>对象都有效，应用程序应设置<xref:System.Net.Sockets.SocketOptionName.PacketInformation>套接字选项`true`绑定到本地终结点使用之前<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>方法。  
  
 应用程序可以检查`ipPacketInformation`参数，如果它需要知道是否使用单播、 多播或广播地址发送数据报。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必须与匹配<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  \- 或-  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去偏移量参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  - 或 -  .NET Framework 运行在 AMD 64 位处理器上。  - 或 -  尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">操作系统为 Windows 2000 或更低版本，而此方法需要在 Windows XP 中使用。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始使用指定的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> 将指定字节数的数据异步接收到数据缓冲区的指定位置，并存储终结点和数据包信息。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法主要用于接收无连接的套接字上的消息数据。 必须知道套接字的本地地址。 此方法仅可用于数据报和原始套接字。 必须使用套接字类型设置为初始化套接字<xref:System.Net.Sockets.SocketType.Dgram>或<xref:System.Net.Sockets.SocketType.Raw>之前调用此方法。 这可以使用构造套接字时<xref:System.Net.Sockets.Socket.%23ctor%2A>。  
  
 调用方必须设置<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>属性设置为<xref:System.Net.IPEndPoint>，数据将从其接收的远程主机。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>成功调用此方法所需的对象：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可能会设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>属性设置为在调用之前所需的任何用户状态对象<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法，以便可在回调方法中检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小类来保存作为成员的其他所需的状态信息。  
  
 对于面向消息的套接字，传入的消息会放入缓冲区中直到缓冲区的总大小。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>属性确定在缓冲区中数据的放置位置和数据量。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法将自动设置<xref:System.Net.Sockets.SocketOptionName.PacketInformation>套接字选项`true`第一次调用时为给定<xref:System.Net.Sockets.Socket>。 但是，<xref:System.Net.Sockets.IPPacketInformation>对象只能是有效的数据包到达本地计算机后已设置的套接字选项。 如果套接字时套接字绑定到的本地终结点发送之间的数据包 (显式<xref:System.Net.Sockets.Socket.Bind%2A>方法或由其中一个隐式<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.ConnectAsync%2A>， <xref:System.Net.Sockets.Socket.SendTo%2A>，或<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法) 和首次调用<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法，调用<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法将导致无效<xref:System.Net.Sockets.IPPacketInformation>这些数据包的对象。  
  
 若要确保所有<xref:System.Net.Sockets.IPPacketInformation>对象都有效，应用程序应设置<xref:System.Net.Sockets.SocketOptionName.PacketInformation>套接字选项`true`绑定到本地终结点使用之前<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>方法。  
  
 应用程序可以检查生成<xref:System.Net.Sockets.IPPacketInformation>对象它是否需要知道是否使用单播、 多播或广播地址发送数据报。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为 null。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定之后同步 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 调用将超时的时间长度。</summary>
        <value>超时值（以毫秒为单位）。 默认值为 0，指示超时期限无限大。 指定 -1 还会指示超时期限无限大。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此选项适用于同步<xref:System.Net.Sockets.Socket.Receive%2A>仅调用。 如果超出超时期限，则<xref:System.Net.Sockets.Socket.Receive%2A>方法将引发<xref:System.Net.Sockets.SocketException>。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 1。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取远程终结点。</summary>
        <value>当前和 <see cref="T:System.Net.EndPoint" /> 通信的 <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>属性获取<xref:System.Net.EndPoint>，其中包含到的远程 IP 地址和端口号<xref:System.Net.Sockets.Socket>连接。 如果使用的是无连接协议<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>包含的默认远程 IP 地址和端口号与<xref:System.Net.Sockets.Socket>将通信。 您必须将此对象转换<xref:System.Net.EndPoint>到<xref:System.Net.IPEndPoint>之前检索的任何信息。 然后，可以调用<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>方法来检索远程<xref:System.Net.IPAddress>，和<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>方法来检索远程端口号。  
  
 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>会在调用后设置<xref:System.Net.Sockets.Socket.Accept%2A>或<xref:System.Net.Sockets.Socket.Connect%2A>。 如果你尝试访问更早版本，此属性<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例检索并显示本地和远程终结点。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead">用于检查可读性的 <see cref="T:System.Net.Sockets.Socket" /> 实例的 <see cref="T:System.Collections.IList" />。</param>
        <param name="checkWrite">用于检查可写性的 <see cref="T:System.Net.Sockets.Socket" /> 实例的 <see cref="T:System.Collections.IList" />。</param>
        <param name="checkError">用于检查错误的 <see cref="T:System.Net.Sockets.Socket" /> 实例的 <see cref="T:System.Collections.IList" />。</param>
        <param name="microSeconds">超时值（以微秒为单位）。 值 -1 指示无限超时。</param>
        <summary>确定一个或多个套接字的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> 是确定的一个或多个状态的静态方法<xref:System.Net.Sockets.Socket>实例。 必须将放置到一个或多个套接字<xref:System.Collections.IList>可以使用之前<xref:System.Net.Sockets.Socket.Select%2A>方法。 通过调用检查可读性<xref:System.Net.Sockets.Socket.Select%2A>与<xref:System.Collections.IList>作为`checkRead`参数。 若要检查的可写性套接字，使用`checkWrite`参数。 检测错误条件，请使用`checkError`。 在调用<xref:System.Net.Sockets.Socket.Select%2A>，则<xref:System.Collections.IList>会填充使用满足条件这些套接字。  
  
 如果您在侦听状态，可读性意味着调用<xref:System.Net.Sockets.Socket.Accept%2A>而不会阻止将会成功。 如果已接受连接，可读性意味着数据可供读取。 在这些情况下，所有接收操作而不会阻止将会成功。 可读性也可指示是否在远程<xref:System.Net.Sockets.Socket>已关闭连接; 在这种情况下调用<xref:System.Net.Sockets.Socket.Receive%2A>会立即返回，返回零字节。  
  
 <xref:System.Net.Sockets.Socket.Select%2A> 返回时至少一个感兴趣的套接字 (在套接字`checkRead`， `checkWrite`，并`checkError`列出了) 满足指定的条件时，或`microSeconds`超过参数，具体取决于第一个。 设置`microSeconds`为-1 指定无限期超时。  
  
 如果进行到非阻止调用<xref:System.Net.Sockets.Socket.Connect%2A>，可写性表示您已成功连接。 如果已建立的连接，可写性意味着所有发送操作都将成功而不会阻塞。  
  
 如果您已到非阻止调用<xref:System.Net.Sockets.Socket.Connect%2A>，则`checkerror`参数标识未成功连接的套接字。  
  
> [!NOTE]
>  使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，如果只想要确定的单个状态<xref:System.Net.Sockets.Socket>。  
  
> [!NOTE]
>  此方法无法检测到某些类型的连接问题，例如断开的网络电缆，或远程主机意外关闭。 您必须尝试发送或接收数据，以检测这些类型的错误。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.Sockets.Socket.Select%2A>来确定哪些侦听套接字已连接请求。  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="checkRead" /> 参数为 <see langword="null" /> 或为空。  - 并且 -  <paramref name="checkWrite" /> 参数为 <see langword="null" /> 或为空  - 并且 -  <paramref name="checkError" /> 参数为 <see langword="null" /> 或为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <summary>将数据发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式将数据发送到远程主机中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法，并返回已成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的和无连接协议。  
  
 此重载需要包含想要发送的数据的缓冲区。 <xref:System.Net.Sockets.SocketFlags>值将默认为 0，缓冲区偏移量的默认值为 0，并要将默认值发送到缓冲区的大小的字节数。  
  
 如果您使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果使用的是面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机连接，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果使用无连接协议，并且打算将数据发送到多个不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您将需要致电<xref:System.Net.Sockets.Socket.Connect%2A>每次调用前<xref:System.Net.Sockets.Socket.Send%2A>。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 您还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>到另一个调用，从而<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.Send%2A>会阻塞，直到所有缓冲区中的字节都将发送，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超过超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在阻止模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能成功完成，即使它发送的字节数小于缓冲区中。 它是应用程序负责跟踪发送的字节数并重试操作，直到应用程序将字节发送缓冲区中。 此外，还有您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  发送的成功完成并不表示数据已成功传递。 如果任何缓冲区空间以容纳要传输的数据在传输系统中不不可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何在连接上的发送数据<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 类型的 <see cref="T:System.Byte" /> 的列表，它包含要发送的数据。</param>
        <summary>将列表中的一组缓冲区发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的和无连接协议。  
  
 此重载需要至少一个缓冲区，其中包含你想要发送的数据。  
  
 如果您使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果使用的是面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机连接，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果使用无连接协议，并且打算将数据发送到多个不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您将需要致电<xref:System.Net.Sockets.Socket.Connect%2A>每次调用前<xref:System.Net.Sockets.Socket.Send%2A>。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 您还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>到另一个调用，从而<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.Send%2A>会阻塞，直到所有缓冲区中的字节都将发送，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超过超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在阻止模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能成功完成，即使它发送的字节数小于缓冲区中。 它是应用程序负责跟踪发送的字节数并重试操作，直到应用程序将字节发送缓冲区中。 此外，还有您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  发送的成功完成并不表示数据已成功传递。 如果任何缓冲区空间以容纳要传输的数据在传输系统中不不可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" /> 将数据发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式将数据发送到远程主机中建立<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法，并返回已成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A>方法可用于面向连接的和无连接协议。  
  
 此重载需要包含想要发送的数据的缓冲区和的按位组合<xref:System.Net.Sockets.SocketFlags>。 缓冲区偏移量的默认值为 0，并要将默认值发送到缓冲区的大小的字节数。 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数值，则不会将路由发送的数据。  
  
 如果您使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果使用的是面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机连接，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果使用无连接协议，并且打算将数据发送到多个不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您将需要致电<xref:System.Net.Sockets.Socket.Connect%2A>方法，然后再每次调用<xref:System.Net.Sockets.Socket.Send%2A>。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 您还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>到另一个调用，从而<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.Send%2A>会阻塞，直到所有缓冲区中的字节都将发送，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超过超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在阻止模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能成功完成，即使它发送的字节数小于缓冲区中。 它是应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送请求的字节数。 此外，还有您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
> [!NOTE]
>  您必须确保在缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，将不发送数据报并<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  发送的成功完成并不表示数据已成功传递。 如果任何缓冲区空间以容纳要传输的数据在传输系统中不不可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何在连接上的发送数据<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 类型的 <see cref="T:System.Byte" /> 的列表，它包含要发送的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，将列表中的一组缓冲区发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载需要至少一个缓冲区，其中包含你想要发送的数据。 <xref:System.Net.Sockets.SocketFlags>默认值为 0。 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketFlags`参数，不会将路由发送的数据。  
  
 如果您使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果使用的是面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机连接，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果使用无连接协议，并且打算将数据发送到多个不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您将需要致电<xref:System.Net.Sockets.Socket.Connect%2A>每次调用前<xref:System.Net.Sockets.Socket.Send%2A>。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 您还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>到另一个调用，从而<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.Send%2A>会阻塞，直到所有缓冲区中的字节都将发送，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超过超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在非阻止模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能成功完成，即使它发送的字节数小于缓冲区中。 它是应用程序负责跟踪发送的字节数并重试操作，直到应用程序将字节发送缓冲区中。 此外，还有您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  发送的成功完成并不表示数据已成功传递。 如果任何缓冲区空间以容纳要传输的数据在传输系统中不不可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，将指定字节数的数据发送到已连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式将数据发送到远程主机中建立<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法，并返回已成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的和无连接协议。  
  
 此重载需要包含想要你想要发送的字节数和按位组合的任何发送的数据的缓冲区<xref:System.Net.Sockets.SocketFlags>。 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，不会将路由发送的数据。  
  
 如果您使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果使用的是面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机连接，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果使用无连接协议，并且打算将数据发送到多个不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您将需要致电<xref:System.Net.Sockets.Socket.Connect%2A>方法，然后再每次调用<xref:System.Net.Sockets.Socket.Send%2A>方法。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 您还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>到另一个调用，从而<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 使用面向连接的协议<xref:System.Net.Sockets.Socket.Send%2A>会阻塞，直到发送请求的字节数，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超过超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在阻止模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能成功完成，即使它发送的请求的字节数小于。 它是应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送请求的字节数。 此外，还有您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
> [!NOTE]
>  您必须确保大小不超过基础服务提供程序的最大数据包大小。 如果是这样，将不发送数据报并<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  发送的成功完成并不表示数据已成功传递。 如果任何缓冲区空间以容纳要传输的数据在传输系统中不不可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例将发送缓冲区中找到的数据，并指定<xref:System.Net.Sockets.SocketFlags.None>为<xref:System.Net.Sockets.SocketFlags>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> 小于 0 或超过缓冲区的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  访问套接字时发生操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 类型的 <see cref="T:System.Byte" /> 的列表，它包含要发送的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，将列表中的一组缓冲区发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载需要至少一个缓冲区，其中包含你想要发送的数据。 <xref:System.Net.Sockets.SocketFlags>默认值为 0。 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketFlags`参数，不会将路由发送的数据。  
  
 如果您使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果使用的是面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机连接，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果使用无连接协议，并且打算将数据发送到多个不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您将需要致电<xref:System.Net.Sockets.Socket.Connect%2A>每次调用前<xref:System.Net.Sockets.Socket.Send%2A>。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 您还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>到另一个调用，从而<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.Send%2A>会阻塞，直到所有缓冲区中的字节都将发送，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超过超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在非阻止模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能成功完成，即使它发送的字节数小于缓冲区中。 它是应用程序负责跟踪发送的字节数并重试操作，直到应用程序将字节发送缓冲区中。 此外，还有您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  发送的成功完成并不表示数据已成功传递。 如果任何缓冲区空间以容纳要传输的数据在传输系统中不不可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="offset">开始发送数据的缓冲区中的位置。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>从指定偏移量开始，使用指定 <see cref="T:System.Net.Sockets.SocketFlags" />，将指定的数据字节数发送到已连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式将数据发送到远程主机中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法，并返回已成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的和无连接协议。  
  
 在此重载中，如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，不会将路由发送的数据。  
  
 如果您使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果使用的是面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机连接，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果使用无连接协议，并且打算将数据发送到多个不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>，您将需要致电<xref:System.Net.Sockets.Socket.Connect%2A>每次调用前<xref:System.Net.Sockets.Socket.Send%2A>。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 您还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>到另一个调用，从而<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 您还必须确保大小不超过基础服务提供程序的最大数据包大小。 如果是这样，将不发送数据报并<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.Send%2A>会阻塞，直到发送请求的字节数，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超过超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在阻止模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能成功完成，即使它发送的请求的字节数小于。 它是应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送请求的字节数。 此外，还有您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  发送的成功完成并不表示数据已成功传递。 如果任何缓冲区空间以容纳要传输的数据在传输系统中不不可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例指定数据缓冲区、 偏移、 大小和<xref:System.Net.Sockets.SocketFlags>将数据发送到连接<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="offset">开始发送数据的缓冲区中的位置。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>从指定的偏移量开始使用指定的 <see cref="T:System.Net.Sockets.Socket" /> 将指定字节数的数据发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式将数据发送到远程主机中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法，并返回已成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的和无连接协议。  
  
 在此重载中，如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，不会将路由发送的数据。  
  
 如果您使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果使用的是面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机连接，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果使用无连接协议，并且打算将数据发送到多个不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>，您将需要致电<xref:System.Net.Sockets.Socket.Connect%2A>每次调用前<xref:System.Net.Sockets.Socket.Send%2A>。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 您还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>到另一个调用，从而<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 您还必须确保大小不超过基础服务提供程序的最大数据包大小。 如果是这样，将不发送数据报并<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.Send%2A>会阻塞，直到发送请求的字节数，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超过超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在阻止模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能成功完成，即使它发送的请求的字节数小于。 它是应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送请求的字节数。 此外，还有您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  发送的成功完成并不表示数据已成功传递。 如果任何缓冲区空间以容纳要传输的数据在传输系统中不不可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例指定数据缓冲区、 偏移、 大小和<xref:System.Net.Sockets.SocketFlags>将数据发送到连接<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>方法用于从面向连接的套接字上的一个或多个缓冲区写入传出数据。 此方法也可用，但是，已对连接操作指定远程主机的无连接套接字上。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>方法启动异步发送操作中建立的远程主机<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>成功调用此方法所需的对象：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>设置  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>设置  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可能会设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>属性设置为在调用之前所需的任何用户状态对象<xref:System.Net.Sockets.Socket.SendAsync%2A>方法，以便可在回调方法中检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小类来保存作为成员的其他所需的状态信息。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>方法将引发异常，如果不首先调用<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>。  
  
 调用<xref:System.Net.Sockets.Socket.SendAsync%2A>方法使你能够发送单独的执行线程中的数据。  
  
 对于面向消息的套接字，不超过基础 Windows 套接字服务提供程序的最大消息大小。 如果数据太长，以原子方式通过基础服务提供商，传输任何数据并<xref:System.Net.Sockets.Socket.SendAsync%2A>方法会抛出<xref:System.Net.Sockets.SocketException>与<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>设置为本机 Winsock WSAEMSGSIZE 错误代码 (10040)。  
  
 请注意，成功完成<xref:System.Net.Sockets.Socket.SendAsync%2A>方法并不表示数据已成功传递。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="e" /> 参数的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 或 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性必须引用有效的缓冲区。 可以设置这两个属性中的某一个，但不能同时设置这两个属性。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <see cref="T:System.Net.Sockets.Socket" /> 尚未连接或者尚未通过 <see cref="M:System.Net.Sockets.Socket.Accept" />、<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 或 <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> 方法获得。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 发送缓冲区的大小。</summary>
        <value>
          <see cref="T:System.Int32" />，它包含发送缓冲区的大小（以字节为单位）。 默认值为 8192。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 更大的缓冲区大小可能会延迟连接问题的识别。 请考虑增加缓冲区大小，如果传输大型文件，或者使用的高带宽、 高延迟连接 （如机顶盒宽带提供商。）  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.SendBufferSize%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 0。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将文件和可选数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">一个 <see cref="T:System.String" />，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 传输标志，将文件 <paramref name="fileName" /> 发送到连接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载将该文件发送`fileName`到连接的套接字。 `flags`参数默认为<xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread>(0)，并`preBuffer`并`postBuffer`参数默认为`null`。 如果`fileName`是在本地目录中，它可能会标识只是该文件的名称; 否则，必须指定完整路径和文件的名称。 通配符 ("...\\\myfile.txt") 和 UNC 共享名 ("\\\\\\\shared directory\\\myfile.txt") 支持。 如果未找到文件，该异常<xref:System.IO.FileNotFoundException>引发。  
  
 此方法使用`TransmitFile`Windows Sockets 2 API 中找到函数。 有关详细信息`TransmitFile`函数和它的标志，请参阅 MSDN 库中的 Windows 套接字文档。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 以同步方式将文件发送到远程主机中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 <xref:System.Net.Sockets.Socket.SendFile%2A> 可以使用面向连接的两个和无连接协议。  
  
 如果您使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法，否则<xref:System.Net.Sockets.Socket.SendFile%2A>引发<xref:System.Net.Sockets.SocketException>异常。 如果使用的是面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机连接或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.SendFile%2A>阻止，直到该文件发送。 在阻止模式下，<xref:System.Net.Sockets.Socket.SendFile%2A>发送整个文件之前，可能会成功完成。 则您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.SendFile%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例创建并连接套接字，然后将文件发送到远程主机。 文件"test.txt"位于本地计算机的根目录中。  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">套接字未连接到远程主机。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象未处于阻止模式，无法接受此同步调用。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">一个 <see cref="T:System.String" />，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <param name="preBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件前要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="postBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件后要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="flags">一个或多个 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值。</param>
        <summary>通过指定的 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值，将文件 <paramref name="fileName" /> 和数据缓冲区发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载需要的名称以及你想要发送的文件的按位组合<xref:System.Net.Sockets.TransmitFileOptions>值。 `preBuffer`参数包含你想要前加上该文件的任何数据。 `postBuffer` 包含你想要遵照该文件的数据。 如果`fileName`是在当前工作目录，它可能会标识只是该文件的名称; 否则，必须指定完整路径和文件的名称。 通配符 ("...\\\myfile.txt") 和 UNC 共享名 ("\\\\\\\shared directory\\\myfile.txt") 支持。  
  
 `flags`参数提供了关于文件传输的其他信息的窗口套接字服务提供程序。 有关如何使用此参数的详细信息，请参阅<xref:System.Net.Sockets.TransmitFileOptions>。  
  
 此方法使用`TransmitFile`Windows Sockets 2 API 中找到函数。 有关详细信息`TransmitFile`函数和它的标志，请参阅 MSDN 库中的 Windows 套接字文档。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 以同步方式将文件发送到远程主机中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 <xref:System.Net.Sockets.Socket.SendFile%2A> 可以使用面向连接的两个和无连接协议。  
  
 如果您使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法; 否则为<xref:System.Net.Sockets.Socket.SendFile%2A>引发<xref:System.Net.Sockets.SocketException>。 如果使用的是面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机连接，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果使用面向连接的协议<xref:System.Net.Sockets.Socket.SendFile%2A>阻止，直到发送整个文件。 在阻止模式下，<xref:System.Net.Sockets.Socket.SendFile%2A>发送整个文件之前，可能会成功完成。 则您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.SendFile%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例创建并连接套接字。 文件"test.txt"位于本地计算机的根目录中。 在此示例中，我们创建缓冲区和数据后，并将其与文件一起发送到远程主机。 默认值<xref:System.Net.Sockets.TransmitFileOptions>使用。  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">操作系统不是 Windows NT 或更高版本。  \- 或 -  套接字未连接到远程主机。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象未处于阻止模式，无法接受此同步调用。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>将文件集合或者内存中的数据缓冲区以异步方法发送给连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法用于将集合中的文件或在内存中数据缓冲区发送到远程主机。 <xref:System.Net.Sockets.Socket>必须已连接到远程主机。  
  
 如果<xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType>的工作目录中的文件的引用，则可能会将其标识只是该文件的名称; 否则，必须指定完整路径和文件的名称。 支持通配符和 UNC 共享名称。 如果找不到该文件，<xref:System.IO.FileNotFoundException>引发。  
  
 若要在完成时得到通知，必须创建实现事件处理程序的回调方法\<SocketAsyncEventArgs > 委托并将附加到回调<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>属性上的`e`参数提供了关于文件传输的其他信息的窗口套接字服务提供程序。 有关如何使用此参数的详细信息，请参阅<xref:System.Net.Sockets.TransmitFileOptions>。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>成功调用此方法所需的对象：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可能会设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>属性设置为在调用之前所需的任何用户状态对象<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法，以便可在回调方法中检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小类来保存作为成员的其他所需的状态信息。  
  
 此方法使用 Windows Sockets 2 API 中找到的 TransmitPackets 函数。 有关 TransmitPackets 函数和它的标志的详细信息，请参阅 MSDN 库中的 Windows 套接字文档。  
  
 适用于面向连接的协议，尽管<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法也适用于无连接协议，前提是先调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法以建立默认远程主机。 使用无连接协议时，您还必须确保文件的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，不发送数据报并<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>引发<xref:System.Net.Sockets.SocketException>异常。  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法优化根据操作系统使用它。 在 Windows server 版本，<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>针对高性能优化方法。  
  
 Windows 客户端版本上<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法适用于最小内存和资源利用率。  
  
 利用<xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType>中的标志<xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>属性上的`e`参数可以提供显著的性能优势。 如果线程启动<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法调用的使用进行大量计算，则可以，尽管可能性不大，，Apc 可能无法启动。 请注意，内核和用户模式下的 Apc 之间的差异。 内核 Apc 在一个线程处于等待状态时启动。 用户模式下 Apc 在一个线程处于可报警等待状态时启动  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">未找到在 <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> 属性中指定的文件。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。 如果 <see cref="T:System.Net.Sockets.Socket" /> 未连接到远程主机，也会发生此异常。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">使用的是无连接 <see cref="T:System.Net.Sockets.Socket" />，并且所发送的文件超过了基础传输的最大数据包大小。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定之后同步 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 调用将超时的时间长度。</summary>
        <value>超时值（以毫秒为单位）。 如果将该属性设置为 1 到 499 之间的值，该值将被更改为 500。 默认值为 0，指示超时期限无限大。 指定 -1 还会指示超时期限无限大。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此选项适用于同步<xref:System.Net.Sockets.Socket.Send%2A>仅调用。 如果超出超时期限，则<xref:System.Net.Sockets.Socket.Send%2A>方法将引发<xref:System.Net.Sockets.SocketException>。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.SendTimeout%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 1。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据发送到特定终结点。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>将数据发送到指定的终结点。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载中的缓冲区偏移量的默认值为 0，要将默认值发送到的大小的字节数`buffer`参数，和<xref:System.Net.Sockets.SocketFlags>默认值为 0。  
  
 如果使用的是无连接协议，不需要建立默认远程主机使用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>。 只需执行此操作，如果你想要调用<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>，则`remoteEP`参数将替代指定的默认远程主机，只为发送操作。 也不需要调用<xref:System.Net.Sockets.Socket.Bind%2A>方法，因为基础服务提供程序将分配的最合适的本地网络地址和端口号。 如果你需要标识分配的本地网络地址和端口号，则可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性后的<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。  
  
 适用于无连接协议，尽管<xref:System.Net.Sockets.Socket.SendTo%2A>也适用于面向连接的协议。 如果使用的是面向连接的协议，首先必须通过调用建立远程主机连接<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受传入的连接请求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果没有建立或接受远程主机连接，<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。 您还可以建立默认远程主机之前调用的无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.SendTo%2A>将忽略`remoteEP`参数仅将数据发送到已连接或默认远程主机。  
  
 阻止套接字将阻止，直到发送的字节缓冲区中的所有。 由于非阻止性<xref:System.Net.Sockets.Socket>完成立即，它可能不会发送的字节中的所有`buffer`。 它是应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送的字节中的所有`buffer`。 此外，还有您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
 如果在阻止模式下，使用无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>会阻塞，直到发送数据报。 如果你想要将数据发送到的广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，设置套接字选项设为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您还必须确保发送的字节数不超过基础服务提供程序的最大数据包大小。 如果是这样，将不发送数据报并<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例将无连接的数据报发送到指定的远程主机。  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，将数据发送到特定的终结点。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载中的缓冲区偏移量的默认值为 0，并要将默认值发送到的大小的字节数`buffer`。 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，不会将路由发送的数据。  
  
 如果使用的是无连接协议，不需要建立默认远程主机使用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>。 只需执行此操作，如果你想要调用<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>，则`remoteEP`参数将替代指定的默认远程主机，只为发送操作。 也不需要调用<xref:System.Net.Sockets.Socket.Bind%2A>方法，因为基础服务提供程序将分配的最合适的本地网络地址和端口号。 如果你需要标识分配的本地网络地址和端口号，则可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性后的<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。  
  
 适用于无连接协议，尽管<xref:System.Net.Sockets.Socket.SendTo%2A>也适用于面向连接的协议。 如果使用的是面向连接的协议，首先必须通过调用建立远程主机连接<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受传入的连接请求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果没有建立或接受远程主机连接，<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。 您还可以建立默认远程主机之前调用的无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.SendTo%2A>将忽略`remoteEP`参数仅将数据发送到已连接或默认远程主机。  
  
 阻止套接字将一直阻止请求中的字节的所有`buffer`发送。 由于非阻止性<xref:System.Net.Sockets.Socket>完成立即，它可能不会发送的字节中的所有`buffer`。 它是应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送的字节中的所有`buffer`。 此外，还有您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
 如果在阻止模式下，使用无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>会阻塞，直到发送数据报。 如果你想要将数据发送到的广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，设置套接字选项设为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您还必须确保发送的字节数不超过基础服务提供程序的最大数据包大小。 如果是这样，将不发送数据报并<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例将无连接的数据报发送到指定的远程主机。 <xref:System.Net.Sockets.SocketFlags> 传递给<xref:System.Net.Sockets.Socket.SendTo%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，将指定字节数的数据发送到指定的终结点。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载中的缓冲区偏移量的默认值为 0。 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，不会将路由发送的数据。  
  
 如果使用的是无连接协议，不需要建立默认远程主机使用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>。 只需执行此操作，如果你想要调用<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>，则`remoteEP`参数将替代指定的默认远程主机，只为发送操作。 也不需要调用<xref:System.Net.Sockets.Socket.Bind%2A>方法，因为基础服务提供程序将分配的最合适的本地网络地址和端口号。 如果你需要标识分配的本地网络地址和端口号，则可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性后的<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。  
  
 适用于无连接协议，尽管<xref:System.Net.Sockets.Socket.SendTo%2A>也适用于面向连接的协议。 如果使用的是面向连接的协议，首先必须通过调用建立远程主机连接<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受传入的连接请求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果没有建立或接受远程主机连接，<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。 您还可以建立默认远程主机之前调用的无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.SendTo%2A>将忽略`remoteEP`参数仅将数据发送到已连接或默认远程主机。  
  
 阻止套接字将阻止，直到发送请求的字节数。 由于非阻止性<xref:System.Net.Sockets.Socket>完成立即，它可能不会发送所有单个操作中请求的字节数。 它是应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送请求的字节数。 此外，还有您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
 如果在阻止模式下，使用无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>会阻塞，直到发送数据报。 如果你想要将数据发送到的广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，设置套接字选项设为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您还必须确保发送的字节数不超过基础服务提供程序的最大数据包大小。 如果是这样，将不发送数据报并<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例将无连接的数据报发送到指定的远程主机。 大小和<xref:System.Net.Sockets.SocketFlags>传递给<xref:System.Net.Sockets.Socket.SendTo%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的 <paramref name="size" /> 超出 <paramref name="buffer" /> 的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="offset">开始发送数据的缓冲区中的位置。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，将指定字节数的数据发送到指定终结点（从缓冲区中的指定位置开始）。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此重载中，如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，不会将路由发送的数据。  
  
 如果使用的是无连接协议，不需要建立默认远程主机使用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>。 只需执行此操作，如果你想要调用<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>，则`remoteEP`参数将替代指定的默认远程主机，只为发送操作。 也不需要调用<xref:System.Net.Sockets.Socket.Bind%2A>方法，因为基础服务提供程序将分配的最合适的本地网络地址和端口号。 如果你需要标识分配的本地网络地址和端口号，则可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性后的<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。  
  
 适用于无连接协议，尽管<xref:System.Net.Sockets.Socket.SendTo%2A>也适用于面向连接的协议。 如果使用的是面向连接的协议，首先必须通过调用建立远程主机连接<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受传入的连接请求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果没有建立或接受远程主机连接，<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。 您还可以建立默认远程主机之前调用的无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.SendTo%2A>将忽略`remoteEP`参数仅将数据发送到已连接或默认远程主机。  
  
 阻止套接字将阻止，直到发送请求的字节数。 由于非阻塞<xref:System.Net.Sockets.Socket>完成立即，它可能不会发送所有单个操作中请求的字节数。 它由你的应用程序负责跟踪发送的字节数，重试该操作，直到应用程序发送请求的字节数。 此外，还有您发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法意味着的基础系统已为你的数据的网络发送的缓冲区的空间。  
  
 如果在阻止模式下，使用无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>会阻塞，直到发送数据报。 如果你想要将数据发送到的广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，设置套接字选项设为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您还必须确保大小不超过基础服务提供程序的最大数据包大小。 如果是这样，将不发送数据报并<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例将无连接的数据报发送到指定的远程主机。 偏移量、 大小、 和<xref:System.Net.Sockets.SocketFlags>传递给<xref:System.Net.Sockets.Socket.SendTo%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>以异步方式将数据发送到特定远程主机。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendToAsync%2A>方法启动异步发送操作中指定远程主机<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>属性的`e`参数。 调用<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法使你能够发送单独的执行线程中的数据。 尽管此方法适用于无连接协议，<xref:System.Net.Sockets.Socket.SendToAsync%2A>适用于无连接和面向连接的协议。  
  
 若要在完成时得到通知，必须创建实现事件处理程序的回调方法\<SocketAsyncEventArgs > 委托并将附加到回调<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>成功调用此方法所需的对象：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可能会设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>属性设置为在调用之前所需的任何用户状态对象<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法，以便可在回调方法中检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小类来保存作为成员的其他所需的状态信息。  
  
 如果使用的是面向连接的协议，必须首先调用<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法。 否则为<xref:System.Net.Sockets.Socket.SendToAsync%2A>将引发<xref:System.Net.Sockets.SocketException>。 当使用面向连接的协议<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法将忽略<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>属性并将数据发送到<xref:System.Net.EndPoint?displayProperty=nameWithType>中建立<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法。  
  
 如果使用的是无连接协议，不需要建立默认远程主机使用<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，然后调用<xref:System.Net.Sockets.Socket.SendToAsync%2A>。 只需执行此操作，如果你想要调用<xref:System.Net.Sockets.Socket.BeginSend%2A>或<xref:System.Net.Sockets.Socket.SendAsync%2A>方法。 如果调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，然后调用<xref:System.Net.Sockets.Socket.SendToAsync%2A>，则<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>属性将为该发送操作仅重写指定的默认远程主机。 也不需要调用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 在这种情况下，基础服务提供程序将分配的最合适的本地网络 IP 地址和端口号。 如果你想要选择可用端口的基础服务提供程序，请使用端口号 0。 如果你需要标识分配的本地网络 IP 地址和端口号，则可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性后的<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件收到信号状态，调用关联的委托。  
  
 如果你想要将数据发送到的广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，设置套接字选项<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>为 true。 您还必须确保在缓冲区的大小不超过基础服务提供程序的最大数据包大小。 如果是这样，将不发送数据报并<xref:System.Net.Sockets.Socket.SendToAsync%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果指定中的 DontRoute 标志<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>属性中，不会将路由发送的数据。  
  
 对于面向消息的套接字，必须格外小心不能超过基础传输的最大消息大小。 如果缓冲区的大小超过基础服务提供程序的最大数据包大小，不发送数据报并<xref:System.Net.Sockets.Socket.SendToAsync%2A>将引发<xref:System.Net.Sockets.SocketException>。 成功完成<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法并不表示数据已成功传递。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为 null。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">指定的协议是面向连接的，但 <see cref="T:System.Net.Sockets.Socket" /> 尚未连接。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">要为此套接字设置的 IP 保护级别。</param>
        <summary>设置套接字的 IP 保护级别。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>方法使限制 IPv6 或 IP 套接字以侦听指定的作用域，如具有相同的地址的链接本地或站点本地前缀。 此套接字选项使应用程序可以限制对 IPv6 或 IP 套接字的访问权限。 通过应用此类限制，可让在专用局域网上运行的应用程序能够通过简单的方式很好地增强自身的安全性，以便防范外部攻击。 此套接字选项还可用于删除访问权限限制，如果`level`参数设置为<xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>。 此套接字选项可以扩大或缩小侦听套接字的范围，从而使得公共用户和私人用户可以在适当情况下对站点进行无限制的访问，或者可以根据需要对同一站点进行有限制的访问。  
  
 此套接字选项具有 <xref:System.Net.Sockets.IPProtectionLevel> 枚举中指定的已定义保护级别。  
  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>方法用于启用或禁用网络地址遍历 (NAT) 为<xref:System.Net.Sockets.Socket>实例。 可以使用 Teredo、 6to4、 或的 ISATAP 隧道提供 NAT 遍历。  
  
 当`level`参数设置为<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>，或<xref:System.Net.Sockets.IPProtectionLevel.Restricted>，这将显式禁用 NAT 遍历<xref:System.Net.Sockets.Socket>实例。  
  
 当`level`参数设置为<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>，这可能使 NAT 遍历<xref:System.Net.Sockets.Socket>具体取决于在系统上发生的防火墙规则。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="level" /> 参数不能为 <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />。 IP 保护级别不能设置为未指定。</exception>
        <exception cref="T:System.NotSupportedException">套接字的 <see cref="T:System.Net.Sockets.AddressFamily" /> 必须为 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />。</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置 <see cref="T:System.Net.Sockets.Socket" /> 选项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">选项的值，表示为 <see cref="T:System.Boolean" />。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定的 <see cref="T:System.Boolean" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项将确定当前的行为<xref:System.Net.Sockets.Socket>。 设置`optionValue`到`true`以启用该选项，或设置为`false`以禁用该选项。  
  
 <xref:System.Net.Sockets.Socket> 按协议支持的级别进行分组选项。  
  
 下面列出了各种<xref:System.Net.Sockets.Socket>可以使用此重载来设置的选项。 这些选项进行分组的相应<xref:System.Net.Sockets.SocketOptionLevel>值。 如果你要设置上述任何选项，请确保使用适当<xref:System.Net.Sockets.SocketOptionLevel>值`optionLevel`参数。 选择要设置的选项必须指定在`optionName`参数。 如果你想要获取任何所列的选项的当前值，请使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 可以使用此重载来设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 可以使用此重载来设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 可以使用此重载来设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 可以使用此重载来设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 有关这些选项的详细信息，请参阅<xref:System.Net.Sockets.SocketOptionName>枚举。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>异常，请使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例打开一个套接字并启用`DontLinger`和`OutOfBandInline`套接字选项。  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">
          <see cref="T:System.Byte" /> 类型的数组，表示选项值。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定的值，表示为字节数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项将确定当前的行为<xref:System.Net.Sockets.Socket>。 使用此重载来设置那些<xref:System.Net.Sockets.Socket>需要为选项值的字节数组的选项。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>超时值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">该选项的值。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定的整数值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项将确定当前的行为<xref:System.Net.Sockets.Socket>。 有关使用选项<xref:System.Boolean>数据类型，指定一个非零值以启用该选项和零值以禁用该选项。 有关使用整数数据类型的选项，指定适当的值。 <xref:System.Net.Sockets.Socket> 按协议支持的级别进行分组选项。  
  
 下面列出了各种<xref:System.Net.Sockets.Socket>可以使用此重载来设置的选项。 这些选项进行分组的相应<xref:System.Net.Sockets.SocketOptionLevel>。 如果你要设置上述任何选项，请确保使用适当<xref:System.Net.Sockets.SocketOptionLevel>为`optionLevel`参数。 选择要设置的选项必须指定在`optionName`参数。 如果你想要获取任何所列的选项的当前值，请使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 可以使用此重载来设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 可以使用此重载来设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 可以使用此重载来设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 可以使用此重载来设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> 可以使用此重载来设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 有关这些选项的详细信息，请参阅<xref:System.Net.Sockets.SocketOptionName>枚举。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>超时值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">一个 <see cref="T:System.Net.Sockets.LingerOption" /> 或 <see cref="T:System.Net.Sockets.MulticastOption" />，它包含该选项的值。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定值，表示为对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项将确定当前的行为<xref:System.Net.Sockets.Socket>。 使用此重载来设置<xref:System.Net.Sockets.SocketOptionName.Linger>， <xref:System.Net.Sockets.SocketOptionName.AddMembership>，并<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>选项。 有关<xref:System.Net.Sockets.SocketOptionName.Linger>选项，请使用<xref:System.Net.Sockets.Socket>为`optionLevel`参数。 有关<xref:System.Net.Sockets.SocketOptionName.AddMembership>并<xref:System.Net.Sockets.SocketOptionName.DropMembership>，使用<xref:System.Net.Sockets.SocketOptionLevel.IP>。 如果你想要获取任何上面列出的选项的当前值，请使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>超时值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="optionValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">
          <see cref="T:System.Net.Sockets.SocketShutdown" /> 值之一，它指定不再允许执行的操作。</param>
        <summary>禁用某 <see cref="T:System.Net.Sockets.Socket" /> 上的发送和接收。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当使用面向连接的<xref:System.Net.Sockets.Socket>，始终调用<xref:System.Net.Sockets.Socket.Shutdown%2A>方法关闭之前<xref:System.Net.Sockets.Socket>。 这可确保发送和关闭之前连接的套接字上接收到的所有数据。  
  
 调用<xref:System.Net.Sockets.Socket.Close%2A>方法来释放所有托管和非托管资源与关联<xref:System.Net.Sockets.Socket>。 不要尝试重复使用<xref:System.Net.Sockets.Socket>关闭之后。  
  
 下表显示<xref:System.Net.Sockets.SocketShutdown>对有效的枚举值`how`参数。  
  
|“值”|描述|  
|-----------|-----------------|  
|发送|禁止对此发送<xref:System.Net.Sockets.Socket>。|  
|接收|禁用对此接收<xref:System.Net.Sockets.Socket>。|  
|消息和传送|禁用发送和接收对此<xref:System.Net.Sockets.Socket>。|  
  
 设置`how`到<xref:System.Net.Sockets.SocketShutdown.Send>指定后续调用<xref:System.Net.Sockets.Socket.Send%2A>不允许。 如果您使用的是无连接<xref:System.Net.Sockets.Socket>，并指定<xref:System.Net.Sockets.SocketShutdown.Send>不会产生影响。  
  
 设置`how`到<xref:System.Net.Sockets.SocketShutdown.Receive>指定后续调用<xref:System.Net.Sockets.Socket.Receive%2A>不允许。 这没有任何影响较低的协议层上。 如果使用的是面向连接的协议，如果存在以下条件之一调用后，连接将终止<xref:System.Net.Sockets.Socket.Shutdown%2A>:  
  
-   数据是等待接收的传入网络缓冲区中。  
  
-   更多的数据现正供应。  
  
 如果使用的是无连接协议，数据报是接受并已排队。 但是，如果没有缓冲区空间可用于其他传入的数据报，他们会被放弃，并且会向发件人返回任何错误。 使用<xref:System.Net.Sockets.Socket.Shutdown%2A>上是无连接<xref:System.Net.Sockets.Socket>不建议。  
  
 设置`how`到<xref:System.Net.Sockets.SocketShutdown.Both>同时禁用发送和接收上文所述。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>调用时<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，请使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.Sockets.Socket.Shutdown%2A>若要禁用<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的类型。</summary>
        <value>
          <see cref="T:System.Net.Sockets.SocketType" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> 是只读的则会设置<xref:System.Net.Sockets.Socket>创建。  
  
   
  
## Examples  
 下面的代码示例显示<xref:System.Net.Sockets.AddressFamily>， <xref:System.Net.Sockets.SocketType>，和<xref:System.Net.Sockets.ProtocolType>到控制台。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在当前主机上 IPv4 支持是否可用并且已启用。</summary>
        <value>如果当前主机支持 IPv4 协议，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能会支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 Framework 对某些已过时的 <see cref="T:System.Net.Dns" /> 成员是否支持 IPv6。</summary>
        <value>如果 Framework 对某些已过时的 <see cref="T:System.Net.Dns" /> 方法支持 IPv6，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能会支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，指定 <see cref="T:System.Net.Sockets.Socket" /> 发送的 Internet 协议 (IP) 数据包的生存时间 (TTL) 值。</summary>
        <value>TTL 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TTL 值指示的路由器数据包可以遍历路由器会丢弃该数据包和 Internet 控制消息协议 (ICMP)"超出 TTL"之前的最大数目的错误信息返回到发件人。  
  
 TTL 值可能设置为值，从 0 到 255 之间。 如果未设置此属性，套接字的默认 TTL 值为 32。  
  
 如果尚未建立成功的连接使用套接字，传输控制协议 (TCP) 套接字上设置此属性是通过 TCP/IP 堆栈忽略。  
  
 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档在 MSDN 库中的有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.Ttl%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">TTL 值不能设置为负数。</exception>
        <exception cref="T:System.NotSupportedException">只有对于在 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 族中的套接字，才可以设置此属性。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 在尝试将 TTL 设置为大于 255 的值时，也将返回此错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定套接字是否应仅使用重叠 I/O 模式。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 仅使用重叠 I/O，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此属性设置为`true`有关<xref:System.Net.Sockets.Socket>想要调用<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>。 否则，该框架可以将完成端口分配给套接字，将禁止使用<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">套接字已绑定到完成端口。</exception>
      </Docs>
    </Member>
  </Members>
</Type>