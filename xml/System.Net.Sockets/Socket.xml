<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Socket.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac53e382a75359056b74e79a6c44021c6bb0b7e382c.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3e382a75359056b74e79a6c44021c6bb0b7e382c</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Implements the Berkeley sockets interface.</source>
          
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class provides a rich set of methods and properties for network communications.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类为的网络通信提供一组丰富的方法和属性。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <ph id="ph2">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> enumeration.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类允许你执行同步和异步数据传输使用任何通信协议列入<ph id="ph2">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph>枚举。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class follows the .NET Framework naming pattern for asynchronous methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类遵循的异步方法的.NET Framework 命名模式。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>For example, the synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method corresponds to the asynchronous <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> methods.</source>
          <target state="translated">例如，同步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法对应于异步<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>和<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</source>
          <target state="translated">如果你的应用程序仅在执行过程中需要一个线程，使用以下方法，旨在同步操作模式。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用如 TCP 一个面向连接的协议，你的服务器可以侦听连接使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method processes any incoming connection requests and returns a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that you can use to communicate data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法处理任何传入的连接请求，并返回<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，你可以使用与远程主机通信数据。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">使用此返回<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method prior to calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method if you want to specify the local IP address and port number.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>方法如果你想要指定本地 IP 地址和端口号。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use a port number of zero if you want the underlying service provider to assign a free port for you.</source>
          <target state="translated">如果你想要为您分配一个可用端口的基础服务提供程序，请使用端口号 0。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you want to connect to a listening host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">如果你想要连接到侦听主机，调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>To communicate data, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">若要进行数据通信，调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</source>
          <target state="translated">如果使用如 UDP 无连接协议时，你不需要在所有侦听连接。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method to accept any incoming datagrams.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法，以接受任何传入的数据报。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method to send datagrams to a remote host.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法以将数据报发送到远程主机。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</source>
          <target state="translated">若要处理通信在执行期间使用单独的线程，使用以下方法，适用于异步操作模式。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connection-oriented protocol such as TCP, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> methods to connect with a listening host.</source>
          <target state="translated">如果你使用如 TCP 一个面向连接的协议，使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>， <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>方法来侦听主机的连接。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> methods to communicate data asynchronously.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>和<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>数据之间进行异步通信的方法。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Incoming connection requests can be processed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>.</source>
          <target state="translated">可以使用处理传入的连接请求<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connectionless protocol such as UDP, you can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> to send datagrams, and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> to receive datagrams.</source>
          <target state="translated">如果使用如 UDP 无连接协议时，你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>来发送数据报，和<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>和<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>来接收数据报。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</source>
          <target state="translated">如果执行套接字上的多个异步操作，它们不一定会完成中启动它们的顺序。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>When you are finished sending and receiving data, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method to disable the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">当你完成发送和接收数据，请使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>方法来禁用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>After calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to release all resources associated with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">在调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>，调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法来释放与关联的所有资源<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class allows you to configure your <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类允许你配置你<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>使用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Retrieve these settings using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">检索使用这些设置<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are writing a relatively simple application and do not require maximum performance, consider using <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.TcpListener&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.UdpClient&gt;</ph>.</source>
          <target state="translated">如果你在编写相对简单的应用程序，并且不需要最高的性能，请考虑使用<ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient&gt;</ph>， <ph id="ph2">&lt;xref:System.Net.Sockets.TcpListener&gt;</ph>，和<ph id="ph3">&lt;xref:System.Net.Sockets.UdpClient&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>These classes provide a simpler and more user-friendly interface to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> communications.</source>
          <target state="translated">这些类提供的更简单且更加用户友好界面<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>通信。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The following code example shows how the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class can be used to send data to an HTTP server and receive the response.</source>
          <target state="translated">下面的代码示例演示如何<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类可以用于将数据发送到 HTTP 服务器并接收响应。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>This example blocks until the entire page is received.</source>
          <target state="translated">此示例阻塞，直到收到整个页面。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>To establish an outgoing connection or accept an incoming request.</source>
          <target state="translated">若要建立一个传出连接或接受传入请求。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Instances of this class are thread safe.</source>
          <target state="translated">此类的实例都是线程安全。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>The socket information returned by <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class using the specified value returned from <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>s with the same underlying socket.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>多次使用相同的字节数组作为每个调用的参数的构造函数，你将创建多个托管<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>具有相同的基础套接字的 s。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>This practice is strongly discouraged.</source>
          <target state="translated">强烈建议不要使用这种做法。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class using the specified socket type and protocol.</source>
          
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The <ph id="ph1">`socketType`</ph> parameter specifies the type of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class and the <ph id="ph3">`protocolType`</ph> parameter specifies the protocol used by <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`socketType`</ph>参数指定的一种<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类和<ph id="ph3">`protocolType`</ph>参数指定使用的协议<ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The two parameters are not independent.</source>
          <target state="translated">两个参数不是独立的。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Often the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type is implicit in the protocol.</source>
          <target state="translated">通常<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类型是在协议中隐式。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If the combination of <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type and protocol type results in an invalid <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, this constructor throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果的组合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类型和协议类型无效导致<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，此构造函数引发<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If this constructor throws a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果此构造函数引发<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The combination of  <ph id="ph1">&lt;paramref name="socketType" /&gt;</ph> and <ph id="ph2">&lt;paramref name="protocolType" /&gt;</ph> results in an invalid socket.</source>
          
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class using the specified address family, socket type and protocol.</source>
          
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The <ph id="ph1">`addressFamily`</ph> parameter specifies the addressing scheme that the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class uses, the <ph id="ph3">`socketType`</ph> parameter specifies the type of the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class, and the <ph id="ph5">`protocolType`</ph> parameter specifies the protocol used by <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`addressFamily`</ph>参数指定的寻址方案<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类使用，<ph id="ph3">`socketType`</ph>参数指定的一种<ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类，与<ph id="ph5">`protocolType`</ph>参数指定使用的协议<ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The three parameters are not independent.</source>
          <target state="translated">三个参数不是独立的。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Some address families restrict which protocols can be used with them, and often the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type is implicit in the protocol.</source>
          <target state="translated">某些地址族限制哪些协议可用来与它们，并且通常<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类型是在协议中隐式。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If the combination of address family, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type, and protocol type results in an invalid <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, this constructor throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果地址族的组合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类型和协议类型无效导致<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，此构造函数引发<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If this constructor throws a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果此构造函数引发<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The following code example demonstrates how to create an instance of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
          <target state="translated">下面的代码示例演示如何创建的实例<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The combination of <ph id="ph1">&lt;paramref name="addressFamily" /&gt;</ph>, <ph id="ph2">&lt;paramref name="socketType" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="protocolType" /&gt;</ph> results in an invalid socket.</source>
          
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>Creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> for a newly created connection.</source>
          
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> for a newly created connection.</source>
          
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> 以同步方式从侦听套接字，连接请求队列中提取第一个挂起的连接请求，然后创建并返回一个新<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">不能使用此返回<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>接受任何额外连接从连接队列。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>However, you can call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> method of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to identify the remote host's network address and port number.</source>
          <target state="translated">但是，你可以调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph>方法的返回<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>来标识远程主机的网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>In blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> blocks until an incoming connection attempt is queued.</source>
          <target state="translated">在阻止模式下，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>被阻止，直至传入的连接尝试将会排队。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>Once a connection is accepted, the original <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> continues queuing incoming connection requests until you close it.</source>
          <target state="translated">一旦接受连接，则原始<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>继续队列传入连接请求之前关闭它。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>If you call this method using a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and no connection requests are queued, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果调用此方法使用的非阻塞<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，并且不启用连接请求将排队等待，<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>引发<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method, you must first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法时，你必须首先调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>方法来侦听并对传入的连接请求进行排队。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>The following code example accepts a simple <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection.</source>
          <target state="translated">下面的代码示例接受一个简单<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>连接。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>The accepting socket is not listening for connections.</source>
          
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
          
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">可以使用面向连接的协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>方法异步处理传入的连接尝试。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">以异步方式接受连接使你能够发送和接收在单独的执行线程中的数据。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>方法时，必须调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>方法来侦听并对传入的连接请求进行排队。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and hook it to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">若要在完成时得到通知，必须创建实现的回调方法<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; 委托并将挂钩到<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required:</source>
          <target state="translated">下列属性和事件上的<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>是必需的对象：</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller can optionally specify an existing <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to use for the incoming connection by specifying the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to use with the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">调用方可以选择指定现有<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>要通过指定用于传入连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>用于<ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> property is null, a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is constructed with the same <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AddressFamily%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> as the current <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and set as the <ph id="ph7">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph>属性为 null，新<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>构造具有相同<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AddressFamily%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph>，和<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph>与当前<ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph>并将设置为<ph id="ph7">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">调用方可能设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>到在调用前要求任何用户状态对象的属性<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>方法，以便在回叫方法可检索信息。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
          <target state="translated">（可选） 可能要接收后套接字上的数据的初始块在其中提供一个缓冲区<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法成功。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the buffer containing the data to receive and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the maximum number of bytes of data to receive in the buffer.</source>
          <target state="translated">在这种情况下，<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph>属性应设置为包含数据的缓冲区，以接收和<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph>属性应设置为最大的数据的字节数，以接收缓冲区中。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>These properties can be set using the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">可以使用设置这些属性<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</source>
          <target state="translated">传入的缓冲区的一部分将可供内部使用的基础 Winsock AcceptEx 调用。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This means that the amount of data returned will always be less than the value of the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> instance provided.</source>
          <target state="translated">这意味着返回的数据量始终为的值小于<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph>属性<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>提供实例。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The amount of the buffer used internally varies based on the address family of the socket.</source>
          <target state="translated">在内部使用的缓冲区的量的套接字地址族有所不同。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The minimum buffer size required is 288 bytes.</source>
          <target state="translated">所需的最小缓冲区大小为 288 个字节。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a larger buffer size is specified, then the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</source>
          <target state="translated">如果指定较大缓冲区大小，则<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>应除了 Winsock AcceptEx 调用收到的地址数据之外一些额外的数据和将等待，直到收到此额外的数据。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a timeout occurs, the connection is reset.</source>
          <target state="translated">如果发生超时，则连接将重置。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</source>
          <target state="translated">因此如果特定量的预期会有额外的数据，则应缓冲区大小设置为最小缓冲区大小加上此段中。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The completion callback method should examine the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> property to determine if the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> operation was successful.</source>
          <target state="translated">完成回调方法应该检查<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph>属性来确定如果<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>操作成功。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event can occur in some cases when no connection has been accepted and cause the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> property to be set to <ph id="ph3">&lt;xref:System.Net.Sockets.SocketError.ConnectionReset&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph>事件可发生在某些情况下，在没有连接已被接受时，使<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph>属性设置为<ph id="ph3">&lt;xref:System.Net.Sockets.SocketError.ConnectionReset&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This can occur as a result of port scanning using a half-open SYN type scan (a SYN -&gt; SYN-ACK -&gt; RST sequence).</source>
          <target state="translated">这会导致端口扫描使用半开 SYN 类型扫描 (SYN-&gt; SYN ACK-&gt; RST 序列)。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Applications using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method should be prepared to handle this condition.</source>
          <target state="translated">使用应用程序<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>方法应准备好处理此情况。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is not valid.</source>
          
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if the buffer provided is not large enough.</source>
          
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The buffer must be at least 2 * (sizeof(SOCKADDR_STORAGE + 16) bytes.</source>
          
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if multiple buffers are specified, the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> property is not null.</source>
          
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is out of range.</source>
          
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The exception occurs if the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An invalid operation was requested.</source>
          
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if the accepting <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not listening for connections or the accepted socket is bound.</source>
          
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You must call the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> method before calling the <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph> method.</source>
          
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>Gets the address family of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> specifies the addressing scheme that an instance of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class can use.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>指定的寻址方案的实例<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类可以使用。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>This property is read-only and is set when the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created.</source>
          <target state="translated">此属性是只读的并且时会设置<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>创建。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> to the console.</source>
          <target state="translated">下面的代码示例显示<ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>， <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>，和<ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph>到控制台。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Available">
          <source>Gets the amount of data that has been received from the network and is available to be read.</source>
          
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>The number of bytes of data received from the network and available to be read.</source>
          <target state="translated">从网络接收的、可供读取的数据的字节数。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If you are using a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is a good way to determine whether data is queued for reading, before calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的非阻塞<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>是一种好方法，以便确定是否将数据排队以进行读取，然后再调用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>The available data is the total amount of data queued in the network buffer for reading.</source>
          <target state="translated">可用的数据是在读取的网络缓冲区中排队的总数据量。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If no data is queued in the network buffer, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> returns 0.</source>
          <target state="translated">如果无数据排队网络缓冲区中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>返回 0。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If the remote host shuts down or closes the connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> can throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果远程主机关闭或关闭了连接，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>可以引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>The following code example compares the results of calling IOControl with FIONREAD and the Available property.</source>
          <target state="translated">下面的代码示例使用 FIONREAD 和可用的属性的调用 IOControl 的结果进行比较。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Available">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Available">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
          
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
          
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> creation.</source>
          
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">可以使用面向连接的协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法异步处理传入的连接尝试。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">以异步方式接受连接使你能够发送和接收在单独的执行线程中的数据。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法时，必须调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>方法来侦听并对传入的连接请求进行排队。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">你必须创建实现一个回调方法<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>委托并将传递到其名称<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">若要这样做，请至少，你必须传递侦听<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>对象传递给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>通过<ph id="ph3">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">如果你的回调需要详细信息，你可以创建一个小型类来保存<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>和其他必需的信息。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">将此类的实例传递<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法通过<ph id="ph2">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
          <target state="translated">你的回调方法应调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
          <target state="translated">当你的应用程序调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>，系统通常使用单独的线程来执行指定的回调方法，并阻止在<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>直到检索到挂起的连接。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> will return a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object that you can use to send and receive data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> 将返回一个新<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>对象可用于发送和接收与远程主机的数据。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">不能使用此返回<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>接受任何额外连接从连接队列。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你想要阻止后调用的原始线程<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法，请使用<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">在调用 Set 方法<ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>当你想要继续执行原始线程时的回调方法中。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The system may also use the calling thread to invoke the callback method.</source>
          <target state="translated">系统还可能使用调用的线程来调用的回调方法。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method completed synchronously.</source>
          <target state="translated">在这种情况下，<ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph>属性对返回<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>将设置，则指示<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>已同步完成的方法。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">有关编写回调方法的更多信息，请参阅<bpt id="p1">[</bpt>委托作为回调方法进行封送<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">若要取消挂起调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法，关闭<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法调用的异步操作正在进行时，回调提供给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>方法会引发<ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph>以指示已取消该操作。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to identify the remote host's network address and port number.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph>属性返回的<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>来标识远程主机的网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The following code example attempts to receive an incoming connection asynchronously.</source>
          <target state="translated">下面的代码示例将以异步接收的传入连接。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Windows NT is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The accepting socket is not listening for connections.</source>
          
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The accepted socket is bound.</source>
          
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The number of bytes to accept from the sender.</source>
          
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</source>
          
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> creation.</source>
          
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">可以使用面向连接的协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法异步处理传入的连接尝试。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</source>
          <target state="translated">以异步方式接受连接可以发送和接收在单独的执行线程中的数据。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>This overload allows you to specify the number of bytes to accept in the initial transfer in the <ph id="ph1">`receiveSize`</ph> parameter.</source>
          <target state="translated">此重载允许你指定要接受中的初始传输中的字节数<ph id="ph1">`receiveSize`</ph>参数。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法时，必须调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>方法来侦听并对传入的连接请求进行排队。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">你必须创建实现一个回调方法<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>委托并将传递到其名称<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">若要这样做，请至少，你必须传递侦听<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>对象传递给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>通过<ph id="ph3">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">如果你的回调需要详细信息，你可以创建一个小型类来保存<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>和其他必需的信息。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">将此类的实例传递<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法通过<ph id="ph2">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
          <target state="translated">你的回调方法应调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
          <target state="translated">当你的应用程序调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>，系统通常使用单独的线程来执行指定的回调方法，并阻止在<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>直到检索到挂起的连接。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that you can use to send and receive data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> 返回一个新<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>可用于发送和接收与远程主机的数据。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">不能使用此返回<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>接受任何额外连接从连接队列。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你想要阻止后调用的原始线程<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法，请使用<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">在调用 Set 方法<ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>当你想要继续执行原始线程时的回调方法中。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The system may also use the calling thread to invoke the callback method.</source>
          <target state="translated">系统还可能使用调用的线程来调用的回调方法。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method completed synchronously.</source>
          <target state="translated">在这种情况下，<ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph>属性对返回<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>将设置，则指示<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>已同步完成的方法。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">有关编写回调方法的更多信息，请参阅<bpt id="p1">[</bpt>委托作为回调方法进行封送<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">若要取消挂起调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法，关闭<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法调用的异步操作正在进行时，回调提供给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>方法会引发<ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph>以指示已取消该操作。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You can call use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to identify the remote host's network address and port number.</source>
          <target state="translated">你可以调用使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph>属性返回的<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>对象来标识远程主机的网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example opens a socket and accepts an asynchronous connection.</source>
          <target state="translated">下面的代码示例打开一个套接字并接受异步连接。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>In this example, the socket accepts the initial 10 bytes of data.</source>
          <target state="translated">在此示例中，套接字接受前 10 个字节的数据。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The number of bytes received and the data are displayed on the console by the callback delegate.</source>
          <target state="translated">接收的字节数和数据被显示在控制台上的回调委托。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> for a description of how the remaining data is received.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>有关接收剩余数据的方式的说明。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Windows NT is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepting socket is not listening for connections.</source>
          
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepted socket is bound.</source>
          
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepted <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>This value may be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The maximum number of bytes to receive.</source>
          
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</source>
          
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that references the asynchronous <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object creation.</source>
          
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">可以使用面向连接的协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法异步处理传入的连接尝试。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">以异步方式接受连接使你能够发送和接收在单独的执行线程中的数据。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>This overload allows you to specify the accepted socket in the <ph id="ph1">`acceptSocket`</ph> parameter.</source>
          <target state="translated">此重载允许你指定接受的套接字中<ph id="ph1">`acceptSocket`</ph>参数。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If this parameter is <ph id="ph1">`null`</ph>, the accepted socket is created by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">如果此参数为<ph id="ph1">`null`</ph>，通过创建接受的套接字<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You can specify the number of bytes to accept in the initial transfer in the <ph id="ph1">`receiveSize`</ph> parameter.</source>
          <target state="translated">你可以指定要接受中的初始传输中的字节数<ph id="ph1">`receiveSize`</ph>参数。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法时，必须调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>方法来侦听并对传入的连接请求进行排队。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">你必须创建实现一个回调方法<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>委托并将传递到其名称<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">若要这样做，请至少，你必须传递侦听<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>对象传递给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>通过<ph id="ph3">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">如果你的回调需要详细信息，你可以创建一个小型类来保存<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>和其他必需的信息。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">将此类的实例传递<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法通过<ph id="ph2">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
          <target state="translated">你的回调方法应调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
          <target state="translated">当你的应用程序调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>，系统通常使用单独的线程来执行指定的回调方法，并阻止在<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>直到检索到挂起的连接。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object that you can use to send and receive data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> 返回一个新<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>对象可用于发送和接收与远程主机的数据。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">不能使用此返回<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>接受任何额外连接从连接队列。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你想要阻止后调用的原始线程<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法，请使用<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">在调用 Set 方法<ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>当你想要继续执行原始线程时的回调方法中。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The system may also use the calling thread to invoke the callback method.</source>
          <target state="translated">系统还可能使用调用的线程来调用的回调方法。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method completed synchronously.</source>
          <target state="translated">在这种情况下，<ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph>属性对返回<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>将设置，则指示<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>已同步完成的方法。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">有关编写回调方法的其他信息，请参阅<bpt id="p1">[</bpt>委托作为回调方法进行封送<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">若要取消挂起调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法，关闭<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法调用的异步操作正在进行时，回调提供给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>方法会引发<ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph>以指示已取消该操作。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to identify the remote host's network address and port number.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph>属性返回的<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>对象来标识远程主机的网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example opens a socket and accepts an asynchronous connection.</source>
          <target state="translated">下面的代码示例打开一个套接字并接受异步连接。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>In this example, the socket accepts the initial 10 bytes of data and the <ph id="ph1">`acceptSocket`</ph> parameter is <ph id="ph2">`null`</ph>, which forces the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to create the accepted socket.</source>
          <target state="translated">在此示例中，套接字接受前 10 个字节的数据和<ph id="ph1">`acceptSocket`</ph>参数是<ph id="ph2">`null`</ph>，这将强制<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法来创建接受的套接字。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The number of bytes received and the data are displayed on the console by the callback delegate.</source>
          <target state="translated">接收的字节数和数据被显示在控制台上的回调委托。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> for a description of how the remaining data is received.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>有关接收剩余数据的方式的说明。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Windows NT is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepting socket is not listening for connections.</source>
          
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepted socket is bound.</source>
          
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins an asynchronous request for a remote host connection.</source>
          
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connection.</source>
          
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method starts an asynchronous request for a connection to the <ph id="ph2">`remoteEP`</ph> parameter.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法会启动到的连接的异步请求<ph id="ph2">`remoteEP`</ph>参数。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">如果你使用的是无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">连接或以异步方式设置默认远程主机使你能够发送和接收在单独的执行线程中的数据。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method.</source>
          <target state="translated">你可以创建实现一个回调方法<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>委托并将传递到其名称<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>At the very minimum, you must pass the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">至少，你必须传递<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>到<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>通过<ph id="ph3">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and the other required information.</source>
          <target state="translated">如果你的回调需要详细信息，你可以创建一个小型类来保存<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，和其他必需的信息。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">将此类的实例传递<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法通过<ph id="ph2">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">你的回调方法应调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connects successfully or throws an exception.</source>
          <target state="translated">当你的应用程序调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>，系统将使用一个单独的线程执行的指定的回调方法，并阻止<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>直到<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>成功连接或引发异常。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
          <target state="translated">如果你想要阻止后调用的原始线程<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法，请使用<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">在调用 Set 方法<ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>当你想要继续执行原始线程时的回调方法中。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">有关编写回调方法的更多信息，请参阅<bpt id="p1">[</bpt>委托作为回调方法进行封送<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">如果使用如 UDP 无连接协议时，不需要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>之前发送和接收数据。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> to communicate with a remote host.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>与远程主机通信。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>，来自地址而不是指定默认的地址的任何数据报将被放弃。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you wish to set your default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">如果你想要将默认远程主机为广播地址，必须先调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>并将广播设置为<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you cannot, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你不能<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">如果你使用的是面向连接的协议，并且不调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>，基础服务提供程序将分配的最合适的本地网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接协议，直到你调用，则服务提供程序将不分配本地网络地址和端口号<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method again with the desired endpoint.</source>
          <target state="translated">如果你想要更改默认远程主机时，调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>再次使用所需终结点的方法。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">若要取消挂起调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法，关闭<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法调用的异步操作正在进行时，回调提供给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>方法会引发<ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph>以指示已取消该操作。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">如果以前已断开此套接字，然后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>必须调用该操作完成之前不会退出的线程上。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">这是基础提供程序的限制。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">下面的代码示例启动异步连接尝试。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> of the remote host.</source>
          
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number of the remote host.</source>
          
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the connect operation.</source>
          
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> delegate when the operation is complete.</source>
          
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The host is specified by an <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> and a port number.</source>
          
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connection.</source>
          
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>操作必须通过调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
          <target state="translated">通常情况下，通过调用该方法<ph id="ph1">`requestCallback`</ph>委托。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">此方法不会阻止，直到完成该操作。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>.</source>
          <target state="translated">若要阻止该操作完成之前，请使用之一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法重载或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">若要取消挂起调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法，关闭<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法调用的异步操作正在进行时，回调提供给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>方法会引发<ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph>以指示已取消该操作。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
          <target state="translated">有关使用异步编程模型的详细信息，请参阅<bpt id="p1">[</bpt>异步调用同步方法<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">如果以前已断开此套接字，然后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>必须调用该操作完成之前不会退出的线程上。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">这是基础提供程序的限制。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
          <target state="translated">此外<ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>，它是使用必须不同。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">下面的代码示例启动异步连接尝试。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="address" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not in the socket family.</source>
          
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number is not valid.</source>
          
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>At least one <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph>, designating the remote host.</source>
          
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number of the remote host.</source>
          
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the connect operation.</source>
          
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> delegate when the operation is complete.</source>
          
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The host is specified by an <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> array and a port number.</source>
          
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connections.</source>
          
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>操作必须通过调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
          <target state="translated">通常情况下，通过调用该方法<ph id="ph1">`requestCallback`</ph>委托。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">此方法不会阻止，直到完成该操作。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads.</source>
          <target state="translated">若要阻止该操作完成之前，请使用之一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">若要取消挂起调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法，关闭<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法调用的异步操作正在进行时，回调提供给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>方法会引发<ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph>以指示已取消该操作。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">有关使用异步编程模型的详细信息，请参阅<bpt id="p1">[</bpt>异步调用同步方法<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">如果以前已断开此套接字，然后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>必须调用该操作完成之前不会退出的线程上。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">这是基础提供程序的限制。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
          <target state="translated">此外<ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>，它是使用必须不同。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">下面的代码示例启动异步连接尝试。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This method is valid for sockets that use <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number is not valid.</source>
          
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The name of the remote host.</source>
          
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number of the remote host.</source>
          
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the connect operation.</source>
          
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> delegate when the operation is complete.</source>
          
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The host is specified by a host name and a port number.</source>
          
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connection.</source>
          
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>操作必须通过调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
          <target state="translated">通常情况下，通过调用该方法<ph id="ph1">`requestCallback`</ph>委托。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">此方法不会阻止，直到完成该操作。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads.</source>
          <target state="translated">若要阻止该操作完成之前，请使用之一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the  <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">若要取消挂起调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法，关闭<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法调用的异步操作正在进行时，回调提供给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>方法会引发<ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph>以指示已取消该操作。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
          <target state="translated">有关使用异步编程模型的详细信息，请参阅<bpt id="p1">[</bpt>异步调用同步方法<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">如果以前已断开此套接字，然后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>必须调用该操作完成之前不会退出的线程上。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">这是基础提供程序的限制。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
          <target state="translated">此外<ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>，它是使用必须不同。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">下面的代码示例启动异步连接尝试。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="host" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number is not valid.</source>
          
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this socket can be reused after the connection is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request to disconnect from a remote endpoint.</source>
          
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that references the asynchronous operation.</source>
          
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol, you can call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> method to request a disconnect from a remote endpoint.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则可以调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>方法来从远程终结点请求断开连接。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>If <ph id="ph1">`reuseSocket`</ph> is <ph id="ph2">`true`</ph>, you can reuse the socket.</source>
          <target state="translated">如果<ph id="ph1">`reuseSocket`</ph>是<ph id="ph2">`true`</ph>，你可以重复使用套接字。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> method uses a separate thread to invoke the specified callback method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>方法使用一个单独的线程来调用指定的回调方法。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> method blocks until the pending disconnect is complete.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph>方法阻塞，直到挂起的断开连接已完成。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">有关编写回调方法的其他信息，请参阅<bpt id="p1">[</bpt>委托作为回调方法进行封送<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>异常，请改用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The following code example creates a socket for asynchronous communication and sends some data to a remote host.</source>
          <target state="translated">下面的代码示例创建套接字进行异步通信，并将一些数据发送到远程主机。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>When the data has been sent, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> is called to stop the send and receive activity.</source>
          <target state="translated">当数据已发送时，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>调用以停止发送和接收活动。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>Then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> is called to begin a disconnect request.</source>
          <target state="translated">然后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>调用以开始断开连接请求。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>When the request completes, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is queried to test whether the socket is disconnected.</source>
          <target state="translated">完成请求后，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>属性将查询以测试是否断开连接的套接字。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>操作必须通过调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">通常情况下，通过调用该方法<ph id="ph1">`callback`</ph>委托。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">此方法不会阻止，直到完成该操作。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">若要阻止该操作完成之前，请使用之一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">若要取消挂起<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>，调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">有关使用异步编程模型的详细信息，请参阅<bpt id="p1">[</bpt>异步调用同步方法<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">在线程退出时，由给定线程启动的所有 i/o 操作已取消。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">如果在线程退出操作完成前，挂起的异步操作可能会失败。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> 是用户定义的实例化。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>操作必须通过调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">通常情况下，通过调用该方法<ph id="ph1">`callback`</ph>委托。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">此方法不会阻止，直到完成该操作。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">若要阻止该操作完成之前，请使用之一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">若要取消挂起<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>，调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">有关使用异步编程模型的详细信息，请参阅<bpt id="p1">[</bpt>异步调用同步方法<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">在线程退出时，由给定线程启动的所有 i/o 操作已取消。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">如果在线程退出操作完成前，挂起的异步操作可能会失败。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> 是用户定义的实例化。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to store the received data.</source>
          
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>操作必须通过调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">通常情况下，通过调用该方法<ph id="ph1">`callback`</ph>委托。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">此方法不会阻止，直到完成该操作。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">若要阻止该操作完成之前，请使用之一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">若要取消挂起<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>，调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">有关使用异步编程模型的详细信息，请参阅<bpt id="p1">[</bpt>异步调用同步方法<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">在线程退出时，由给定线程启动的所有 i/o 操作已取消。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">如果在线程退出操作完成前，挂起的异步操作可能会失败。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> 是用户定义的实例化。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The following code example begins to asynchronously receive data from a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">下面的代码示例开始以异步方式从连接中接收数据<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The location in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> to store the received data.</source>
          
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>操作必须通过调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">通常情况下，通过调用该方法<ph id="ph1">`callback`</ph>委托。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">此方法不会阻止，直到完成该操作。</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">若要阻止该操作完成之前，请使用之一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">若要取消挂起<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>，调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">有关使用异步编程模型的详细信息，请参阅<bpt id="p1">[</bpt>异步调用同步方法<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">在线程退出时，由给定线程启动的所有 i/o 操作已取消。</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">如果在线程退出操作完成前，挂起的异步操作可能会失败。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> 是用户定义的实例化。</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to store the data.</source>
          
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a specified network device.</source>
          
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method starts asynchronously reading connectionless datagrams from a remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>方法会启动异步读取远程主机无连接数据报。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method gives you the ability to receive data within a separate execution thread.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>方法使你能够接收在单独的执行线程中的数据。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">你可以创建实现一个回调方法<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>委托并将传递到其名称<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">为此，请至少，你<ph id="ph1">`state`</ph>参数必须包含连接或默认<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>用于进行通信。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">如果你的回调需要详细信息，你可以创建一个小型类来保存<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>和其他必需的信息。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">将此类的实例传递<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>方法通过<ph id="ph2">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">你的回调方法应调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and it will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> reads data or throws an exception.</source>
          <target state="translated">当你的应用程序调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>，系统将使用一个单独的线程执行指定的回调方法，它将阻塞<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>直到<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>读取数据或引发异常。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你想要阻止后调用的原始线程<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>方法，请使用<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">当你想要继续执行原始线程时，请在回调方法调用 Set 方法。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">有关编写回调方法的其他信息，请参阅<bpt id="p1">[</bpt>委托作为回调方法进行封送<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>。</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will throw a <ph id="ph5">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>，必须显式将绑定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>本地终结点使用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法，或<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>将引发<ph id="ph5">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method reads data into the <ph id="ph1">`buffer`</ph> parameter, and captures the remote host endpoint from which the data is sent.</source>
          <target state="translated">此方法将数据读入<ph id="ph1">`buffer`</ph>参数，而捕获的远程主机从其发送数据的终结点。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For information on how to retrieve this endpoint, refer to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</source>
          <target state="translated">有关如何检索此终结点的信息，请参阅<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">此方法是最有用，如果你想要以异步方式从未知的主机或多个主机中接收无连接数据报。</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>In these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">在这些情况下，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>将读取到本地网络缓冲区接收到第一个排队数据报。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你收到的数据报大于的大小<ph id="ph1">`buffer`</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>方法将填充<ph id="ph3">`buffer`</ph>尽可能可能，而引发的消息与<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">如果你使用的不可靠的协议，多余的数据将丢失。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">如果你使用的是可靠的协议对过量数据将保留由服务提供商，你可以通过调用来检索它<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>使用足够大的缓冲区的方法。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method and then call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method with the <ph id="ph4">`optionLevel`</ph> parameter set to <ph id="ph5">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph> or <ph id="ph6">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6&gt;</ph> as appropriate, the <ph id="ph7">`optionName`</ph> parameter set to <ph id="ph8">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>, and the <ph id="ph9">`optionValue`</ph> parameter to enable this option before calling the <ph id="ph10">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">若要确保始终返回远程主机终结点、 应用程序应显式绑定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>本地终结点使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法，然后调用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>方法替换<ph id="ph4">`optionLevel`</ph>参数设置为<ph id="ph5">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>或<ph id="ph6">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6&gt;</ph>视情况而定<ph id="ph7">`optionName`</ph>参数设置为<ph id="ph8">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>，和<ph id="ph9">`optionValue`</ph>参数以启用此选项之前调用<ph id="ph10">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">否则，它是要发件人已发送的数据报数目之前接收方调用时不会返回的远程主机终结点可能<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">尽管<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>适用于无连接协议，你可以使用也是一个面向连接的协议。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph><ph id="ph2"> / </ph><ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method or accept an incoming connection request by calling the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">如果你选择这样做，你必须首先可以建立远程主机的连接通过调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> <ph id="ph2"> / </ph> <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法或通过调用接受传入的连接请求<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method before establishing or accepting a connection, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>方法时建立或接受连接之前，你将获取<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">你还可以建立默认远程主机之前调用无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">在这些情况下，任一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>方法将忽略<ph id="ph2">`remoteEP`</ph>参数和仅接收从连接的数据或默认远程主机。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will read as much data as is available up to the number of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">对于面向连接的套接字，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>将读取原样可用直到达到指定的字节数多的数据<ph id="ph2">`size`</ph>参数。</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">若要取消挂起<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>，调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The following code example asynchronously receives connectionless datagrams from a remote host.</source>
          <target state="translated">下面的代码示例以异步方式从远程主机接收无连接数据报。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to store the data.</source>
          
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the source of the data.</source>
          
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint and packet information..</source>
          
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The asynchronous receive operation must be completed by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">异步接收操作必须由调用完成<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`asyncCallback`</ph> delegate.</source>
          <target state="translated">通常情况下，通过调用该方法<ph id="ph1">`asyncCallback`</ph>委托。</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation completes.</source>
          <target state="translated">此方法不会阻止该操作完成之前。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To block until the operation completes, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">若要阻止该操作完成之前，请使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">若要取消挂起<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A&gt;</ph>，调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
          <target state="translated">有关使用异步编程模型的详细信息，请参阅<bpt id="p1">[</bpt>异步调用同步方法<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method reads data into the <ph id="ph1">`buffer`</ph> parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</source>
          <target state="translated">此方法将数据读入<ph id="ph1">`buffer`</ph>参数，并捕获的远程主机终结点从其发送数据，以及有关接收的数据包的信息。</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For information on how to retrieve this endpoint, refer to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</source>
          <target state="translated">有关如何检索此终结点的信息，请参阅<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">此方法是最有用，如果你想要以异步方式从未知的主机或多个主机中接收无连接数据报。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法会启动异步发送操作中建立的远程主机<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> 如果不首先调用将引发异常<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法使你能够发送单独的执行线程中的数据。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">你可以创建实现一个回调方法<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>委托并将传递到其名称<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">为此，请至少，你<ph id="ph1">`state`</ph>参数必须包含连接或默认<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>用于进行通信。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">如果你的回调需要详细信息，可以创建一个小型类或结构，用于保存<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>和其他必需的信息。</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">将此类的实例传递<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法通过<ph id="ph2">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">你的回调方法应调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">当你的应用程序调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>，系统将使用一个单独的线程执行的指定的回调方法，并阻止<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>直到<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>发送请求的字节数或引发异常。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">如果你想要阻止后调用的原始线程<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法，请使用<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">当你想要继续执行原始线程时，请在回调方法调用 Set 方法。</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">有关编写回调方法的更多信息，请参阅<bpt id="p1">[</bpt>委托作为回调方法进行封送<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">适用于面向连接的协议，尽管<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>还应用于无连接协议，前提是你第一次调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法来建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>甚至已建立默认远程主机使用后<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">你还可以更改默认远程主机之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>通过另一个调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">使用无连接协议，你还必须确保你的缓冲区的大小不能超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果是这样，将不发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">如果指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>标记为<ph id="ph2">`socketflags`</ph>参数，发送的无法路由的数据。</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">在线程退出时，由给定线程启动的所有 i/o 操作已取消。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">如果在线程退出操作完成前，挂起的异步操作可能会失败。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> 是用户定义的实例化。</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">成功完成后发送不指示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法会启动异步发送操作中建立的远程主机<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> 如果不首先调用将引发异常<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法使你能够发送单独的执行线程中的数据。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">你可以创建实现一个回调方法<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>委托并将传递到其名称<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">为此，请至少，你<ph id="ph1">`state`</ph>参数必须包含连接或默认<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>用于进行通信。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">如果你的回调需要详细信息，可以创建一个小型类或结构，用于保存<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>和其他必需的信息。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">将此类的实例传递<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法通过<ph id="ph2">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">你的回调方法应调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">当你的应用程序调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>，系统将使用一个单独的线程执行的指定的回调方法，并阻止<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>直到<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>发送请求的字节数或引发异常。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">如果你想要阻止后调用的原始线程<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法，请使用<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">在调用 Set 方法<ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>当你想要继续执行原始线程时的回调方法中。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">有关编写回调方法的更多信息，请参阅<bpt id="p1">[</bpt>委托作为回调方法进行封送<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">适用于面向连接的协议，尽管<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>还应用于无连接协议，前提是你第一次调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法来建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>甚至已建立默认远程主机使用后<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">你还可以更改默认远程主机之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>通过另一个调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">使用无连接协议，你还必须确保你的缓冲区的大小不能超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果是这样，将不发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">如果指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>标记为<ph id="ph2">`socketflags`</ph>参数，发送的无法路由的数据。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">在线程退出时，由给定线程启动的所有 i/o 操作已取消。</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">如果在线程退出操作完成前，挂起的异步操作可能会失败。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> 是用户定义的实例化。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">成功完成后发送不指示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to begin sending data.</source>
          
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to send.</source>
          
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法会启动异步发送操作中建立的远程主机<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> 如果不首先调用将引发异常<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法使你能够发送单独的执行线程中的数据。</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">你可以创建实现一个回调方法<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>委托并将传递到其名称<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">为此，请至少，你<ph id="ph1">`state`</ph>参数必须包含连接或默认<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>用于进行通信。</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">如果你的回调需要详细信息，可以创建一个小型类或结构，用于保存<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>和其他必需的信息。</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">将此类的实例传递<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法通过<ph id="ph2">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">你的回调方法应调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">当你的应用程序调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>，系统将使用一个单独的线程执行的指定的回调方法，并阻止<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>直到<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>发送请求的字节数或引发异常。</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">如果你想要阻止后调用的原始线程<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法，请使用<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">当你想要继续执行原始线程时，请在回调方法调用 Set 方法。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">有关编写回调方法的更多信息，请参阅<bpt id="p1">[</bpt>委托作为回调方法进行封送<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">适用于面向连接的协议，尽管<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>还应用于无连接协议，前提是你第一次调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法来建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>甚至已建立默认远程主机使用后<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">你还可以更改默认远程主机之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>通过另一个调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">使用无连接协议，你还必须确保你的缓冲区的大小不能超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果是这样，将不发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">如果指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>标记为<ph id="ph2">`socketflags`</ph>参数，发送的无法路由的数据。</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">在线程退出时，由给定线程启动的所有 i/o 操作已取消。</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">如果在线程退出操作完成前，挂起的异步操作可能会失败。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> 是用户定义的实例化。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">成功完成后发送不指示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to begin sending data.</source>
          
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The number of bytes to send.</source>
          
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法会启动异步发送操作中建立的远程主机<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> 如果不首先调用将引发异常<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法使你能够发送单独的执行线程中的数据。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">你可以创建实现一个回调方法<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>委托并将传递到其名称<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">为此，请至少，你<ph id="ph1">`state`</ph>参数必须包含连接或默认<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>用于进行通信。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">如果你的回调需要详细信息，可以创建一个小型类或结构，用于保存<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>和其他必需的信息。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">将此类的实例传递<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法通过<ph id="ph2">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">你的回调方法应调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">当你的应用程序调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>，系统将使用一个单独的线程执行的指定的回调方法，并阻止<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>直到<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>发送请求的字节数或引发异常。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">如果你想要阻止后调用的原始线程<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法，请使用<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">当你想要继续执行原始线程时，请在回调方法调用 Set 方法。</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">有关编写回调方法的更多信息，请参阅<bpt id="p1">[</bpt>委托作为回调方法进行封送<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">适用于面向连接的协议，尽管<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>还应用于无连接协议，前提是你第一次调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法来建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>甚至已建立默认远程主机使用后<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">你还可以更改默认远程主机之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>通过另一个调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">使用无连接协议，你还必须确保你的缓冲区的大小不能超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果是这样，将不发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">如果指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>标记为<ph id="ph2">`socketflags`</ph>参数，发送的无法路由的数据。</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">在线程退出时，由给定线程启动的所有 i/o 操作已取消。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">如果在线程退出操作完成前，挂起的异步操作可能会失败。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> 是用户定义的实例化。</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">成功完成后发送不指示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The following code example begins asynchronously sending data to a remote host.</source>
          <target state="translated">下面的代码示例开始以异步方式将数据发送到远程主机。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends a file asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>A string that contains the path and name of the file to send.</source>
          
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Sends the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> to a connected <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object using the <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph> flag.</source>
          
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that represents the asynchronous send.</source>
          
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This overload sends the file <ph id="ph1">`fileName`</ph> to the connected socket.</source>
          <target state="translated">此重载将文件发送<ph id="ph1">`fileName`</ph>到连接的套接字。</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">如果<ph id="ph1">`fileName`</ph>是在本地目录中，则可以标识与只是文件的名称; 否则，必须指定完整路径和文件的名称。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">通配符 ("...<ph id="ph1">\\</ph>\myfile.txt") 和 UNC 共享名 ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared 目录<ph id="ph5">\\</ph>\myfile.txt") 支持。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">如果未找到文件，该异常<ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">此方法使用<ph id="ph1">`TransmitFile`</ph>Windows 套接字 2 API 中找到函数。</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`TransmitFile`</ph>函数和其标志，请参阅 MSDN 库中的 Windows 套接字文档。</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>,<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>方法会启动异步发送操作中建立的远程主机<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> 引发异常，如果不首先调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method enables you to send a file within a separate execution thread.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>方法使你能够发送单独的执行线程中的文件。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>To complete the operation, you can create a callback method that is invoked by the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate parameter.</source>
          <target state="translated">若要完成该操作，你可以创建由调用的回调方法<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>委托参数。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, the <ph id="ph1">`state`</ph> parameter must contain the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object being used for communication.</source>
          <target state="translated">为此，请至少，<ph id="ph1">`state`</ph>参数必须包含<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>对象用于进行通信。</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">如果你的回调需要详细信息，可以创建类或结构，用于保存<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>和其他必需的信息。</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this custom object to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">将为此自定义对象的实例传递<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>方法通过<ph id="ph2">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Your callback method must invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method.</source>
          <target state="translated">你的回调方法必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, the system uses a separate thread to execute the specified callback method, and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the entire file or throws an exception.</source>
          <target state="translated">当你的应用程序调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>，系统将使用一个单独的线程执行指定的回调方法，并阻止在<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>直到<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>发送完整的文件或引发异常。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">有关编写回调方法的更多信息，请参阅<bpt id="p1">[</bpt>委托作为回调方法进行封送<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">适用于面向连接的协议，尽管<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>还应用于无连接协议，前提是你第一次调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法来建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">使用无连接协议，则必须确保你的文件的大小不超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">如果是这样，不会发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>异常。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>异常，请改用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The following code example creates and connects a socket for asynchronous communication.</source>
          <target state="translated">下面的代码示例创建并连接的套接字进行异步通信。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>First, the file "text.txt" is sent asynchronously to the remote host.</source>
          <target state="translated">首先，"text.txt"该文件是以异步方式发送，到远程主机。</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> to complete the transmission.</source>
          <target state="translated">回调委托调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>完成传输。</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The socket is not connected to a remote host.</source>
          
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A string that contains the path and name of the file to be sent.</source>
          
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent before the file is sent.</source>
          
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent after the file is sent.</source>
          
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate to be invoked when this operation completes.</source>
          
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains state information for this request.</source>
          
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Sends a file and buffers of data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that represents the asynchronous operation.</source>
          
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This overload requires the name of the file you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> values.</source>
          <target state="translated">此重载需要你想要发送的文件和的按位组合的名称<ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>值。</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">`preBuffer`</ph> parameter contains any data you want to precede the file.</source>
          <target state="translated"><ph id="ph1">`preBuffer`</ph>参数包含你想要位于文件之前的任何数据。</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`postBuffer`</ph> contains data you want to follow the file.</source>
          <target state="translated"><ph id="ph1">`postBuffer`</ph> 包含你想要遵照该文件的数据。</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">如果<ph id="ph1">`fileName`</ph>是在本地目录中，则可以标识与只是文件的名称; 否则，必须指定完整路径和文件的名称。</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">通配符 ("...<ph id="ph1">\\</ph>\myfile.txt") 和 UNC 共享名 ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared 目录<ph id="ph5">\\</ph>\myfile.txt") 支持。</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">如果未找到文件，该异常<ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">`flags`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
          <target state="translated"><ph id="ph1">`flags`</ph>参数提供关于文件传输的其他信息的窗口套接字服务提供程序。</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
          <target state="translated">有关如何使用此参数的详细信息，请参阅<ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">此方法使用<ph id="ph1">`TransmitFile`</ph>Windows 套接字 2 API 中找到函数。</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`TransmitFile`</ph>函数和其标志，请参阅 MSDN 库中的 Windows 套接字文档。</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>方法会启动异步发送操作中建立的远程主机<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> 引发异常，如果不首先调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method gives you the ability to send a file within a separate execution thread.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>方法使你能够发送单独的执行线程中的文件。</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>To complete the operation, you can create a callback method that is invoked by the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate parameter.</source>
          <target state="translated">若要完成该操作，你可以创建由调用的回调方法<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>委托参数。</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, the <ph id="ph1">`state`</ph> parameter must contain the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object being used for communication.</source>
          <target state="translated">为此，请至少，<ph id="ph1">`state`</ph>参数必须包含<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>对象用于进行通信。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">如果你的回调需要详细信息，可以创建类或结构，用于保存<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>和其他必需的信息。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this custom object to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">将为此自定义对象的实例传递<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>方法通过<ph id="ph2">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Your callback method must invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method.</source>
          <target state="translated">你的回调方法必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, the system uses a separate thread to execute the specified callback method, and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the entire file or throws an exception.</source>
          <target state="translated">当你的应用程序调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>，系统将使用一个单独的线程执行指定的回调方法，并阻止在<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>直到<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>发送完整的文件或引发异常。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">有关编写回调方法的更多信息，请参阅<bpt id="p1">[</bpt>委托作为回调方法进行封送<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>。</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">适用于面向连接的协议，尽管<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>还应用于无连接协议，前提是你第一次调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法来建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">使用无连接协议，你还必须确保你的文件的大小不能超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">如果是这样，不会发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>异常。</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>异常，请改用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</source>
          <target state="translated">下面的代码示例创建和连接进行异步通信套接字并开始文件"text.txt"以异步方式发送到远程主机。</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>In this example, a <ph id="ph1">`preBuffer`</ph> and a <ph id="ph2">`postBuffer`</ph> of data is created to send with the file and the default <ph id="ph3">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> value is used.</source>
          <target state="translated">在此示例中，<ph id="ph1">`preBuffer`</ph>和<ph id="ph2">`postBuffer`</ph>的数据创建要与文件和默认值一起发送<ph id="ph3">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>使用值。</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> to complete the transmission.</source>
          <target state="translated">回调委托调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>完成传输。</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The operating system is not Windows NT or later.</source>
          
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">\-</ph> or -</source>
          
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The socket is not connected to a remote host.</source>
          
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The zero-based position in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin sending data.</source>
          
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The number of bytes to send.</source>
          
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a specific remote host.</source>
          
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method starts an asynchronous send operation to the remote host specified in the <ph id="ph2">`remoteEP`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>方法会启动异步发送操作中指定远程主机<ph id="ph2">`remoteEP`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>方法使你能够发送单独的执行线程中的数据。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> works with both connectionless and connection-oriented protocols.</source>
          <target state="translated">虽然供无连接协议，但是<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>适用于无连接和面向连接的协议。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method.</source>
          <target state="translated">你可以创建实现一个回调方法<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>委托并将传递到其名称<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">为此，请至少，你<ph id="ph1">`state`</ph>参数必须包含连接或默认<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>用于进行通信。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and the other required information.</source>
          <target state="translated">如果你的回调需要详细信息，你可以创建一个小型类来保存<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，和其他必需的信息。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">将此类的实例传递<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>方法通过<ph id="ph2">`state`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method.</source>
          <target state="translated">你的回调方法应调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">当你的应用程序调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>，系统将使用一个单独的线程执行的指定的回调方法，并阻止<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>直到<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>发送请求的字节数或引发异常。</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">如果你想要阻止后调用的原始线程<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>方法，请使用<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">当你想要继续执行原始线程时，请在回调方法调用 Set 方法。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For additional information about writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">有关编写回调方法的其他信息请参阅<bpt id="p1">[</bpt>委托作为回调方法进行封送<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> will throw a <ph id="ph6">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你使用的一个面向连接的协议，必须先调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>，或<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法，或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>将引发<ph id="ph6">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and send data to the <ph id="ph3">&lt;xref:System.Net.EndPoint&gt;</ph> established in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> 将忽略<ph id="ph2">`remoteEP`</ph>参数并将数据发送到<ph id="ph3">&lt;xref:System.Net.EndPoint&gt;</ph>中建立<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>， <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>， <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>，或<ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的是无连接协议，不需要建立默认远程主机使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法之前调用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">只需执行此操作，如果你想要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph4">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法之前调用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>、<ph id="ph4">`remoteEP`</ph>只为发送操作，参数将覆盖指定的默认远程主机。</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">你还无需调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>In this case, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">在这种情况下，基础服务提供程序将分配的最合适的本地网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Use a port number of zero if you want the underlying service provider to select a free port.</source>
          <target state="translated">如果你想要选择可用端口的基础服务提供程序，请使用端口号 0。</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">如果你需要确定分配的本地网络地址和端口号，则可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>属性后的<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>方法已成功完成。</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你想要将数据发送到广播地址，则必须首先调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>方法并设置套接字选项设为<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">-你还必须确保你的缓冲区的大小不能超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果是这样，将不发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">如果指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>标记为<ph id="ph2">`socketflags`</ph>参数，发送的无法路由的数据。</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">在特定上下文首次使用后 (异步特定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>方法、 特定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例和特定的回调)，以后使用该上下文将提高性能。</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The following code example asynchronously sends data to the specified remote host.</source>
          <target state="translated">下面的代码示例以异步方式将数据发送到指定的远程主机。</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>The local <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> to associate with the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Associates a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> with a local endpoint.</source>
          
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method if you need to use a specific local endpoint.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法如果你需要使用特定的本地终结点。</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method.</source>
          <target state="translated">必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>才能调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You do not need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method unless you need to use a specific local endpoint.</source>
          <target state="translated">不需要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>之前使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法除非你需要使用特定的本地终结点。</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method on both connectionless and connection-oriented protocols.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>无连接和面向连接的协议方法。</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>, you must first create the local <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> from which you intend to communicate data.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>，你必须首先创建本地<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>从想要进行数据通信。</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you do not care which local address is assigned, you can create an <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> using <ph id="ph2">&lt;xref:System.Net.IPAddress.Any?displayProperty=nameWithType&gt;</ph> as the address parameter, and the underlying service provider will assign the most appropriate network address.</source>
          <target state="translated">如果你不关心哪些本地地址分配，你可以创建<ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph>使用<ph id="ph2">&lt;xref:System.Net.IPAddress.Any?displayProperty=nameWithType&gt;</ph>地址参数，以及基础服务提供程序将分配的最合适的网络地址。</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>This might help simplify your application if you have multiple network interfaces.</source>
          <target state="translated">这可能有助于简化你的应用程序，如果你有多个网络接口。</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you do not care which local port is used, you can create an <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> using 0 for the port number.</source>
          <target state="translated">如果你不关心使用哪个本地端口，则可以创建<ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph>使用 0 作为端口号。</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>In this case, the service provider will assign an available port number between 1024 and 5000.</source>
          <target state="translated">在这种情况下，服务提供商将分配 1024年和 5000 之间可用的端口号。</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you use the above approach, you can discover what local network address and port number has been assigned by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>.</source>
          <target state="translated">如果使用上面的方法，你可能会发现已通过调用分配了哪些本地网络地址和端口数量<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> will not return the locally assigned network address until after you have made a call to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>后所做的调用不会返回之前的本地分配的网络地址<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</source>
          <target state="translated">如果你使用的是无连接协议，将不具有访问此信息，直到已完成发送或接收。</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If a UDP socket wants to receive interface information on received packets,  the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method should be explicitly called with the socket option set to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> immediately after calling the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">如果 UDP 套接字想要接收上接收数据包的接口信息<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>应该与套接字选项设置为显式调用方法<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>后立即调用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you intend to receive multicast datagrams, you must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method with a multicast port number.</source>
          <target state="translated">如果你想要接收多播数据报，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法具有多路广播的端口号。</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method if you intend to receive connectionless datagrams using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法如果你想要接收无连接数据报使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, use the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>调用时<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法，请使用<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>The following code example binds a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> using the specified local endpoint.</source>
          <target state="translated">下面的代码示例将绑定<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>使用指定的本地终结点。</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="localEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          
        </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>for accepting connections from the host defined by <ph id="ph1">&lt;paramref name="localEP" /&gt;</ph>.</source>
          <target state="translated">用于接受来自定义的主机的连接<ph id="ph1">&lt;paramref name="localEP" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>Gets or sets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is in blocking mode.</source>
          
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> will block; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 如果<ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>将阻止; 否则为<ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property indicates whether a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is in blocking mode.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph>属性指示是否<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>处于阻止模式。</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</source>
          <target state="translated">如果你是在阻止模式下，并且进行方法调用这不会立即完成，你的应用程序将请求的操作完成之前阻止执行。</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you want execution to continue even though the requested operation is not complete, change the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果你想执行要继续即使请求的操作未完成，更改<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph>属性<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property has no effect on asynchronous methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph>属性不起作用对异步方法。</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you are sending and receiving data asynchronously and want to block execution, use the <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> class.</source>
          <target state="translated">如果你是发送和异步接收数据，并想要阻止执行，使用<ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object used to request the connection to the remote host by calling one of the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph> methods.</source>
          
        </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Cancels an asynchronous request for a remote host connection.</source>
          
        </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.CancelConnectAsync%2A&gt;</ph> method cancels an asynchronous request for a remote host connection.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.CancelConnectAsync%2A&gt;</ph>方法取消对远程主机连接的异步请求。</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null and the <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          
        </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connection and releases all associated resources.</source>
          
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Close">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connection and releases all associated resources.</source>
          
        </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method closes the remote host connection and releases all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法关闭远程主机连接并释放所有托管和非托管资源与关联<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>Upon closing, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">结算时，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>属性设置为<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>For connection-oriented protocols, it is recommended that you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">对于面向连接的协议，建议您调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
          <target state="translated">这可确保发送和关闭之前连接的套接字上接收到的所有数据。</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can ensure that data queued for outgoing transmission will be sent by setting the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option to <ph id="ph5">`false`</ph> and specifying a non-zero time-out interval.</source>
          <target state="translated">如果你需要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>而无需首先调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>，你可以确保数据排队等待传出传输将发送通过设置<ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>选项设为<ph id="ph5">`false`</ph>并指定非零的超时间隔。</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> will then block until this data is sent or until the specified time-out expires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> 然后将阻止状态，直到发送此数据，或直到指定的超时时间已到。</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
          <target state="translated">如果你设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>到<ph id="ph2">`false`</ph>并指定零的超时间隔、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>释放连接并自动放弃传出排队的数据。</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>To set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to <ph id="ph2">`false`</ph>, create a <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, set the enabled property to <ph id="ph4">`true`</ph>, and set the <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property to the desired time out period.</source>
          <target state="translated">若要设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>套接字选项<ph id="ph2">`false`</ph>，创建<ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>，将启用的属性设置为<ph id="ph4">`true`</ph>，并设置<ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph>到所需的超时期间的属性。</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>Use this <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> along with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">使用此<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>连同<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>套接字选项调用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>The following code example closes a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">下面的代码示例关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Wait up to <bpt id="p1">&lt;c&gt;</bpt>timeout<ept id="p1">&lt;/c&gt;</ept> seconds to send any remaining data, then close the socket.</source>
          
        </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</source>
          
        </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method closes the remote host connection and releases all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法关闭远程主机连接并释放所有托管和非托管资源与关联<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Upon closing, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">结算时，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>属性设置为<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>For connection-oriented protocols, it is recommended that you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>.</source>
          <target state="translated">对于面向连接的协议，建议您调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
          <target state="translated">这可确保发送和关闭之前连接的套接字上接收到的所有数据。</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can ensure that data queued for outgoing transmission will be sent by setting the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> option to <ph id="ph4">`false`</ph> and specifying a non-zero time-out interval.</source>
          <target state="translated">如果你需要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>而无需首先调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>，你可以确保数据排队等待传出传输将发送通过设置<ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>选项设为<ph id="ph4">`false`</ph>并指定非零的超时间隔。</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> will then block until this data is sent or until the specified time-out expires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> 然后将阻止状态，直到发送此数据，或直到指定的超时时间已到。</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
          <target state="translated">如果你设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>到<ph id="ph2">`false`</ph>并指定零的超时间隔、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>释放连接并自动放弃传出排队的数据。</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>To set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to <ph id="ph2">`false`</ph>, create a <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, set the enabled property to <ph id="ph4">`true`</ph>, and set the <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property to the desired time-out period.</source>
          <target state="translated">若要设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>套接字选项<ph id="ph2">`false`</ph>，创建<ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>，将启用的属性设置为<ph id="ph4">`true`</ph>，并设置<ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph>到所需的超时期间的属性。</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Use this <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> along with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">使用此<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>连同<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>套接字选项调用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>The following code example demonstrates how to close a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">下面的代码示例演示如何关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Establishes a connection to a remote host.</source>
          
        </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the remote device.</source>
          
        </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Establishes a connection to a remote host.</source>
          
        </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
          <target state="translated">如果你使用的使用面向连接的协议 TCP，例如<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法以同步方式网络之间建立连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>和指定的远程终结点。</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">如果你使用的是无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">调用后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，你可以将数据发送到远程设备与<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法，或从远程设备与接收数据<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">如果使用如 UDP 无连接协议时，不需要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>之前发送和接收数据。</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>能够同步与远程主机通信。</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，来自地址而不是指定默认的地址的任何数据报将被放弃。</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你想要将默认远程主机为广播地址，则必须首先调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>方法并设置套接字选项设为<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>，或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>将引发<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法将一直阻止，除非专门设置<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph>属性<ph id="ph3">`false`</ph>之前调用<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">如果你使用一个面向连接的协议，如 TCP 和你确实禁用了阻止，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>因为它需要时间来建立连接。</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">无连接协议不会引发异常，因为它们只需要建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>以获得特定错误代码。</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">如果 WSAEWOULDBLOCK 返回的错误，已由一个面向连接的启动远程主机连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，但未尚未成功完成。</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph>方法来确定何时<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>完成连接。</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">如果你使用一个面向连接的协议，并且未调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，基础服务提供程序将分配的本地网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">如果你使用的是无连接协议，服务提供程序将不会分配本地网络地址和端口号，直到完成发送或接收操作。</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">如果你想要更改默认远程主机时，调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>再次使用所需终结点。</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">如果之前断开连接的套接字，然后无法使用此方法以恢复连接。</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">使用异步之一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法重新连接。</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">这是基础提供程序的限制。</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">下面的代码示例连接到远程终结点，并接着验证连接。</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          
        </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>for connecting to the remote host.</source>
          <target state="translated">用于连接到远程主机。</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Connect" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Connect" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The IP address of the remote host.</source>
          
        </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The port number of the remote host.</source>
          
        </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Establishes a connection to a remote host.</source>
          
        </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The host is specified by an IP address and a port number.</source>
          
        </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
          <target state="translated">如果你使用的使用面向连接的协议 TCP，例如<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法以同步方式网络之间建立连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>和指定的远程终结点。</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">如果你使用的是无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">调用后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>你可以将数据发送到远程设备与<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法，或从远程设备与接收数据<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">如果使用如 UDP 无连接协议时，不需要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>之前发送和接收数据。</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>能够同步与远程主机通信。</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>来自地址而不是指定默认的地址的任何数据报将被放弃。</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你想要将默认远程主机为广播地址，则必须首先调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>方法并设置套接字选项设为<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>，或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>将引发<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> 方法将一直阻止，除非专门设置<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph>属性<ph id="ph3">`false`</ph>之前调用<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">如果你使用一个面向连接的协议，如 TCP 和你确实禁用了阻止，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>因为它需要时间来建立连接。</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">无连接协议不会引发异常，因为它们只需要建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>以获得特定错误代码。</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">如果 WSAEWOULDBLOCK 返回的错误，已由一个面向连接的启动远程主机连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，但未尚未成功完成。</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph>方法来确定何时<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>完成连接。</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">如果你使用一个面向连接的协议，并且未调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，基础服务提供程序将分配的本地网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">如果你使用的是无连接协议，服务提供程序将不会分配本地网络地址和端口号，直到完成发送或接收操作。</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">如果你想要更改默认远程主机时，调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>再次使用所需终结点。</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">如果之前断开连接的套接字，然后无法使用此方法以恢复连接。</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">使用异步之一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法重新连接。</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">这是基础提供程序的限制。</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">下面的代码示例连接到远程终结点，并接着验证连接。</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="address" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The port number is not valid.</source>
          
        </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          
        </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          
        </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The IP addresses of the remote host.</source>
          
        </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The port number of the remote host.</source>
          
        </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Establishes a connection to a remote host.</source>
          
        </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The host is specified by an array of IP addresses and a port number.</source>
          
        </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This method is typically used immediately after a call to <ph id="ph1">&lt;xref:System.Net.Dns.GetHostAddresses%2A&gt;</ph>, which can return multiple IP addresses for a single host.</source>
          <target state="translated">在调用之后立即通常使用此方法<ph id="ph1">&lt;xref:System.Net.Dns.GetHostAddresses%2A&gt;</ph>，这可以针对单个主机返回多个 IP 地址。</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
          <target state="translated">如果你使用的使用面向连接的协议 TCP，例如<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法以同步方式网络之间建立连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>和指定的远程终结点。</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">如果你使用的是无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">调用后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>你可以将数据发送到远程设备与<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法，或从远程设备与接收数据<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">如果使用如 UDP 无连接协议时，不需要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>之前发送和接收数据。</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>能够同步与远程主机通信。</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>来自地址而不是指定默认的地址的任何数据报将被放弃。</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你想要将默认远程主机为广播地址，则必须首先调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>方法并设置套接字选项设为<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>，或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>将引发<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> 方法将一直阻止，除非专门设置<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph>属性<ph id="ph3">`false`</ph>之前调用<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">如果你使用一个面向连接的协议，如 TCP 和你确实禁用了阻止，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>因为它需要时间来建立连接。</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">无连接协议不会引发异常，因为它们只需要建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>以获得特定错误代码。</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">如果 WSAEWOULDBLOCK 返回的错误，已由一个面向连接的启动远程主机连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，但未尚未成功完成。</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph>方法来确定何时<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>完成连接。</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">如果你使用一个面向连接的协议，并且未调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，基础服务提供程序将分配的本地网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">如果你使用的是无连接协议，服务提供程序将不会分配本地网络地址和端口号，直到完成发送或接收操作。</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">如果你想要更改默认远程主机时，调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>再次使用所需终结点。</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">如果之前断开连接的套接字，然后无法使用此方法以恢复连接。</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">使用异步之一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法重新连接。</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">这是基础提供程序的限制。</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">下面的代码示例连接到远程终结点，并接着验证连接。</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The port number is not valid.</source>
          
        </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          
        </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          
        </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The name of the remote host.</source>
          
        </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The port number of the remote host.</source>
          
        </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Establishes a connection to a remote host.</source>
          
        </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The host is specified by a host name and a port number.</source>
          
        </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote host.</source>
          <target state="translated">如果你使用的使用面向连接的协议 TCP，例如<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法以同步方式网络之间建立连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>和指定的远程主机。</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">如果你使用的是无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">调用后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>你可以将数据发送到远程设备与<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法，或从远程设备与接收数据<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">如果使用如 UDP 无连接协议时，不需要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>之前发送和接收数据。</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>能够同步与远程主机通信。</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>来自地址而不是指定默认的地址的任何数据报将被放弃。</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你想要将默认远程主机为广播地址，则必须首先调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>方法并设置套接字选项设为<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>，或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>将引发<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> 方法将一直阻止，除非专门设置<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph>属性<ph id="ph3">`false`</ph>之前调用<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">如果你使用一个面向连接的协议，如 TCP 和你确实禁用了阻止，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>因为它需要时间来建立连接。</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">无连接协议不会引发异常，因为它们只需要建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>以获得特定错误代码。</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">如果 WSAEWOULDBLOCK 返回的错误，已由一个面向连接的启动远程主机连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，但未尚未成功完成。</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph>方法来确定何时<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>完成连接。</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If IPv6 is enabled and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29&gt;</ph> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</source>
          <target state="translated">如果启用了 IPv6 和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29&gt;</ph>调用方法来连接到的主机，将解析为这两个 IPv6 和 IPv4 地址、 IPv6 地址将与连接尝试之前的 IPv4 地址的第一个。</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</source>
          <target state="translated">这可能产生的延迟的时间来建立连接，如果主机未侦听 IPv6 地址的效果。</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">如果你使用一个面向连接的协议，并且未调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，基础服务提供程序将分配的本地网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">如果你使用的是无连接协议，服务提供程序将不会分配本地网络地址和端口号，直到完成发送或接收操作。</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">如果你想要更改默认远程主机时，调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>再次使用所需终结点。</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">如果之前断开连接的套接字，然后无法使用此方法以恢复连接。</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">使用异步之一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法重新连接。</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">这是基础提供程序的限制。</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">下面的代码示例连接到远程终结点，并接着验证连接。</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="host" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The port number is not valid.</source>
          
        </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          
        </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
          
        </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          
        </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
          
        </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          
        </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          
        </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          
        </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          
        </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method starts an asynchronous request for a connection to the remote host.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法会启动与远程主机的连接的异步请求。</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">如果你使用的是无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">若要在完成时得到通知，必须创建实现的回调方法<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; 委托和附加到回调<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host to connect to.</source>
          <target state="translated">调用方必须设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>属性<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>要连接到的远程主机。</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">调用方可能设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>到在调用前要求任何用户状态对象的属性<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法，以便在回叫方法可检索信息。</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">如果使用如 UDP 无连接协议时，不需要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>之前发送和接收数据。</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> to communicate with a remote host.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph>与远程主机通信。</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>，来自地址而不是指定默认的地址的任何数据报将被放弃。</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method again with the desired endpoint.</source>
          <target state="translated">如果你想要更改默认远程主机时，调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>再次使用所需终结点的方法。</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you wish to set the default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">如果你想要设置为广播地址的默认远程主机，必须先调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>并将广播设置为<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If this is not done, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果不执行此操作，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法会引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required:</source>
          <target state="translated">下列属性和事件上的<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>是必需的对象：</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Optionally, a buffer may be provided which will atomically be sent on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
          <target state="translated">（可选） 缓冲区可能会提供它以原子方式发送后的套接字上<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法成功。</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the buffer containing the data to send and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the number of bytes of data to send from the buffer.</source>
          <target state="translated">在这种情况下，<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph>属性应设置为包含数据的缓冲区，以发送和<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph>属性应设置为数据的字节数，以从该缓冲区发送。</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Once a connection is established, this buffer of data is sent.</source>
          <target state="translated">一旦建立的连接，该缓冲区中的数据被发送。</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">如果你使用的是面向连接的协议，并且不调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>，基础服务提供程序将分配的最合适的本地网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> methods.</source>
          <target state="translated">如果你使用的是无连接协议，直到你调用，则服务提供程序将不分配本地网络 IP 地址和端口号<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method throws <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> if the address family of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> are not the same address family.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法抛出异常<ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>如果的地址族<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>和<ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>不是相同的地址族。</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling this method, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>调用此方法时，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is not valid.</source>
          
        </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if multiple buffers are specified, the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> property is not null.</source>
          
        </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null and the <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          
        </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is listening or a socket operation was already in progress using the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the local endpoint and the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> are not the same address family.</source>
          
        </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          
        </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          
        </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
          
        </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          
        </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          
        </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          
        </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          
        </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</source>
          <target state="translated">如果你使用的一个面向连接的协议，M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) 方法会启动对的异步请求连接到远程主机。</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> establishes a default remote host specified by the <ph id="ph2">`socketType`</ph> and <ph id="ph3">`protocolType`</ph> parameters.</source>
          <target state="translated">如果你使用的是无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>建立默认远程主机由指定<ph id="ph2">`socketType`</ph>和<ph id="ph3">`protocolType`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">若要在完成时得到通知，必须创建实现的回调方法<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; 委托和附加到回调<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host to connect to.</source>
          <target state="translated">调用方必须设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>属性<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>要连接到的远程主机。</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">调用方可能设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>到在调用前要求任何用户状态对象的属性<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法，以便在回叫方法可检索信息。</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">如果使用如 UDP 无连接协议时，不需要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>之前发送和接收数据。</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> to communicate with a remote host.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph>与远程主机通信。</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>，来自地址而不是指定默认的地址的任何数据报将被放弃。</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method again with the desired endpoint.</source>
          <target state="translated">如果你想要更改默认远程主机时，调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>再次使用所需终结点的方法。</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you wish to set the default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">如果你想要设置为广播地址的默认远程主机，必须先调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>并将广播设置为<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If this is not done, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果不执行此操作，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法会引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required:</source>
          <target state="translated">下列属性和事件上的<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>是必需的对象：</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Optionally, a buffer may be provided which will atomically be sent on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
          <target state="translated">（可选） 缓冲区可能会提供它以原子方式发送后的套接字上<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法成功。</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the buffer containing the data to send and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the number of bytes of data to send from the buffer.</source>
          <target state="translated">在这种情况下，<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph>属性应设置为包含数据的缓冲区，以发送和<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph>属性应设置为数据的字节数，以从该缓冲区发送。</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Once a connection is established, this buffer of data is sent.</source>
          <target state="translated">一旦建立的连接，该缓冲区中的数据被发送。</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">如果你使用的是面向连接的协议，并且不调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>，基础服务提供程序将分配的最合适的本地网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> methods.</source>
          <target state="translated">如果你使用的是无连接协议，直到你调用，则服务提供程序将不分配本地网络 IP 地址和端口号<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method throws <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> if the address family of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> are not the same address family.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法抛出异常<ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>如果的地址族<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>和<ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>不是相同的地址族。</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling this method, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>调用此方法时，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is not valid.</source>
          
        </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if multiple buffers are specified, the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> property is not null.</source>
          
        </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null and the <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          
        </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is listening or a socket operation was already in progress using the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the local endpoint and the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> are not the same address family.</source>
          
        </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          
        </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Connected">
          <source>Gets a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is connected to a remote host as of the last <ph id="ph2">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> or <ph id="ph3">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph> operation.</source>
          
        </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> was connected to a remote resource as of the most recent operation; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 如果<ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>连接到远程资源截止到最近的操作; 否则为<ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>The <ph id="ph1">`Connected`</ph> property gets the connection state of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> as of the last I/O operation.</source>
          <target state="translated"><ph id="ph1">`Connected`</ph>属性获取的连接状态<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>截止到最后一个的 I/O 操作。</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>When it returns <ph id="ph1">`false`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> was either never connected, or is no longer connected.</source>
          <target state="translated">如果该属性返回<ph id="ph1">`false`</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>要么从未连接，或已断开连接。</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>The value of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property reflects the state of the connection as of the most recent operation.</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>属性反映截至最近的操作连接的状态。</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</source>
          <target state="translated">如果你需要确定连接的当前状态，请调用阻止、 零字节发送。</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</source>
          <target state="translated">如果调用成功返回，或者引发 WAEWOULDBLOCK 错误代码 (10035)，则仍会连接套接字;否则，套接字已断开连接。</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>If you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> on a User Datagram Protocol (UDP) socket, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property always returns <ph id="ph3">`true`</ph>; however, this action does not change the inherent connectionless nature of UDP.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>用户数据报协议 (UDP) 套接字上,<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>属性始终返回<ph id="ph3">`true`</ph>; 但是，此操作不会更改的 UDP 固有无连接的特点。</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>The following code example connects to a remote endpoint, checks the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property, and checks the current state of the connection.</source>
          <target state="translated">下面的代码示例连接到远程终结点，检查<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>属性，并检查连接的当前状态。</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this socket can be reused after the current connection is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>Closes the socket connection and allows reuse of the socket.</source>
          
        </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you are using a connection-oriented protocol, you can use this method to close the socket.</source>
          <target state="translated">如果你使用的一个面向连接的协议，你可以使用此方法关闭套接字。</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>This method ends the connection and sets the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">此方法将结束的连接和集<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>属性<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>However, if <ph id="ph1">`reuseSocket`</ph> is <ph id="ph2">`true`</ph>, you can reuse the socket.</source>
          <target state="translated">但是，如果<ph id="ph1">`reuseSocket`</ph>是<ph id="ph2">`true`</ph>，你可以重复使用套接字。</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>To ensure that all data is sent and received before the socket is closed, you should call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> method.</source>
          <target state="translated">若要确保所有数据是发送和接收套接字关闭之前，应调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can set the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option to <ph id="ph5">`false`</ph> and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</source>
          <target state="translated">如果你需要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph>而无需首先调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>，你可以设置<ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>选项设为<ph id="ph5">`false`</ph>和指定非零的超时间隔，以确保排队等待发送传出传输的数据。</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> then blocks until the data is sent or until the specified time-out expires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> 然后阻止，直到发送数据，或直到指定的超时时间已到。</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
          <target state="translated">如果你设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>到<ph id="ph2">`false`</ph>并指定零的超时间隔、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>释放连接并自动放弃传出排队的数据。</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>The following code example creates a socket for synchronous communication and sends some data to a remote host.</source>
          <target state="translated">下面的代码示例创建进行同步通信套接字，并将一些数据发送到远程主机。</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>It then calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, to stop the send and receive activity, and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph>, to close the socket connection.</source>
          <target state="translated">然后，它调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>，以停止发送和接收活动，和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph>以关闭套接字连接。</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>This method requires Windows 2000 or earlier, or the exception will be thrown.</source>
          
        </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          
        </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request to disconnect from a remote endpoint.</source>
          
        </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          
        </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          
        </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          
        </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          
        </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>When using a connection-oriented protocol, calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DisconnectAsync%2A&gt;</ph> method requests a disconnect from a remote endpoint.</source>
          <target state="translated">当使用面向连接的协议时，调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DisconnectAsync%2A&gt;</ph>方法从远程终结点请求断开连接。</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType&gt;</ph> to <ph id="ph2">`true`</ph> in the <ph id="ph3">`e`</ph> parameter, the socket can be reused.</source>
          <target state="translated">如果你设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType&gt;</ph>到<ph id="ph2">`true`</ph>中<ph id="ph3">`e`</ph>参数，可以重用套接字。</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null.</source>
          
        </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          
        </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          
        </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Call <ph id="ph1">`Dispose`</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">在完成使用 <ph id="ph1">`Dispose`</ph> 后，应调用 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>The <ph id="ph1">`Dispose`</ph> method leaves the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> in an unusable state.</source>
          <target state="translated"><ph id="ph1">`Dispose`</ph> 方法使 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> 处于不可用状态。</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>After calling <ph id="ph1">`Dispose`</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> was occupying.</source>
          <target state="translated">在调用<ph id="ph1">`Dispose`</ph>，必须释放对所有引用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>以便垃圾回收器才能回收的内存，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>占用。</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>清洗向上非托管资源<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>和<bpt id="p2">[</bpt>实现 Dispose 方法<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Always call <ph id="ph1">`Dispose`</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">每次释放对 <ph id="ph1">`Dispose`</ph> 的最后一个引用前，均应调用 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object's <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">否则，在垃圾回收器调用 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> 对象的 <ph id="ph2">`Finalize`</ph> 方法之前，该对象正在使用的资源不会被释放。</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to releases only unmanaged resources.</source>
          
        </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, and optionally disposes of the managed resources.</source>
          
        </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">`Dispose()`</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">此方法称为由公共<ph id="ph1">`Dispose()`</ph>方法和<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">`Dispose()`</ph> invokes the protected <ph id="ph2">`Dispose(Boolean)`</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">`Dispose()`</ph> 调用受保护<ph id="ph2">`Dispose(Boolean)`</ph>方法替换<ph id="ph3">`disposing`</ph>参数设置为<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id="ph2">`Dispose`</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> 调用<ph id="ph2">`Dispose`</ph>与<ph id="ph3">`disposing`</ph>设置为<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> references.</source>
          <target state="translated">当 <ph id="ph1">`disposing`</ph> 参数为 <ph id="ph2">`true`</ph> 时，此方法释放该 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> 引用的、由任何托管对象持有的全部资源。</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">`Dispose()`</ph> method of each referenced object.</source>
          <target state="translated">此方法调用每个引用对象的 <ph id="ph1">`Dispose()`</ph> 方法。</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> 可以由其他对象多次调用。</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>, be careful not to reference objects that have been previously disposed of in an earlier call to <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph>.</source>
          <target state="translated">重写 <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph> 时，请注意不要引用在以前调用 <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph> 时已释放的对象。</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">有关如何实现详细信息<ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>，请参阅<bpt id="p1">[</bpt>实现 Dispose 方法<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Overriding the Finalize Method<ept id="p2">](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)</ept>.</source>
          <target state="translated">有关详细信息<ph id="ph1">&lt;see langword="Dispose" /&gt;</ph>和<ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>，请参阅<bpt id="p1">[</bpt>清洗向上非托管资源<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>和<bpt id="p2">[</bpt>重写 Finalize 方法<ept id="p2">](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)</ept>。</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows Internet Protocol (IP) datagrams to be fragmented.</source>
          
        </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows datagram fragmentation; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 如果<ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>允许数据报碎片; 否则为<ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</source>
          <target state="translated">其大小超过最大传输单元 (MTU) 的传输介质时，数据报需要碎片。</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</source>
          <target state="translated">可以对数据报消息分片通过发送主机 （所有 Internet 协议版本） 或中间的路由器 (Internet 协议版本 4 仅)。</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>If a datagram must be fragmented, and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</source>
          <target state="translated">如果必须碎片数据报，和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph>选项设置、 数据报将被丢弃，以及 Internet 控制消息协议 (ICMP) 错误消息发送回数据报的发件人。</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
          <target state="translated">传输控制协议 (TCP) 套接字上设置此属性将产生任何影响。</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例演示如何将<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>This property can be set only for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          
        </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DualMode">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is a dual-mode socket used for both IPv4 and IPv6.</source>
          
        </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DualMode">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is a  dual-mode socket; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> 是双模式套接字，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DualMode">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>The ID of the target process where a duplicate of the socket reference is created.</source>
          
        </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>Duplicates the socket reference for the target process, and closes the socket for this process.</source>
          
        </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>The socket reference to be passed to the target process.</source>
          
        </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>The target process should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> to create the duplicate socket instance.</source>
          <target state="translated">目标进程应使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>创建重复的套接字实例。</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances with the same underlying socket.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>多次使用相同的字节数组作为每个调用的参数的构造函数，你将创建多个托管<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>具有相同的基础套接字的实例。</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>This practice is strongly discouraged.</source>
          <target state="translated">强烈建议不要使用这种做法。</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>If the process creating the socket uses asynchronous methods (<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>), the process must first set the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A&gt;</ph> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph> to be thrown on the target process.</source>
          <target state="translated">如果进程创建套接字使用异步方法 (<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>)，必须首先设置过程<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A&gt;</ph>属性设置为 true; 否则为套接字绑定到完成端口的创建过程中，这可能导致<ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph>上目标进程引发。</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="targetProcessID" /&gt;</ph> is not a valid process id.</source>
          
        </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>Duplication of the socket reference failed.</source>
          
        </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> can send or receive broadcast packets.</source>
          
        </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows broadcast packets; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 如果<ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>允许广播的数据包数; 否则为<ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</source>
          <target state="translated">广播将仅限于特定子网，并且必须使用用户数据报协议 (UDP)。有关 Internet 协议版本 4，您可以通过将数据包发送到 255.255.255.255; 广播本地子网或者，你可以使用定向广播的地址，这是与设置的主机部分中的所有位的 Internet 协议 (IP) 地址的网络部分。</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</source>
          <target state="translated">例如，如果你的 IP 地址为 192.168.1.40 （C 类地址，网络掩码为 255.255.255.0-网络部分是前三个八位字节，和的主机部分是最后一个八位字节），则定向广播的地址是 192.168.1.255。</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
          <target state="translated">传输控制协议 (TCP) 套接字上设置此属性将产生任何影响。</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EnableBroadcast%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例演示如何将<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EnableBroadcast%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>This option is valid for a datagram socket only.</source>
          
        </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Asynchronously accepts an incoming connection attempt.</source>
          
        </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the bytes transferred.</source>
          
        </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information for this asynchronous operation as well as any user defined data.</source>
          
        </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle remote host communication.</source>
          
        </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>This method returns a buffer that contains the initial data transferred.</source>
          
        </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle communication with the remote host.</source>
          
        </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> 完成对调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that is invoked by the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>，你需要创建一个由调用的回调方法<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>委托。</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
          <target state="translated">此回调方法在单独的线程中，执行之后, 由系统调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法返回。</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">在回调方法中，调用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>方法<ph id="ph2">`asyncResult`</ph>参数来获取<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>对其进行连接尝试。</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">获取之后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，可以调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>方法才能成功完成连接尝试。</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">`buffer`</ph> parameter of this overload contains the data that was received in the call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and the <ph id="ph3">`bytesTransferred`</ph> parameter contains the number of bytes that were transferred in the call.</source>
          <target state="translated"><ph id="ph1">`buffer`</ph>的此重载的参数包含对的调用中收到的数据<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>和<ph id="ph3">`bytesTransferred`</ph>参数包含已传输的调用中的字节数。</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>方法阻止，直到连接正在等待传入的连接队列中。</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>方法接受传入连接，并返回一个新<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>可用来将数据发送到和从远程主机接收数据。</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to create and connect a socket and accept the initial 10 bytes of data.</source>
          <target state="translated">下面的代码示例使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>创建和连接套接字并接受前 10 个字节的数据。</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> to end the asynchronous request.</source>
          <target state="translated">回调委托调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>来结束异步请求。</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The number of bytes transmitted and the data are returned in the <ph id="ph1">`buffer`</ph> and <ph id="ph2">`bytesTransferred`</ph> parameters of this method and are displayed on the console.</source>
          <target state="translated">在中返回传输的字节数和数据<ph id="ph1">`buffer`</ph>和<ph id="ph2">`bytesTransferred`</ph>此方法的参数并在控制台上显示。</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is empty.</source>
          
        </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not created by a call to <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> method was previously called.</source>
          
        </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph></source>
          
        </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> to handle remote host communication.</source>
          
        </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> to handle communication with the remote host.</source>
          
        </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> 完成对调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>，你需要创建实现一个回调方法<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>委托。</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
          <target state="translated">此回调方法在单独的线程中，执行之后, 由系统调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法返回。</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>It must accept the <ph id="ph1">`asyncResult`</ph> parameter returned from the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">它必须接受<ph id="ph1">`asyncResult`</ph>参数从返回<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">在回调方法中，调用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>方法<ph id="ph2">`asyncResult`</ph>参数来获取<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>对其进行连接尝试。</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">获取之后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，可以调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>方法才能成功完成连接尝试。</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>方法阻止，直到连接正在等待传入的连接队列中。</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>方法接受传入连接，并返回一个新<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>可用来将数据发送到和从远程主机接收数据。</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The following code example ends an asynchronous request and creates a new <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept an incoming connection request.</source>
          <target state="translated">下面的代码示例结束的异步请求并创建一个新<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>无法接受传入的连接请求。</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>For a complete example that demonstrates asynchronous communications with sockets, see <bpt id="p1">[</bpt>Socket Code Examples<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</source>
          <target state="translated">有关完整示例，演示与套接字的异步通信的说明，请参阅<bpt id="p1">[</bpt>套接字的代码示例<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not created by a call to <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>See the Remarks section for more information.</source>
          
        </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> method was previously called.</source>
          
        </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the bytes transferred.</source>
          
        </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The number of bytes transferred.</source>
          
        </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information for this asynchronous operation as well as any user defined data.</source>
          
        </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle remote host communication.</source>
          
        </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>This method returns a buffer that contains the initial data and the number of bytes transferred.</source>
          
        </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle communication with the remote host.</source>
          
        </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> 完成对调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that is invoked by the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>，你需要创建一个由调用的回调方法<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>委托。</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
          <target state="translated">此回调方法在单独的线程中，执行之后, 由系统调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法返回。</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>It must accept the <ph id="ph1">`asyncResult`</ph> parameter returned from the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">它必须接受<ph id="ph1">`asyncResult`</ph>参数从返回<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">在回调方法中，调用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>方法<ph id="ph2">`asyncResult`</ph>参数来获取<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>对其进行连接尝试。</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">获取之后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，可以调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>方法才能成功完成连接尝试。</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">`buffer`</ph> parameter of this overload contains the data that was received in the call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and the <ph id="ph3">`bytesTransferred`</ph> parameter contains the number of bytes that were transferred in the call.</source>
          <target state="translated"><ph id="ph1">`buffer`</ph>的此重载的参数包含对的调用中收到的数据<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>和<ph id="ph3">`bytesTransferred`</ph>参数包含已传输的调用中的字节数。</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>方法阻止，直到连接正在等待传入的连接队列中。</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>方法接受传入连接，并返回一个新<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>可用来将数据发送到和从远程主机接收数据。</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to create and connect a socket and accept the initial 10 bytes of data.</source>
          <target state="translated">下面的代码示例使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>创建和连接套接字并接受前 10 个字节的数据。</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> to end the asynchronous request.</source>
          <target state="translated">回调委托调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>来结束异步请求。</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The number of bytes transmitted and the data are returned in the <ph id="ph1">`buffer`</ph> and <ph id="ph2">`bytesTransferred`</ph> parameters of this method and are displayed on the console.</source>
          <target state="translated">在中返回传输的字节数和数据<ph id="ph1">`buffer`</ph>和<ph id="ph2">`bytesTransferred`</ph>此方法的参数并在控制台上显示。</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is empty.</source>
          
        </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not created by a call to <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> method was previously called.</source>
          
        </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>Ends a pending asynchronous connection request.</source>
          
        </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> is a blocking method that completes the asynchronous remote host connection request started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> 在中启动一个完成异步远程主机连接请求的阻止方法<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>，你需要创建实现一个回调方法<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>委托。</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> returns.</source>
          <target state="translated">此回调方法在一个单独的线程中执行之后, 由系统调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>返回。</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">回调方法必须接受<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>返回<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>作为参数的方法。</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">在回调方法中，调用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>参数来获取<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>对其进行连接尝试。</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">获取之后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，可以调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>方法才能成功完成连接尝试。</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>The following code example ends the asynchronous connection attempt.</source>
          <target state="translated">下面的代码示例结束异步连接尝试。</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>For a complete example that demonstrates asynchronous communications with sockets, see <bpt id="p1">[</bpt>Socket Code Examples<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</source>
          <target state="translated">有关完整示例，演示与套接字的异步通信的说明，请参阅<bpt id="p1">[</bpt>套接字的代码示例<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          
        </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous connection.</source>
          
        </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information and any user-defined data for this asynchronous operation.</source>
          
        </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>Ends a pending asynchronous disconnect request.</source>
          
        </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> 完成对调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> method blocks until the disconnect completes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph>方法阻止，直至断开连接完成。</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</source>
          <target state="translated">有关异步操作的信息，请参阅 MSDN 库中的异步编程的概述主题。</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The following code example creates a socket for asynchronous communication and sends some data to a remote host.</source>
          <target state="translated">下面的代码示例创建套接字进行异步通信，并将一些数据发送到远程主机。</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>When the data has been sent, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> is called to stop the send and receive activity.</source>
          <target state="translated">当数据已发送时，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>调用以停止发送和接收活动。</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>Then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> is called to begin a disconnect request.</source>
          <target state="translated">然后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>调用以开始断开连接请求。</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> to end the asynchronous request.</source>
          <target state="translated">回调委托调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph>来结束异步请求。</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>When the request completes, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is queried to test whether the socket is disconnected.</source>
          <target state="translated">完成请求后，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>属性将查询以测试是否断开连接的套接字。</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          
        </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          
        </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous connection.</source>
          
        </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The disconnect request has timed out.</source>
          
        </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Ends a pending asynchronous read.</source>
          
        </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Ends a pending asynchronous read.</source>
          
        </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>方法完成异步读取的操作以启动<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>，你需要创建实现一个回调方法<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>委托。</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
          <target state="translated">此回调方法在一个单独的线程中执行之后, 由系统调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>返回。</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">回调方法必须接受<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>返回<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>作为参数的方法。</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">在回调方法中，调用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>以获取状态对象传递给<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
          <target state="translated">提取接收<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>从此状态对象。</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
          <target state="translated">获取之后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，可以调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>方法已成功完成读取的操作，并返回读取的字节数。</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>方法将一直阻止到的数据是否可用。</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
          <target state="translated">如果你使用的是无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>将读取传入的网络缓冲区中可用的第一个排队数据报。</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>方法将读取多的数据可用最中指定的字节数多<ph id="ph2">`size`</ph>参数<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">如果远程主机关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>与连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>收到方法，并且所有可用数据，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>方法将立即完成并返回零字节。</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>, and extract the buffer contained in the resulting state object.</source>
          <target state="translated">若要获取已接收的数据，请调用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>，然后提取生成的状态对象中包含的缓冲区。</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">若要取消挂起<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>，调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">在线程退出时，由给定线程启动的所有 i/o 操作已取消。</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">如果在线程退出操作完成前，挂起的异步操作可能会失败。</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The following code example ends a pending asynchronous read.</source>
          <target state="translated">下面的代码示例结束挂起的异步读取。</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>For a complete example that demonstrates asynchronous communications with sockets, see <bpt id="p1">[</bpt>Socket Code Examples<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</source>
          <target state="translated">有关完整示例，演示与套接字的异步通信的说明，请参阅<bpt id="p1">[</bpt>套接字的代码示例<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          
        </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous read.</source>
          
        </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that stores state information and any user defined data for this asynchronous operation.</source>
          
        </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          
        </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Ends a pending asynchronous read.</source>
          
        </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>方法完成异步读取的操作以启动<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>，你需要创建实现一个回调方法<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>委托。</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
          <target state="translated">此回调方法在一个单独的线程中执行之后, 由系统调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>返回。</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">回调方法必须接受<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>返回<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>作为参数的方法。</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">在回调方法中，调用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>以获取状态对象传递给<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
          <target state="translated">提取接收<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>从此状态对象。</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
          <target state="translated">获取之后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，可以调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>方法已成功完成读取的操作，并返回读取的字节数。</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>方法将一直阻止到的数据是否可用。</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
          <target state="translated">如果你使用的是无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>将读取传入的网络缓冲区中可用的第一个排队数据报。</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>方法将读取多的数据可用最中指定的字节数多<ph id="ph2">`size`</ph>参数<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">如果远程主机关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>与连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>收到方法，并且所有可用数据，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>方法将立即完成并返回零字节。</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>, and extract the buffer contained in the resulting state object.</source>
          <target state="translated">若要获取已接收的数据，请调用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>，然后提取生成的状态对象中包含的缓冲区。</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">在线程退出时，由给定线程启动的所有 i/o 操作已取消。</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">如果在线程退出操作完成前，挂起的异步操作可能会失败。</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          
        </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous read.</source>
          
        </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Ends a pending asynchronous read from a specific endpoint.</source>
          
        </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If successful, the number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If unsuccessful, returns 0.</source>
          
        </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>方法完成异步读取的操作以启动<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>，你需要创建实现一个回调方法<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>委托。</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> returns.</source>
          <target state="translated">此回调方法在一个单独的线程中执行之后, 由系统调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>返回。</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">回调方法必须接受<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>返回<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>作为参数的方法。</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">在回调方法中，调用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>以获取状态对象传递给<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
          <target state="translated">提取接收<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>从此状态对象。</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
          <target state="translated">获取之后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，可以调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>方法已成功完成读取的操作，并返回读取的字节数。</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>方法将一直阻止到的数据是否可用。</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
          <target state="translated">如果你使用的是无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>将读取传入的网络缓冲区中可用的第一个排队数据报。</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>方法将读取多的数据可用最中指定的字节数多<ph id="ph2">`size`</ph>参数<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">如果远程主机关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>与连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>收到方法，并且所有可用数据，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>方法将立即完成并返回零字节。</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> object, and extract the buffer contained in the resulting state object.</source>
          <target state="translated">若要获取已接收的数据，请调用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>对象，然后提取生成的状态对象中包含的缓冲区。</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>To identify the originating host, extract the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> and cast it to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>.</source>
          <target state="translated">若要标识原始主机，提取<ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>和将其转换为<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> method to obtain the IP address and the <ph id="ph2">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> method to obtain the port number.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph>方法来获取的 IP 地址和<ph id="ph2">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph>方法来获取端口号。</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The following code example ends a pending asynchronous read from a specific <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>.</source>
          <target state="translated">下面的代码示例结束挂起的异步读取从特定<ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          
        </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph> was previously called for the asynchronous read.</source>
          
        </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that stores state information and any user defined data for this asynchronous operation.</source>
          
        </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values for the received packet.</source>
          
        </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The source <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> and interface of the received packet.</source>
          
        </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Ends a pending asynchronous read from a specific endpoint.</source>
          
        </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This method also reveals more information about the packet than <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If successful, the number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If unsuccessful, returns 0.</source>
          
        </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If the operation has not completed, this method blocks until it does.</source>
          <target state="translated">如果该操作未完成，此方法阻止，直至它执行。</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>To perform this operation synchronously, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">若要以同步方式执行此操作，使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Examine <ph id="ph1">`ipPacketInformation`</ph> if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
          <target state="translated">检查<ph id="ph1">`ipPacketInformation`</ph>如果你需要知道是否使用单播、 多播或广播地址发送数据报。</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          
        </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="endPoint" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          
        </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /&gt;</ph> was previously called for the asynchronous read.</source>
          
        </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Ends a pending asynchronous send.</source>
          
        </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>Ends a pending asynchronous send.</source>
          
        </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If successful, the number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>; otherwise, an invalid <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> error.</source>
          
        </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> 完成异步发送操作以启动<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>，你需要创建实现一个回调方法<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>委托。</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> returns.</source>
          <target state="translated">此回调方法在一个单独的线程中执行之后, 由系统调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>返回。</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">回调方法必须接受<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>返回<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>作为参数的方法。</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">在回调方法中，调用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>参数来获取发送<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
          <target state="translated">获取之后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，可以调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>方法已成功完成发送操作并返回发送的字节数。</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">如果你使用的是无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>将阻止，直到发送数据报。</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until some of the buffer was sent.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>将阻止，直到一些缓冲区已发送。</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If the return value from <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indicates that the buffer was not completely sent, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method again, modifying the buffer to hold the unsent data.</source>
          <target state="translated">如果返回值从<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>指示缓冲区不完全发送，调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法再次，修改要保存未发送的数据的缓冲区。</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">就你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">在线程退出时，由给定线程启动的所有 i/o 操作已取消。</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">如果在线程退出操作完成前，挂起的异步操作可能会失败。</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">成功完成后发送不指示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The following code example ends a pending asynchronous send.</source>
          <target state="translated">下面的代码示例结束挂起的异步发送。</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          
        </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous send.</source>
          
        </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that stores state information for this asynchronous operation.</source>
          
        </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          
        </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Ends a pending asynchronous send.</source>
          
        </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If successful, the number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>; otherwise, an invalid <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> error.</source>
          
        </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> 完成异步发送操作以启动<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>，你需要创建实现一个回调方法<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>委托。</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> returns.</source>
          <target state="translated">此回调方法在一个单独的线程中执行之后, 由系统调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>返回。</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">回调方法必须接受<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>返回<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>作为参数的方法。</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">在回调方法中，调用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>参数来获取发送<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
          <target state="translated">获取之后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，可以调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>方法已成功完成发送操作并返回发送的字节数。</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">如果你使用的是无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>将阻止，直到发送数据报。</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until some of the buffer was sent.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>将阻止，直到一些缓冲区已发送。</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If the return value from <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indicates that the buffer was not completely sent, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method again, modifying the buffer to hold the unsent data.</source>
          <target state="translated">如果返回值从<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>指示缓冲区不完全发送，调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法再次，修改要保存未发送的数据的缓冲区。</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">就你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">在线程退出时，由给定线程启动的所有 i/o 操作已取消。</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">如果在线程退出操作完成前，挂起的异步操作可能会失败。</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">成功完成后发送不指示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          
        </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous send.</source>
          
        </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information for this asynchronous operation.</source>
          
        </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Ends a pending asynchronous send of a file.</source>
          
        </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> 完成异步发送操作以启动<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, you must create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>，你必须创建实现一个回调方法<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>委托。</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> returns.</source>
          <target state="translated">此回调方法在一个单独的线程中执行之后, 由系统调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>返回。</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">回调方法必须接受<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>返回对象<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>作为参数的方法。</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">在回调方法中，调用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>参数来获取发送<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method to successfully complete the send operation.</source>
          <target state="translated">获取之后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，可以调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>方法才能成功完成发送操作。</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blocks until the datagram is sent.</source>
          <target state="translated">如果你使用的是无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>一直阻塞，直到发送数据报。</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blocks until the entire file is sent.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>一直阻塞，直到发送整个文件。</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">就你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</source>
          <target state="translated">下面的代码示例创建和连接进行异步通信套接字并开始文件"text.txt"以异步方式发送到远程主机。</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> to complete the transmission.</source>
          <target state="translated">回调委托调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>完成传输。</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is empty.</source>
          
        </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          
        </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>See remarks section below.</source>
          
        </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>Ends a pending asynchronous send to a specific location.</source>
          
        </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If successful, the number of bytes sent; otherwise, an invalid <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> error.</source>
          
        </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> 完成异步发送操作以启动<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>，你需要创建实现一个回调方法<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>委托。</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
          <target state="translated">此回调方法在一个单独的线程中执行之后, 由系统调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>返回。</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">回调方法必须接受<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>返回<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>作为参数的方法。</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">在回调方法中，调用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>参数来获取发送<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
          <target state="translated">获取之后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，可以调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>方法已成功完成发送操作并返回发送的字节数。</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">如果你使用的是无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>将阻止，直到发送数据报。</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will block until the requested number of bytes are sent.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>将阻止，直到发送请求的字节数。</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">就你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>The following code example ends an asynchronous send to a specific location.</source>
          <target state="translated">下面的代码示例结束异步发送到特定位置。</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          
        </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous send.</source>
          
        </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows only one process to bind to a port.</source>
          
        </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows only one socket to bind to a specific port; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 如果<ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>允许只有一个套接字将绑定到特定端口; 否则为<ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph> for Windows Server 2003 and Windows XP Service Pack 2, and <ph id="ph2">&lt;see langword="false" /&gt;</ph> for all other versions.</source>
          <target state="translated">默认值是<ph id="ph1">&lt;see langword="true" /&gt;</ph>为 Windows Server 2003 和 Windows XP Service Pack 2，和<ph id="ph2">&lt;see langword="false" /&gt;</ph>对于所有其他版本。</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>If <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> is <ph id="ph2">`false`</ph>, multiple sockets can use the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph>是<ph id="ph2">`false`</ph>，可以使用多个套接字<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法将绑定到特定端口; 但是只有一个套接字可以执行对发送到端口的网络流量的操作。</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>If more than one socket attempts to use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29&gt;</ph> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</source>
          <target state="translated">如果尝试使用多个套接字<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29&gt;</ph>方法来绑定到特定端口，则具有更具体的 IP 地址将处理发送到该端口的网络流量。</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>If <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> is <ph id="ph2">`true`</ph>, the first use of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to attempt to bind to that port will fail until the original bound socket is destroyed.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph>是<ph id="ph2">`true`</ph>，第一次使用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法来尝试将绑定到特定端口，而不考虑 Internet 协议 (IP) 地址，将会成功; 的所有后续使用<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法来尝试将绑定到该端口将之前销毁原始绑定套接字失败。</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>This property must be set before <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> is called; otherwise an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown.</source>
          <target state="translated">此属性必须之前设置<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>调用; 否则为<ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph>将引发。</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例演示如何将<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> has been called for this <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Finalize">
          <source>Frees resources used by the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          
        </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class finalizer calls the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to close the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and free resources associated with the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类终结器调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法来关闭<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>并释放与关联的资源<ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Returns the value of a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option.</source>
          
        </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>Returns the value of a specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option, represented as an object.</source>
          
        </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>An object that represents the value of the option.</source>
          
        </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>When the <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> parameter is set to <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.Linger" /&gt;</ph> the return value is an instance of the <ph id="ph3">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> class.</source>
          
        </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>When <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /&gt;</ph>, the return value is an instance of the <ph id="ph4">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph> class.</source>
          
        </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>When <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> is any other value, the return value is an integer.</source>
          
        </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> 选项将确定当前行为<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>Use this overload to get the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.</source>
          <target state="translated">此重载用于获取<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>， <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>，和<ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>选项。</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>For the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for the <ph id="ph3">`optionLevel`</ph> parameter.</source>
          <target state="translated">有关<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>选项，请使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>为<ph id="ph3">`optionLevel`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>For <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</source>
          <target state="translated">有关<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>，使用<ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>If you want to set the value of any of the options listed above, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">如果你想要设置的任何上面列出的选项的值，则使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>The following code example retrieves the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values and displays them to the console.</source>
          <target state="translated">下面的代码示例检索<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>超时值，并向控制台显示它们。</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source><ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> was set to the unsupported value <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is to receive the option setting.</source>
          
        </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Returns the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option setting, represented as a byte array.</source>
          
        </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> 选项将确定当前行为<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Upon successful completion of this method, the array specified by the <ph id="ph1">`optionValue`</ph> parameter contains the value of the specified <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option.</source>
          <target state="translated">在此方法成功完成，通过将指定的数组<ph id="ph1">`optionValue`</ph>参数包含指定的值<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>选项。</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>When the length of the <ph id="ph1">`optionValue`</ph> array is smaller than the number of bytes required to store the value of the specified <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">时的长度<ph id="ph1">`optionValue`</ph>数组小于存储的值指定所需的字节数<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>选项，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph>将引发<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Use this overload for any sockets that are represented by Boolean values or integers.</source>
          <target state="translated">对于由布尔值或整数表示任何套接字使用此重载。</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The following code example retrieves the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values and displays them to the console.</source>
          <target state="translated">下面的代码示例检索<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>超时值，并向控制台显示它们。</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source><ph id="ph1">\-</ph> or -</source>
          
        </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</source>
          
        </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>You can change the per socket buffer space by calling <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The length, in bytes, of the expected return value.</source>
          
        </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Returns the value of the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option in an array.</source>
          
        </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the value of the socket option.</source>
          
        </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The <ph id="ph1">`optionLength`</ph> parameter sets the maximum size of the returned byte array.</source>
          <target state="translated"><ph id="ph1">`optionLength`</ph>参数设置返回的字节数组的最大大小。</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If the option value requires fewer bytes, the array will contain only that many bytes.</source>
          <target state="translated">如果选项值要求更少字节数，该数组将包含仅的很多字节。</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If the option value requires more bytes, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果选项值需要更多字节<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Use this overload for any sockets that are represented by Boolean values or integers.</source>
          <target state="translated">对于由布尔值或整数表示任何套接字使用此重载。</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The following code example retrieves the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values and displays them to the console.</source>
          <target state="translated">下面的代码示例检索<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>超时值，并向控制台显示它们。</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">\-</ph> or -</source>
          
        </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</source>
          
        </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>You can change the per socket buffer space by calling <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Handle">
          <source>Gets the operating system handle for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Handle">
          <source>An <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> that represents the operating system handle for the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>表示操作系统句柄<ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value that specifies the control code of the operation to perform.</source>
          
        </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains the input data required by the operation.</source>
          
        </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains the output data returned by the operation.</source>
          
        </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> using numerical control codes.</source>
          
        </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The number of bytes in the <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> method provides low-level access to the operating system <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> underlying the current instance of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph>方法提供对操作系统的低级别访问<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>基础的当前实例<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>For more information, see the WSAIoctl documentation in the MSDN library.</source>
          <target state="translated">有关详细信息，请参阅 MSDN 库中的 WSAIoctl 文档。</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The following code example compares the results of FIONREAD and the Available property.</source>
          <target state="translated">下面的代码示例将 FIONREAD 和可用的属性的结果进行比较。</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>An attempt was made to change the blocking mode without using the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph> property.</source>
          
        </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>A caller in the call stack does not have the required permissions.</source>
          
        </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>to execute unmanaged code.</source>
          <target state="translated">若要执行非托管的代码。</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> value that specifies the control code of the operation to perform.</source>
          
        </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the input data required by the operation.</source>
          
        </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the output data returned by the operation.</source>
          
        </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> enumeration to specify control codes.</source>
          
        </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>The number of bytes in the <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>This method provides low-level access to the operating system <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> underlying the current instance of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
          <target state="translated">此方法提供对操作系统的低级别访问<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>基础的当前实例<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>For more, see the WSAIoctl documentation in the MSDN library.</source>
          <target state="translated">有关详细信息，请参阅 MSDN 库中的 WSAIoctl 文档。</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>The following code example compares the results of calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> with <ph id="ph2">&lt;xref:System.Net.Sockets.IOControlCode.DataToRead&gt;</ph> and the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例调用的结果进行比较<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph>与<ph id="ph2">&lt;xref:System.Net.Sockets.IOControlCode.DataToRead&gt;</ph>和<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An attempt was made to change the blocking mode without using the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph> property.</source>
          
        </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>to execute unmanaged code.</source>
          <target state="translated">若要执行非托管的代码。</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.IsBound">
          <source>Gets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is bound to a specific local port.</source>
          
        </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.IsBound">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is bound to a local port; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 如果<ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>绑定到的本地端口; 否则为<ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.IsBound">
          <source>A socket is considered bound to a local port if it is explicitly bound by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, or implicitly bound by calling members like <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to bind to a well-known port so that clients may connect to them.</source>
          <target state="translated">如果显式将其绑定通过调用，套接字将被视为绑定到的本地端口<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法，或通过调用成员等隐式绑定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>，或<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>，此过程使用临时的本地端口 （免费端口大于1024，选择的操作系统。)服务器使用<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法，以便客户端可能会连接到它们将绑定到的已知端口。</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.IsBound">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IsBound%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例演示如何将<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IsBound%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Gets or sets a value that specifies whether the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> will delay closing a socket in an attempt to send all pending data.</source>
          
        </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> that specifies how to linger while closing a socket.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> ，它指定如何关闭套接字时逗留。</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property changes the way <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method behaves.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph>属性用于更改方式<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法的行为。</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This property when set modifies the conditions under which the connection can be reset by Winsock.</source>
          <target state="translated">当组修改在其下连接可以重置通过 Winsock 的条件时，此属性。</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Connection resets can still occur based on the IP protocol behavior.</source>
          <target state="translated">连接重置仍会发生根据 IP 协议行为。</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This property controls the length of time that a connection-oriented connection will remain open after a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> when data remains to be sent.</source>
          <target state="translated">此属性控制的面向连接的连接到在调用后将保持打开的时间长度<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>仍然要发送数据时。</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</source>
          <target state="translated">在调用方法来向对等节点发送数据时，此数据将被置于传出的网络缓冲区。</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This property can be used to ensure that this data is sent to the remote host before the <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient.Close%2A&gt;</ph> method drops the connection.</source>
          <target state="translated">此属性可以用于确保将此数据发送到远程主机之前<ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient.Close%2A&gt;</ph>方法删除连接。</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>To enable lingering, create a <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> instance containing the desired values, and set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property to this instance.</source>
          <target state="translated">若要启用延迟，创建<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>实例包含所需的值，并设置<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph>指向此实例的属性。</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The following table describes the behavior of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method for the possible values of the <ph id="ph2">&lt;xref:System.Net.Sockets.LingerOption.Enabled%2A&gt;</ph> property and the <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property stored in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property.</source>
          <target state="translated">下表描述的行为<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>输入的可能的值的方法<ph id="ph2">&lt;xref:System.Net.Sockets.LingerOption.Enabled%2A&gt;</ph>属性和<ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph>属性存储在<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>LingerState.Enabled</source>
          <target state="translated">LingerState.Enabled</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>LingerState.LingerTime</source>
          <target state="translated">LingerState.LingerTime</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Behavior</source>
          <target state="translated">行为</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source><ph id="ph1">`false`</ph> (disabled), the default value</source>
          <target state="translated"><ph id="ph1">`false`</ph> （禁用），默认值</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The time-out is not applicable, (default).</source>
          <target state="translated">超时不适用，（默认值）。</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Attempts to send pending data until the default IP protocol time-out expires.</source>
          <target state="translated">尝试发送数据挂起，直到默认 IP 协议超时时间已到。</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source><ph id="ph1">`true`</ph> (enabled)</source>
          <target state="translated"><ph id="ph1">`true`</ph> （已启用）</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>A nonzero time-out</source>
          <target state="translated">非零的超时</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</source>
          <target state="translated">尝试发送挂起的数据，直到指定的超时时间已到，如果尝试失败，然后 Winsock 重置连接。</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source><ph id="ph1">`true`</ph> (enabled)</source>
          <target state="translated"><ph id="ph1">`true`</ph> （已启用）</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>A zero timeout.</source>
          <target state="translated">零超时。</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Discards any pending data.</source>
          <target state="translated">丢弃所有挂起的数据。</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>For connection-oriented socket (TCP, for example), Winsock resets the connection.</source>
          <target state="translated">对于面向连接的套接字 (例如 TCP)，Winsock 重置连接。</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</source>
          <target state="translated">IP 堆栈计算默认 IP 协议超时期限为使用基于连接的往返时间。</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>In most cases, the time-out computed by the stack is more relevant than one defined by an application.</source>
          <target state="translated">在大多数情况下，该堆栈计算的该超时是个应用程序定义更具相关性。</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This is the default behavior for a socket when the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property is not set.</source>
          <target state="translated">这是一个套接字的默认行为时<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph>未设置属性。</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property stored in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph>属性存储在<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph>属性设置大于默认 IP 协议超时值，则仍将应用和重写的默认 IP 协议超时时间。</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例演示如何将<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The maximum length of the pending connections queue.</source>
          
        </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>Places a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> in a listening state.</source>
          
        </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> causes a connection-oriented <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to listen for incoming connection attempts.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> 导致一个面向连接的<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>侦听传入的连接尝试。</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The <ph id="ph1">`backlog`</ph> parameter specifies the number of incoming connections that can be queued for acceptance.</source>
          <target state="translated"><ph id="ph1">`backlog`</ph>参数指定可排队等待接受的传入连接数。</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>To determine the maximum number of connections you can specify, retrieve the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.MaxConnections&gt;</ph> value.</source>
          <target state="translated">若要确定的最大可以指定的连接数，检索<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.MaxConnections&gt;</ph>值。</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> does not block.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> 不会阻止。</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to accept a connection from the queue.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>以接受来自队列的连接。</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>You must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>将引发<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The backlog parameter is limited to different values depending on the Operating System.</source>
          <target state="translated">积压工作参数仅限于具体取决于操作系统的不同值。</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>You may specify a higher value, but the backlog will be limited based on the Operating System.</source>
          <target state="translated">你可以指定更高的值，但积压工作将会受到某些限制的基于操作系统。</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to listen for incoming connections.</source>
          <target state="translated">下面的代码示例使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>来侦听传入连接。</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>Gets the local endpoint.</source>
          
        </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is using for communications.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> ，<ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>通信使用。</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property gets an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that contains the local IP address and port number to which your <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is bound.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>属性可以获取<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>包含到的本地 IP 地址和端口号你<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>绑定。</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>You must cast this <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> before retrieving any information.</source>
          <target state="translated">您必须将此转换<ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>到<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>之前检索的任何信息。</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>You can then call the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the local <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>, and the <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the local port number.</source>
          <target state="translated">然后，你可以调用<ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph>方法来检索本地<ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>，和<ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph>方法来检索其中的本地端口号。</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property is usually set after you make a call to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>属性通常设置进行的调用之后<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>If you allow the system to assign your socket's local IP address and port number, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property will be set after the first I/O operation.</source>
          <target state="translated">如果你允许系统分配套接字的本地 IP 地址和端口号，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>属性将设置后第一次的 I/O 操作。</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>For connection-oriented protocols, the first I/O operation would be a call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">对于面向连接的协议，第一次的 I/O 操作将是调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>For connectionless protocols, the first I/O operation would be any of the send or receive calls.</source>
          <target state="translated">对于无连接协议，第一次的 I/O 操作是任何发送或接收调用。</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The following code example retrieves and displays the local and remote endpoints.</source>
          <target state="translated">下面的代码示例检索并显示本地和远程终结点。</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</source>
          
        </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> receives outgoing multicast packets; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 如果<ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>接收传出多播的数据包数; 否则为<ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>Multicast is a scalable method for many-to-many communication on the Internet.</source>
          <target state="translated">多路广播是用于在 Internet 上的多对多通信的可扩展方法。</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</source>
          <target state="translated">进程订阅到多播地址;然后，由订阅进程发送任何数据包接收订阅的多播地址的每个其他进程。</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
          <target state="translated">传输控制协议 (TCP) 套接字上设置此属性将产生任何影响。</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.MulticastLoopback%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例演示如何将<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.MulticastLoopback%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the stream <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is using the Nagle algorithm.</source>
          
        </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> uses the Nagle algorithm; otherwise, <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> 如果<ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>使用 Nagle 算法; 否则为<ph id="ph3">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</source>
          <target state="translated">Nagle 算法旨在导致套接字缓冲小数据包，然后合并并将其发送在某些情况下的一个数据包中，从而减少网络流量。</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>A TCP packet consists of 40 bytes of header plus the data being sent.</source>
          <target state="translated">TCP 数据包包含 40 个字节的标头以及所发送的数据。</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</source>
          <target state="translated">当与 TCP 发送的数据的小数据包时，TCP 标头导致开销可能会的网络流量的重要部分。使高负荷在网络上，这种开销导致拥塞可能导致丢失数据报和重新传输数，以及导致阻塞过多的传播时间。</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.</source>
          <target state="translated">Nagle 算法抑制发送的新 TCP segmentswhen 新传出数据到达从用户中，如果在连接上的任何处数据将保留未确认。</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The majority of network applications should use the Nagle algorithm.</source>
          <target state="translated">大多数网络应用程序应使用 Nagle 算法。</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</source>
          <target state="translated">用户数据报协议 (UDP) 套接字上设置此属性将产生任何影响。</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.NoDelay%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例演示如何将<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.NoDelay%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.OSSupportsIPv4">
          <source>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</source>
          
        </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv4">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operating system and network adaptors support the IPv4 protocol; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 如果操作系统和网络适配器支持 IPv4 协议;，否则为<ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv4">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">操作系统可能支持 IPv4 和 IPv6 协议。</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.OSSupportsIPv6">
          <source>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</source>
          
        </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv6">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operating system and network adaptors support the IPv6 protocol; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 如果操作系统和网络适配器支持了 IPv6 协议;，否则为<ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv6">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">操作系统可能支持 IPv4 和 IPv6 协议。</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The time to wait for a response, in microseconds.</source>
          
        </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Determines the status of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The status of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> based on the polling mode value passed in the <ph id="ph2">&lt;paramref name="mode" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Mode</source>
          
        </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Return Value</source>
          
        </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectRead" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph> if <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> has been called and a connection is pending;</source>
          
        </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if data is available for reading;</source>
          
        </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the connection has been closed, reset, or terminated;</source>
          
        </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>otherwise, returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph>, if processing a <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph>, and the connection has succeeded;</source>
          
        </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if data can be sent;</source>
          
        </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>otherwise, returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectError" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph> if processing a <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph> that does not block, and the connection has failed;</source>
          
        </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /&gt;</ph> is not set and out-of-band data is available;</source>
          
        </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>otherwise, returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method will check the state of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph>方法将检查的状态<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Specify <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType&gt;</ph> for the <ph id="ph2">`selectMode`</ph> parameter to determine if the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is readable.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType&gt;</ph>为<ph id="ph2">`selectMode`</ph>参数，以确定如果<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>是可读。</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Specify <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType&gt;</ph> to determine if the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is writable.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType&gt;</ph>以确定是否<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>是可写。</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Use <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType&gt;</ph> to detect an error condition.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType&gt;</ph>来检测错误条件。</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> will block execution until the specified time period, measured in <ph id="ph2">`microseconds`</ph>, elapses.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> 将阻止执行，直到指定的时间段，以测量<ph id="ph2">`microseconds`</ph>，间隔。</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Set the <ph id="ph1">`microSeconds`</ph> parameter to a negative integer if you would like to wait indefinitely for a response.</source>
          <target state="translated">设置<ph id="ph1">`microSeconds`</ph>参数为负的整数，如果你想要无限期地等待响应。</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>If you want to check the status of multiple sockets, you might prefer to use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> method.</source>
          <target state="translated">如果你想要检查多个套接字的状态，你可能希望使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</source>
          <target state="translated">此方法无法检测到某些类型的连接问题，如网络电缆中断，或远程主机已意外关闭。</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>You must attempt to send or receive data to detect these kinds of errors.</source>
          <target state="translated">你必须尝试发送或接收数据，以检测这些类型的错误。</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The following code example creates a socket, connects to a server, and uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> to check the status of the socket.</source>
          <target state="translated">下面的代码示例创建套接字，连接到服务器，并使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph>若要检查的套接字的状态。</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>See remarks below.</source>
          
        </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>Gets the protocol type of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> property is set when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created, and specifies the protocol used by that <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph>时设置属性<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>创建，并指定所使用的协议<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> to the console.</source>
          <target state="translated">下面的代码示例显示<ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>， <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>，和<ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph>到控制台。</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          
        </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer.</source>
          
        </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将数据读入的缓冲区参数并返回成功读取的字节数。</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">你可以调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>从面向连接的和无连接的套接字。</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>This overload only requires you to provide a receive buffer.</source>
          <target state="translated">此重载仅要求你提供接收缓冲区。</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">缓冲区偏移量的默认值为 0，默认大小为缓冲区参数的长度和<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>值默认为<ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>接受之前调用的传入连接<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将仅读取数据中建立的远程主机从到达<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接协议，你还可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> 将可以接收来自任何主机的数据。</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果没有数据可供读取，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将阻塞，直到数据不可用，除非通过使用设置超时值<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出了超时值，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>调用将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>属性来确定是否可供读取数据。</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>为非零，重试该接收操作。</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">如果使用的一个面向连接的<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将读取多的数据可用，直到达到的缓冲区的大小。</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">如果远程主机关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>与连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>收到方法，并且所有可用数据，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并返回零字节。</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>将从你在中指定的目标地址中读取第一个排队数据报<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">如果你收到的数据报大于的大小<ph id="ph1">`buffer`</ph>参数，<ph id="ph2">`buffer`</ph>被填与消息的第一个部分，多余的数据将丢失和<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The following code example receives data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">下面的代码示例接收在连接上的数据<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>A caller in the call stack does not have the required permissions.</source>
          
        </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>for accepting connections from the network.</source>
          <target state="translated">用于接受来自网络的连接。</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the received data.</source>
          
        </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the list of receive buffers.</source>
          
        </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This method reads data into the buffers parameter and returns the number of bytes successfully read.</source>
          <target state="translated">此方法将数据读入的缓冲区参数并返回成功读取的字节数。</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
          <target state="translated">你可以调用从面向连接的和无连接的套接字。</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This overload requires you to provide one or more receive buffers.</source>
          <target state="translated">此重载都需要你提供一个或多个接收缓冲区。</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>接受之前调用的传入连接<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将仅读取数据中建立的远程主机连接从到达<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接协议，你还可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> 将可以接收来自任何主机的数据。</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果没有数据可供读取，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将阻塞，直到数据不可用，除非通过使用设置超时值<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出了超时值，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>调用将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>属性来确定是否可供读取数据。</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>为非零，重试该接收操作。</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">如果使用的一个面向连接的<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将读取多的数据可用，直到达到的缓冲区的大小。</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">如果远程主机关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>与连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>收到方法，并且所有可用数据，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并返回零字节。</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>将从你在中指定的目标地址中读取第一个排队数据报<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">如果你收到的数据报大于的大小<ph id="ph1">`buffers`</ph>参数，<ph id="ph2">`buffers`</ph>被填与消息的第一个部分，多余的数据将丢失和<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated"><bpt id="p1">**</bpt>请注意<ept id="p1">**</ept>时你的应用程序中启用网络跟踪，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>An error occurred while attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          
        </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将数据读入的缓冲区参数并返回成功读取的字节数。</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">你可以调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>从面向连接的和无连接的套接字。</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This overload only requires you to provide a receive buffer and the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">此重载仅要求您提供接收缓冲区和所需<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</source>
          <target state="translated">缓冲区偏移量的默认值为 0，并且大小默认为字节参数的长度。</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>接受之前调用的传入连接<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将仅读取数据中建立的远程主机从到达<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接协议，你还可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> 将可以接收来自任何主机的数据。</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">如果没有数据可供读取，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将一直阻止到的数据是否可用。</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你是在非阻塞模式下，并且没有在协议堆栈缓冲区中可用的数据<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>属性来确定是否可供读取数据。</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry your receive operation.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>为非零，重试你接收操作。</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available up to the size of the buffer.</source>
          <target state="translated">如果使用的一个面向连接的<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将读取到缓冲区的大小可尽可能数据。</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">如果远程主机关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>与连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>收到方法，并且所有可用数据，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并返回零字节。</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>将从你在中指定的目标地址中读取第一个排队数据报<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">如果你收到的数据报大于的大小<ph id="ph1">`buffer`</ph>参数，<ph id="ph2">`buffer`</ph>被填与消息的第一个部分，多余的数据将丢失和<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The following code example specifies a data buffer, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> for receiving data on a connected <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">下面的代码示例指定数据缓冲区和<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>用于接收上连接的数据<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A caller in the call stack does not have the required permissions.</source>
          
        </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">用于接受来自网络的连接。</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the received data.</source>
          
        </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the list of receive buffers, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This method reads data into the <ph id="ph1">`buffers`</ph> parameter and returns the number of bytes successfully read.</source>
          <target state="translated">此方法将数据读入<ph id="ph1">`buffers`</ph>参数并返回成功读取的字节数。</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
          <target state="translated">你可以调用从面向连接的和无连接的套接字。</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This overload requires you to provide one or more receive buffers.</source>
          <target state="translated">此重载都需要你提供一个或多个接收缓冲区。</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>值默认为<ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>接受之前调用的传入连接<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将仅读取数据中建立的远程主机连接从到达<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接协议，你还可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> 将可以接收来自任何主机的数据。</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果没有数据可供读取，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将阻塞，直到数据不可用，除非通过使用设置超时值<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出了超时值，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>调用会引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>属性来确定是否可供读取数据。</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>为非零，重试该接收操作。</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">如果使用的一个面向连接的<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将读取多的数据可用，直到达到的缓冲区的大小。</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">如果远程主机关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>与连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>收到方法，并且所有可用数据，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并返回零字节。</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>将从你在中指定的目标地址中读取第一个排队数据报<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">如果你收到的数据报大于的大小<ph id="ph1">`buffers`</ph>参数，<ph id="ph2">`buffers`</ph>被填与消息的第一个部分，多余的数据将丢失和<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The following code example demonstrates how to receive data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">下面的代码示例演示如何在连接上接收数据<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count is zero.</source>
          
        </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>An error occurred while attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">用于接受来自网络的连接。</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          
        </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to receive.</source>
          
        </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Receives the specified number of bytes of data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter and returns the number of bytes successfully read.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将数据读入<ph id="ph2">`buffer`</ph>参数并返回成功读取的字节数。</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">你可以调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>从面向连接的和无连接的套接字。</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">此重载仅要求您提供接收缓冲区、 你想要接收，字节和所需的数量<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>接受之前调用的传入连接<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将仅读取数据中建立的远程主机从到达<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接协议，你还可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> 将可以接收来自任何主机的数据。</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果没有数据可供读取，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将阻塞，直到数据不可用，除非通过使用设置超时值<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出了超时值，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>调用将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>属性来确定是否可供读取数据。</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry your receive operation.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>为非零，重试你接收操作。</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the <ph id="ph3">`size`</ph> parameter.</source>
          <target state="translated">如果使用的一个面向连接的<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将读取原样可用，直到达到指定的字节数多的数据<ph id="ph3">`size`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">如果远程主机关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>与连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>收到方法，并且所有可用数据，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并返回零字节。</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>将从你在中指定的目标地址中读取第一个排队数据报<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">如果你收到的数据报大于的大小<ph id="ph1">`buffer`</ph>参数，<ph id="ph2">`buffer`</ph>被填与消息的第一个部分，多余的数据将丢失和<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following receives the data found into <ph id="ph1">`buffer`</ph>, and specifies <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> for <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">以下接收到发现的数据<ph id="ph1">`buffer`</ph>，并指定<ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>为<ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> exceeds the size of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A caller in the call stack does not have the required permissions.</source>
          
        </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">用于接受来自网络的连接。</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the received data.</source>
          
        </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          
        </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the list of receive buffers, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This method reads data into the <ph id="ph1">`buffers`</ph> parameter and returns the number of bytes successfully read.</source>
          <target state="translated">此方法将数据读入<ph id="ph1">`buffers`</ph>参数并返回成功读取的字节数。</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
          <target state="translated">你可以调用从面向连接的和无连接的套接字。</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This overload requires you to provide one or more receive buffers.</source>
          <target state="translated">此重载都需要你提供一个或多个接收缓冲区。</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>值默认为<ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>接受之前调用的传入连接<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将仅读取数据中建立的远程主机连接从到达<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接协议，你还可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> 将可以接收来自任何主机的数据。</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果没有数据可供读取，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将阻塞，直到数据不可用，除非通过使用设置超时值<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出了超时值，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>调用会引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>属性来确定是否可供读取数据。</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>为非零，重试该接收操作。</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">如果使用的一个面向连接的<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将读取多的数据可用，直到达到的缓冲区的大小。</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">如果远程主机关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>与连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>收到方法，并且所有可用数据，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并返回零字节。</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>,<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>将从你在中指定的目标地址中读取第一个排队数据报<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">如果你收到的数据报大于的大小<ph id="ph1">`buffers`</ph>参数，<ph id="ph2">`buffers`</ph>被填与消息的第一个部分，多余的数据将丢失和<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count is zero.</source>
          
        </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An error occurred while attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">用于接受来自网络的连接。</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          
        </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The location in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> to store the received data.</source>
          
        </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to receive.</source>
          
        </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Receives the specified number of bytes from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the specified offset position of the receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将数据读入的缓冲区参数并返回成功读取的字节数。</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">你可以调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>从面向连接的和无连接的套接字。</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>接受之前调用的传入连接<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将仅读取数据中建立的远程主机从到达<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接协议，你还可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> 将可以接收来自任何主机的数据。</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果没有数据可供读取，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将阻塞，直到数据不可用，除非通过使用设置超时值<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出了超时值，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>调用将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">尝试访问套接字时出错。</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>See Remarks below.</source>
          <target state="translated">请参阅下面的备注。</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>属性来确定是否可供读取数据。</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>为非零，重试该接收操作。</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the size parameter.</source>
          <target state="translated">如果使用的一个面向连接的<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将读取原样可用，直到达到指定大小参数的字节数多的数据。</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">如果远程主机关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>与连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>收到方法，并且所有可用数据，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并返回零字节。</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>将从你在中指定的目标地址中读取第一个排队数据报<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">如果你收到的数据报大于的大小<ph id="ph1">`buffer`</ph>参数，<ph id="ph2">`buffer`</ph>被填与消息的第一个部分，多余的数据将丢失和<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">下面的代码示例上连接接收数据之前指定数据缓冲区、 偏移量、 大小和套接字标志<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          
        </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          
        </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A caller in the call stack does not have the required permissions.</source>
          
        </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">用于接受来自网络的连接。</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          
        </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter to store the received data.</source>
          
        </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes to receive.</source>
          
        </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          
        </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将数据读入的缓冲区参数并返回成功读取的字节数。</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">你可以调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>从面向连接的和无连接的套接字。</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>接受之前调用的传入连接<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将仅读取数据中建立的远程主机从到达<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接协议，你还可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> 将可以接收来自任何主机的数据。</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果没有数据可供读取，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将阻塞，直到数据不可用，除非通过使用设置超时值<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出了超时值，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>调用将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">尝试访问套接字时出错。</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>See Remarks below.</source>
          <target state="translated">请参阅下面的备注。</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>属性来确定是否可供读取数据。</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>为非零，重试该接收操作。</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the size parameter.</source>
          <target state="translated">如果使用的一个面向连接的<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将读取原样可用，直到达到指定大小参数的字节数多的数据。</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">如果远程主机关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>与连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>收到方法，并且所有可用数据，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法将立即完成并返回零字节。</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的是无连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>将从你在中指定的目标地址中读取第一个排队数据报<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">如果你收到的数据报大于的大小<ph id="ph1">`buffer`</ph>参数，<ph id="ph2">`buffer`</ph>被填与消息的第一个部分，多余的数据将丢失和<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          
        </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property is not set.</source>
          
        </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          
        </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">用于接受来自网络的连接。</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          
        </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request to receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          
        </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          
        </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          
        </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          
        </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          
        </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph>方法使用套接字或绑定无连接的套接字连接，并且用于读取传入数据。</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket's local address must be known.</source>
          <target state="translated">必须知道套接字的本地地址。</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</source>
          <target state="translated">对于绑定无连接的套接字，此函数将限制从其接受接收的消息的地址。</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The function only returns messages from the remote address specified in the connection.</source>
          <target state="translated">该函数仅返回从连接中指定的远程地址的消息。</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Messages from other addresses are silently discarded.</source>
          <target state="translated">从其他地址的消息将以无提示方式被丢弃。</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the read request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph>属性<ph id="ph2">`e`</ph>参数提供关于读取请求的其他信息的窗口套接字服务提供程序。</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">有关如何使用此参数的详细信息，请参阅<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">下列属性和事件上的<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>对象所需成功调用此方法：</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> 或 <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> 如果<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph>设置</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> 如果<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph>设置</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">调用方可能设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>到在调用前要求任何用户状态对象的属性<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph>方法，以便在回叫方法可检索信息。</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</source>
          <target state="translated">对于字节流样式套接字，传入数据会放入缓冲区中，直到填充了缓冲区，连接将关闭，或用完内部缓冲的数据。</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the <ph id="ph1">`e`</ph> parameter.</source>
          <target state="translated">对于面向消息的套接字，传入消息会放入缓冲区中直到与关联的缓冲区的总大小<ph id="ph1">`e`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the message is larger than the buffer, the buffer is filled with the first part of the message.</source>
          <target state="translated">如果消息是比的缓冲区大，与消息的第一个部分填充缓冲区。</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For connection-oriented sockets, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</source>
          <target state="translated">对于面向连接的套接字，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph>方法可以指示中依赖于套接字为字节流还是面向消息的两种方式之一虚拟线路正常终止。</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</source>
          <target state="translated">对于字节流，设置已读零字节指示正常结束，并且将不会读取任何多个字节。</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, where a zero byte message is often allowable, a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</source>
          <target state="translated">对于面向消息的套接字，其中零字节的消息通常是允许的<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>与<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph>设置为本机 Winsock WSAEDISCON 错误代码 (10101) 用于指示正常的闭包。</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In any case, a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</source>
          <target state="translated">在任何情况下，<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>与<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph>错误代码 (10054) 设置为本机 Winsock WSAECONNRESET 指示放弃性关闭已发生。</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument was invalid.</source>
          
        </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> or <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> properties on the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter must reference valid buffers.</source>
          
        </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One or the other of these properties may be set, but not both at the same time.</source>
          
        </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>Gets or sets a value that specifies the size of the receive buffer of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the size, in bytes, of the receive buffer.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>包含以字节为单位的接收缓冲区的大小。</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The default is 8192.</source>
          <target state="translated">默认值为 8192。</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</source>
          <target state="translated">更大的缓冲区大小可能会减少的空确认 （不包含数据部分的 TCP 数据包），但也可能会延迟连接问题的识别。</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</source>
          <target state="translated">请考虑增加缓冲区大小，如果传输大型文件，或者正在使用的高带宽、 高延迟连接 （如卫星宽带提供程序。）</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例演示如何将<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The value specified for a set operation is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Receives a datagram and stores the source endpoint.</source>
          
        </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          
        </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          
        </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Receives a datagram into the data buffer and stores the endpoint.</source>
          
        </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将数据读入<ph id="ph2">`buffer`</ph>参数中，返回的字节数已成功读取，并捕获从其发送数据的远程主机终结点。</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">此方法很有用，如果你想要从未知的主机或多个主机接收无连接数据报。</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>This overload only requires you to provide a receive <ph id="ph1">`buffer`</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
          <target state="translated">此重载仅要求您提供一个接收<ph id="ph1">`buffer`</ph>，和<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>表示远程主机。</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The buffer offset defaults to 0.</source>
          <target state="translated">缓冲区偏移量的默认值为 0。</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The size defaults to the length of the <ph id="ph1">`buffer`</ph> parameter and the <ph id="ph2">`socketFlags`</ph> value defaults to <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">大小默认的长度为<ph id="ph1">`buffer`</ph>参数和<ph id="ph2">`socketFlags`</ph>值默认为<ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>，必须显式将绑定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>本地终结点使用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你不希望这样做，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">使用无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>将读取到本地网络缓冲区接收到第一个排队数据报。</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你收到的数据报大于的大小<ph id="ph1">`buffer`</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将填充<ph id="ph3">`buffer`</ph>尽可能可能，而引发的消息与<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">如果你使用的不可靠的协议，多余的数据将丢失。</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">如果你使用的是可靠的协议对过量数据将保留由服务提供商，你可以通过调用来检索它<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>使用足够大的缓冲区的方法。</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">如果没有数据可供读取，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将一直阻止到的数据是否可用。</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将立即完成并引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>属性来确定是否可供读取数据。</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>为非零，重试该接收操作。</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">尽管<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>适用于无连接协议，你可以使用也是一个面向连接的协议。</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">如果你选择这样做，你必须首先可以建立远程主机的连接通过调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法或接受传入的远程主机连接，通过调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果未建立或不接受连接，然后调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法时，将获取<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">你还可以建立默认远程主机之前调用无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">在这些情况下，任一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将忽略<ph id="ph2">`remoteEP`</ph>参数和仅接收从连接的数据或默认远程主机。</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the size of <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">对于面向连接的套接字，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>将读取多大小的可用尽可能数据<ph id="ph2">`buffer`</ph>。</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">如果远程主机关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>与连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>收到方法，并且所有可用数据，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将立即完成并返回零字节。</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>的<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>中使用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>需要匹配<ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>的<ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph>中使用<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">下面的代码示例从远程主机接收无连接的数据报。</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          
        </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">用于接受来自网络的连接。</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          
        </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          
        </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Receives a datagram into the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint.</source>
          
        </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将数据读入<ph id="ph2">`buffer`</ph>参数中，返回的字节数已成功读取，并捕获从其发送数据的远程主机终结点。</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">此方法很有用，如果你想要从未知的主机或多个主机接收无连接数据报。</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This overload only requires you to provide a receive buffer, the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
          <target state="translated">此重载仅要求你提供接收缓冲区，所需<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>，和<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>表示远程主机。</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The offset defaults to 0 and the size defaults to the length of the buffer parameter.</source>
          <target state="translated">偏移量默认值为 0 和默认大小为缓冲区参数的长度。</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>，必须显式将绑定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>本地终结点使用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你不希望这样做，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">使用无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>将读取到本地网络缓冲区接收到第一个排队数据报。</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你收到的数据报大于的大小<ph id="ph1">`buffer`</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将填充<ph id="ph3">`buffer`</ph>尽可能可能，而引发的消息与<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">如果你使用的不可靠的协议，多余的数据将丢失。</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">如果你使用的是可靠的协议对过量数据将保留由服务提供商，你可以通过调用来检索它<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>使用足够大的缓冲区的方法。</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">如果没有数据可供读取，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将一直阻止到的数据是否可用。</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将立即完成并引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>属性来确定是否可供读取数据。</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>为非零，重试该接收操作。</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">尽管<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>适用于无连接协议，你可以使用也是一个面向连接的协议。</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">如果你选择这样做，你必须首先可以建立远程主机的连接通过调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法或接受传入的远程主机连接，通过调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果未建立或不接受连接，然后调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法时，将获取<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">你还可以建立默认远程主机之前调用无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">在这些情况下，任一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将忽略<ph id="ph2">`remoteEP`</ph>参数和仅接收从连接的数据或默认远程主机。</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the size of <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">对于面向连接的套接字，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>将读取多大小的可用尽可能数据<ph id="ph2">`buffer`</ph>。</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been Received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">如果远程主机关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>与连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>收到方法，并且所有可用数据，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将立即完成并返回零字节。</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>的<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>中使用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>需要匹配<ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>的<ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph>中使用<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">下面的代码示例从远程主机接收无连接的数据报。</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> 传递给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          
        </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">用于接受来自网络的连接。</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          
        </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes to receive.</source>
          
        </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          
        </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Receives the specified number of bytes into the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint.</source>
          
        </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将数据读入<ph id="ph2">`buffer`</ph>参数中，返回的字节数已成功读取，并捕获从其发送数据的远程主机终结点。</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">此方法很有用，如果你想要从未知的主机或多个主机接收无连接数据报。</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
          <target state="translated">此重载仅要求你提供接收缓冲区，你想要接收，所需的字节数<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>，和<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>表示远程主机。</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The buffer offset defaults to 0.</source>
          <target state="translated">缓冲区偏移量的默认值为 0。</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">使用无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>将读取到本地网络缓冲区接收到第一个排队数据报。</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你收到的数据报大于的大小<ph id="ph1">`buffer`</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将填充<ph id="ph3">`buffer`</ph>尽可能可能，而引发的消息与<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">如果你使用的不可靠的协议，多余的数据将丢失。</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">如果你使用的是可靠的协议对过量数据将保留由服务提供商，你可以通过调用来检索它<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>使用足够大的缓冲区的方法。</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">如果没有数据可供读取，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将一直阻止到的数据是否可用。</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将立即完成并引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>属性来确定是否可供读取数据。</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>为非零，重试该接收操作。</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">尽管<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>适用于无连接协议，你可以使用也是一个面向连接的协议。</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">如果你选择这样做，你必须首先可以建立远程主机的连接通过调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法或接受传入的远程主机连接，通过调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果未建立或不接受连接，然后调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法时，将获取<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">你还可以建立默认远程主机之前调用无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">在这些情况下，任一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将忽略<ph id="ph2">`remoteEP`</ph>参数和仅接收从连接的数据或默认远程主机。</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the number of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">对于面向连接的套接字，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>将读取原样可用直到达到指定的字节数多的数据<ph id="ph2">`size`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">如果远程主机关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>与连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>收到方法，并且所有可用数据，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将立即完成并返回零字节。</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>，必须显式将绑定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>本地终结点使用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你不希望这样做，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>的<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>中使用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>需要匹配<ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>的<ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph>中使用<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">下面的代码示例从远程主机接收无连接的数据报。</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The buffer size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">缓冲区大小和<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>传递给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          
        </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          
        </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          
        </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">用于接受来自网络的连接。</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          
        </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter to store the received data.</source>
          
        </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes to receive.</source>
          
        </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          
        </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint.</source>
          
        </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将数据读入<ph id="ph2">`buffer`</ph>参数中，返回的字节数已成功读取，并捕获从其发送数据的远程主机终结点。</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">此方法很有用，如果你想要从未知的主机或多个主机接收无连接数据报。</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">使用无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>将读取到本地网络缓冲区接收到第一个排队数据报。</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你收到的数据报大于的大小<ph id="ph1">`buffer`</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将填充<ph id="ph3">`buffer`</ph>尽可能可能，而引发的消息与<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">如果你使用的不可靠的协议，多余的数据将丢失。</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">如果你使用的是可靠的协议对过量数据将保留由服务提供商，你可以通过调用来检索它<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>使用足够大的缓冲区的方法。</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">如果没有数据可供读取，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将一直阻止到的数据是否可用。</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将立即完成并引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>属性来确定是否可供读取数据。</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>为非零，重试该接收操作。</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">尽管<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>适用于无连接协议，你可以使用也是一个面向连接的协议。</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">如果你选择这样做，你必须首先可以建立远程主机的连接通过调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法或接受传入的远程主机连接，通过调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果未建立或不接受连接，然后调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法时，将获取<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">你还可以建立默认远程主机之前调用无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">在这些情况下，任一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将忽略<ph id="ph2">`remoteEP`</ph>参数和仅接收从连接的数据或默认远程主机。</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the amount of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">对于面向连接的套接字，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>将读取到指定的字节量可尽可能数据<ph id="ph2">`size`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been Received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">如果远程主机关闭<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>与连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>收到方法，并且所有可用数据，<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法将立即完成并返回零字节。</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>，必须显式将绑定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>本地终结点使用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你不希望这样做，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>的<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>中使用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>需要匹配<ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>的<ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph>中使用<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">下面的代码示例从远程主机接收无连接的数据报。</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The offset, buffer size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">偏移量、 缓冲区大小和<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>传递给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of the <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the offset parameter.</source>
          
        </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          
        </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          
        </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">用于接受来自网络的连接。</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          
        </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins to asynchronously receive data from a specified network device.</source>
          
        </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          
        </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          
        </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          
        </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          
        </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> method is used primarily to receive data on a connectionless socket.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph>方法主要用于在无连接的套接字上接收数据。</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket's local address must be known.</source>
          <target state="translated">必须知道套接字的本地地址。</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host from which the data is to be received.</source>
          <target state="translated">调用方必须设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>属性<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>是要接收数据的远程主机。</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the read request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph>属性<ph id="ph2">`e`</ph>参数提供关于读取请求的其他信息的窗口套接字服务提供程序。</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">有关如何使用此参数的详细信息，请参阅<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">下列属性和事件上的<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>对象所需成功调用此方法：</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">调用方可能设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>到在调用前要求任何用户状态对象的属性<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph>方法，以便在回叫方法可检索信息。</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</source>
          <target state="translated">对于面向消息的套接字，传入消息会放入缓冲区中，直到达到总大小的缓冲区。</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph>属性确定在缓冲区中数据的位置和的数据量。</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For byte stream–style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</source>
          <target state="translated">对于字节流 – 样式套接字，传入数据会放入缓冲区中，直到填充了缓冲区，连接将关闭，或用完内部缓冲的数据。</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph>属性确定在缓冲区中数据的位置和的数据量。</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          
        </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          
        </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter to store the received data.</source>
          
        </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The number of bytes to receive.</source>
          
        </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          
        </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IPPacketInformation" /&gt;</ph> holding address and interface information.</source>
          
        </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint and packet information.</source>
          
        </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The number of bytes received.</source>
          
        </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>方法将数据读入<ph id="ph2">`buffer`</ph>参数中，返回的字节数已成功读取，并捕获从中已发送数据，以及有关接收的数据包的信息的远程主机终结点。</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method is used primarily to receive message data on a connectionless socket.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>方法主要用于接收无连接的套接字上的消息数据。</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The socket's local address must be known.</source>
          <target state="translated">必须知道套接字的本地地址。</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This method can only be used with datagram and raw sockets.</source>
          <target state="translated">此方法仅可用于数据报和原始套接字。</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The socket must be initialized with the socket type set to <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> before calling this method.</source>
          <target state="translated">必须使用套接字类型设置为初始化套接字<ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph>或<ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph>之前调用此方法。</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This can be done when the socket is constructed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</source>
          <target state="translated">这可以使用构造套接字时<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>For message-oriented sockets, an incoming message is placed into the <ph id="ph1">`buffer`</ph> parameter up to the total size specified in the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">对于面向消息的套接字，传入消息放入<ph id="ph1">`buffer`</ph>直到达到总大小中指定的参数<ph id="ph2">`size`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">`offset`</ph> parameter determines where in the <ph id="ph2">`buffer`</ph> the data is placed.</source>
          <target state="translated"><ph id="ph1">`offset`</ph>参数确定中的何处<ph id="ph2">`buffer`</ph>放置数据。</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The actual amount of data placed into the <ph id="ph1">`buffer`</ph> is returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">实际数据量放入<ph id="ph1">`buffer`</ph>返回<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method automatically method sets the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> the first time it is called for a given <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>方法自动方法设置<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>套接字选项<ph id="ph3">`true`</ph>首次调用它的给定<ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>However, the returned <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> object will only be valid for packets which arrive at the local computer after the socket option has been set.</source>
          <target state="translated">但是，返回<ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph>对象将只能的数据包到达本地计算机的套接字选项已设置后有效。</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method or implicitly by one of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> methods) and its first call to the <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method, calls to <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method will return invalid <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects for these packets.</source>
          <target state="translated">如果套接字之间发送数据包时它所绑定到的本地终结点 (显式<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法或通过某项的隐式<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>方法) 和其第一次调用<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>方法，调用到<ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>方法将返回无效<ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph>为这些数据包的对象。</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>To ensure that all <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects are valid, an application should set the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> before it is bound to a local endpoint using the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">若要确保所有<ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph>对象有效，应用程序应设置<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>套接字选项<ph id="ph3">`true`</ph>绑定到本地终结点使用之前<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An application can examine the <ph id="ph1">`ipPacketInformation`</ph> parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
          <target state="translated">应用程序可以检查<ph id="ph1">`ipPacketInformation`</ph>参数是否需要了解是否使用单播、 多播或广播地址发送数据报。</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>的<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>中使用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>需要匹配<ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>的<ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph>中使用<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">\-</ph> or-</source>
          
        </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of the <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the offset parameter.</source>
          
        </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          
        </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          
        </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The .NET Framework is running on an AMD 64-bit processor.</source>
          
        </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          
        </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">用于接受来自网络的连接。</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          
        </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /&gt;</ph>, and stores the endpoint and packet information.</source>
          
        </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          
        </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          
        </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          
        </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          
        </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method is used primarily to receive message data on a connectionless socket.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph>方法主要用于接收无连接的套接字上的消息数据。</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket's local address must be known.</source>
          <target state="translated">必须知道套接字的本地地址。</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This method can only be used with datagram and raw sockets.</source>
          <target state="translated">此方法仅可用于数据报和原始套接字。</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket must be initialized with the socket type set to <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> before calling this method.</source>
          <target state="translated">必须使用套接字类型设置为初始化套接字<ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph>或<ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph>之前调用此方法。</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This can be done when the socket is constructed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</source>
          <target state="translated">这可以使用构造套接字时<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host from which the data is to be received.</source>
          <target state="translated">调用方必须设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>属性<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>是要接收数据的远程主机。</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">下列属性和事件上的<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>对象所需成功调用此方法：</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">调用方可能设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>到在调用前要求任何用户状态对象的属性<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph>方法，以便在回叫方法可检索信息。</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</source>
          <target state="translated">对于面向消息的套接字，传入消息会放入缓冲区中，直到达到总大小的缓冲区。</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph>属性确定在缓冲区中数据的位置和的数据量。</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method automatically sets the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> the first time it is called for a given <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph>方法会自动设置<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>套接字选项<ph id="ph3">`true`</ph>首次调用它的给定<ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>However, the <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> object will only be valid for packets which arrive at the local computer after the socket option has been set.</source>
          <target state="translated">但是，<ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph>对象将只能的数据包到达本地计算机的套接字选项已设置后有效。</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method or implicitly by one of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> methods) and the first call to the <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method, calls to <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method will result in invalid <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects for these packets.</source>
          <target state="translated">如果套接字之间发送数据包时该套接字绑定到的本地终结点 (显式<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法或通过某项的隐式<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>方法) 和首次调用<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph>方法，调用到<ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph>方法将导致无效<ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph>为这些数据包的对象。</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To ensure that all <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects are valid, an application should set the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to<ph id="ph3">`true`</ph> before it is bound to a local endpoint using the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">若要确保所有<ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph>对象有效，应用程序应设置<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>套接字选项<ph id="ph3">`true`</ph>绑定到本地终结点使用之前<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An application can examine the resulting <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
          <target state="translated">应用程序可以检查生成<ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph>对象它是否需要了解是否使用单播、 多播或广播地址发送数据报。</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          
        </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>Gets or sets a value that specifies the amount of time after which a synchronous <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph> call will time out.</source>
          
        </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The time-out value, in milliseconds.</source>
          <target state="translated">超时值（以毫秒为单位）。</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The default value is 0, which indicates an infinite time-out period.</source>
          <target state="translated">默认值为 0，表示超时期限无限。</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>Specifying -1 also indicates an infinite time-out period.</source>
          <target state="translated">指定-1 还指示超时期限无限。</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>This option applies to synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> calls only.</source>
          <target state="translated">此选项适用于同步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>仅调用。</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>If the time-out period is exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出超时期限，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>方法会引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例演示如何将<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The value specified for a set operation is less than -1.</source>
          
        </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>Gets the remote endpoint.</source>
          
        </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> with which the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is communicating.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>与其<ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>进行通信。</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property gets the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that contains the remote IP address and port number to which the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is connected.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph>属性可以获取<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>包含到的远程 IP 地址和端口号<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>连接。</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> contains the default remote IP address and port number with which the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> will communicate.</source>
          <target state="translated">如果你使用的是无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph>包含默认远程 IP 地址和端口号与其<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>将通信。</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>You must cast this <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> before retrieving any information.</source>
          <target state="translated">您必须将此转换<ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>到<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>之前检索的任何信息。</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>You can then call the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the remote <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>, and the <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the remote port number.</source>
          <target state="translated">然后，你可以调用<ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph>方法来检索远程<ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>，和<ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph>方法来检索远程端口号。</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> is set after a call to either <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph>后调用设置<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you try to access this property earlier, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你尝试访问此属性更早版本，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The following code example retrieves and displays the local and remote endpoints.</source>
          <target state="translated">下面的代码示例检索并显示本地和远程终结点。</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances to check for readability.</source>
          
        </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances to check for writability.</source>
          
        </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances to check for errors.</source>
          
        </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The time-out value, in microseconds.</source>
          
        </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>A -1 value indicates an infinite time-out.</source>
          
        </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Determines the status of one or more sockets.</source>
          
        </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> is a static method that determines the status of one or more <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> 是一个静态方法，确定一个或多个状态<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>You must place one or more sockets into an <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> before you can use the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> method.</source>
          <target state="translated">你必须将放置到的一个或多个套接字<ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph>然后才能使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Check for readability by calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> with the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> as the <ph id="ph3">`checkRead`</ph> parameter.</source>
          <target state="translated">通过调用检查可读性<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>与<ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>作为<ph id="ph3">`checkRead`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>To check your sockets for writability, use the <ph id="ph1">`checkWrite`</ph> parameter.</source>
          <target state="translated">若要检查的可写性套接字，使用<ph id="ph1">`checkWrite`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>For detecting error conditions, use <ph id="ph1">`checkError`</ph>.</source>
          <target state="translated">检测错误条件，请使用<ph id="ph1">`checkError`</ph>。</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>After calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> will be filled with only those sockets that satisfy the conditions.</source>
          <target state="translated">在调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>将填充满足条件这些套接字。</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you are in a listening state, readability means that a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> will succeed without blocking.</source>
          <target state="translated">如果要在侦听状态中，可读意味着调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>而不会阻止将会成功。</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you have already accepted the connection, readability means that data is available for reading.</source>
          <target state="translated">如果你已接受连接，则可读意味着数据是可供读取。</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>In these cases, all receive operations will succeed without blocking.</source>
          <target state="translated">在这些情况下，所有的接收操作而不会阻止将会成功。</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Readability can also indicate whether the remote <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> has shut down the connection; in that case a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will return immediately, with zero bytes returned.</source>
          <target state="translated">可读性也可指示是否远程<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>已关闭连接关闭; 在这种情况下调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>会立即返回，返回零字节。</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> returns when at least one of the sockets of interest (the sockets in the <ph id="ph2">`checkRead`</ph>, <ph id="ph3">`checkWrite`</ph>, and <ph id="ph4">`checkError`</ph> lists) meets its specified criteria, or the <ph id="ph5">`microSeconds`</ph> parameter is exceeded, whichever comes first.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> 返回时至少一个感兴趣的套接字 (中的套接字<ph id="ph2">`checkRead`</ph>， <ph id="ph3">`checkWrite`</ph>，和<ph id="ph4">`checkError`</ph>列出) 满足其指定的条件，或<ph id="ph5">`microSeconds`</ph>超过参数，不管先满足。</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Setting <ph id="ph1">`microSeconds`</ph> to -1 specifies an infinite time-out.</source>
          <target state="translated">设置<ph id="ph1">`microSeconds`</ph>为-1 指定无限期超时。</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you make a nonblocking call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, writability means that you have connected successfully.</source>
          <target state="translated">如果进行到非阻止调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，则可写意味着你已成功连接。</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you already have a connection established, writability means that all send operations will succeed without blocking.</source>
          <target state="translated">如果你没有建立的连接，则可写意味着所有发送操作而不会阻止将会成功。</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you have made a non-blocking call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the <ph id="ph2">`checkerror`</ph> parameter identifies sockets that have not connected successfully.</source>
          <target state="translated">如果你具有对进行了非阻止调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、<ph id="ph2">`checkerror`</ph>参数标识未成功连接的套接字。</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method if you only want to determine the status of a single <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph>方法如果你只想要确定的单个状态<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</source>
          <target state="translated">此方法无法检测到某些类型的连接问题，如网络电缆中断，或远程主机已意外关闭。</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>You must attempt to send or receive data to detect these kinds of errors.</source>
          <target state="translated">你必须尝试发送或接收数据，以检测这些类型的错误。</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> to determine which listening sockets have a connection request.</source>
          <target state="translated">下面的代码示例使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>来确定哪些侦听套接字有一个连接请求。</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="checkRead" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or empty.</source>
          
        </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>-and-</source>
          
        </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="checkWrite" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or empty</source>
          
        </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>-and-</source>
          
        </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="checkError" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or empty.</source>
          
        </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          
        </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>Sends data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 以同步方式将数据发送到中指定的远程主机<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法并返回成功发送的字节数。</target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 可以用于面向连接的和无连接协议。</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>This overload requires a buffer that contains the data you want to send.</source>
          <target state="translated">此重载都需要包含你想要发送的数据的缓冲区。</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>的默认值为 0，缓冲区偏移量的默认值为 0，并要将默认值发送到的缓冲区大小的字节数。</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你使用的是无连接协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>之前调用此方法，或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将引发<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或者使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>以接受传入连接。</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">如果不使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法，你将必须调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>对每个调用之前<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>甚至已建立默认远程主机使用后<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">你还可以更改默认远程主机之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>通过另一个调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将阻止，直到缓冲区中的字节的所有发送时，除非使用设置超时<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出了超时值，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>调用将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">在锁定模式下，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>可能会成功完成，即使它发送的字节数小于缓冲区中。</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">它是你的应用程序负责跟踪发送的字节数并重试该操作，直到应用程序发送缓冲区中的字节。</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">此外，还有你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">成功完成后发送不指示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The following code example demonstrates sending data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">下面的代码示例演示如何在连接上的发送数据<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          
        </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 可以用于面向连接的和无连接协议。</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
          <target state="translated">此重载都需要至少一个包含你想要发送的数据的缓冲区。</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你使用的是无连接协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>之前调用此方法，或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将引发<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或者使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>以接受传入连接。</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">如果不使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法，你将必须调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>对每个调用之前<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>甚至已建立默认远程主机使用后<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">你还可以更改默认远程主机之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>通过另一个调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将阻止，直到缓冲区中的字节的所有发送时，除非使用设置超时<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出了超时值，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>调用将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">在锁定模式下，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>可能会成功完成，即使它发送的字节数小于缓冲区中。</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">它是你的应用程序负责跟踪发送的字节数并重试该操作，直到应用程序发送缓冲区中的字节。</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">此外，还有你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">成功完成后发送不指示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          
        </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>See remarks section below.</source>
          
        </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          
        </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>Sends data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 以同步方式将数据发送到中建立的远程主机<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法并返回成功发送的字节数。</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法可以用于面向连接的和无连接协议。</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This overload requires a buffer that contains the data you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">此重载都需要包含你想要发送的数据的缓冲区和的按位组合<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</source>
          <target state="translated">缓冲区偏移量的默认值为 0，并要将默认值发送到的缓冲区大小的字节数。</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter value, the data you are sending will not be routed.</source>
          <target state="translated">如果指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>标记为<ph id="ph2">`socketflags`</ph>参数值，则发送的无法路由的数据。</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你使用的是无连接协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>之前调用此方法，或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将引发<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或者使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>以接受传入连接。</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">如果不使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法，你将必须调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法对每个调用之前<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>甚至已建立默认远程主机使用后<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">你还可以更改默认远程主机之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>通过另一个调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将阻止，直到缓冲区中的字节的所有发送时，除非使用设置超时<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出了超时值，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>调用将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">在锁定模式下，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>可能会成功完成，即使它发送的字节数小于缓冲区中。</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">它是你的应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送请求的字节数。</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">此外，还有你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">你必须确保你的缓冲区的大小不超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果是这样，将不发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">成功完成后发送不指示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>For more information, see<bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The following code example demonstrates sending data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">下面的代码示例演示如何在连接上的发送数据<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          
        </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
          <target state="translated">此重载都需要至少一个包含你想要发送的数据的缓冲区。</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>值默认为 0。</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketFlags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">如果指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>标记为<ph id="ph2">`socketFlags`</ph>参数，发送的无法路由的数据。</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你使用的是无连接协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>之前调用此方法，或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将引发<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或者使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>以接受传入连接。</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">如果不使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法，你将必须调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>对每个调用之前<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>甚至已建立默认远程主机使用后<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">你还可以更改默认远程主机之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>通过另一个调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将阻止，直到缓冲区中的字节的所有发送时，除非使用设置超时<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出了超时值，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>调用将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>In non-blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">在非阻塞模式下，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>可能会成功完成，即使它发送的字节数小于缓冲区中。</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">它是你的应用程序负责跟踪发送的字节数并重试该操作，直到应用程序发送缓冲区中的字节。</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">此外，还有你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">成功完成后发送不指示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          
        </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          
        </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to send.</source>
          
        </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 以同步方式将数据发送到中建立的远程主机<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法并返回成功发送的字节数。</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 可以用于面向连接的和无连接协议。</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">此重载都需要包含你想要发送，你想要发送的字节数和任何的按位组合的数据的缓冲区<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">如果指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>标记为<ph id="ph2">`socketflags`</ph>参数，发送的无法路由的数据。</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你使用的是无连接协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>之前调用此方法，或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将引发<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或者使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>以接受传入连接。</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method before each call to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">如果不使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法，你将必须调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法对每个调用之前<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>甚至已建立默认远程主机使用后<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">你还可以更改默认远程主机之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>通过另一个调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>With a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">与面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将阻止，直到发送请求的字节数，除非使用设置超时<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出了超时值，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>调用将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
          <target state="translated">在锁定模式下，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>可能会成功完成，即使它发送的请求的字节数小于。</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">它是你的应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送请求的字节数。</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">此外，还有你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">你必须确保大小不超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果是这样，将不发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">成功完成后发送不指示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following code example sends the data found in buffer, and specifies <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> for <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">下面的代码示例将发送缓冲区中的数据，并指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>为<ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0 or exceeds the size of the buffer.</source>
          
        </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          
        </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An operating system error occurs while accessing the socket.</source>
          
        </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          
        </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          
        </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
          <target state="translated">此重载都需要至少一个包含你想要发送的数据的缓冲区。</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>值默认为 0。</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketFlags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">如果指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>标记为<ph id="ph2">`socketFlags`</ph>参数，发送的无法路由的数据。</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你使用的是无连接协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>之前调用此方法，或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将引发<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或者使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>以接受传入连接。</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">如果不使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法，你将必须调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>对每个调用之前<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>甚至已建立默认远程主机使用后<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">你还可以更改默认远程主机之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>通过另一个调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将阻止，直到缓冲区中的字节的所有发送时，除非使用设置超时<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出了超时值，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>调用将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>In non-blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">在非阻塞模式下，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>可能会成功完成，即使它发送的字节数小于缓冲区中。</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">它是你的应用程序负责跟踪发送的字节数并重试该操作，直到应用程序发送缓冲区中的字节。</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">此外，还有你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">成功完成后发送不指示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          
        </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          
        </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The position in the data buffer at which to begin sending data.</source>
          
        </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to send.</source>
          
        </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, starting at the specified offset, and using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 以同步方式将数据发送到中指定的远程主机<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法并返回成功发送的字节数。</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 可以用于面向连接的和无连接协议。</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">在此重载中，如果你指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>标记为<ph id="ph2">`socketflags`</ph>参数，发送的无法路由的数据。</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你使用的是无连接协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>在调用此方法之前或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将引发<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或者使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>以接受传入连接。</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you do not use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">如果不使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>，你将需要调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>对每个调用之前<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>甚至已建立默认远程主机使用后<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">你还可以更改默认远程主机之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>通过另一个调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">你还必须确保大小不超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果是这样，将不发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将阻止，直到发送请求的字节数，除非使用设置超时<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出了超时值，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>调用将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
          <target state="translated">在锁定模式下，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>可能会成功完成，即使它发送的请求的字节数小于。</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">它是你的应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送请求的字节数。</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">此外，还有你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">成功完成后发送不指示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following code example specifies the data buffer, an offset, a size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> for sending data to a connected <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">下面的代码示例指定数据缓冲区、 偏移量、 大小和<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>用于将数据发送到连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          
        </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          
        </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The position in the data buffer at which to begin sending data.</source>
          
        </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes to send.</source>
          
        </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          
        </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, starting at the specified offset, and using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph></source>
          
        </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 以同步方式将数据发送到中指定的远程主机<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法并返回成功发送的字节数。</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 可以用于面向连接的和无连接协议。</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">在此重载中，如果你指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>标记为<ph id="ph2">`socketflags`</ph>参数，发送的无法路由的数据。</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你使用的是无连接协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>在调用此方法之前或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将引发<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或者使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>以接受传入连接。</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you do not use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">如果不使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>，你将需要调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>对每个调用之前<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>甚至已建立默认远程主机使用后<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">你还可以更改默认远程主机之前调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>通过另一个调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">你还必须确保大小不超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果是这样，将不发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>将阻止，直到发送请求的字节数，除非使用设置超时<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出了超时值，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>调用将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
          <target state="translated">在锁定模式下，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>可能会成功完成，即使它发送的请求的字节数小于。</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">它是你的应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送请求的字节数。</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">此外，还有你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">成功完成后发送不指示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see<bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The following code example specifies the data buffer, an offset, a size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> for sending data to a connected <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">下面的代码示例指定数据缓冲区、 偏移量、 大小和<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>用于将数据发送到连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          
        </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          
        </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          
        </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          
        </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          
        </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          
        </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          
        </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>方法用于从面向连接的套接字上的一个或多个缓冲区写入传出数据。</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</source>
          <target state="translated">此方法也可用，但是，在已连接操作指定远程主机的无连接套接字上。</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>方法会启动异步发送操作中建立的远程主机<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>， <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>， <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，或<ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">下列属性和事件上的<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>对象所需成功调用此方法：</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> 或 <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> 如果<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph>设置</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> 如果<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph>设置</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">调用方可能设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>到在调用前要求任何用户状态对象的属性<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>方法，以便在回叫方法可检索信息。</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph><ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>方法将引发异常，如果不首先调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>， <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，或<ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>方法使你能够发送单独的执行线程中的数据。</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</source>
          <target state="translated">对于面向消息的套接字，不超过基础 Windows 套接字服务提供程序的最大消息大小。</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> set to the native Winsock WSAEMSGSIZE error code (10040).</source>
          <target state="translated">如果数据太长，来以原子方式通过基础服务提供商，传输任何数据和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>方法抛出异常<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>与<ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph>设置为本机 Winsock WSAEMSGSIZE 错误代码 (10040)。</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Note that the successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method does not indicate that the data was successfully delivered.</source>
          <target state="translated">请注意，成功完成<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>方法并不表示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> or <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> properties on the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter must reference valid buffers.</source>
          
        </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One or the other of these properties may be set, but not both at the same time.</source>
          
        </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not yet connected or was not obtained via an <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph>,or <ph id="ph4">&lt;see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /&gt;</ph>, method.</source>
          
        </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>Gets or sets a value that specifies the size of the send buffer of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the size, in bytes, of the send buffer.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>包含以字节为单位的发送缓冲区的大小。</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The default is 8192.</source>
          <target state="translated">默认值为 8192。</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>A larger buffer size might delay the recognition of connection difficulties.</source>
          <target state="translated">更大的缓冲区大小可能会延迟连接问题的识别。</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</source>
          <target state="translated">请考虑增加缓冲区大小，如果传输大型文件，或者正在使用的高带宽、 高延迟连接 （如卫星宽带提供程序。）</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendBufferSize%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例演示如何将<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendBufferSize%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The value specified for a set operation is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends a file and optional data synchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the path and name of the file to be sent.</source>
          
        </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>Sends the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> to a connected <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object with the <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph> transmit flag.</source>
          
        </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This overload sends the file <ph id="ph1">`fileName`</ph> to the connected socket.</source>
          <target state="translated">此重载将文件发送<ph id="ph1">`fileName`</ph>到连接的套接字。</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The <ph id="ph1">`flags`</ph> parameter defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread&gt;</ph> (0), and the <ph id="ph3">`preBuffer`</ph> and <ph id="ph4">`postBuffer`</ph> parameters default to <ph id="ph5">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`flags`</ph>参数默认为<ph id="ph2">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread&gt;</ph>(0)，和<ph id="ph3">`preBuffer`</ph>和<ph id="ph4">`postBuffer`</ph>参数默认为<ph id="ph5">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">如果<ph id="ph1">`fileName`</ph>是在本地目录中，则可以标识与只是文件的名称; 否则，必须指定完整路径和文件的名称。</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">通配符 ("...<ph id="ph1">\\</ph>\myfile.txt") 和 UNC 共享名 ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared 目录<ph id="ph5">\\</ph>\myfile.txt") 支持。</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">如果未找到文件，该异常<ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">此方法使用<ph id="ph1">`TransmitFile`</ph>Windows 套接字 2 API 中找到函数。</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`TransmitFile`</ph>函数和其标志，请参阅 MSDN 库中的 Windows 套接字文档。</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> synchronously sends a file to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> 以同步方式将文件发送到中指定的远程主机<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> can be used for both connection-oriented and for connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> 可用于同时面向连接的和无连接协议。</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, otherwise <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">如果你使用的是无连接协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>之前调用此方法，否则<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>引发<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>异常。</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机连接或使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>以接受传入连接。</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blocks until the file is sent.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>阻止，直到发送文件为止。</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> may complete successfully before the entire file has been sent.</source>
          <target state="translated">在锁定模式下，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>已发送的整个文件之前，可能会成功完成。</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">就你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The following code example creates and connects a socket and then sends a file to the remote host.</source>
          <target state="translated">下面的代码示例创建并连接套接字然后将文件发送到远程主机。</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The file "test.txt" is located in the root directory of the local machine.</source>
          <target state="translated">文件"test.txt"位于本地计算机的根目录中。</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The socket is not connected to a remote host.</source>
          
        </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          
        </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object is not in blocking mode and cannot accept this synchronous call.</source>
          
        </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          
        </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the path and name of the file to be sent.</source>
          
        </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent before the file is sent.</source>
          
        </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent after the file is sent.</source>
          
        </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>One or more of <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>Sends the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> and buffers of data to a connected <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object using the specified <ph id="ph3">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> value.</source>
          
        </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This overload requires the name of the file you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> values.</source>
          <target state="translated">此重载需要你想要发送的文件和的按位组合的名称<ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>值。</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">`preBuffer`</ph> parameter contains any data you want to precede the file.</source>
          <target state="translated"><ph id="ph1">`preBuffer`</ph>参数包含你想要位于文件之前的任何数据。</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">`postBuffer`</ph> contains data you want to follow the file.</source>
          <target state="translated"><ph id="ph1">`postBuffer`</ph> 包含你想要遵照该文件的数据。</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If <ph id="ph1">`fileName`</ph> is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">如果<ph id="ph1">`fileName`</ph>是在当前工作目录中，则可以标识与只是文件的名称; 否则，必须指定完整路径和文件的名称。</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">通配符 ("...<ph id="ph1">\\</ph>\myfile.txt") 和 UNC 共享名 ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared 目录<ph id="ph5">\\</ph>\myfile.txt") 支持。</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">`flags`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
          <target state="translated"><ph id="ph1">`flags`</ph>参数提供关于文件传输的其他信息的窗口套接字服务提供程序。</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
          <target state="translated">有关如何使用此参数的详细信息，请参阅<ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">此方法使用<ph id="ph1">`TransmitFile`</ph>Windows 套接字 2 API 中找到函数。</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`TransmitFile`</ph>函数和其标志，请参阅 MSDN 库中的 Windows 套接字文档。</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> synchronously sends a file to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> 以同步方式将文件发送到中指定的远程主机<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> can be used for both connection-oriented and for connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> 可用于同时面向连接的和无连接协议。</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method; otherwise <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果你使用的是无连接协议，则必须调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>之前调用此方法; 否则为<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>引发<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">如果你使用的一个面向连接的协议，则必须使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>建立远程主机的连接，或者使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>以接受传入连接。</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blocks until the entire file is sent.</source>
          <target state="translated">如果你使用的一种面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>一直阻塞，直到发送整个文件。</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> may complete successfully before the entire file has been sent.</source>
          <target state="translated">在锁定模式下，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>已发送的整个文件之前，可能会成功完成。</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">就你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The following code example creates and connects a socket.</source>
          <target state="translated">下面的代码示例创建并连接套接字。</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The file "test.txt" is located in the root directory of the local machine.</source>
          <target state="translated">文件"test.txt"位于本地计算机的根目录中。</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</source>
          <target state="translated">在此示例中，我们将创建缓冲区和数据后，并使用该文件将它们发送到远程主机。</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The default <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> are used.</source>
          <target state="translated">默认值<ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>使用。</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The operating system is not Windows NT or later.</source>
          
        </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">\-</ph> or -</source>
          
        </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The socket is not connected to a remote host.</source>
          
        </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          
        </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object is not in blocking mode and cannot accept this synchronous call.</source>
          
        </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          
        </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          
        </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Sends a collection of files or in memory data buffers asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          
        </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          
        </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          
        </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          
        </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          
        </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is used to send a collection of files or in memory data buffers to remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>方法用于将集合中的文件或在内存中发送到远程主机的数据缓冲区。</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> must already be connected to the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>必须已连接到远程主机。</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a <ph id="ph1">&lt;xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType&gt;</ph> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType&gt;</ph>的工作目录中的文件的引用，那么可能只是文件的名称以进行标识; 否则，必须指定完整路径和文件的名称。</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Wildcards and UNC share names are supported.</source>
          <target state="translated">支持通配符和 UNC 共享名。</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the file is not found, <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">如果未找到该文件，<ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">若要在完成时得到通知，必须创建实现的回调方法<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; 委托和附加到回调<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph>属性<ph id="ph2">`e`</ph>参数提供关于文件传输的其他信息的窗口套接字服务提供程序。</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
          <target state="translated">有关如何使用此参数的详细信息，请参阅<ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">下列属性和事件上的<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>对象所需成功调用此方法：</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">调用方可能设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>到在调用前要求任何用户状态对象的属性<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>方法，以便在回叫方法可检索信息。</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This method uses the TransmitPackets function found in the Windows Sockets 2 API.</source>
          <target state="translated">此方法使用在 Windows 套接字 2 API 中找到 TransmitPackets 函数。</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">有关 TransmitPackets 函数和其标志的详细信息，请参阅 MSDN 库中的 Windows 套接字文档。</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Although intended for connection-oriented protocols, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">适用于面向连接的协议，尽管<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>方法也适用于无连接协议，前提是你第一次调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，或<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法来建立默认远程主机。</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">使用无连接协议，你还必须确保你的文件的大小不能超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">如果是这样，不会发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>异常。</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized according to the operating system on which it is used.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>方法进行了优化根据在其中使用的操作系统。</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>On Windows server editions, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized for high performance.</source>
          <target state="translated">在 Windows server 版本上<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>获得高性能优化方法。</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>On Windows client editions, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized for minimum memory and resource utilization.</source>
          <target state="translated">Windows 客户端版本，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>方法进行了优化以最小内存和资源利用率。</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Use of the <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType&gt;</ph> flag in the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph3">`e`</ph> parameter can deliver significant performance benefits.</source>
          <target state="translated">利用<ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType&gt;</ph>中标记出来<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph>属性<ph id="ph3">`e`</ph>参数可以提供显著的性能优势。</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the thread initiating the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</source>
          <target state="translated">如果线程启动<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>方法调用用于繁重的计算，但可以，虽然不，Apc 可能无法启动。</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Note that there is a difference between kernel and user-mode APCs.</source>
          <target state="translated">请注意，内核和用户模式 Apc 之间存在的差异。</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Kernel APCs launch when a thread is in a wait state.</source>
          <target state="translated">在线程处于等待状态时，将启动内核 Apc。</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>User-mode APCs launch when a thread is in an alertable wait state</source>
          <target state="translated">用户模式 Apc 在线程处于可报警等待状态时启动</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The file specified in the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /&gt;</ph> property was not found.</source>
          
        </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not connected to a remote host.</source>
          
        </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A connectionless <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</source>
          
        </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>Gets or sets a value that specifies the amount of time after which a synchronous <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> call will time out.</source>
          
        </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The time-out value, in milliseconds.</source>
          <target state="translated">超时值（以毫秒为单位）。</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>If you set the property with a value between 1 and 499, the value will be changed to 500.</source>
          <target state="translated">如果你设置具有介于 1 和 499 之间的值的属性，则该值将更改为 500。</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The default value is 0, which indicates an infinite time-out period.</source>
          <target state="translated">默认值为 0，表示超时期限无限。</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>Specifying -1 also indicates an infinite time-out period.</source>
          <target state="translated">指定-1 还指示超时期限无限。</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>This option applies to synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> calls only.</source>
          <target state="translated">此选项适用于同步<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>仅调用。</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>If the time-out period is exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果超出超时期限，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法会引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例演示如何将<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The value specified for a set operation is less than -1.</source>
          
        </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends data to a specific endpoint.</source>
          
        </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          
        </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination for the data.</source>
          
        </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Sends data to the specified endpoint.</source>
          
        </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          
        </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the <ph id="ph1">`buffer`</ph> parameter, and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
          <target state="translated">在此重载中，缓冲区偏移量的默认值为 0，要将默认值发送到的大小的字节数<ph id="ph1">`buffer`</ph>参数，与<ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>值默认为 0。</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的是无连接协议，不需要建立默认远程主机使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">只需执行此操作，如果你想要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>、<ph id="ph3">`remoteEP`</ph>只为发送操作，参数将覆盖指定的默认远程主机。</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">你还无需调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法，因为基础服务提供程序将分配的最合适的本地网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">如果你需要确定分配的本地网络地址和端口号，则可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>属性后的<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法已成功完成。</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">虽然供无连接协议，但是<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>也适用于面向连接的协议。</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">如果使用的一个面向连接的协议，你首先必须通过调用来建立远程主机连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法或接受传入的连接请求使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果未建立或不接受远程主机的连接，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">你还可以建立默认远程主机之前调用无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">在这些情况下，任一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将忽略<ph id="ph2">`remoteEP`</ph>参数并仅将数据发送到已连接或默认远程主机。</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Blocking sockets will block until the all of the bytes in the buffer are sent.</source>
          <target state="translated">阻止套接字将发送的字节缓冲区中的所有一直阻止。</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Since a nonblocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes in the <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">由于非阻止<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>完成立即，它可能不发送的字节数的所有<ph id="ph2">`buffer`</ph>。</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">它是你的应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送的字节数的所有<ph id="ph1">`buffer`</ph>。</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">此外，还有你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">如果在阻止模式下，将无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将阻止，直到发送数据报。</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你想要将数据发送到广播地址，则必须首先调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>方法并设置套接字选项设为<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">你还必须是确保发送的字节数不超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果是这样，将不发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">下面的代码示例将无连接的数据报发送到指定的远程主机。</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          
        </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination location for the data.</source>
          
        </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Sends data to a specific endpoint using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          
        </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">在此重载中，缓冲区偏移量的默认值为 0，并要将默认值发送到的大小的字节数<ph id="ph1">`buffer`</ph>。</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">如果指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>标记为<ph id="ph2">`socketflags`</ph>参数，发送的无法路由的数据。</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的是无连接协议，不需要建立默认远程主机使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">只需执行此操作，如果你想要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>、<ph id="ph3">`remoteEP`</ph>只为发送操作，参数将覆盖指定的默认远程主机。</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">你还无需调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法，因为基础服务提供程序将分配的最合适的本地网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">如果你需要确定分配的本地网络地址和端口号，则可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>属性后的<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法已成功完成。</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">虽然供无连接协议，但是<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>也适用于面向连接的协议。</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">如果使用的一个面向连接的协议，你首先必须通过调用来建立远程主机连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法或接受传入的连接请求使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果未建立或不接受远程主机的连接，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">你还可以建立默认远程主机之前调用无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">在这些情况下，任一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将忽略<ph id="ph2">`remoteEP`</ph>参数并仅将数据发送到已连接或默认远程主机。</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Blocking sockets will block until the requested all of the bytes in the <ph id="ph1">`buffer`</ph> are sent.</source>
          <target state="translated">阻止套接字将一直阻止请求中的字节的所有<ph id="ph1">`buffer`</ph>发送。</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Since a nonblocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes in the <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">由于非阻止<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>完成立即，它可能不发送的字节数的所有<ph id="ph2">`buffer`</ph>。</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">它是你的应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送的字节数的所有<ph id="ph1">`buffer`</ph>。</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">此外，还有你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">如果在阻止模式下，将无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将阻止，直到发送数据报。</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你想要将数据发送到广播地址，则必须首先调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>方法并设置套接字选项设为<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">你还必须是确保发送的字节数不超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果是这样，将不发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">下面的代码示例将无连接的数据报发送到指定的远程主机。</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> 传递给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          
        </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes to send.</source>
          
        </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination location for the data.</source>
          
        </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Sends the specified number of bytes of data to the specified endpoint using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          
        </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In this overload, the buffer offset defaults to 0.</source>
          <target state="translated">在此重载中，缓冲区偏移量的默认值为 0。</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">如果指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>标记为<ph id="ph2">`socketflags`</ph>参数，发送的无法路由的数据。</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的是无连接协议，不需要建立默认远程主机使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">只需执行此操作，如果你想要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>、<ph id="ph3">`remoteEP`</ph>只为发送操作，参数将覆盖指定的默认远程主机。</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">你还无需调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法，因为基础服务提供程序将分配的最合适的本地网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">如果你需要确定分配的本地网络地址和端口号，则可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>属性后的<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法已成功完成。</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">虽然供无连接协议，但是<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>也适用于面向连接的协议。</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">如果使用的一个面向连接的协议，你首先必须通过调用来建立远程主机连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法或接受传入的连接请求使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果未建立或不接受远程主机的连接，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">你还可以建立默认远程主机之前调用无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">在这些情况下，任一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将忽略<ph id="ph2">`remoteEP`</ph>参数并仅将数据发送到已连接或默认远程主机。</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Blocking sockets will block until the requested number of bytes are sent.</source>
          <target state="translated">阻止套接字将阻止，直到发送请求的字节数。</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Since a nonblocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes requested in a single operation.</source>
          <target state="translated">由于非阻止<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>完成立即，它可能未发送的所有单个操作中请求的字节数。</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">它是你的应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送请求的字节数。</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">此外，还有你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">如果在阻止模式下，将无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将阻止，直到发送数据报。</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你想要将数据发送到广播地址，则必须首先调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>方法并设置套接字选项设为<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">你还必须是确保发送的字节数不超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果是这样，将不发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">下面的代码示例将无连接的数据报发送到指定的远程主机。</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The size and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">大小和<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>传递给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The specified <ph id="ph1">&lt;paramref name="size" /&gt;</ph> exceeds the size of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          
        </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The position in the data buffer at which to begin sending data.</source>
          
        </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes to send.</source>
          
        </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination location for the data.</source>
          
        </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          
        </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">在此重载中，如果你指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>标记为<ph id="ph2">`socketflags`</ph>参数，发送的无法路由的数据。</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的是无连接协议，不需要建立默认远程主机使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">只需执行此操作，如果你想要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法之前调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>、<ph id="ph3">`remoteEP`</ph>只为发送操作，参数将覆盖指定的默认远程主机。</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">你还无需调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法，因为基础服务提供程序将分配的最合适的本地网络地址和端口号。</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">如果你需要确定分配的本地网络地址和端口号，则可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>属性后的<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法已成功完成。</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">虽然供无连接协议，但是<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>也适用于面向连接的协议。</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">如果使用的一个面向连接的协议，你首先必须通过调用来建立远程主机连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>方法或接受传入的连接请求使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果未建立或不接受远程主机的连接，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">你还可以建立默认远程主机之前调用无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">在这些情况下，任一<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将忽略<ph id="ph2">`remoteEP`</ph>参数并仅将数据发送到已连接或默认远程主机。</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Blocking sockets will block until the requested number of bytes are sent.</source>
          <target state="translated">阻止套接字将阻止，直到发送请求的字节数。</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Since a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes requested in a single operation.</source>
          <target state="translated">由于非阻塞<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>完成立即，它可能未发送的所有单个操作中请求的字节数。</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">它是你应用程序负责跟踪发送的字节数并重试该操作，直到应用程序发送请求的字节数。</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">此外，还有你发送的数据将立即显示在网络不能保证。</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
          <target state="translated">若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">成功完成后<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">如果在阻止模式下，将无连接协议<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将阻止，直到发送数据报。</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">如果你想要将数据发送到广播地址，则必须首先调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>方法并设置套接字选项设为<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">你还必须确保大小不超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果是这样，将不发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">下面的代码示例将无连接的数据报发送到指定的远程主机。</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The offset, size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">偏移量、 大小和<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>传递给<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          
        </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          
        </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A caller in the call stack does not have the required permissions.</source>
          
        </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          
        </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Sends data asynchronously to a specific remote host.</source>
          
        </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          
        </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          
        </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          
        </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          
        </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method starts an asynchronous send operation to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property of the <ph id="ph3">`e`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>方法会启动异步发送操作中指定远程主机<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>属性<ph id="ph3">`e`</ph>参数。</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>方法使你能够发送单独的执行线程中的数据。</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Although this method is intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> works with both connectionless and connection-oriented protocols.</source>
          <target state="translated">尽管此方法适用于无连接协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>适用于无连接和面向连接的协议。</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">若要在完成时得到通知，必须创建实现的回调方法<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; 委托和附加到回调<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">下列属性和事件上的<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>对象所需成功调用此方法：</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">调用方可能设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>到在调用前要求任何用户状态对象的属性<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>方法，以便在回叫方法可检索信息。</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
          <target state="translated">如果你使用的一个面向连接的协议，必须先调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>， <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，或<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Otherwise <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">否则为<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>When using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method will ignore the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property and send data to the <ph id="ph3">&lt;xref:System.Net.EndPoint?displayProperty=nameWithType&gt;</ph> established in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph9">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
          <target state="translated">当使用面向连接的协议，<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>方法将忽略<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>属性并将数据发送到<ph id="ph3">&lt;xref:System.Net.EndPoint?displayProperty=nameWithType&gt;</ph>中建立<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>， <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>， <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>， <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>， <ph id="ph8">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>或<ph id="ph9">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>.</source>
          <target state="translated">如果你使用的是无连接协议，不需要建立默认远程主机使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法之前调用<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> methods.</source>
          <target state="translated">只需执行此操作，如果你想要调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>, the <ph id="ph5">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property will override the specified default remote host for that send operation only.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>方法之前调用<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>、<ph id="ph5">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>属性只为发送操作将覆盖指定的默认远程主机。</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">你还无需调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</source>
          <target state="translated">在这种情况下，基础服务提供程序将分配的最合适的本地网络 IP 地址和端口号。</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Use a port number of zero if you want the underlying service provider to select a free port.</source>
          <target state="translated">如果你想要选择可用端口的基础服务提供程序，请使用端口号 0。</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you need to identify the assigned local network IP address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event is signaled and the associated delegates are called.</source>
          <target state="translated">如果你需要确定分配的本地网络 IP 地址和端口号，则可以使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>属性后的<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph>发出信号事件和调用关联的委托。</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option for <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph> to true.</source>
          <target state="translated">如果你想要将数据发送到广播地址，则必须首先调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>方法并设置套接字选项<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>为 true。</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">你还必须是缓冲区的确保你的大小不超过基础服务提供程序的最大的数据包大小。</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果是这样，将不发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you specify the DontRoute flag in the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> property, the data you are sending will not be routed.</source>
          <target state="translated">如果指定中的 DontRoute 标志<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph>属性、 发送的无法路由的数据。</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</source>
          <target state="translated">对于面向消息的套接字，必须格外小心不能超过基础传输的最大消息大小。</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">如果缓冲区的大小超过基础服务提供程序的最大的数据包大小，不会发送数据报和<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>将引发<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The successful completion of a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method does not indicate that the data was successfully delivered.</source>
          <target state="translated">成功完成<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>方法并不表示已成功传递数据。</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          
        </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          
        </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          
        </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The protocol specified is connection-oriented, but the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not yet connected.</source>
          
        </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The IP protection level to set on this socket.</source>
          
        </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>Set the IP protection level on a socket.</source>
          
        </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph>方法使限制 IPv6 或 IP 套接字以侦听指定的作用域，如具有相同的地址的链接本地或站点本地前缀。</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option enables applications to place access restrictions on IPv6 or IP sockets.</source>
          <target state="translated">此套接字选项使应用程序可以限制对 IPv6 或 IP 套接字的访问。</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</source>
          <target state="translated">通过应用此类限制，可让在专用局域网上运行的应用程序能够通过简单的方式很好地增强自身的安全性，以便防范外部攻击。</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option can also be used to remove access restrictions if the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.Unrestricted&gt;</ph>.</source>
          <target state="translated">此套接字选项还可以用于删除访问权限限制，如果<ph id="ph1">`level`</ph>参数设置为<ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.Unrestricted&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</source>
          <target state="translated">此套接字选项可以扩大或缩小侦听套接字的范围，从而使得公共用户和私人用户可以在适当情况下对站点进行无限制的访问，或者可以根据需要对同一站点进行有限制的访问。</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option has defined protection levels specified in the <ph id="ph1">&lt;xref:System.Net.Sockets.IPProtectionLevel&gt;</ph> enumeration.</source>
          <target state="translated">此套接字选项具有 <ph id="ph1">&lt;xref:System.Net.Sockets.IPProtectionLevel&gt;</ph> 枚举中指定的已定义保护级别。</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> method is used to enable or disable Network Address Traversal (NAT) for a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph>方法用于启用或禁用网络地址遍历 (NAT) 为<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</source>
          <target state="translated">可能使用 Teredo、 6to4 或 ISATAP 隧道提供 NAT 遍历。</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>When the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.IPProtectionLevel.Restricted&gt;</ph>, this explicitly disables NAT traversal for a <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.</source>
          <target state="translated">当<ph id="ph1">`level`</ph>参数设置为<ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>，或<ph id="ph3">&lt;xref:System.Net.Sockets.IPProtectionLevel.Restricted&gt;</ph>，这会显式禁用 NAT 遍历<ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>When the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, this may allow NAT traversal for a <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> depending on firewall rules in place on the system.</source>
          <target state="translated">当<ph id="ph1">`level`</ph>参数设置为<ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>，这可能使 NAT 遍历<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>具体取决于系统上实施防火墙规则。</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;paramref name="level" /&gt;</ph> parameter cannot be <ph id="ph2">&lt;see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The IP protection level cannot be set to unspecified.</source>
          
        </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> of the socket must be either <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sets a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option.</source>
          
        </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The value of the option, represented as a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified <ph id="ph2">&lt;see cref="T:System.Boolean" /&gt;</ph> value.</source>
          
        </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> 选项将确定当前行为<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>Set <ph id="ph1">`optionValue`</ph> to <ph id="ph2">`true`</ph> to enable the option, or to <ph id="ph3">`false`</ph> to disable the option.</source>
          <target state="translated">设置<ph id="ph1">`optionValue`</ph>到<ph id="ph2">`true`</ph>以启用该选项，或<ph id="ph3">`false`</ph>以禁用该选项。</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options are grouped by level of protocol support.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> 选项级别协议支持的分组。</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>Listed below are the various <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that can be set using this overload.</source>
          <target state="translated">下面列出了各种<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>可以使用此重载设置的选项。</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>These options are grouped by the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> value.</source>
          <target state="translated">这些选项按相应分组<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>值。</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>If you intend to set any of these options, be sure to use the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> value for the <ph id="ph2">`optionLevel`</ph> parameter.</source>
          <target state="translated">如果你想要设置下列任一选项，请确保使用适当<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>值<ph id="ph2">`optionLevel`</ph>参数。</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The option you choose to set must be specified in the <ph id="ph1">`optionName`</ph> parameter.</source>
          <target state="translated">必须指定你选择设置选项<ph id="ph1">`optionName`</ph>参数。</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>If you want to get the current value of any of the options listed, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">如果你想要获取任何所列的选项的当前值，请使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> 可以使用此重载设置的选项。</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> 可以使用此重载设置的选项。</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> 可以使用此重载设置的选项。</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> 可以使用此重载设置的选项。</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>For more information on these options, refer to the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeration.</source>
          <target state="translated">有关这些选项的详细信息，请参阅<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph>枚举。</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>异常，请改用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The following code example opens a socket and enables the <ph id="ph1">`DontLinger`</ph> and the <ph id="ph2">`OutOfBandInline`</ph> socket options.</source>
          <target state="translated">下面的代码示例打开一个套接字并启用<ph id="ph1">`DontLinger`</ph>和<ph id="ph2">`OutOfBandInline`</ph>套接字选项。</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          
        </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that represents the value of the option.</source>
          
        </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified value, represented as a byte array.</source>
          
        </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> 选项将确定当前行为<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Use this overload to set those <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that require a byte array as an option value.</source>
          <target state="translated">使用此重载来设置那些<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>需要作为一个选项值的字节数组的选项。</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The following code example sets the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values.</source>
          <target state="translated">下面的代码示例设置<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>超时值。</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>A value of the option.</source>
          
        </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified integer value.</source>
          
        </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> 选项将确定当前行为<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For an option with a <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</source>
          <target state="translated">针对选项<ph id="ph1">&lt;xref:System.Boolean&gt;</ph>数据类型，指定要启用该选项，则为非 0 值和零值以禁用该选项。</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For an option with an integer data type, specify the appropriate value.</source>
          <target state="translated">对于具有整数数据类型选项，指定适当的值。</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options are grouped by level of protocol support.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> 选项级别协议支持的分组。</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Listed below are the various <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that can be set using this overload.</source>
          <target state="translated">下面列出了各种<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>可以使用此重载设置的选项。</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>These options are grouped by the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>.</source>
          <target state="translated">这些选项按相应分组<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you intend to set any of these options, be sure to use the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> for the <ph id="ph2">`optionLevel`</ph> parameter.</source>
          <target state="translated">如果你想要设置下列任一选项，请确保使用适当<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>为<ph id="ph2">`optionLevel`</ph>参数。</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The option you choose to set must be specified in the <ph id="ph1">`optionName`</ph> parameter.</source>
          <target state="translated">必须指定你选择设置选项<ph id="ph1">`optionName`</ph>参数。</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you want to get the current value of any of the options listed, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">如果你想要获取任何所列的选项的当前值，请使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> 可以使用此重载设置的选项。</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> 可以使用此重载设置的选项。</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> 可以使用此重载设置的选项。</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> 可以使用此重载设置的选项。</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType&gt;</ph> 可以使用此重载设置的选项。</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For more information about these options, refer to the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeration.</source>
          <target state="translated">有关这些选项的详细信息，请参阅<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph>枚举。</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The following code example sets the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values.</source>
          <target state="translated">下面的代码示例设置<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>超时值。</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          
        </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph> that contains the value of the option.</source>
          
        </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified value, represented as an object.</source>
          
        </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> 选项将确定当前行为<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>Use this overload to set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.</source>
          <target state="translated">此重载用于设置<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>， <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>，和<ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>选项。</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>For the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for the <ph id="ph3">`optionLevel`</ph> parameter.</source>
          <target state="translated">有关<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>选项，请使用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>为<ph id="ph3">`optionLevel`</ph>参数。</target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>For <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</source>
          <target state="translated">有关<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>，使用<ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>If you want to get the current value of any of the options listed above, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">如果你想要获取任何上面列出的选项的当前值，请使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>The following code example sets the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time out values.</source>
          <target state="translated">下面的代码示例设置<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>和<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>超时值。</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source><ph id="ph1">&lt;paramref name="optionValue" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketShutdown" /&gt;</ph> values that specifies the operation that will no longer be allowed.</source>
          
        </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disables sends and receives on a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>When using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, always call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method before closing the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">当使用面向连接的<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，始终调用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>方法在关闭前的<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
          <target state="translated">这可确保发送和关闭之前连接的套接字上接收到的所有数据。</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to free all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>方法释放所有托管和非托管资源与关联<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Do not attempt to reuse the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> after closing.</source>
          <target state="translated">请不要尝试重用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>后结束。</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>The following table shows the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketShutdown&gt;</ph> enumeration values that are valid for the <ph id="ph2">`how`</ph> parameter.</source>
          <target state="translated">下表显示<ph id="ph1">&lt;xref:System.Net.Sockets.SocketShutdown&gt;</ph>对有效的枚举值<ph id="ph2">`how`</ph>参数。</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Value</source>
          <target state="translated">值</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Description</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Send</source>
          <target state="translated">发送</target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disable sending on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">禁用对此发送<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Receive</source>
          <target state="translated">接收</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disable receiving on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">禁用对此接收<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Both</source>
          <target state="translated">消息和传送</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disable both sending and receiving on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">禁用同时发送和接收此<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> specifies that subsequent calls to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> are not allowed.</source>
          <target state="translated">设置<ph id="ph1">`how`</ph>到<ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph>指定，后续调用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>不允许。</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, specifying <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> will have no effect.</source>
          <target state="translated">如果你使用的是无连接<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>，并指定<ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph>将产生任何影响。</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Receive&gt;</ph> specifies that subsequent calls to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> are not allowed.</source>
          <target state="translated">设置<ph id="ph1">`how`</ph>到<ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Receive&gt;</ph>指定，后续调用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>不允许。</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>This has no effect on lower protocol layers.</source>
          <target state="translated">这在较低的协议层上无效。</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> :</source>
          <target state="translated">如果你使用的一个面向连接的协议，如果以下条件之一存在后调用，则连接将终止<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Data is in the incoming network buffer waiting to be received.</source>
          <target state="translated">数据是等待接收传入的网络缓冲区中。</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>More data has arrived.</source>
          <target state="translated">更多的数据已到达。</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you are using a connectionless protocol, datagrams are accepted and queued.</source>
          <target state="translated">如果你使用的是无连接协议，接受并排队数据报。</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</source>
          <target state="translated">但是，如果没有缓冲区空间可用于其他传入数据报，它们将被放弃，并且将向发件人返回任何错误。</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> on a connectionless <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is not recommended.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>上是无连接<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>不建议。</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Both&gt;</ph> disables both sends and receives as described above.</source>
          <target state="translated">设置<ph id="ph1">`how`</ph>到<ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Both&gt;</ph>同时禁用发送和接收上文所述。</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, use the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>调用时<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>方法，请使用<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在.NET Framework 中进行网络跟踪<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>。</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> to disable the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">下面的代码示例使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>禁用<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SocketType">
          <source>Gets the type of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SocketType">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SocketType">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph> is read-only and is set when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph> 是只读的和设置时<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>创建。</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SocketType">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> to the console.</source>
          <target state="translated">下面的代码示例显示<ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>， <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>，和<ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph>到控制台。</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SupportsIPv4">
          <source>Gets a value indicating whether IPv4 support is available and enabled on the current host.</source>
          
        </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv4">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current host supports the IPv4 protocol; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 如果当前主机支持 IPv4 协议;否则为<ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv4">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">操作系统可能支持 IPv4 和 IPv6 协议。</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SupportsIPv6">
          <source>Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <ph id="ph1">&lt;see cref="T:System.Net.Dns" /&gt;</ph> members.</source>
          
        </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv6">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the Framework supports IPv6 for certain obsolete <ph id="ph2">&lt;see cref="T:System.Net.Dns" /&gt;</ph> methods; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 如果框架支持 IPv6 对于某些过时<ph id="ph2">&lt;see cref="T:System.Net.Dns" /&gt;</ph>方法; 否则为<ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv6">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">操作系统可能支持 IPv4 和 IPv6 协议。</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value.</source>
          <target state="translated">TTL 值。</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</source>
          <target state="translated">TTL 值指示的路由器数据包可以遍历路由器放弃数据包和 Internet 控制消息协议 (ICMP)"TTL 超出"之前的最大数目的错误消息返回到发件人。</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value may be set to a value from 0 to 255.</source>
          <target state="translated">从 0 到 255，TTL 值可能设置为一个值。</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>When this property is not set, the default TTL value for a socket is 32.</source>
          <target state="translated">如果未设置此属性，套接字的默认 TTL 值为 32。</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</source>
          <target state="translated">传输控制协议 (TCP) 套接字上设置此属性被忽略由 TCP/IP 堆栈中，如果具有使用套接字已建立成功连接。</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">如果你收到<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>，使用<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>属性来获取特定的错误代码。</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Ttl%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例演示如何将<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Ttl%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value can't be set to a negative number.</source>
          
        </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>This property can be set only for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          
        </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>An error occurred when attempting to access the socket.</source>
          
        </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>This error is also returned when an attempt was made to set TTL to a value higher than 255.</source>
          
        </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          
        </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>Specifies whether the socket should only use Overlapped I/O mode.</source>
          
        </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> uses only overlapped I/O; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 如果<ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>仅使用重叠的 I/O; 否则为<ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>Set this property to <ph id="ph1">`true`</ph> for a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> you intend to call <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</source>
          <target state="translated">将此属性设置为<ph id="ph1">`true`</ph>为<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>你想要调用<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</source>
          <target state="translated">否则，框架可以将完成端口分配给套接字，它将禁止使用<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>The socket has been bound to a completion port.</source>
          
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>